diff -u curry-0.9.11/aclocal.m4 curry-0.9.11-classful/aclocal.m4
--- curry-0.9.11/aclocal.m4	2007-06-15 14:16:33.000000000 +0200
+++ curry-0.9.11-classful/aclocal.m4	2013-01-02 10:16:57.000000000 +0100
@@ -1,6 +1,6 @@
-# $Id: aclocal.m4 2239 2007-06-10 00:46:39Z wlux $
+# $Id: aclocal.m4 3118 2013-01-02 09:05:07Z wlux $
 #
-# Copyright (c) 2002-2007, Wolfgang Lux
+# Copyright (c) 2002-2012, Wolfgang Lux
 #
 
 ########################################################################
@@ -153,7 +153,7 @@
 # Haskell compiler
 
 # CURRY_HC_HASKELL98(HC,[ACTION-IF-TRUE],[ACTION-IF-FALSE])
-# Check whether Haskell compiler HC compiles Haskell 98
+# Check whether Haskell compiler HC compiles Haskell 98.
 AC_DEFUN([CURRY_HC_HASKELL98],
 [AC_CACHE_CHECK([whether $$1 supports Haskell 98],
 [curry_cv_prog_$1_haskell98],
@@ -164,68 +164,75 @@
 import Char
 main = print (isAlphaNum 'a')
 EOF
-$$1 conftest.hs -o conftest 2>/dev/null && curry_cv_prog_$1_haskell98=yes
-rm -f conftest* Main.hi])
+$$1 $HFLAGS conftest.hs -o conftest >&AS_MESSAGE_LOG_FD 2>&1 && curry_cv_prog_$1_haskell98=yes
+rm -rf conftest* Main.hi])
 case $curry_cv_prog_$1_haskell98 in
   yes ) $2;;
   no ) $3;;
 esac])
 
-# CURRY_PROG_GHC, CURRY_PROG_HBC, CURRY_PROG_NHC
-# Check for ghc, hbc, nhc compiler in the path which handles Haskell 98
-# Set the variables GHC, HBC, and NHC, resp. and AC_SUBST the variable
+# CURRY_HC_HASKELL2010(HC,[ACTION-IF-TRUE],[ACTION-IF-FALSE])
+# Check whether Haskell compiler HC compiles Haskell 2010.
+AC_DEFUN([CURRY_HC_HASKELL2010],
+[AC_CACHE_CHECK([whether $$1 supports Haskell 2010],
+[curry_cv_prog_$1_haskell2010],
+[curry_cv_prog_$1_haskell2010=no
+# Check whether Data.Char.isAlphaNum is available.
+cat <<EOF >conftest.hs
+import Data.Char
+main = print (isAlphaNum 'a')
+EOF
+$$1 $HFLAGS conftest.hs -o conftest >&AS_MESSAGE_LOG_FD 2>&1 && curry_cv_prog_$1_haskell2010=yes
+rm -rf conftest* Main.hi])
+case $curry_cv_prog_$1_haskell2010 in
+  yes ) $2;;
+  no ) $3;;
+esac])
 
-AC_DEFUN([CURRY_GHC_VERSION],
-[AC_CACHE_CHECK([ghc version],[curry_cv_prog_ghc_version],
-[curry_ghc_version=`$GHC --version 2>&1`
-curry_cv_prog_ghc_version=`expr "$curry_ghc_version" : '.*version \([[0-9]]*.[[0-9]]*\)'`
-test -n "$curry_cv_prog_ghc_version" || unset curry_cv_prog_ghc_version])])
-
-AC_DEFUN([CURRY_HBC_VERSION],
-[AC_CACHE_CHECK([hbc version],[curry_cv_prog_hbc_version],
-[# NB: hbc 0.9999.3 and earlier do not support -v. Who cares?
-curry_hbc_version=`$HBC -v 2>&1`
-curry_cv_prog_hbc_version=`expr "$curry_hbc_version" : '.*version \(0.9999.[[0-9]]*\)'`
-test -n "$curry_cv_prog_hbc_version" || unset curry_cv_prog_hbc_version])])
-
-AC_DEFUN([CURRY_NHC_VERSION],
-[AC_CACHE_CHECK([nhc version],[curry_cv_prog_nhc_version],
-[# NB: most versions of nhc 1.3 do not support -v. Who cares?
-curry_nhc_version=`$NHC --version 2>&1`
-curry_cv_prog_nhc_version=`expr "$curry_nhc_version" : '.*: v\([[0-9]]*\.[[0-9]][[0-9]]*\)'`
-test -n "$curry_cv_prog_nhc_version" || unset curry_cv_prog_nhc_version])])
 
+# CURRY_HC_STD_HASKELL(HC,[ACTION-IF-TRUE],[ACTION-IF-FALSE])
+# Check whether Haskell compiler HC compiles Haskell 98 or 2010. Sets
+# the variable HASKELL to either hs98, hs2010, or no.
+AC_DEFUN([CURRY_HC_STD_HASKELL],
+[CURRY_HC_HASKELL98($1,[HASKELL=hs98],
+[CURRY_HC_HASKELL2010($1,[HASKELL=hs2010],[HASKELL=no])])
+case $HASKELL in
+  no ) $3;;
+  * ) $2;;
+esac])
+
+# CURRY_PROG_GHC, CURRY_PROG_HBC, CURRY_PROG_NHC
+# Check for ghc, hbc, nhc compiler in the path. Set the variable GHC, HBC,
+# and NHC, respectively, to the command and also set the variable HC to the
+# command if the compiler handles Haskell 98 or Haskell 2010.
 AC_DEFUN([CURRY_PROG_GHC],
 [AC_CHECK_PROG(GHC, ghc, ghc)
 if test -n "$GHC"; then
-  CURRY_GHC_VERSION(GHC)
-  CURRY_HC_HASKELL98(GHC,[],[GHC=])
+  CURRY_HC_STD_HASKELL(GHC,[HC=$GHC curry_cv_prog_HC_haskell98=$curry_cv_prog_GHC_haskell98])
 fi])
 
 AC_DEFUN([CURRY_PROG_HBC],
 [AC_CHECK_PROG(HBC, hbc, hbc)
 if test -n "$HBC"; then
-  CURRY_HBC_VERSION(HBC)
-  CURRY_HC_HASKELL98(HBC,[],[HBC=])
+  CURRY_HC_HASKELL98(HBC,[HC=$HBC curry_cv_prog_HC_haskell98=$curry_cv_prog_HBC_haskell98])
 fi])
 
 AC_DEFUN([CURRY_PROG_NHC],
-[AC_CHECK_PROGS(NHC, [nhc98 nhc])
+[AC_CHECK_PROG(NHC, nhc98, nhc98)
 if test -n "$NHC"; then
-  CURRY_NHC_VERSION(NHC)
-  CURRY_HC_HASKELL98(NHC,[],[NHC=])
+  CURRY_HC_HASKELL98(NHC,[HC=$NHC curry_cv_prog_HC_haskell98=$curry_cv_prog_NHC_haskell98])
 fi])
 
 
-# CURRY_HC_VERSION(HC)
-# Check whether HC is one of the supported compilers and set either
-# GHC, HBC, or NHC to this compiler
+# CURRY_HC_VERSION(HC_VERSION)
+# Determine the type and version number of the Haskell compiler HC
+# and set the argument variable to the version string
 AC_DEFUN([CURRY_HC_VERSION],
-[AC_MSG_CHECKING([Haskell compiler version])
-cat <<EOF >conftest.hs
+[AC_CACHE_CHECK([Haskell compiler type and version],[curry_cv_prog_HC_version],
+[cat <<EOF >conftest.hs
 main = putStr (
 #ifdef __GLASGOW_HASKELL__
-  "ghc " ++ show (__GLASGOW_HASKELL__/100)
+  "ghc " ++ shows (div __GLASGOW_HASKELL__ 100) ('.' : show (mod __GLASGOW_HASKELL__ 100))
 #endif
 #ifdef __HBC__
 # if __HASKELL1__==5
@@ -243,27 +250,23 @@
   "nhc13"
 # endif
 # if __HASKELL__==98
+#  if __NHC__ > 1
+  "nhc98 " ++ shows (div __NHC__ 100) ('.' : show (mod __NHC__ 100))
+#  else
   "nhc98"
+#  endif
 # endif
 #endif
   )
 EOF
-rm -f conftest; $$1 -cpp conftest.hs -o conftest 2>/dev/null; rm -f Main.hi
-if curry_hc_version=`./conftest 2>/dev/null`; then
-  AC_MSG_RESULT([$curry_hc_version])
+rm -f conftest; $HC $HFLAGS -cpp conftest.hs -o conftest >&AS_MESSAGE_LOG_FD 2>&1; rm -f Main.hi
+if curry_hc_version=`./conftest 2>&AS_MESSAGE_LOG_FD`; then
+  curry_cv_prog_HC_version=$curry_hc_version
 else
-  AC_MSG_ERROR([cannot determine version of $$1])
+  AC_MSG_ERROR([cannot determine version of $HC])
 fi
-rm -f conftest* Main.hi
-CURRY_HC_HASKELL98([$1],
-[# do not cache the result for this variable
-unset curry_cv_prog_$1_haskell98
-case $curry_hc_version in
-  ghc* ) GHC=$$1; HBC=; NHC=;;
-  hbc* ) HBC=$$1; GHC=; NHC=;;
-  nhc* ) NHC=$$1; GHC=; HBC=;;
-esac],
-[GHC= HBC= NHC=])])
+rm -rf conftest* Main.hi])
+$1=$curry_cv_prog_HC_version])
 
 # CURRY_HC_HLIB(HC,[ACTION-IF-TRUE],[ACTION-IF-FALSE])
 # Checks whether HC supports the standard hierarchical libraries.
@@ -276,8 +279,8 @@
 module ConfTest(module Data.IORef) where
 import Data.IORef
 EOF
-$$1 -c ConfTest.hs 2>/dev/null && curry_cv_prog_$1_hlib=yes
-rm -f ConfTest*])
+$$1 $HFLAGS -c ConfTest.hs >&AS_MESSAGE_LOG_FD 2>&1 && curry_cv_prog_$1_hlib=yes
+rm -rf ConfTest*])
 case $curry_cv_prog_$1_hlib in
   yes ) $2;;
   no ) $3;;
@@ -285,7 +288,7 @@
 
 # CURRY_GHC_IOEXTS
 # Check how to import IOExts when compiling with ghc
-# and add the appropriate switches to the variable HCFLAGS
+# and add the appropriate switches to the variable HFLAGS
 # NB this should be used only for ghc version 4.x or earlier;
 #    on later versions of ghc Data.IORef should be used instead
 #    of IOExts
@@ -297,17 +300,17 @@
 EOF
 curry_ghc_ioexts_lib=
 for lib in exts lang; do
-  if $GHC $HCFLAGS -syslib $lib -c conftest.hs 2>/dev/null; then
+  if $HC $HFLAGS -syslib $lib -c conftest.hs >&AS_MESSAGE_LOG_FD 2>&1; then
     curry_ghc_ioexts_lib="-syslib $lib"
     break
   fi
 done
-rm -f conftest* Main.hi
+rm -rf conftest* Main.hi
 case $curry_ghc_ioexts_lib in
   "" ) AC_MSG_ERROR([cannot determine how to import IOExts]);;
   * )
     AC_MSG_RESULT([$curry_ghc_ioexts_lib])
-    HCFLAGS="$HCFLAGS $curry_ghc_ioexts_lib"
+    HFLAGS="$HFLAGS $curry_ghc_ioexts_lib"
     ;;
 esac])
 
@@ -321,15 +324,15 @@
 main = readFile "`pwd`/conftest.hs"
 EOF
 rm -f conftest$EXEEXT
-$HC conftest.hs -o conftest$EXEEXT 2>/dev/null
-if ./conftest$EXEEXT 2>/dev/null; then
+$HC $HFLAGS conftest.hs -o conftest$EXEEXT >&AS_MESSAGE_LOG_FD 2>&1
+if ./conftest$EXEEXT 2>&AS_MESSAGE_LOG_FD; then
    AC_MSG_RESULT([yes])
    HC_PATH_STYLE=unix
 else
    AC_MSG_RESULT([no])
    HC_PATH_STYLE=windows
 fi
-rm -f conftest* Main.hi
+rm -rf conftest* Main.hi
 ])
 
 
@@ -382,3 +385,29 @@
    AC_DEFINE(UNALIGNED_DOUBLE)
  fi
 ])
+
+# CURRY_STACK_GROWSUP
+# Check whether the stack grows upward. Define C_STACK_GROWS_UPWARD
+# via AC_DEFINE in this case.
+# NB We must make sure that this test is compiled without optimization.
+# An aggressive optimizer otherwise could include the code of the check
+# function inside the main function, whence the order of the two local
+# variables is no longer an indication of the stack direction.
+AC_DEFUN([CURRY_STACK_GROWSUP],
+[AC_REQUIRE([AC_PROG_CC]) dnl
+ AC_CACHE_CHECK([whether stack grows upward],
+   [curry_cv_sys_stack_growsup],
+   save_CFLAGS=$CFLAGS
+   [CFLAGS=`echo " $CFLAGS " | sed 's/ -O[[0-9]]* / /g'`]
+   AC_TRY_RUN([#include <stdlib.h>
+       void check(unsigned long p_addr) {
+         void *q; if ( (unsigned long)&q < p_addr ) exit(1); }
+       int main() { void *p; check ((unsigned long)&p); exit(0); }],
+     curry_cv_sys_stack_growsup=yes,
+     curry_cv_sys_stack_growsup=no,
+     curry_cv_sys_stack_growsup=no)
+     CFLAGS=$save_CFLAGS)
+ if test "$curry_cv_sys_stack_growsup" = yes; then
+   AC_DEFINE(C_STACK_GROWS_UPWARD)
+ fi
+])
diff -u curry-0.9.11/Base.lhs curry-0.9.11-classful/Base.lhs
--- curry-0.9.11/Base.lhs	2007-06-15 14:16:34.000000000 +0200
+++ curry-0.9.11-classful/Base.lhs	2010-06-28 10:54:14.000000000 +0200
@@ -1,7 +1,7 @@
 % -*- LaTeX -*-
-% $Id: Base.lhs 2235 2007-06-08 10:12:15Z wlux $
+% $Id: Base.lhs 2968 2010-06-24 14:39:50Z wlux $
 %
-% Copyright (c) 1999-2007, Wolfgang Lux
+% Copyright (c) 1999-2010, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{Base.lhs}
@@ -10,353 +10,15 @@
 in various phases of the compiler.
 \begin{verbatim}
 
-> module Base(module Base,module Ident,module Position,module Types,
->             module CurrySyntax) where
-> import Ident
-> import Position
-> import CurrySyntax
-> import Types
+> module Base where
+> import Curry
+> import CurryUtils
 > import Env
-> import TopEnv
-> import NestEnv
 > import List
-> import Maybe
-> import Monad
+> import Position
 > import Set
 
 \end{verbatim}
-\paragraph{Interfaces}
-The compiler maintains a global environment containing all interfaces
-imported directly or indirectly into the current module.
-\begin{verbatim}
-
-> type ModuleEnv = Env ModuleIdent Interface
-
-> bindModule :: Interface -> ModuleEnv -> ModuleEnv
-> bindModule (Interface m is ds) = bindEnv m (Interface m is ds)
-
-> unbindModule :: ModuleIdent -> ModuleEnv -> ModuleEnv
-> unbindModule = unbindEnv
-
-\end{verbatim}
-\paragraph{Type constructors}
-For all defined types, the compiler must maintain kind information. At
-present, Curry does not support type classes. Therefore, its type
-language is first order and the only information that must be recorded
-is the arity of each type. For algebraic data types and renaming
-types, the compiler also records all data constructors belonging to
-that type, for alias types the expanded right hand side type
-expression is saved.
-
-Importing and exporting algebraic data types and renaming types is
-complicated by the fact that the constructors of the type may be
-(partially) hidden in the interface. This facilitates the definition
-of abstract data types. An abstract type is always represented as a
-data type without constructors in the interface regardless of whether
-it is defined as a data type or as a renaming type. When only some
-constructors of a data type are hidden, those constructors are
-replaced by underscores in the interface.
-\begin{verbatim}
-
-> type TCEnv = TopEnv TypeInfo
-
-> data TypeInfo = DataType QualIdent Int [Maybe Ident]
->               | RenamingType QualIdent Int Ident
->               | AliasType QualIdent Int Type
->               deriving Show
-
-> instance Entity TypeInfo where
->   origName (DataType tc _ _) = tc
->   origName (RenamingType tc _ _) = tc
->   origName (AliasType tc _ _) = tc
->   merge (DataType tc n cs) (DataType tc' _ cs')
->     | tc == tc' = Just (DataType tc n (mergeData cs cs'))
->     where mergeData cs cs'
->             | null cs = cs'
->             | null cs' = cs
->             | otherwise = zipWith mplus cs cs'
->   merge (DataType tc n _) (RenamingType tc' _ nc)
->     | tc == tc' = Just (RenamingType tc n nc)
->   merge (RenamingType tc n nc) (DataType tc' _ _)
->     | tc == tc' = Just (RenamingType tc n nc)
->   merge (RenamingType tc n nc) (RenamingType tc' _ _)
->     | tc == tc' = Just (RenamingType tc n nc)
->   merge (AliasType tc n ty) (AliasType tc' _ _)
->     | tc == tc' = Just (AliasType tc n ty)
->   merge _ _ = Nothing
-
-\end{verbatim}
-The function \texttt{constrKind} returns the arity of a type
-constructor from the type constructor environment and the function
-\texttt{constructors} returns the names of the data and newtype
-constructors of a type. Both functions are supposed to be used only
-after checking for undefined and ambiguous type identifiers and
-therefore should not fail.
-\begin{verbatim}
-
-> constrKind :: QualIdent -> TCEnv -> Int
-> constrKind tc tcEnv =
->   case qualLookupTopEnv tc tcEnv of
->     [DataType _ n _] -> n
->     [RenamingType _ n _] -> n
->     [AliasType _ n _] -> n
->     _ -> internalError ("constrKind " ++ show tc)
-
-> constructors :: QualIdent -> TCEnv -> [Maybe Ident]
-> constructors tc tcEnv =
->   case qualLookupTopEnv tc tcEnv of
->     [DataType _ _ cs] -> cs
->     [RenamingType _ _ c] -> [Just c]
->     [AliasType _ _ _] -> []
->     _ -> internalError ("constructors " ++ show tc)
-
-\end{verbatim}
-A simpler environment is used for checking the syntax of type
-expressions, where only the original names and the data constructors
-associated with each type are needed. Since synonym types are treated
-differently in import and export lists, we distinguish data and
-renaming types on one side and synonym types on the other side.
-\begin{verbatim}
-
-> type TypeEnv = TopEnv TypeKind
-
-> data TypeKind =
->     Data QualIdent [Ident]
->   | Alias QualIdent
->   deriving (Eq,Show)
-
-> typeKind :: TypeInfo -> TypeKind
-> typeKind (DataType tc _ cs) = Data tc (catMaybes cs)
-> typeKind (RenamingType tc _ c) = Data tc [c]
-> typeKind (AliasType tc _ _) = Alias tc
-
-> instance Entity TypeKind where
->   origName (Data tc _) = tc
->   origName (Alias tc) = tc
-
-\end{verbatim}
-\paragraph{Function and constructor types}
-In order to test type correctness of a module, the compiler needs to
-determine the type of every data constructor, function, and variable
-in the module. For the purpose of type checking, there is no need to
-distinguish variables and functions. For all objects, their original
-names and their types are saved. In addition, the compiler also saves
-the arity of functions and data constructors. For constructors, the
-arity could be computed from the constructor's type. However, this is
-not possible in general for functions. Note that the arity of a
-newtype constructor is always one, so there is no need to save it
-explicitly.
-
-Even though value declarations may be nested, the compiler uses a flat
-environment for saving type information. This is possible because all
-identifiers are renamed by the compiler before it starts computing type
-information.
-\begin{verbatim}
-
-> type ValueEnv = TopEnv ValueInfo
-
-> data ValueInfo = DataConstructor QualIdent Int TypeScheme
->                | NewtypeConstructor QualIdent TypeScheme
->                | Value QualIdent Int TypeScheme
->                deriving Show
-
-> instance Entity ValueInfo where
->   origName (DataConstructor origName _ _) = origName
->   origName (NewtypeConstructor origName _) = origName
->   origName (Value origName _ _) = origName
-
-> bindFun :: ModuleIdent -> Ident -> Int -> TypeScheme -> ValueEnv -> ValueEnv
-> bindFun m f n ty = bindTopEnv m f (Value (qualifyWith m f) n ty)
-
-> rebindFun :: ModuleIdent -> Ident -> Int -> TypeScheme -> ValueEnv -> ValueEnv
-> rebindFun m f n ty = rebindTopEnv m f (Value (qualifyWith m f) n ty)
-
-\end{verbatim}
-The functions \texttt{conType}, \texttt{varType}, and \texttt{funType}
-return the type of constructors, pattern variables, and variables in
-expressions, respectively, from the type environment. They are
-supposed to be used only after checking for duplicate and ambiguous
-identifiers and therefore should not fail.
-
-The function \texttt{varType} can handle ambiguous identifiers and
-returns the first available type. This makes it possible to use
-\texttt{varType} in order to determine the type of a locally defined
-function even though the function's name may be ambiguous.
-
-The function \texttt{arity} returns the arity of a constructor or
-function and the function \texttt{changeArity} changes the arity of a
-(local) function.
-\begin{verbatim}
-
-> conType :: QualIdent -> ValueEnv -> TypeScheme
-> conType c tyEnv =
->   case qualLookupTopEnv c tyEnv of
->     [DataConstructor _ _ ty] -> ty
->     [NewtypeConstructor _ ty] -> ty
->     _ -> internalError ("conType " ++ show c)
-
-> varType :: Ident -> ValueEnv -> TypeScheme
-> varType v tyEnv =
->   case lookupTopEnv v tyEnv of
->     Value _ _ ty : _ -> ty
->     _ -> internalError ("varType " ++ show v)
-
-> funType :: QualIdent -> ValueEnv -> TypeScheme
-> funType f tyEnv =
->   case qualLookupTopEnv f tyEnv of
->     [Value _ _ ty] -> ty
->     _ -> internalError ("funType " ++ show f)
-
-> arity :: QualIdent -> ValueEnv -> Int
-> arity x tyEnv =
->   case qualLookupTopEnv x tyEnv of
->     [DataConstructor _ n _] -> n
->     [NewtypeConstructor _ _] -> 1
->     [Value _ n _] -> n
->     _ -> internalError ("arity " ++ show x)
-
-> changeArity :: ModuleIdent -> Ident -> Int -> ValueEnv -> ValueEnv
-> changeArity m f n tyEnv =
->   case lookupTopEnv f tyEnv of
->     Value _ _ ty : _ -> rebindFun m f n ty tyEnv
->     _ -> internalError ("changeArity " ++ show f)
-
-\end{verbatim}
-The function \texttt{isNewtypeConstr} uses the value type environment
-in order to distinguish data and newtype constructors.
-\begin{verbatim}
-
-> isNewtypeConstr :: ValueEnv -> QualIdent -> Bool
-> isNewtypeConstr tyEnv c =
->   case qualLookupTopEnv c tyEnv of
->     [DataConstructor _ _ _] -> False
->     [NewtypeConstructor _ _] -> True
->     _ -> internalError ("isNewtypeConstr: " ++ show c)
-
-\end{verbatim}
-A simpler kind of environment is used for syntax checking of
-expressions. We only distinguish constructors and variables here. A
-nested environment is used for syntax checking because it is performed
-before renaming. However, only the top-level of this environment is
-used in order to check the export list of a module.
-\begin{verbatim}
-
-> type FunEnv = TopEnv ValueKind
-> type VarEnv = NestEnv ValueKind
-
-> data ValueKind = Constr QualIdent | Var QualIdent deriving (Eq,Show)
-
-> valueKind :: ValueInfo -> ValueKind
-> valueKind (DataConstructor c _ _) = Constr c
-> valueKind (NewtypeConstructor c _) = Constr c
-> valueKind (Value v _ _) = Var v
-
-> instance Entity ValueKind where
->   origName (Constr c) = c
->   origName (Var x) = x
-
-\end{verbatim}
-\paragraph{Operator precedences}
-In order to parse infix expressions correctly, the compiler must know
-the precedence and associativity of each operator. Operator
-precedences are associated with entities and will be checked after
-renaming. Nevertheless, we need to save precedences for ambiguous
-names in order to handle them correctly while computing the exported
-interface of a module.
-
-If no fixity is assigned to an operator, it will be given the default
-precedence 9 and assumed to be a left-associative operator.
-\begin{verbatim}
-
-> data OpPrec = OpPrec Infix Int deriving Eq
-
-> instance Show OpPrec where
->   showsPrec _ (OpPrec fix p) = showString (assoc fix) . shows p
->     where assoc InfixL = "left "
->           assoc InfixR = "right "
->           assoc Infix  = "non-assoc "
-
-> defaultPrec :: OpPrec
-> defaultPrec = OpPrec InfixL defaultP
-
-> defaultP :: Int
-> defaultP = 9
-
-\end{verbatim}
-Operator precedences that are different from the default are recorded
-in the precedence environment. A top-level environment is sufficient
-because precedences are checked after renaming.
-\begin{verbatim}
-
-> type PEnv = TopEnv PrecInfo
-
-> data PrecInfo = PrecInfo QualIdent OpPrec deriving (Eq,Show)
-
-> instance Entity PrecInfo where
->   origName (PrecInfo op _) = op
-
-\end{verbatim}
-\paragraph{Trusted functions}
-The compiler collects trust annotations from the source code in an
-environment. A simple environment mapping unqualified names onto
-annotations is sufficient because trust annotations control how
-function declarations are transformed when generating code for the
-declarative debugger (cf.  Sect.~\ref{sec:dtrans}).
-\begin{verbatim}
-
-> type TrustEnv = Env Ident Trust
-
-\end{verbatim}
-\paragraph{Predefined types}
-The unit and list data types must be predefined because the
-declarations
-\begin{verbatim}
-data () = ()
-data [] a = [] | a : [a]
-\end{verbatim}
-are not valid in Curry. The same is true for the -- potentially --
-infinite number of tuple types. The corresponding types are available
-in the environments \texttt{initTCEnv} and \texttt{initDCEnv}. In
-addition, the precedence of the infix list constructor is available in
-the environment \texttt{initPEnv}.
-\begin{verbatim}
-
-> initPEnv :: PEnv
-> initPEnv = predefTopEnv qConsId (PrecInfo qConsId (OpPrec InfixR 5)) emptyPEnv
->   where emptyPEnv = emptyTopEnv Nothing
-
-> initTCEnv :: TCEnv
-> initTCEnv = foldr (uncurry predefTC) emptyTCEnv predefTypes
->   where emptyTCEnv = emptyTopEnv (Just (map fst tuples))
->         predefTC (TypeConstructor tc tys) cs =
->           predefTopEnv tc (DataType tc (length tys) (map (Just . fst) cs))
-
-> initDCEnv :: ValueEnv
-> initDCEnv = foldr (uncurry predefDC) emptyDCEnv (concatMap snd predefTypes)
->   where emptyDCEnv = emptyTopEnv (Just (map snd tuples))
->         predefDC c ty =
->           predefTopEnv c' (DataConstructor c' (arrowArity ty) (polyType ty))
->           where c' = qualify c
-
-> predefTypes :: [(Type,[(Ident,Type)])]
-> predefTypes =
->   let a = typeVar 0 in [
->     (unitType,   [(unitId,unitType)]),
->     (listType a, [(nilId,nilType a), (consId,consType a)])
->   ]
->   where nilType a = listType a
->         consType a = TypeArrow a (TypeArrow (listType a) (listType a))
-
-> tuples :: [(TypeInfo,ValueInfo)]
-> tuples = map tupleInfo [2..]
->   where tvs = map typeVar [0..]
->         tupleInfo n =
->           (DataType c n [Just (unqualify c)],
->            DataConstructor c n (ForAll n (tupleConstrType (take n tvs))))
->           where c = qTupleId n
->         tupleConstrType tys = foldr TypeArrow (tupleType tys) tys
-
-\end{verbatim}
 \paragraph{Free and bound variables}
 The compiler needs to compute the sets of free and bound variables for
 various entities. We will devote three type classes to that purpose.
@@ -372,9 +34,7 @@
 variables on the right hand side, regardless of whether they are bound
 on the left hand side. This is more convenient because declarations are
 usually processed in a declaration group where the set of free
-variables cannot be computed independently for each declaration. Also
-note that the operator in a unary minus expression is not a free
-variable, but always refers to a global function from the prelude.
+variables cannot be computed independently for each declaration.
 \begin{verbatim}
 
 > class Expr e where
@@ -391,93 +51,142 @@
 > instance QuantExpr e => QuantExpr [e] where
 >   bv = concat . map bv
 
-> instance QualExpr Decl where
->   qfv m (FunctionDecl _ _ eqs) = qfv m eqs
->   qfv m (PatternDecl _ _ rhs) = qfv m rhs
+> instance QualExpr (TopDecl a) where
+>   qfv m (ClassDecl _ _ _ _ ds) = qfv m ds
+>   qfv m (InstanceDecl _ _ _ _ ds) = qfv m ds
+>   qfv m (BlockDecl d) = qfv m d
+>   qfv _ _ = []
+
+> instance QuantExpr (TopDecl a) where
+>   bv (ClassDecl _ _ _ _ ds) = [f | TypeSig _ fs _ <- ds, f <- fs]
+>   bv (BlockDecl d) = bv d
+>   bv _ = []
+
+> instance QualExpr (Decl a) where
+>   qfv m (FunctionDecl _ _ _ eqs) = qfv m eqs
+>   qfv m (PatternDecl _ t rhs) = qfv m t ++ qfv m rhs
 >   qfv _ _ = []
 
-> instance QuantExpr Decl where
->   bv (FunctionDecl _ f _) = [f]
->   bv (ForeignDecl _ _ _ _ f _) = [f]
+> instance QuantExpr (Decl a) where
+>   bv (FunctionDecl _ _ f _) = [f]
+>   bv (ForeignDecl _ _ _ f _) = [f]
 >   bv (PatternDecl _ t _) = bv t
->   bv (FreeDecl _ vs) = vs
+>   bv (FreeDecl _ vs) = bv vs
 >   bv _ = []
 
-> instance QualExpr Equation where
->   qfv m (Equation _ lhs rhs) = filterBv lhs (qfv m rhs)
+> instance QuantExpr (FreeVar a) where
+>   bv (FreeVar _ v) = [v]
 
-> instance QuantExpr Lhs where
+> instance QualExpr (Equation a) where
+>   qfv m (Equation _ lhs rhs) = qfv m lhs ++ filterBv lhs (qfv m rhs)
+
+> instance QualExpr (Lhs a) where
+>   qfv m = qfv m . snd . flatLhs
+
+> instance QuantExpr (Lhs a) where
 >   bv = bv . snd . flatLhs
 
-> instance QualExpr Rhs where
+> instance QualExpr (Rhs a) where
 >   qfv m (SimpleRhs _ e ds) = filterBv ds (qfv m e ++ qfv m ds)
 >   qfv m (GuardedRhs es ds) = filterBv ds (qfv m es ++ qfv m ds)
 
-> instance QualExpr CondExpr where
+> instance QualExpr (CondExpr a) where
 >   qfv m (CondExpr _ g e) = qfv m g ++ qfv m e
 
-> instance QualExpr Expression where
->   qfv _ (Literal _) = []
->   qfv m (Variable v) = maybe [] return (localIdent m v)
->   qfv _ (Constructor _) = []
+> instance QualExpr (Expression a) where
+>   qfv _ (Literal _ _) = []
+>   qfv m (Variable _ v) =
+>     maybe [] (\v' -> [v' | v' /= anonId]) (localIdent m v)
+>   qfv _ (Constructor _ _) = []
 >   qfv m (Paren e) = qfv m e
 >   qfv m (Typed e _) = qfv m e
+>   qfv m (Record _ _ fs) = qfv m fs
+>   qfv m (RecordUpdate e fs) = qfv m e ++ qfv m fs
 >   qfv m (Tuple es) = qfv m es
->   qfv m (List es) = qfv m es
+>   qfv m (List _ es) = qfv m es
 >   qfv m (ListCompr e qs) = foldr (qfvStmt m) (qfv m e) qs
 >   qfv m (EnumFrom e) = qfv m e
 >   qfv m (EnumFromThen e1 e2) = qfv m e1 ++ qfv m e2
 >   qfv m (EnumFromTo e1 e2) = qfv m e1 ++ qfv m e2
 >   qfv m (EnumFromThenTo e1 e2 e3) = qfv m e1 ++ qfv m e2 ++ qfv m e3
->   qfv m (UnaryMinus _ e) = qfv m e
+>   qfv m (UnaryMinus e) = qfv m e
 >   qfv m (Apply e1 e2) = qfv m e1 ++ qfv m e2
 >   qfv m (InfixApply e1 op e2) = qfv m op ++ qfv m e1 ++ qfv m e2
 >   qfv m (LeftSection e op) = qfv m op ++ qfv m e
 >   qfv m (RightSection op e) = qfv m op ++ qfv m e
->   qfv m (Lambda ts e) = filterBv ts (qfv m e)
+>   qfv m (Lambda _ ts e) = qfv m ts ++ filterBv ts (qfv m e)
 >   qfv m (Let ds e) = filterBv ds (qfv m ds ++ qfv m e)
 >   qfv m (Do sts e) = foldr (qfvStmt m) (qfv m e) sts
 >   qfv m (IfThenElse e1 e2 e3) = qfv m e1 ++ qfv m e2 ++ qfv m e3
->   qfv m (Case e alts) = qfv m e ++ qfv m alts
+>   qfv m (Case e as) = qfv m e ++ qfv m as
+>   qfv m (Fcase e as) = qfv m e ++ qfv m as
 
-> qfvStmt :: ModuleIdent -> Statement -> [Ident] -> [Ident]
+> qfvStmt :: ModuleIdent -> Statement a -> [Ident] -> [Ident]
 > qfvStmt m st fvs = qfv m st ++ filterBv st fvs
 
-> instance QualExpr Statement where
+> instance QualExpr (Statement a) where
 >   qfv m (StmtExpr e) = qfv m e
+>   qfv m (StmtBind _ t e) = qfv m e ++ qfv m t
 >   qfv m (StmtDecl ds) = filterBv ds (qfv m ds)
->   qfv m (StmtBind t e) = qfv m e
 
-> instance QualExpr Alt where
->   qfv m (Alt _ t rhs) = filterBv t (qfv m rhs)
+> instance QualExpr (Alt a) where
+>   qfv m (Alt _ t rhs) = qfv m t ++ filterBv t (qfv m rhs)
 
-> instance QuantExpr Statement where
+> instance QuantExpr (Statement a) where
 >   bv (StmtExpr e) = []
->   bv (StmtBind t e) = bv t
+>   bv (StmtBind _ t e) = bv t
 >   bv (StmtDecl ds) = bv ds
 
-> instance QualExpr InfixOp where
->   qfv m (InfixOp op) = qfv m (Variable op)
->   qfv _ (InfixConstr _) = []
+> instance QualExpr (InfixOp a) where
+>   qfv m op = qfv m (infixOp op)
+
+> instance QualExpr a => QualExpr (Field a) where
+>   qfv m (Field _ e) = qfv m e
 
-> instance QuantExpr ConstrTerm where
->   bv (LiteralPattern _) = []
+> instance QualExpr (ConstrTerm a) where
+>   qfv _ (LiteralPattern _ _) = []
+>   qfv _ (NegativePattern _ _) = []
+>   qfv _ (VariablePattern _ _) = []
+>   qfv m (ConstructorPattern _ _ ts) = qfv m ts
+>   qfv m (FunctionPattern _ f ts) = maybe id (:) (localIdent m f) (qfv m ts)
+>   qfv m (InfixPattern _ t1 op t2) = qfv m t1 ++ qfv m op ++ qfv m t2
+>   qfv m (ParenPattern t) = qfv m t
+>   qfv m (RecordPattern _ _ fs) = qfv m fs
+>   qfv m (TuplePattern ts) = qfv m ts
+>   qfv m (ListPattern _ ts) = qfv m ts
+>   qfv m (AsPattern _ t) = qfv m t
+>   qfv m (LazyPattern t) = qfv m t
+
+> instance QuantExpr (ConstrTerm a) where
+>   bv (LiteralPattern _ _) = []
 >   bv (NegativePattern _ _) = []
->   bv (VariablePattern v) = [v | v /= anonId]
->   bv (ConstructorPattern c ts) = bv ts
->   bv (InfixPattern t1 op t2) = bv t1 ++ bv t2
+>   bv (VariablePattern _ v) = [v | v /= anonId]
+>   bv (ConstructorPattern _ _ ts) = bv ts
+>   bv (FunctionPattern _ _ ts) = bv ts
+>   bv (InfixPattern _ t1 _ t2) = bv t1 ++ bv t2
 >   bv (ParenPattern t) = bv t
+>   bv (RecordPattern _ _ fs) = bv fs
 >   bv (TuplePattern ts) = bv ts
->   bv (ListPattern ts) = bv ts
+>   bv (ListPattern _ ts) = bv ts
 >   bv (AsPattern v t) = v : bv t
 >   bv (LazyPattern t) = bv t
 
+> instance QuantExpr a => QuantExpr (Field a) where
+>   bv (Field _ t) = bv t
+
+> instance Expr QualTypeExpr where
+>   fv (QualTypeExpr _ ty) = fv ty
+
+> instance Expr ClassAssert where
+>   fv (ClassAssert _ ty) = fv ty
+
 > instance Expr TypeExpr where
->   fv (ConstructorType _ tys) = fv tys
+>   fv (ConstructorType _) = []
 >   fv (VariableType tv) = [tv]
 >   fv (TupleType tys) = fv tys
 >   fv (ListType ty) = fv ty
 >   fv (ArrowType ty1 ty2) = fv ty1 ++ fv ty2
+>   fv (ApplyType ty1 ty2) = fv ty1 ++ fv ty2
 
 > filterBv :: QuantExpr e => e -> [Ident] -> [Ident]
 > filterBv e = filter (`notElemSet` fromListSet (bv e))
@@ -506,44 +215,6 @@
 \ToDo{The \texttt{nameSupply} should respect the current case mode, 
 i.e., use upper case for variables in Prolog mode.}
 
-Here is a list of predicates identifying various kinds of
-declarations.
-\begin{verbatim}
-
-> isTypeDecl, isBlockDecl :: TopDecl -> Bool
-> isTypeDecl (DataDecl _ _ _ _) = True
-> isTypeDecl (NewtypeDecl _ _ _ _) = True
-> isTypeDecl (TypeDecl _ _ _ _) = True
-> isTypeDecl (BlockDecl _) = False
-> isBlockDecl (BlockDecl _) = True
-> isBlockDecl _ = False
-
-> isInfixDecl, isTypeSig, isFreeDecl, isTrustAnnot, isValueDecl :: Decl -> Bool
-> isInfixDecl (InfixDecl _ _ _ _) = True
-> isInfixDecl _ = False
-> isTypeSig (TypeSig _ _ _) = True
-> isTypeSig (ForeignDecl _ _ _ _ _ _) = True
-> isTypeSig _ = False
-> isFreeDecl (FreeDecl _ _) = True
-> isFreeDecl _ = False
-> isTrustAnnot (TrustAnnot _ _ _) = True
-> isTrustAnnot _ = False
-> isValueDecl (FunctionDecl _ _ _) = True
-> isValueDecl (ForeignDecl _ _ _ _ _ _) = True
-> isValueDecl (PatternDecl _ _ _) = True
-> isValueDecl (FreeDecl _ _) = True
-> isValueDecl _ = False
-
-\end{verbatim}
-The function \texttt{infixOp} converts an infix operator into an
-expression.
-\begin{verbatim}
-
-> infixOp :: InfixOp -> Expression
-> infixOp (InfixOp op) = Variable op
-> infixOp (InfixConstr op) = Constructor op
-
-\end{verbatim}
 The function \texttt{duplicates} returns a list containing all
 duplicate items from its input list. The result is a list of pairs
 whose first element contains the first occurrence of a duplicate item
diff -u curry-0.9.11/cam2c.lhs curry-0.9.11-classful/cam2c.lhs
--- curry-0.9.11/cam2c.lhs	2007-06-15 14:16:35.000000000 +0200
+++ curry-0.9.11-classful/cam2c.lhs	2013-05-13 09:54:58.000000000 +0200
@@ -1,7 +1,7 @@
 % -*- LaTeX -*-
-% $Id: cam2c.lhs 1884 2006-04-05 16:48:01Z wlux $
+% $Id: cam2c.lhs 3136 2013-05-12 15:53:27Z wlux $
 %
-% Copyright (c) 2005, Wolfgang Lux
+% Copyright (c) 2005-2013, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{cam2c.lhs}
@@ -24,14 +24,15 @@
 > import GetOpt
 > import PathUtils
 > import System
+> import Utils
 
 > main :: IO ()
 > main =
 >   do
 >     prog <- getProgName
 >     args <- getArgs
->     importPath <- catch (getEnv "CURRY_IMPORT_PATH" >>= return . pathList)
->                         (const (return []))
+>     importPath <- IO.catch (getEnv "CURRY_IMPORT_PATH" >>= return . pathList)
+>                            (const (return []))
 >     cam2c prog args importPath
 
 \end{verbatim}
@@ -86,11 +87,6 @@
 >         goal (IO f) gs = (f,Nothing) : gs
 >         goal _ gs = gs
 
-
-> putErr, putErrLn :: String -> IO ()
-> putErr = hPutStr stderr
-> putErrLn = hPutStr stderr . (++ "\n")
-
 \end{verbatim}
 Besides the \texttt{-o} switch, the compiler understands a few more
 options. In particular, it is possible to generate entry code for a
@@ -137,18 +133,20 @@
 >     cam <- if null fns then parseInput else parseFiles fns
 >     let (ms,_,_) = splitCam cam
 >     cam' <- mapM (lookupModule importPath) ms >>= parseFiles
+>     let ts = [(tc,map constr cs) | DataDecl tc _ cs <- cam ++ cam']
 >     let ccode =
->           maybe id (flip mergeCFile . uncurry genGoal) g (genModule cam' cam)
->     maybe putStr writeFile ofn $ showln $ ppCFile ccode
->   where showln x = shows x "\n"
+>           maybe id (flip mergeCFile . uncurry genGoal) g (genModule ts cam)
+>     maybe putStr writeFile ofn $ showLn $ ppCFile ccode
+>   where constr (ConstrDecl _ c _) = c
 
 > genGoal :: String -> Maybe [String] -> CFile
 > genGoal f (Just vs) =
->   genModule []
->             [FunctionDecl (Name "curry_eval") (Name "_1" : map Name vs)
->               (Seq (Let [Bind (Name "_2") (Closure (Name f) (map Name vs))])
->                    (Exec (mangle "=:=") [Name "_1",Name "_2"]))] ++
->   genMain (Name "curry_eval") (Just vs)
+>   genModule [] [FunctionDecl Exported f' vs' st] ++ genMain f' (Just vs)
+>   where f' = Name "curry_eval"
+>         vs' = Name "_1" : map Name vs
+>         st =
+>           Seq (Name "_2" :<- Return (Closure (Name f) (map Name vs)))
+>               (Exec (mangle "=:=") [Name "_1",Name "_2"])
 > genGoal f Nothing = genMain (Name f) Nothing
 
 > parseInput :: IO Module
diff -u curry-0.9.11/Cam.lhs curry-0.9.11-classful/Cam.lhs
--- curry-0.9.11/Cam.lhs	2007-06-15 14:16:36.000000000 +0200
+++ curry-0.9.11-classful/Cam.lhs	2011-10-08 12:42:52.000000000 +0200
@@ -1,7 +1,7 @@
 % -*- LaTeX -*-
-% $Id: Cam.lhs 2102 2007-02-21 19:58:26Z wlux $
+% $Id: Cam.lhs 3054 2011-10-07 15:19:59Z wlux $
 %
-% Copyright (c) 1998-2007, Wolfgang Lux
+% Copyright (c) 1998-2011, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{Cam.lhs}
@@ -23,9 +23,10 @@
 > data Decl =
 >     ImportDecl Name
 >   | DataDecl Name [Name] [ConstrDecl]
->   | FunctionDecl Name [Name] Stmt
+>   | FunctionDecl Visibility Name [Name] Stmt
 >   deriving (Eq,Show)
-> data ConstrDecl = ConstrDecl Name [Type] deriving (Eq,Show)
+> data ConstrDecl = ConstrDecl Visibility Name [Type] deriving (Eq,Show)
+> data Visibility = Private | Exported deriving (Eq,Show)
 > data Type =
 >     TypeVar Name
 >   | TypeApp Name [Type]
@@ -33,11 +34,14 @@
 >   deriving (Eq,Show)
 
 > splitCam :: Module
->          -> ([Name],[(Name,[Name],[ConstrDecl])],[(Name,[Name],Stmt)])
+>          -> ([Name],
+>              [(Name,[Name],[ConstrDecl])],
+>              [(Visibility,Name,[Name],Stmt)])
 > splitCam = foldr split ([],[],[])
 >   where split (ImportDecl m) ~(ms,ds,fs) = (m:ms,ds,fs)
 >         split (DataDecl t vs cs) ~(ms,ds,fs) = (ms,(t,vs,cs):ds,fs)
->         split (FunctionDecl f vs st) ~(ms,dss,fs) = (ms,dss,(f,vs,st):fs)
+>         split (FunctionDecl vb f vs st) ~(ms,dss,fs) =
+>           (ms,dss,(vb,f,vs,st):fs)
 
 \end{verbatim}
 \subsection{Instruction Set}
@@ -48,19 +52,12 @@
 code~\cite{BoquistJohnsson96:GRIN, Boquist99:Thesis}, evaluation of
 nodes is made explicit in the Curry abstract machine.
 
-In our abstract machine language, we distinguish two kinds of
-statements. The statements \texttt{return}, \texttt{enter},
-\texttt{exec}, \texttt{ccall}, \texttt{switch}, and \texttt{choices}
-compute a value. The remaining statements do not compute a value. The
-body of a function and the last statement of a statement sequence are
-always value computing statements.
-
 \texttt{Return} $e$ allocates a fresh node for the expression $e$ and
 returns its address.
 
-\texttt{Enter} $x$ evaluates the node bound to $x$ to head normal form
+\texttt{Eval} $x$ evaluates the node bound to $x$ to head normal form
 and returns its address. If the node is already in head normal form,
-\texttt{enter}~$x$ is equivalent to \texttt{return}~$x$.
+\texttt{eval}~$x$ is equivalent to \texttt{return}~$x$.
 
 \texttt{Exec} $f(x_1,\dots,x_n)$, where $n$ is the arity of $f$,
 enters the global function $f$ and passes the nodes referenced by
@@ -80,10 +77,23 @@
 optional file name $h$ specifies the name of a C header file, which
 contains a prototype of $f$ or a declaration of $x$, respectively.
 
-\emph{St$_1$}\texttt{;} \emph{st$_2$} first executes \emph{st$_1$} and
-then executes \emph{st$_2$}. \emph{St$_1$} must not compute a value.
-However, it may introduce new variables (see \texttt{<-} and
-\texttt{let} below).
+A statement sequence $x$ \texttt{<-} \emph{st$_1$}\texttt{;}
+\emph{st$_2$} first executes \emph{st$_1$} and binds the (fresh)
+variable $x$ to the computed result. It then executes \emph{st$_2$} in
+the extended environment.
+
+\texttt{Let} \texttt{\lb}~$x_1$\texttt{=}$e_1$\texttt{;}
+\dots\texttt{;} $x_n$\texttt{=}$e_n$~\texttt{\rb} \texttt{in}
+\emph{st} allocates new nodes for the expressions $e_1,\dots,e_n$,
+binds the variables $x_1,\dots,x_n$ to the respective nodes, and then
+executes \emph{st} in the extended environment. The bindings in a
+\texttt{let} statement may be mutually recursive. Note that the
+possibility to introduce mutually recursive bindings is the only
+raison d'\^etre for \texttt{let} statements. Non-recursive
+\texttt{let} bindings can be removed using \texttt{let}
+\texttt{\lb}~$x$ \texttt{=} $e$~\texttt{\rb} \texttt{in} \emph{st}
+$\null\equiv\null$ $x$ \texttt{<-} \texttt{return} $e$\texttt{;}
+\emph{st}.
 
 \texttt{Switch} \emph{rf} $x$
 \texttt{\lb}~$t_1$\texttt{:}\emph{st$_1$} \texttt{|} $\dots$
@@ -98,47 +108,22 @@
 variable is instantiated and then the matching alternative is
 selected.
 
-\texttt{Choices} \texttt{\lb}~\emph{st$_1$} \texttt{|} $\dots$
+\texttt{Choice} \texttt{\lb}~\emph{st$_1$} \texttt{|} $\dots$
 \texttt{|} \emph{st$_n$}~\texttt{\rb} non-deterministically executes a
 statement from $\emph{st$_1$},\dots,\emph{st$_n$}$.
-
-$x$ \texttt{<-} \emph{st} executes the (value computing) statement
-\emph{st} and binds its result to the (fresh) variable $x$.
-
-\texttt{Let} \texttt{\lb}~$x_1$\texttt{=}$e_1$\texttt{;}
-\dots\texttt{;} $x_n$\texttt{=}$e_n$~\texttt{\rb} allocates new nodes
-for the expressions $e_1,\dots,e_n$ and binds them to the variables
-$x_1,\dots,x_n$. The bindings in a \texttt{let} statement may be
-mutually recursive. Note that the possibility to introduce mutually
-recursive bindings is the only raison d'\^etre for \texttt{let}
-statements. Non-recursive \texttt{let} bindings can be removed using
-\texttt{let} \texttt{\lb}~$x$ \texttt{=} $e$~\texttt{\rb}
-$\null\equiv\null$ $x$ \texttt{<-} \texttt{return} $e$.
-
-The statements \texttt{lock}~$x$ and \texttt{update}~$x$~$y$ are used
-for implementing the pattern binding update strategy.
-\texttt{Lock}~$x$ overwrites the node bound to $x$ with a queue-me
-node, and \texttt{update}~$x$~$y$ overwrites the node bound to $x$
-with a pointer to $y$. The variable $x$ must be bound to a local,
-unevaluated suspension node when \texttt{lock} is executed, and to a
-local queue-me node when \texttt{update} is executed.
 \begin{verbatim}
 
 > data Stmt =
 >     Return Expr
->   | Enter Name
+>   | Eval Name
 >   | Exec Name [Name]
 >   | CCall (Maybe String) CRetType CCall
 >   | Seq Stmt0 Stmt
+>   | Let [Bind] Stmt
 >   | Switch RF Name [Case]
->   | Choices [Alt]
->   deriving (Eq,Show)
-> data Stmt0 =
->     Lock Name
->   | Update Name Name
->   | Name :<- Stmt
->   | Let [Bind]
+>   | Choice [Alt]
 >   deriving (Eq,Show)
+> data Stmt0 = Name :<- Stmt deriving (Eq,Show)
 
 > type Alt = Stmt
 > data Bind = Bind Name Expr deriving (Eq,Show)
@@ -159,7 +144,11 @@
 reference to the node bound to $x$.
 \begin{verbatim}
 
-> data Literal = Char Char | Int Int | Float Double deriving (Eq,Show)
+> data Literal =
+>     Char Char
+>   | Int Integer
+>   | Integer Integer
+>   | Float Double deriving (Eq,Show)
 
 > data Expr =
 >     Lit Literal
@@ -229,7 +218,7 @@
 > mangle cs = Name (mangleIdent cs)
 >   where mangleIdent [] = []
 >         mangleIdent (c:cs)
->           | isAlphaNum c = c : mangleIdent cs
+>           | isAlphaNum c && ord c < 128 = c : mangleIdent cs
 >           | otherwise = '_' : show (ord c) ++ '_' : mangleIdent cs
 
 > mangleQualified :: String -> Name
diff -u curry-0.9.11/CamParser.lhs curry-0.9.11-classful/CamParser.lhs
--- curry-0.9.11/CamParser.lhs	2007-06-15 14:16:36.000000000 +0200
+++ curry-0.9.11-classful/CamParser.lhs	2011-10-08 12:42:52.000000000 +0200
@@ -1,7 +1,7 @@
 % -*- LaTeX -*-
-% $Id: CamParser.lhs 2102 2007-02-21 19:58:26Z wlux $
+% $Id: CamParser.lhs 3054 2011-10-07 15:19:59Z wlux $
 %
-% Copyright (c) 1999-2007, Wolfgang Lux
+% Copyright (c) 1999-2011, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{CamParser.lhs}
@@ -50,7 +50,7 @@
 > data Attributes =
 >     NoAttributes
 >   | NameAttributes{ sval :: String }
->   | IntAttributes{ ival :: Int }
+>   | IntAttributes{ ival :: Integer }
 >   | FloatAttributes{ fval :: Double }
 
 > tok :: Category -> Token
@@ -64,34 +64,34 @@
 
 > floatTok :: String -> String -> Int -> Token
 > floatTok mant frac exp =
->   Token FloatNum FloatAttributes{ fval = convertSignedFloating mant frac exp }
+>   Token FloatNum FloatAttributes{ fval = convertSignedFloat mant frac exp }
 
 > data Keyword =
 >     KW_bool
 >   | KW_ccall
 >   | KW_char
->   | KW_choices
+>   | KW_choice
 >   | KW_data
 >   | KW_default
->   | KW_enter
->   | KW_exec
+>   | KW_eval
 >   | KW_flex
 >   | KW_float
 >   | KW_free
->   | KW_function
+>   | KW_fun
 >   | KW_import
+>   | KW_in
 >   | KW_int
+>   | KW_integer
 >   | KW_lazy
 >   | KW_let
->   | KW_lock
 >   | KW_papp
 >   | KW_pointer
+>   | KW_private
 >   | KW_return
 >   | KW_rigid
 >   | KW_stable
 >   | KW_switch
 >   | KW_unit
->   | KW_update
 >   deriving (Eq,Ord)
 
 > instance Show Attributes where
@@ -126,28 +126,28 @@
 >   showsPrec _ KW_bool = showKeyword "bool"
 >   showsPrec _ KW_ccall = showKeyword "ccall"
 >   showsPrec _ KW_char = showKeyword "char"
->   showsPrec _ KW_choices = showKeyword "choices"
+>   showsPrec _ KW_choice = showKeyword "choice"
 >   showsPrec _ KW_data = showKeyword "data"
 >   showsPrec _ KW_default = showKeyword "default"
->   showsPrec _ KW_enter = showKeyword "enter"
->   showsPrec _ KW_exec = showKeyword "exec"
+>   showsPrec _ KW_eval = showKeyword "eval"
 >   showsPrec _ KW_flex = showKeyword "flex"
 >   showsPrec _ KW_float = showKeyword "float"
 >   showsPrec _ KW_free = showKeyword "free"
->   showsPrec _ KW_function = showKeyword "function"
+>   showsPrec _ KW_fun = showKeyword "fun"
 >   showsPrec _ KW_import = showKeyword "import"
+>   showsPrec _ KW_in = showKeyword "in"
 >   showsPrec _ KW_int = showKeyword "int"
+>   showsPrec _ KW_integer = showKeyword "integer"
 >   showsPrec _ KW_lazy = showKeyword "lazy"
 >   showsPrec _ KW_let = showKeyword "let"
->   showsPrec _ KW_lock = showKeyword "lock"
 >   showsPrec _ KW_papp = showKeyword "papp"
 >   showsPrec _ KW_pointer = showKeyword "pointer"
+>   showsPrec _ KW_private = showKeyword "private"
 >   showsPrec _ KW_return = showKeyword "return"
 >   showsPrec _ KW_rigid = showKeyword "rigid"
 >   showsPrec _ KW_stable = showKeyword "stable"
 >   showsPrec _ KW_switch = showKeyword "switch"
 >   showsPrec _ KW_unit = showKeyword "unit"
->   showsPrec _ KW_update = showKeyword "update"
 
 > showKeyword :: String -> ShowS
 > showKeyword kw = showChar '.' . showString kw
@@ -163,28 +163,28 @@
 >     ("bool",     KW_bool),
 >     ("ccall",    KW_ccall),
 >     ("char",     KW_char),
->     ("choices",  KW_choices),
+>     ("choice",   KW_choice),
 >     ("data",     KW_data),
 >     ("default",  KW_default),
->     ("enter",    KW_enter),
->     ("exec",     KW_exec),
+>     ("eval",     KW_eval),
 >     ("flex",     KW_flex),
 >     ("float",    KW_float),
 >     ("free",     KW_free),
->     ("function", KW_function),
+>     ("fun",      KW_fun),
 >     ("import",   KW_import),
+>     ("in",       KW_in),
 >     ("int",      KW_int),
+>     ("integer",  KW_integer),
 >     ("lazy",     KW_lazy),
 >     ("let",      KW_let),
->     ("lock",     KW_lock),
 >     ("papp",     KW_papp),
 >     ("pointer",  KW_pointer),
+>     ("private",  KW_private),
 >     ("return",   KW_return),
 >     ("rigid",    KW_rigid),
 >     ("stable",   KW_stable),
 >     ("switch",   KW_switch),
->     ("unit",     KW_unit),
->     ("update",   KW_update)
+>     ("unit",     KW_unit)
 >   ]
 
 > type SuccessL a = Position -> Token -> L a
@@ -311,41 +311,40 @@
 > importDecl = ImportDecl <$-> keyword KW_import <*> checkName
 
 > dataDecl :: Parser Token Decl a
-> dataDecl = DataDecl <$-> keyword KW_data <*> checkName <*> (nameList `opt` [])
->                     <*> (equals <-*> (constrDecl `sepBy1` bar) `opt` [])
+> dataDecl =
+>   DataDecl <$-> keyword KW_data <*> checkName <*> (nameList `opt` [])
+>            <*> (equals <-*> (constrDecl `sepBy1` bar) `opt` [])
 
 > constrDecl :: Parser Token ConstrDecl a
-> constrDecl = ConstrDecl <$> name <*> (parenList typ `opt` [])
+> constrDecl = ConstrDecl <$> vis <*> name <*> (parenList typ `opt` [])
 
 > typ, atyp :: Parser Token Type a
 > typ = atyp `chainr1` (TypeArr <$-> rightArrow)
 > atyp = name <**> (flip TypeApp <$> parenList typ `opt` TypeVar)
 
 > funcDecl :: Parser Token Decl a
-> funcDecl =
->   FunctionDecl <$-> keyword KW_function <*> checkName <*> nameList <*> block
-
-> block :: Parser Token Stmt a
-> block = braces stmt
+> funcDecl = FunctionDecl <$> vis <*> name <*> nameList <*> braces stmt
 
 > stmt :: Parser Token Stmt a
-> stmt = Return <$-> keyword KW_return <*> node
->    <|> Enter <$-> keyword KW_enter <*> checkName
->    <|> Exec <$-> keyword KW_exec <*> checkName <*> nameList
->    <|> CCall <$-> keyword KW_ccall <*> (Just <$> string `opt` Nothing)
->              <*> (parens cRetType `opt` Just TypeNodePtr) <*> cCall
->    <|> Seq <$> stmt0 <*-> checkSemi <*> stmt
->    <|> flip Switch <$-> keyword KW_switch <*> checkName <*> rf
->                    <*> braces cases
->    <|> Choices <$-> keyword KW_choices <*> braces (block `sepBy1` bar)
->    <|> block
->    where rf = Rigid <$-> keyword KW_rigid <|> Flex <$-> keyword KW_flex
-
-> stmt0 :: Parser Token Stmt0 a
-> stmt0 = Lock <$-> keyword KW_lock <*> checkName
->     <|> Update <$-> keyword KW_update <*> checkName <*> checkName
->     <|> (:<-) <$> name <*-> checkLeftArrow <*> stmt <\> stmt0
->     <|> Let <$-> keyword KW_let <*> braces (binding `sepBy1` semi)
+> stmt = name <**> nameStmt
+>    <|> Let <$-> keyword KW_let <*> braces (binding `sepBy1` semi)
+>            <*-> keyword KW_in <*> stmt
+>    <|> astmt <\> name
+>  where nameStmt = flip Exec <$> nameList
+>               <|> stmtSeq <$-> leftArrow <*> astmt <*-> checkSemi <*> stmt
+>        stmtSeq st1 st2 v = Seq (v :<- st1) st2
+
+> astmt :: Parser Token Stmt a
+> astmt = Return <$-> keyword KW_return <*> node
+>     <|> Eval <$-> keyword KW_eval <*> checkName
+>     <|> Exec <$> name <*> nameList
+>     <|> CCall <$-> keyword KW_ccall <*> (Just <$> string `opt` Nothing)
+>               <*> (parens cRetType `opt` Just TypeNodePtr) <*> cCall
+>     <|> flip Switch <$-> keyword KW_switch <*> checkName <*> rf
+>                     <*> braces cases
+>     <|> Choice <$-> keyword KW_choice <*> braces (stmt `sepBy` bar)
+>     <|> leftBrace <-*> stmt <*-> rightBrace
+>   where rf = Rigid <$-> keyword KW_rigid <|> Flex <$-> keyword KW_flex
 
 > binding :: Parser Token Bind a
 > binding = Bind <$> name <*-> checkEquals <*> node
@@ -354,7 +353,7 @@
 > node = Lit <$> literal
 >    <|> Constr <$-> keyword KW_data <*> checkName <*> nameList
 >    <|> Papp <$-> keyword KW_papp <*> checkName <*> nameList
->    <|> Closure <$-> keyword KW_function <*> checkName <*> nameList
+>    <|> Closure <$-> keyword KW_fun <*> checkName <*> nameList
 >    <|> Lazy <$-> keyword KW_lazy <*> checkName <*> nameList
 >    <|> Free <$-> keyword KW_free
 >    <|> Var <$> name
@@ -362,11 +361,12 @@
 > cases :: Parser Token [Case] a
 > cases = return <$> switchCase defaultTag
 >     <|> (:) <$> switchCase caseTag <*> (bar <-*> cases `opt` [])
->   where switchCase tag = Case <$> tag <*-> checkColon <*> block
+>   where switchCase tag = Case <$> tag <*-> checkColon <*> stmt
 
 > literal :: Parser Token Literal a
-> literal = Char . toEnum <$-> keyword KW_char <*> checkInt
+> literal = Char . toEnum . fromInteger <$-> keyword KW_char <*> checkInt
 >       <|> Int <$-> keyword KW_int <*> checkInt
+>       <|> Integer <$-> keyword KW_integer <*> checkInt
 >       <|> Float <$-> keyword KW_float <*> checkFloat
 
 > cCall :: Parser Token CCall a
@@ -386,9 +386,13 @@
 >        <|> TypeInt <$-> keyword KW_int
 >        <|> TypeFloat <$-> keyword KW_float
 >        <|> TypePtr <$-> keyword KW_pointer
->        <|> TypeFunPtr <$-> keyword KW_function
+>        <|> TypeFunPtr <$-> keyword KW_fun
 >        <|> TypeStablePtr <$-> keyword KW_stable
 
+> vis :: Parser Token Visibility a
+> vis = Private <$-> keyword KW_private
+>   <|> succeed Exported
+
 > name, checkName :: Parser Token Name a
 > name = Name . sval <$> token Ident
 > checkName = name <?> "name expected"
@@ -402,7 +406,7 @@
 > keyword :: Keyword -> Parser Token Attributes a
 > keyword k = token (Keyword k)
 
-> int,checkInt :: Parser Token Int a
+> int,checkInt :: Parser Token Integer a
 > int = ival <$> token IntNum
 > checkInt = int <?> "integer number expected"
 
@@ -449,11 +453,8 @@
 > asterisk = token Asterisk
 > checkAsterisk = asterisk <?> "* expected"
 
-> leftArrow, checkLeftArrow :: Parser Token Attributes a
+> leftArrow, rightArrow :: Parser Token Attributes a
 > leftArrow = token LeftArrow
-> checkLeftArrow = leftArrow <?> "<- expected"
-
-> rightArrow :: Parser Token Attributes a
 > rightArrow = token RightArrow
 
 > leftParen, rightParen :: Parser Token Attributes a
diff -u curry-0.9.11/CamPP.lhs curry-0.9.11-classful/CamPP.lhs
--- curry-0.9.11/CamPP.lhs	2007-06-15 14:16:34.000000000 +0200
+++ curry-0.9.11-classful/CamPP.lhs	2011-10-08 12:42:52.000000000 +0200
@@ -1,7 +1,7 @@
 % -*- LaTeX -*-
-% $Id: CamPP.lhs 2102 2007-02-21 19:58:26Z wlux $
+% $Id: CamPP.lhs 3054 2011-10-07 15:19:59Z wlux $
 %
-% Copyright (c) 2002-2007, Wolfgang Lux
+% Copyright (c) 2002-2011, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \subsection{Pretty-printing Abstract Machine Code}
@@ -22,80 +22,81 @@
 > ppDecl :: Decl -> Doc
 > ppDecl (ImportDecl m) = ppKW "import" <+> ppName m
 > ppDecl (DataDecl tc vs cs) =
->   ppKW "data" <+> ppName tc <> (if null vs then empty else ppNames vs)
->               <+> sep (zipWith (<+>) (equals : repeat bar) (map ppConstr cs))
-> ppDecl (FunctionDecl f vs st) =
->   ppCode (ppKW "function" <+> ppName f <> ppNames vs) st
+>   sep (ppKW "data" <+> ppName tc <> (if null vs then empty else ppNames vs) :
+>        zipWith ppConstrDecl (equals : repeat bar) cs)
+>   where ppConstrDecl sep c = nest blockIndent (sep <+> ppConstr c)
+> ppDecl (FunctionDecl vb f vs st) =
+>   ppBlock (ppVis vb <+> ppName f <> ppNames vs) (ppStmt st)
 
 > ppConstr :: ConstrDecl -> Doc
-> ppConstr (ConstrDecl c tys) =
->   ppName c <> if null tys then empty else ppList ppType tys
+> ppConstr (ConstrDecl vb c tys) =
+>   ppVis vb <+> ppName c <> if null tys then empty else ppList ppType tys
 
 > ppType :: Type -> Doc
 > ppType (TypeVar v) = ppName v
 > ppType (TypeApp tc tys) = ppName tc <> ppList ppType tys
 > ppType (TypeArr ty1 ty2) = ppType ty1 <+> text "->" <+> ppType ty2
 
-> ppCode :: Doc -> Stmt -> Doc
-> ppCode prefix = ppBlock prefix . ppStmt
-
 > ppBlock :: Doc -> Doc -> Doc
 > ppBlock prefix x = sep [prefix <+> lbrace,nest blockIndent x,rbrace]
 
 > ppStmt :: Stmt -> Doc
 > ppStmt (Return e) = ppKW "return" <+> ppExpr e
-> ppStmt (Enter v) = ppKW "enter" <+> ppName v
-> ppStmt (Exec f vs) = ppKW "exec" <+> ppName f <> ppNames vs
+> ppStmt (Eval v) = ppKW "eval" <+> ppName v
+> ppStmt (Exec f vs) = ppName f <> ppNames vs
 > ppStmt (CCall h ty cc) =
 >   ppKW "ccall" <+> maybe empty ppHeader h <+> ppCRetType ty <> ppCCall cc
 >   where ppHeader h = char '"' <> text h <> char '"'
 > ppStmt (Seq st1 st2) = ppStmt0 st1 <> semi $$ ppStmt st2
+> ppStmt (Let ds st) =
+>   sep [ppKW "let" <+> ppBindings ds <+> ppKW "in",ppStmt st]
 > ppStmt (Switch rf v cases) =
->   ppBlock (ppKW "switch" <+> ppName v <+> ppRF rf) (ppAlts ppCase cases)
+>   ppAlts (ppKW "switch" <+> ppName v <+> ppRF rf) ppCase cases
 >   where ppRF Rigid = ppKW "rigid"
 >         ppRF Flex = ppKW "flex"
-> ppStmt (Choices alts) = ppBlock (ppKW "choices") (ppAlts ppAlt alts)
+> ppStmt (Choice alts) = ppAlts (ppKW "choice") ppStmt alts
 
 > ppStmt0 :: Stmt0 -> Doc
-> ppStmt0 (Lock v) = ppKW "lock" <+> ppName v
-> ppStmt0 (Update v1 v2) = ppKW "update" <+> ppName v1 <+> ppName v2
 > ppStmt0 (v :<- st) =
 >   case st of
 >     Seq _ _ -> ppBlock prefix (ppStmt st)
->     _       -> prefix <+> ppStmt st
+>     Let _ _ -> ppBlock prefix (ppStmt st)
+>     _       -> sep [prefix,nest blockIndent (ppStmt st)]
 >   where prefix = ppName v <+> text "<-"
-> ppStmt0 (Let bds) = ppKW "let" <+> ppBindings (map ppBinding bds)
->   where ppBinding (Bind v n) = ppName v <+> equals <+> ppExpr n
 
-> ppBindings :: [Doc] -> Doc
-> ppBindings bds = lbrace <+> vcat (punctuate semi bds) <+> rbrace
+> ppBindings :: [Bind] -> Doc
+> ppBindings ds = lbrace <+> vcat (punctuate semi (map ppBinding ds)) <+> rbrace
+
+> ppBinding :: Bind -> Doc
+> ppBinding (Bind v n) = sep [ppName v <+> equals,nest blockIndent (ppExpr n)]
 
 > ppLiteral :: Literal -> Doc
 > ppLiteral (Char c) = ppKW "char" <+> int (ord c)
-> ppLiteral (Int i) = ppKW "int" <+> int i
+> ppLiteral (Int i) = ppKW "int" <+> integer i
+> ppLiteral (Integer i) = ppKW "integer" <+> integer i
 > ppLiteral (Float f) = ppKW "float" <+> double f
 
 > ppExpr :: Expr -> Doc
 > ppExpr (Lit c) = ppLiteral c
 > ppExpr (Constr c vs) = ppKW "data" <+> ppName c <> ppNames vs
 > ppExpr (Papp f vs) = ppKW "papp" <+> ppName f <> ppNames vs
-> ppExpr (Closure f vs) = ppKW "function" <+> ppName f <> ppNames vs
+> ppExpr (Closure f vs) = ppKW "fun" <+> ppName f <> ppNames vs
 > ppExpr (Lazy f vs) = ppKW "lazy" <+> ppName f <> ppNames vs
 > ppExpr Free = ppKW "free"
 > ppExpr (Var v) = ppName v
 
-> ppAlts :: (a -> Doc) -> [a] -> Doc
-> ppAlts ppAlt = vcat . zipWith (<+>) (space : repeat bar) . map ppAlt
+> ppAlts :: Doc -> (a -> Doc) -> [a] -> Doc
+> ppAlts prefix ppAlt as =
+>   sep [prefix <+> lbrace,
+>        vcat (zipWith ($) (nest 2 : repeat ((<+>) bar)) (map ppAlt as)),
+>        rbrace]
 
 > ppCase :: Case -> Doc
-> ppCase (Case t st) = ppCode (ppTag t <> colon) st
+> ppCase (Case t st) = sep [ppTag t <> colon,nest blockIndent (ppStmt st)]
 >   where ppTag (LitCase c) = ppLiteral c
 >         ppTag (ConstrCase c vs) = ppKW "data" <+> ppName c <> ppNames vs
 >         ppTag DefaultCase = ppKW "default"
 
-> ppAlt :: Stmt -> Doc
-> ppAlt = ppCode empty
-
 > ppCCall :: CCall -> Doc
 > ppCCall (StaticCall f xs) = ppCFunCall (text f) xs
 > ppCCall (DynamicCall v xs) = ppCFunCall (parens (char '*' <> ppName v)) xs
@@ -111,7 +112,7 @@
 > ppCArgType TypeInt = parens (ppKW "int")
 > ppCArgType TypeFloat = parens (ppKW "float")
 > ppCArgType TypePtr = parens (ppKW "pointer")
-> ppCArgType TypeFunPtr = parens (ppKW "function")
+> ppCArgType TypeFunPtr = parens (ppKW "fun")
 > ppCArgType TypeStablePtr = parens (ppKW "stable")
 > ppCArgType TypeNodePtr = text ""          -- Do not replace text "" by empty!
 
@@ -121,6 +122,10 @@
 > ppKW :: String -> Doc
 > ppKW kw = char '.' <> text kw
 
+> ppVis :: Visibility -> Doc
+> ppVis Private = ppKW "private"
+> ppVis Exported = empty
+
 > ppName :: Name -> Doc
 > ppName = text . show
 
diff -u curry-0.9.11/CaseCheck.lhs curry-0.9.11-classful/CaseCheck.lhs
--- curry-0.9.11/CaseCheck.lhs	2007-06-15 14:16:34.000000000 +0200
+++ curry-0.9.11-classful/CaseCheck.lhs	2011-10-08 12:42:57.000000000 +0200
@@ -1,7 +1,7 @@
 % -*- LaTeX -*-
-% $Id: CaseCheck.lhs 2101 2007-02-21 16:25:07Z wlux $
+% $Id: CaseCheck.lhs 3056 2011-10-07 16:27:03Z wlux $
 %
-% Copyright (c) 2003-2007, Wolfgang Lux
+% Copyright (c) 2003-2011, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{CaseCheck.lhs}
@@ -26,9 +26,10 @@
 
 In order to check identifier cases, the compiler collects and
 categorizes all type and value identifiers defined in the module. We
-recognize the following five identifier categories:
-\emph{TypeConstrId}, \emph{TypeVarId}, \emph{DataConstrId},
-\emph{FunctionId}, and \emph{VariableId}. At present, we do not check
+recognize the following eight identifier categories:
+\emph{TypeConstrId}, \emph{TypeClassId}, \emph{TypeVarId},
+\emph{DataConstrId}, \emph{FunctionId}, \emph{MethodId},
+\emph{LabelId}, and \emph{VariableId}. At present, we do not check
 module names, even though Haskell requires them to start with an upper
 case letter.
 \begin{verbatim}
@@ -36,26 +37,31 @@
 > module CaseCheck(caseCheck,caseCheckGoal) where
 > import Base
 > import Char
+> import Curry
 > import List
 > import Options
+> import Position
 
 > data Case =
 >   UpperCase | LowerCase | ColonCase | NoColonCase
 >   deriving (Eq,Show)
 > data Category =
 >     TypeConstrId
+>   | TypeClassId
 >   | TypeVarId
 >   | DataConstrId
 >   | FunctionId
+>   | MethodId
+>   | LabelId
 >   | VariableId
 >   deriving Show
 
 > data Definition = D Position Category Ident
 
-> caseCheck :: CaseMode -> Module -> [String]
+> caseCheck :: CaseMode -> Module a -> [String]
 > caseCheck cm m = check cm (definitions m)
 
-> caseCheckGoal :: CaseMode -> Goal -> [String]
+> caseCheckGoal :: CaseMode -> Goal a -> [String]
 > caseCheckGoal cm g = check cm (goalDefinitions g)
 
 > check :: CaseMode -> [Definition] -> [String]
@@ -85,23 +91,32 @@
 
 > haskellMode :: Category -> [Case]
 > haskellMode TypeConstrId = [UpperCase]
+> haskellMode TypeClassId = [UpperCase]
 > haskellMode TypeVarId = [LowerCase]
 > haskellMode DataConstrId = [UpperCase,ColonCase]
 > haskellMode FunctionId = [LowerCase,NoColonCase]
+> haskellMode MethodId = [LowerCase,NoColonCase]
+> haskellMode LabelId = [LowerCase,NoColonCase]
 > haskellMode VariableId = [LowerCase,NoColonCase]
 
 > prologMode :: Category -> [Case]
 > prologMode TypeConstrId = [LowerCase]
+> prologMode TypeClassId = [LowerCase]
 > prologMode TypeVarId = [UpperCase]
 > prologMode DataConstrId = [LowerCase,ColonCase,NoColonCase]
 > prologMode FunctionId = [LowerCase,ColonCase,NoColonCase]
+> prologMode MethodId = [LowerCase,ColonCase,NoColonCase]
+> prologMode LabelId = [LowerCase,ColonCase,NoColonCase]
 > prologMode VariableId = [UpperCase]
 
 > goedelMode :: Category -> [Case]
 > goedelMode TypeConstrId = [UpperCase]
+> goedelMode TypeClassId = [LowerCase]
 > goedelMode TypeVarId = [LowerCase]
 > goedelMode DataConstrId = [UpperCase,ColonCase,NoColonCase]
 > goedelMode FunctionId = [UpperCase,ColonCase,NoColonCase]
+> goedelMode MethodId = [UpperCase,ColonCase,NoColonCase]
+> goedelMode LabelId = [UpperCase,ColonCase,NoColonCase]
 > goedelMode VariableId = [LowerCase]
 
 \end{verbatim}
@@ -109,11 +124,11 @@
 collect all defined identifiers.
 \begin{verbatim}
 
-> definitions :: Module -> [Definition]
+> definitions :: Module a -> [Definition]
 > definitions (Module _ _ _ ds) = names noPosition ds []
 >   where noPosition = error "noPosition"
 
-> goalDefinitions :: Goal -> [Definition]
+> goalDefinitions :: Goal a -> [Definition]
 > goalDefinitions (Goal p e ds) = names p ds (names p e [])
 
 > class SyntaxTree a where
@@ -122,103 +137,119 @@
 > instance SyntaxTree a => SyntaxTree [a] where
 >   names p xs ys = foldr (names p) ys xs
 
-> instance SyntaxTree TopDecl where
->   names _ (DataDecl p tc tvs cs) xs = typeNames p tc tvs ++ names p cs xs
->   names _ (NewtypeDecl p tc tvs nc) xs = typeNames p tc tvs ++ names p nc xs
+> instance SyntaxTree (TopDecl a) where
+>   names _ (DataDecl p _ tc tvs cs _) xs =
+>     typeNames p tc tvs ++ names p cs (labelNames cs ++ xs)
+>   names _ (NewtypeDecl p _ tc tvs nc _) xs =
+>     typeNames p tc tvs ++ names p nc xs
 >   names _ (TypeDecl p tc tvs _) xs = typeNames p tc tvs ++ xs
+>   names _ (ClassDecl p _ cls tv ds) xs =
+>     D p TypeClassId cls : D p TypeVarId tv :
+>     filter (not . isTypeVar tv) (foldr methodNames [] ds) ++ xs
+>     where isTypeVar tv (D _ TypeVarId tv') = tv == tv'
+>           isTypeVar _ _ = False
+>   names _ (InstanceDecl p _ _ ty ds) xs = names p ty (foldr methodNames xs ds)
+>   names _ (DefaultDecl p tys) xs = names p tys xs
 >   names p (BlockDecl d) xs = names p d xs
 
 > typeNames :: Position -> Ident -> [Ident] -> [Definition]
 > typeNames p tc tvs =
->   D p TypeConstrId tc : map (D p TypeVarId) (filter (not . isAnonId) tvs)
+>   D p TypeConstrId tc : map (D p TypeVarId) (filter (anonId /=) tvs)
 
-> instance SyntaxTree ConstrDecl where
->   names _ (ConstrDecl p evs c _) xs = constrNames p evs c ++ xs
->   names _ (ConOpDecl p evs _ c _) xs = constrNames p evs c ++ xs
+> labelNames :: [ConstrDecl] -> [Definition]
+> labelNames cs = [D p LabelId l | P p l <- ls]
+>   where ls = nub [P p l | RecordDecl _ _ _ _ fs <- cs,
+>                           FieldDecl p ls _ <- fs, l <- ls]
 
-> instance SyntaxTree NewConstrDecl where
->   names _ (NewConstrDecl p c _) xs = constrNames p [] c ++ xs
+> instance SyntaxTree ConstrDecl where
+>   names _ (ConstrDecl p evs _ c _) xs = constrNames p evs c ++ xs
+>   names _ (ConOpDecl p evs _ _ c _) xs = constrNames p evs c ++ xs
+>   names _ (RecordDecl p evs _ c _) xs = constrNames p evs c ++ xs
 
 > constrNames ::  Position -> [Ident] -> Ident -> [Definition]
 > constrNames p evs c =
->   D p DataConstrId c : map (D p TypeVarId) (filter (not . isAnonId) evs)
+>   D p DataConstrId c : map (D p TypeVarId) (filter (anonId /=) evs)
+
+> instance SyntaxTree NewConstrDecl where
+>   names _ (NewConstrDecl p c _) xs = D p DataConstrId c : xs
+>   names _ (NewRecordDecl p c l _) xs = D p DataConstrId c : D p LabelId l : xs
+
+> instance SyntaxTree QualTypeExpr where
+>   names p (QualTypeExpr _ ty) = names p ty
 
 > instance SyntaxTree TypeExpr where
->   names p ty xs =
->     map (D p TypeVarId) (nub (filter (not . isAnonId) (fv ty))) ++ xs
+>   names p ty xs = map (D p TypeVarId) (nub (filter (anonId /=) (fv ty))) ++ xs
+
+> methodNames :: Decl a -> [Definition] -> [Definition]
+> methodNames (InfixDecl _ _ _ _) xs = xs
+> methodNames (TypeSig p fs ty) xs = map (D p MethodId) fs ++ names p ty xs
+> methodNames (FunctionDecl p _ _ eqs) xs = names p eqs xs
+> methodNames (TrustAnnot _ _ _) xs = xs
 
-> instance SyntaxTree Decl where
+> instance SyntaxTree (Decl a) where
 >   names _ (InfixDecl _ _ _ _) xs = xs
 >   names _ (TypeSig p _ ty) xs = names p ty xs
->   names _ (FunctionDecl p f eqs) xs = D p FunctionId f : names p eqs xs
->   names _ (ForeignDecl p _ _ _ f ty) xs = D p FunctionId f : names p ty xs
+>   names _ (FunctionDecl p _ f eqs) xs = D p FunctionId f : names p eqs xs
+>   names _ (ForeignDecl p _ _ f ty) xs = D p FunctionId f : names p ty xs
 >   names _ (PatternDecl p t rhs) xs = names p t (names p rhs xs)
->   names _ (FreeDecl p vs) xs = map (D p VariableId) vs ++ xs
+>   names _ (FreeDecl p vs) xs = map (D p VariableId) (bv vs) ++ xs
 >   names _ (TrustAnnot _ _ _) xs = xs
 
-> instance SyntaxTree Equation where
+> instance SyntaxTree (Equation a) where
 >   names _ (Equation p lhs rhs) = names p lhs . names p rhs
 
-> instance SyntaxTree Lhs where
+> instance SyntaxTree (Lhs a) where
 >   names p (FunLhs _ ts) = names p ts
 >   names p (OpLhs t1 _ t2) = names p t1 . names p t2
 >   names p (ApLhs lhs ts) = names p lhs . names p ts
 
-> instance SyntaxTree Rhs where
+> instance SyntaxTree (Rhs a) where
 >   names _ (SimpleRhs p e ds) = names p ds . names p e
 >   names p (GuardedRhs es ds) = names p ds . names p es
 
-> instance SyntaxTree ConstrTerm where
->   names _ (LiteralPattern _) xs = xs
->   names _ (NegativePattern _ _) xs = xs
->   names p (VariablePattern v) xs
->     | isAnonId v = xs
->     | otherwise = D p VariableId v : xs
->   names p (ConstructorPattern _ ts) xs = names p ts xs
->   names p (InfixPattern t1 _ t2) xs = names p t1 (names p t2 xs)
->   names p (ParenPattern t) xs = names p t xs
->   names p (TuplePattern ts) xs = names p ts xs
->   names p (ListPattern ts) xs = names p ts xs
->   names p (AsPattern v t) xs = D p VariableId v : names p t xs
->   names p (LazyPattern t) xs = names p t xs
+> instance SyntaxTree (ConstrTerm a) where
+>   names p t xs = map (D p VariableId) (bv t) ++ xs
 
-> instance SyntaxTree CondExpr where
+> instance SyntaxTree (CondExpr a) where
 >   names _ (CondExpr p g e) = names p g . names p e
 
-> instance SyntaxTree Expression where
->   names _ (Literal _) = id
->   names _ (Variable _) = id
->   names _ (Constructor _) = id
+> instance SyntaxTree (Expression a) where
+>   names _ (Literal _ _) = id
+>   names _ (Variable _ _) = id
+>   names _ (Constructor _ _) = id
 >   names p (Paren e) = names p e
 >   names p (Typed e ty) = names p e . names p ty
+>   names p (Record _ _ fs) = names p fs
+>   names p (RecordUpdate e fs) = names p e . names p fs
 >   names p (Tuple es) = names p es
->   names p (List es) = names p es
+>   names p (List _ es) = names p es
 >   names p (ListCompr e sts) = names p sts . names p e
 >   names p (EnumFrom e) = names p e
 >   names p (EnumFromThen e1 e2) = names p e1 . names p e2
 >   names p (EnumFromTo e1 e2) = names p e1 . names p e2
 >   names p (EnumFromThenTo e1 e2 e3) = names p e1 . names p e2 . names p e3
->   names p (UnaryMinus _ e) = names p e
+>   names p (UnaryMinus e) = names p e
 >   names p (Apply e1 e2) = names p e1 . names p e2
 >   names p (InfixApply e1 _ e2) = names p e1 . names p e2
 >   names p (LeftSection e _) = names p e
 >   names p (RightSection _ e) = names p e
->   names p (Lambda ts e) = names p ts . names p e
+>   names _ (Lambda p ts e) = names p ts . names p e
 >   names p (Let ds e) = names p ds . names p e
 >   names p (Do sts e) = names p sts . names p e
 >   names p (IfThenElse e1 e2 e3) = names p e1 . names p e2 . names p e3
 >   names p (Case e as) = names p e . names p as
+>   names p (Fcase e as) = names p e . names p as
 
-> instance SyntaxTree Statement where
+> instance SyntaxTree (Statement a) where
 >   names p (StmtExpr e) = names p e
+>   names _ (StmtBind p t e) = names p t . names p e
 >   names p (StmtDecl ds) = names p ds
->   names p (StmtBind t e) = names p t . names p e
 
-> instance SyntaxTree Alt where
+> instance SyntaxTree (Alt a) where
 >   names _ (Alt p t rhs) = names p t . names p rhs
 
-> isAnonId :: Ident -> Bool
-> isAnonId x = unRenameIdent x == anonId
+> instance SyntaxTree a => SyntaxTree (Field a) where
+>   names p (Field _ x) = names p x
 
 \end{verbatim}
 Warning messages.
@@ -230,9 +261,12 @@
 
 > kind :: Category -> String
 > kind TypeConstrId = "type constructor"
+> kind TypeClassId = "type class"
 > kind TypeVarId = "type variable"
 > kind DataConstrId = "data constructor"
 > kind FunctionId = "function"
+> kind MethodId = "type class method"
+> kind LabelId = "field label"
 > kind VariableId = "variable"
 
 > start :: Case -> String
Solo in curry-0.9.11-classful/: CaseMatch.lhs
diff -u curry-0.9.11/CCode.lhs curry-0.9.11-classful/CCode.lhs
--- curry-0.9.11/CCode.lhs	2007-06-15 14:16:35.000000000 +0200
+++ curry-0.9.11-classful/CCode.lhs	2008-02-09 09:08:12.000000000 +0100
@@ -1,7 +1,7 @@
 % -*- LaTeX -*-
-% $Id: CCode.lhs 1822 2005-11-07 22:50:22Z wlux $
+% $Id: CCode.lhs 2620 2008-02-08 13:20:26Z wlux $
 %
-% Copyright (c) 2002-2005, Wolfgang Lux
+% Copyright (c) 2002-2008, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{CCode.lhs}
@@ -54,7 +54,7 @@
 >   | CExternArrayDecl CType String
 >   | CEnumDecl [CConst]
 >   | CFuncDecl CVisibility String
->   | CVarDef CVisibility CType String CInitializer
+>   | CVarDef CVisibility CType String (Maybe CInitializer)
 >   | CArrayDef CVisibility CType String [CInitializer]
 >   | CFuncDef CVisibility String CBlock
 >   | CMainDecl String [String]
@@ -62,7 +62,7 @@
 >   deriving Eq
 
 > data CVisibility = CPublic | CPrivate deriving Eq
-> data CConst = CConst String (Maybe Int) deriving Eq
+> data CConst = CConst String (Maybe Integer) deriving Eq
 > data CInitializer = CInit CExpr | CStruct [CInitializer] deriving Eq
 
 \end{verbatim}
@@ -98,11 +98,13 @@
 >   deriving Eq
 
 > data LVar = LVar String | LElem LVar CExpr | LField LVar String deriving Eq
-> data CCase = CCase String [CStmt] | CDefault [CStmt] deriving Eq
+> data CCase = CCase CCaseLabel [CStmt] deriving Eq
+> data CCaseLabel =
+>   CCaseLabel String | CCaseInt Integer | CCaseDefault deriving Eq
 
 > data CExpr =
 >     CNull
->   | CInt Int
+>   | CInt Integer
 >   | CFloat Double
 >   | CString String
 >   | CElem CExpr CExpr
diff -u curry-0.9.11/CElim.lhs curry-0.9.11-classful/CElim.lhs
--- curry-0.9.11/CElim.lhs	2007-06-15 14:16:35.000000000 +0200
+++ curry-0.9.11-classful/CElim.lhs	2007-08-27 08:51:39.000000000 +0200
@@ -1,7 +1,7 @@
 % -*- LaTeX -*-
-% $Id: CElim.lhs 1822 2005-11-07 22:50:22Z wlux $
+% $Id: CElim.lhs 2453 2007-08-23 22:58:14Z wlux $
 %
-% Copyright (c) 2003-2005, Wolfgang Lux
+% Copyright (c) 2003-2007, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{CElim.lhs}
@@ -55,8 +55,6 @@
 >   where (vss,cases') = unzip (map elimUnusedCaseVars cases)
 >         elimUnusedCaseVars (CCase c sts) = (vs,CCase c sts')
 >           where (vs,sts') = foldr elimUnusedVars (zeroSet,[]) sts
->         elimUnusedCaseVars (CDefault sts) = (vs,CDefault sts')
->           where (vs,sts') = foldr elimUnusedVars (zeroSet,[]) sts
 > elimUnusedVars (CLoop sts) ~(vs,sts') =
 >   (vs' `unionSet` vs,CLoop sts'' : sts')
 >   where (vs',sts'') = foldr elimUnusedVars (zeroSet,[]) sts
diff -u curry-0.9.11/CGen.lhs curry-0.9.11-classful/CGen.lhs
--- curry-0.9.11/CGen.lhs	2007-06-15 14:16:35.000000000 +0200
+++ curry-0.9.11-classful/CGen.lhs	2012-08-14 13:14:36.000000000 +0200
@@ -1,7 +1,7 @@
 % -*- LaTeX -*-
-% $Id: CGen.lhs 2204 2007-05-17 16:29:53Z wlux $
+% $Id: CGen.lhs 3096 2012-08-13 09:53:52Z wlux $
 %
-% Copyright (c) 1998-2007, Wolfgang Lux
+% Copyright (c) 1998-2012, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{CGen.lhs}
@@ -45,22 +45,21 @@
 >     (maybe [] (return . fvDecl "fv_names") fvs ++
 >      [initVar v (defaultValue v) | v <- rtsVars] ++
 >      [procCall "curry_init" ["&argc","argv"],
->       CLocalVar intType "rc"
->         (Just (curry_main fvs f "fv_names" ["argc","argv"])),
->       procCall "curry_terminate" [],
->       procCall "exit" ["rc"],
+>       curry_main fvs f "fv_names" ["argc","argv"],
+>       procCall "curry_exit" [],
 >       CReturn (CInt 0)])]
 >   where fvDecl v vs =
 >           CStaticArray (CPointerType (CConstType "char")) v
 >                        (map CInit (map CString vs ++ [CNull]))
->         initVar v d = CppCondStmts d [setVar (Name v) (CExpr d)] []
+>         initVar v d = CppCondStmts (defined d) [setVar (Name v) (CExpr d)] []
 >         defaultValue v = "DEFAULT_" ++ map toUpper v
+>         defined v = "defined(" ++ v ++ ")"
 >         curry_main (Just _) = curry_eval
 >         curry_main Nothing = const . curry_exec
 >         curry_exec g args =
->           CFunCall "curry_exec" (constRef (constFunc g) : map CExpr args)
+>           CProcCall "curry_exec" (constRef (constFunc g) : map CExpr args)
 >         curry_eval g v args =
->           CFunCall "curry_eval" (addr (nodeInfo g) : map CExpr (v:args))
+>           CProcCall "curry_eval" (addr (nodeInfo g) : map CExpr (v:args))
 
 > rtsVars :: [String]
 > rtsVars = [
@@ -78,166 +77,161 @@
 type declarations and code generated for the function definitions of
 the module. Code generation is complicated by a few special cases that
 need to be handled. In particular, the compiler must provide
-definitions for those tuples that are used in the module and for the
-functions \texttt{@}$_n$ that implement applications of a higher-order
-variable to $n$ arguments.\footnote{The function name \texttt{@} is
-used instead of \texttt{@}$_1$.} These functions cannot be predefined
-because there are no upper limits on the arity of a tuple or
-application. Since these functions may be added in each module, they
-must be declared as private -- i.e., \verb|static| -- functions.
-
-\ToDo{The runtime system should preallocate tuple descriptors up to a
-reasonable size (e.g., 10). Thus the compiler only has to create
-private descriptors if a module uses a tuple with a higher arity.}
+definitions for the functions \texttt{@}$_n$ that implement
+applications of a higher-order variable to $n$ arguments.\footnote{The
+function name \texttt{@} is used instead of \texttt{@}$_1$.} These
+functions cannot be predefined because there is no upper limit on the
+arity of an application. Since these functions may be added in each
+module, they must be declared as private -- i.e., \verb|static| --
+functions.
 
 In addition, the code generator preallocates the nodes for literal
 constants globally. In fact, it preallocates all constants, but this
-is done independently. Constant constructors are defined together with
+happens elsewhere. Constant constructors are defined together with
 their node info and other constants are allocated separately for every
 function because there is not much chance for them to be shared.
 \begin{verbatim}
 
-> genModule :: [Decl] -> Module -> CFile
-> genModule impDs cam =
->   map CppInclude (nub ("curry.h" : [h | CCall (Just h) _ _ <- sts])) ++
->   genTypes impDs ds sts ns ++
->   genFunctions ds fs sts ns
+> genModule :: [(Name,[Name])] -> Module -> CFile
+> genModule ts cam =
+>   map CppInclude (nub ("curry.h" : [h | CCall (Just h) _ _ <- sts'])) ++
+>   genTypes ts ds sts' ns ++
+>   genFunctions ds fs sts' ns
 >   where (_,ds,fs) = splitCam cam
->         (sts0,sts) = foldr linStmts ([],[]) (map thd3 fs)
->         ns = nodes sts ++ letNodes sts0 ++ ccallNodes sts ++ flexNodes sts
+>         sts = [st | (_,_,_,st) <- fs]
+>         sts' = foldr linStmts [] sts
+>         ns = foldr nodes [] sts
 
-> linStmts :: Stmt -> ([Stmt0],[Stmt]) -> ([Stmt0],[Stmt])
-> linStmts st sts = addStmt st (linStmts' st sts)
->   where addStmt st ~(sts0,sts) = (sts0,st:sts)
+> linStmts :: Stmt -> [Stmt] -> [Stmt]
+> linStmts st sts = st : linStmts' st sts
 
-> linStmts' :: Stmt -> ([Stmt0],[Stmt]) -> ([Stmt0],[Stmt])
+> linStmts' :: Stmt -> [Stmt] -> [Stmt]
 > linStmts' (Return _) sts = sts
-> linStmts' (Enter _) sts = sts
+> linStmts' (Eval _) sts = sts
 > linStmts' (Exec _ _) sts = sts
 > linStmts' (CCall _ _ _) sts = sts
-> linStmts' (Seq st1 st2) sts = addStmt st1 $ linStmts0 st1 $ linStmts st2 sts
->   where addStmt st ~(sts0,sts) = (st:sts0,sts)
->         linStmts0 (_ :<- st) sts = linStmts st sts
->         linStmts0 _ sts = sts
+> linStmts' (Seq (_ :<- st1) st2) sts = linStmts st1 $ linStmts st2 sts
+> linStmts' (Let _ st) sts = linStmts st sts
 > linStmts' (Switch rf x cs) sts = foldr linStmts sts [st | Case _ st <- cs]
-> linStmts' (Choices sts) sts' = foldr linStmts sts' sts
+> linStmts' (Choice sts) sts' = foldr linStmts sts' sts
 
 > switchTags :: [Stmt] -> [(Name,Int)]
 > switchTags sts =
 >   [(c,length vs) | Switch _ _ cs <- sts, Case (ConstrCase c vs) _ <- cs]
 
-> nodes :: [Stmt] -> [Expr]
-> nodes sts = [n | Return n <- sts]
-
-> letNodes :: [Stmt0] -> [Expr]
-> letNodes sts0 = [n | Let bds <- sts0, Bind _ n <- bds]
-
-> ccallNodes :: [Stmt] -> [Expr]
-> ccallNodes sts
->   | TypeBool `elem` [ty | CCall _ (Just ty) _ <- sts] =
->       [Constr prelTrue [],Constr prelFalse []]
->   | otherwise = []
-
-> flexNodes :: [Stmt] -> [Expr]
-> flexNodes sts = [node t | Switch Flex _ cs <- sts, Case t _ <- cs]
->   where node (LitCase l) = Lit l
+> nodes :: Stmt -> [Expr] -> [Expr]
+> nodes (Return n) ns = n : ns
+> nodes (Eval _) ns = ns
+> nodes (Exec _ _) ns = ns
+> nodes (CCall _ ty _) ns =
+>   case ty of
+>     Just TypeBool -> Constr prelTrue [] : Constr prelFalse [] : ns
+>     Just _ -> ns
+>     Nothing -> Constr prelUnit [] : ns
+> nodes (Seq (_ :<- st1) st2) ns = nodes st1 $ nodes st2 ns
+> nodes (Let ds st) ns = [n | Bind _ n <- ds] ++ nodes st ns
+> nodes (Switch rf x cs) ns =
+>   case rf of
+>     Flex -> [node t | Case t _ <- cs] ++ ns'
+>     Rigid ->
+>       [Lit l | Case (LitCase l@(Integer i)) _ <- cs, not (fits32bits i)] ++
+>       ns'
+>   where ns' = foldr nodes ns [st | Case _ st <- cs]
+>         node (LitCase l) = Lit l
 >         node (ConstrCase c vs) = Constr c vs
+> nodes (Choice sts) ns = foldr nodes ns sts
 
 \end{verbatim}
 \subsection{Data Types and Constants}
 For every data type, the compiler defines an enumeration that assigns
-tag numbers to its data constructors. Normally, tags starting at zero
-are assigned to the constructors of each type from left to right.
-However, in order to distinguish constructors of existentially
-quantified types, those constructors are assigned negative tag values
-starting at $-1$. The \verb|enum| declarations are not strictly
-necessary, but simplify the code generator because it does not need to
-determine the tag value of a constructor when it is used.
+tag numbers starting at zero to its data constructors from left to
+right. The \verb|enum| declarations are not strictly necessary, but
+simplify the code generator because it does not need to determine the
+tag value of a constructor when it is used.
 
 In addition to the tag enumerations, the compiler also defines node
 info structures for every data constructor and preallocates constant
-constructors and literal constants. Integer constants need to be
-allocated only if they cannot be represented in $n-1$ bits where $n$
-is the number of bits per word of the target architecture. The
-generated code uses the preprocessor macro \texttt{is\_large\_int}
-defined in the runtime system (see Sect.~\ref{sec:heap}) in order to
-determine whether allocation is necessary. Note that this macro always
-returns true if the system was configured with the
+constructors and literal constants. Native integer constants as well
+as multiple precision integer constants need to be allocated only if
+they cannot be represented in $n-1$ bits where $n$ is the number of
+bits per word of the target architecture. The generated code uses the
+preprocessor macros \texttt{is\_large\_int} and
+\texttt{is\_large\_int\_32\_64} defined in the runtime system (see
+Sect.~\ref{sec:heap}) in order to determine whether allocation is
+necessary. The latter macro is used only for multiple precision
+integer constants that require more than 32 bits and less than 64
+bits. On a 32-bit target this macro always yields true, whereas it
+yields true on a 64-bit architecture only when the constant does not
+fit into 63 bits.  Multiple precision integer constants that do not
+fit into 64 bits are always allocated. Note that both macros always
+return true if the system was configured with the
 \texttt{--disable-pointer-tags} configuration option. Character
 constants are encoded in pointers unless the system was configured
 with the \texttt{--disable-pointer-tags} configuration option. In that
 case, character constants with codes below 256, which are most
 commonly used, are allocated in a table defined by the runtime system
 and only constants with larger codes need to be preallocated in the
-generated code.
+generated code. Multiple precision integer constants are preallocated
+as well but they cannot be initialized statically because their
+underlying representation is opaque. Instead, these constants are
+initialized upon their first use.
 \begin{verbatim}
 
-> genTypes :: [Decl] -> [(Name,[Name],[ConstrDecl])] -> [Stmt] -> [Expr]
->          -> [CTopDecl]
-> genTypes impDs ds sts ns =
+> genTypes :: [(Name,[Name])] -> [(Name,[Name],[ConstrDecl])] -> [Stmt]
+>          -> [Expr] -> [CTopDecl]
+> genTypes ts ds sts ns =
 >   -- imported data constructors
->   [tagDecl t vs cs | DataDecl t vs cs <- impDs, any (`conElem` usedTs) cs] ++
->   [dataDecl c | DataDecl _ _ cs <- impDs, c <- cs, c `conElem` usedCs] ++
->   -- (private) tuple constructors
->   map (tupleTagDecl . fst) (nub (usedTts ++ usedTcs)) ++
->   concatMap (dataDef CPrivate . uncurry tupleConstr) usedTcs ++
+>   [tagDecl cs | (_,cs) <- ts, any (`elem` usedTs) cs] ++
+>   [dataDecl c n | (c,n) <- usedCs] ++
 >   -- local data declarations
->   [tagDecl t vs cs | (t,vs,cs) <- ds] ++
->   concat [dataDecl c : dataDef CPublic c | cs <- map thd3 ds, c <- cs] ++
+>   [tagDecl (map snd3 cs) | (_,cs) <- ds'] ++
+>   concat [dataDef ex vb c n | (ex,cs) <- ds', (vb,c,n) <- cs] ++
 >   -- literal constants
 >   literals [c | Lit c <- ns]
->   where constrs = [(c,length vs) | Constr c vs <- ns]
->         (usedTts,usedTs) = partition (isTuple . fst) (nub (switchTags sts))
->         (usedTcs',usedCs) = partition (isTuple . fst) (nub constrs)
->         usedTcs = nub (usedTcs' ++ usedTfs)
->         usedTfs = [(f,tupleArity f) | Papp f _ <- ns, isTuple f]
->         conElem c = (constr c `elem`)
-
-> constr :: ConstrDecl -> (Name,Int)
-> constr (ConstrDecl c tys) = (c,length tys)
-
-> tupleConstr :: Name -> Int -> ConstrDecl
-> tupleConstr c n = ConstrDecl c (map TypeVar vs)
->   where vs = [Name ('a' : show i) | i <- [1..n]]
-
-> tagDecl :: Name -> [Name] -> [ConstrDecl] -> CTopDecl
-> tagDecl _ vs cs =
->   CEnumDecl [CConst (dataTag c) (Just n)
->             | (ConstrDecl c _,n) <- zip cs tags, c /= Name "_"]
->   where tags
->           | any hasExistType cs = [-1,-2..]
->           | otherwise = [0..]
->         hasExistType (ConstrDecl _ tys) = any hasExistVar tys
+>   where ds' = [(existType vs cs,map constr cs) | (_,vs,cs) <- ds]
+>         cs = concatMap snd ds'
+>         cs' = [(c,n) | (_,c,n) <- cs]
+>         usedTs = map fst (nub (switchTags sts) \\ cs')
+>         usedCs = nub [(c,length vs) | Constr c vs <- ns] \\ cs'
+
+> existType :: [Name] -> [ConstrDecl] -> Bool
+> existType vs cs = any hasExistType cs
+>   where hasExistType (ConstrDecl _ _ tys) = any hasExistVar tys
 >         hasExistVar (TypeVar v) = v `notElem` vs
 >         hasExistVar (TypeApp _ tys) = any hasExistVar tys
 >         hasExistVar (TypeArr ty1 ty2) = hasExistVar ty1 || hasExistVar ty2
 
-> tupleTagDecl :: Name -> CTopDecl
-> tupleTagDecl c = CEnumDecl [CConst (dataTag c) (Just 0)]
+> constr :: ConstrDecl -> (Visibility,Name,Int)
+> constr (ConstrDecl vb c tys) = (vb,c,length tys)
+
+> tagDecl :: [Name] -> CTopDecl
+> tagDecl cs = CEnumDecl [CConst (dataTag c) (Just n) | (c,n) <- zip cs [0..]]
 
-> dataDecl :: ConstrDecl -> CTopDecl
-> dataDecl (ConstrDecl c tys)
->   | null tys = CExternVarDecl nodeInfoConstPtrType (constNode c)
->   | otherwise = CExternVarDecl nodeInfoType (nodeInfo c)
-
-> dataDef :: CVisibility -> ConstrDecl -> [CTopDecl]
-> dataDef vb (ConstrDecl c tys)
->   | null tys =
->       [CVarDef CPrivate nodeInfoType (nodeInfo c) nodeinfo,
->        CVarDef vb nodeInfoConstPtrType (constNode c)
->                (CInit (addr (nodeInfo c)))]
->   | otherwise = [CVarDef vb nodeInfoType (nodeInfo c) nodeinfo]
+> dataDecl :: Name -> Int -> CTopDecl
+> dataDecl c n = head (dataDef undefined Exported c n)
+
+> dataDef :: Bool -> Visibility -> Name -> Int -> [CTopDecl]
+> dataDef ex vb c n
+>   | n == 0 =
+>       [CExternVarDecl nodeInfoConstPtrType (constNode c) | vb == Exported] ++
+>       [CVarDef CPrivate nodeInfoType (nodeInfo c) (Just nodeinfo),
+>        CVarDef (cVis vb) nodeInfoConstPtrType (constNode c)
+>                (Just (CInit (addr (nodeInfo c))))]
+>   | otherwise =
+>       [CExternVarDecl nodeInfoType (nodeInfo c) | vb == Exported] ++
+>       [CVarDef (cVis vb) nodeInfoType (nodeInfo c) (Just nodeinfo)]
 >   where nodeinfo = CStruct (map CInit nodeinfo')
 >         nodeinfo' =
->           [CExpr "CAPP_KIND",CExpr (dataTag c),closureNodeSize (length tys),
->            gcPointerTable,CString name,CExpr "eval_whnf",noApply,noEntry,
->            notFinalized]
+>           [CExpr (if ex then "EAPP_KIND" else "CAPP_KIND"),CExpr (dataTag c),
+>            closureNodeSize n,gcPointerTable,CString name,
+>            CExpr "eval_whnf",noApply,noEntry,notFinalized]
 >         name = snd $ splitQualified $ demangle c
 
 > literals :: [Literal] -> [CTopDecl]
 > literals cs =
 >   map charConstant (nub [c | Char c <- cs]) ++
 >   map intConstant (nub [i | Int i <- cs]) ++
+>   map integerConstant (nub [i | Integer i <- cs]) ++
 >   map floatConstant (nub [f | Float f <- cs])
 
 > charConstant :: Char -> CTopDecl
@@ -246,26 +240,38 @@
 >   where charNode c
 >           | ord c < 0x100 =
 >               [CppDefine (constChar c)
->                          (asNode (CAdd (CExpr "char_table") (CInt (ord c))))]
+>                          (asNode (CAdd (CExpr "char_table") (charCode c)))]
 >           | otherwise =
 >               [CVarDef CPrivate (CConstType "struct char_node") (constChar c)
->                        (CStruct $ map CInit [addr "char_info",CInt (ord c)]),
+>                  (Just (CStruct (map CInit [addr "char_info",charCode c]))),
 >                CppDefine (constChar c) (constRef (constChar c))]
 >         taggedChar c =
->           [CppDefine (constChar c) (CFunCall "tag_char" [CInt (ord c)])]
+>           [CppDefine (constChar c) (CFunCall "tag_char" [charCode c])]
+>         charCode c = int (ord c)
 
-> intConstant :: Int -> CTopDecl
+> intConstant :: Integer -> CTopDecl
 > intConstant i =
 >   CppCondDecls (CFunCall "is_large_int" [CInt i])
 >     [CVarDef CPrivate (CConstType "struct int_node") (constInt i)
->              (CStruct $ map CInit [addr "int_info",CInt i]),
+>              (Just (CStruct (map CInit [addr "int_info",CInt i]))),
 >      CppDefine (constInt i) (constRef (constInt i))]
 >     [CppDefine (constInt i) (CFunCall "tag_int" [CInt i])]
 
+> integerConstant :: Integer -> CTopDecl
+> integerConstant i =
+>   CppCondDecls (isLargeInt [CInt i])
+>     [CVarDef CPrivate (CType "struct bigint_node") (constInteger i) Nothing,
+>      CppDefine (constInteger i) (constRef (constInteger i))]
+>     [CppDefine (constInteger i) (CFunCall "tag_int" [CInt i])]
+>   where isLargeInt
+>           | fits32bits i = CFunCall "is_large_int"
+>           | fits64bits i = CFunCall "is_large_int_32_64"
+>           | otherwise = const (CInt 1)
+
 > floatConstant :: Double -> CTopDecl
 > floatConstant f =
 >   CVarDef CPrivate (CConstType "struct float_node") (constFloat f)
->           (CStruct $ map CInit [addr "float_info",fval f])
+>           (Just (CStruct (map CInit [addr "float_info",fval f])))
 >   where fval f
 >           | isNaN f = error "internalError: NaN literal in CGen.floatConstant"
 >           | isInfinite f = CExpr (withSign f "1e500")
@@ -287,18 +293,18 @@
 non-updatable) lazy application nodes. In addition, the compiler
 introduces auxiliary functions that instantiate unbound variables with
 literals and data constructors, respectively, and functions that
-implement partial applications of data constructors including tuple
-constructors used in the current module. Furthermore, the code for
-those functions \texttt{@}$_n$, which are used in the current module,
-is generated.
+implement partial applications of data constructors. Furthermore, the
+code for those functions \texttt{@}$_n$, which are used in the current
+module, is generated.
 \begin{verbatim}
 
-> genFunctions :: [(Name,[Name],[ConstrDecl])] -> [(Name,[Name],Stmt)]
->              -> [Stmt] -> [Expr] -> [CTopDecl]
+> genFunctions :: [(Name,[Name],[ConstrDecl])]
+>              -> [(Visibility,Name,[Name],Stmt)] -> [Stmt] -> [Expr]
+>              -> [CTopDecl]
 > genFunctions ds fs sts ns =
 >   -- imported functions
->   map (instEntryDecl CPublic) (nonLocalData (map fst flexData)) ++
->   map (entryDecl CPublic) (nonLocal call) ++
+>   map (instEntryDecl Exported) (nonLocal flexData) ++
+>   map (entryDecl Exported) (nonLocal call) ++
 >   map pappDecl (nonLocal papp) ++
 >   map evalDecl (nonLocal clos) ++
 >   map lazyDecl (nonLocal lazy) ++
@@ -309,66 +315,56 @@
 >   concat [[evalEntryDecl n,evalFunction n] | n <- closArities] ++
 >   concat [[lazyEntryDecl n,lazyFunction n] | n <- lazyArities] ++
 >   -- instantiation functions for data constructors
->   map (instEntryDecl CPublic . fst) cs ++
->   [instFunction CPublic c n | (c,n) <- cs] ++
+>   [instEntryDecl vb c | (vb,c,_) <- flex'] ++
+>   [instFunction vb c n | (vb,c,n) <- flex'] ++
 >   -- (private) instantiation functions for literals
 >   map litInstEntryDecl flexLits ++
 >   map litInstFunction flexLits ++
->   -- (private) instantiation functions for tuples
->   map (instEntryDecl CPrivate . fst) flexTuples ++
->   [instFunction CPrivate c n | (c,n) <- flexTuples] ++
 >   -- (private) @ functions
->   [entryDecl CPrivate (apName n) | n <- [2..maxApArity]] ++
->   concat [evalDef CPrivate f (apArity f) | f <- apClos] ++
->   concat [lazyDef CPrivate f (apArity f) | f <- apLazy] ++
+>   [entryDecl Private (apName n) | n <- [2..maxApArity]] ++
+>   concat [evalDef Private f (apArity f) | f <- apClos] ++
+>   concat [lazyDef Private f (apArity f) | f <- apLazy] ++
 >   concat [apFunction (apName n) n | n <- [2..maxApArity]] ++
->   -- (private) auxiliary functions for partial applications of tuples
->   map (entryDecl CPrivate) tuplePapp ++
->   concat [pappDef CPrivate f (tupleArity f) | f <- tuplePapp] ++
->   concat [fun0Def CPrivate f (tupleArity f) | f <- tupleFun0] ++
->   concat [conFunction CPrivate f (tupleArity f) | f <- tuplePapp] ++
 >   -- auxiliary functions for partial applications of data constructors
->   map (entryDecl CPublic . fst) cs ++
->   concat [pappDef CPublic c n | (c,n) <- cs, n > 0] ++
->   concat [fun0Def CPublic c n | (c,n) <- cs, n > 0] ++
->   concat [conFunction CPublic c n | (c,n) <- cs, n > 0] ++
+>   [entryDecl Private c | (_,c,n) <- pcon', n > 0] ++
+>   concat [pappDef vb c n | (vb,c,n) <- pcon', n > 0] ++
+>   concat [fun0Def vb c n | (vb,c,n) <- con0', n > 0] ++
+>   concat [conFunction Private c n | (_,c,n) <- pcon', n > 0] ++
 >   -- local function declarations
->   [entryDecl (public f) f | (f,_,_) <- fs] ++
->   concat [pappDef (public f) f n | (f,n) <- papp', n > 0] ++
->   concat [evalDef (public f) f n | (f,n) <- clos'] ++
->   concat [lazyDef (public f) f n | (f,n) <- lazy'] ++
->   concat [fun0Def (public f) f n | (f,n) <- fun0'] ++
->   concat [function (public f) f vs st | (f,vs,st) <- fs]
->   where nonLocal = filter (`notElem` map fst3 fs)
->         nonLocalData = filter (`notElem` map fst cs)
->         (tuplePapp,papp) = partition isTuple (nub [f | Papp f _ <- ns])
+>   [entryDecl vb f | (vb,f,_,_) <- fs] ++
+>   concat [pappDef vb f n | (vb,f,n) <- papp', n > 0] ++
+>   concat [evalDef vb f n | (vb,f,n) <- clos'] ++
+>   concat [lazyDef vb f n | (vb,f,n) <- lazy'] ++
+>   concat [fun0Def vb f n | (vb,f,n) <- fun0'] ++
+>   concat [function vb f vs st | (vb,f,vs,st) <- fs]
+>   where nonLocal =
+>           filter (`notElem` [c | (_,c,_) <- cs] ++ [f | (_,f,_,_) <- fs])
+>         papp = nub [f | Papp f _ <- ns]
 >         (apCall,call) = partition isAp (nub [f | Exec f _ <- sts])
 >         (apClos,clos) = partition isAp (nub [f | Closure f _ <- ns])
 >         (apLazy,lazy) = partition isAp (nub [f | Lazy f _ <- ns])
->         (tupleFun0,fun0) =
->           partition isTuple
->                     (nub ([f | Papp f [] <- ns] ++ [f | Closure f [] <- ns]))
+>         fun0 = nub ([f | Papp f [] <- ns] ++ [f | Closure f [] <- ns])
 >         maxApArity = maximum (0 : map apArity (apCall ++ apClos ++ apLazy))
 >         cs = [constr c | c <- concatMap thd3 ds]
->         fs' = [(f,n) | (f,vs,_) <- fs, let n = length vs, (f,n) `notElem` cs]
->         papp' = filter (used papp . fst) fs'
->         clos' = filter (used clos . fst) fs'
->         lazy' = filter (used lazy . fst) fs'
->         fun0' = filter (used fun0 . fst) fs'
->         pappArities =
->           nub (map snd cs ++ map tupleArity tuplePapp ++ map snd papp')
->         closArities = nub (map apArity apClos ++ map snd clos')
->         lazyArities = nub (map apArity apLazy ++ map snd lazy')
+>         fs' = [(vb,f,length vs) | (vb,f,vs,_) <- fs]
+>         flex' = filter (used flexData) cs
+>         pcon' = filter (used papp) cs
+>         con0' = filter (used fun0) cs
+>         papp' = filter (used papp) fs'
+>         clos' = filter (used clos) fs'
+>         lazy' = filter (used lazy) fs'
+>         fun0' = filter (used fun0) fs'
+>         pappArities = nub (map thd3 (pcon' ++ papp'))
+>         closArities = nub (map apArity apClos ++ map thd3 clos')
+>         lazyArities = nub (map apArity apLazy ++ map thd3 lazy')
 >         ts = [t | Switch Flex _ cs <- sts, Case t _ <- cs]
 >         flexLits = nub [l | LitCase l <- ts]
->         (flexTuples,flexData) =
->           partition (isTuple . fst)
->                     (nub [(c,length vs) | ConstrCase c vs <- ts])
->         used fs f = isPublic f || f `elem` fs
->         public f = if isPublic f then CPublic else CPrivate
+>         flexData = nub [c | ConstrCase c _ <- ts]
+>         used _ (Exported,_,_) = True
+>         used xs (Private,x,_) = x `elem` xs
 
-> entryDecl :: CVisibility -> Name -> CTopDecl
-> entryDecl vb f = CFuncDecl vb (cName f)
+> entryDecl :: Visibility -> Name -> CTopDecl
+> entryDecl vb f = CFuncDecl (cVis vb) (cName f)
 
 > applyEntryDecl :: Int -> Int -> CTopDecl
 > applyEntryDecl m n = CFuncDecl CPrivate (applyFunc m n)
@@ -379,8 +375,8 @@
 > lazyEntryDecl :: Int -> CTopDecl
 > lazyEntryDecl n = CFuncDecl CPrivate (lazyFunc n)
 
-> instEntryDecl :: CVisibility -> Name -> CTopDecl
-> instEntryDecl vb c = CFuncDecl vb (instFunc c)
+> instEntryDecl :: Visibility -> Name -> CTopDecl
+> instEntryDecl vb c = CFuncDecl (cVis vb) (instFunc c)
 
 > litInstEntryDecl :: Literal -> CTopDecl
 > litInstEntryDecl l = CFuncDecl CPrivate (litInstFunc l)
@@ -397,43 +393,43 @@
 > fun0Decl :: Name -> CTopDecl
 > fun0Decl f = CExternVarDecl (CConstType "struct closure_node") (constFunc f)
 
-> pappDef :: CVisibility -> Name -> Int -> [CTopDecl]
+> pappDef :: Visibility -> Name -> Int -> [CTopDecl]
 > pappDef vb f n =
->   [pappDecl f | vb == CPublic] ++
->   [CArrayDef vb nodeInfoType (pappInfoTable f)
+>   [pappDecl f | vb == Exported] ++
+>   [CArrayDef (cVis vb) nodeInfoType (pappInfoTable f)
 >              [pappInfo f i n | i <- [0..n-1]]]
 
-> evalDef :: CVisibility -> Name -> Int -> [CTopDecl]
+> evalDef :: Visibility -> Name -> Int -> [CTopDecl]
 > evalDef vb f n =
->   [evalDecl f | vb == CPublic] ++
->   [CVarDef vb nodeInfoType (nodeInfo f) (funInfo f n)]
+>   [evalDecl f | vb == Exported] ++
+>   [CVarDef (cVis vb) nodeInfoType (nodeInfo f) (Just (funInfo f n))]
 
-> lazyDef :: CVisibility -> Name -> Int -> [CTopDecl]
+> lazyDef :: Visibility -> Name -> Int -> [CTopDecl]
 > lazyDef vb f n =
->   [lazyDecl f | vb == CPublic] ++
+>   [lazyDecl f | vb == Exported] ++
 >   [CppCondDecls (CExpr "!COPY_SEARCH_SPACE")
->      [CArrayDef vb nodeInfoType (lazyInfoTable f)
+>      [CArrayDef (cVis vb) nodeInfoType (lazyInfoTable f)
 >                 (map (CStruct . map CInit) [suspinfo,queuemeinfo,indirinfo])]
->      [CArrayDef vb nodeInfoType (lazyInfoTable f)
+>      [CArrayDef (cVis vb) nodeInfoType (lazyInfoTable f)
 >                 [CStruct (map CInit suspinfo)]]]
 >   where suspinfo =
->           [CExpr "LAZY_KIND",CExpr "UPD_TAG",suspendNodeSize n,
+>           [CExpr "SUSPEND_KIND",CExpr "EVAL_TAG",suspendNodeSize n,
 >            gcPointerTable,CString (undecorate (demangle f)),
 >            CExpr (lazyFunc n),noApply,CExpr (cName f),notFinalized]
 >         queuemeinfo =
->           [CExpr "LAZY_KIND",CExpr "QUEUEME_TAG",suspendNodeSize n,
+>           [CExpr "QUEUEME_KIND",CExpr "EVAL_TAG",suspendNodeSize n,
 >            gcPointerTable,noName,CExpr "eval_queueMe",noApply,noEntry,
 >            notFinalized]
 >         indirinfo =
->           [CExpr "INDIR_KIND",CInt 0,suspendNodeSize n,
+>           [CExpr "INDIR_KIND",CExpr "INDIR_TAG",suspendNodeSize n,
 >            gcPointerTable,noName,CExpr "eval_indir",noApply,noEntry,
 >            notFinalized]
 
-> fun0Def :: CVisibility -> Name -> Int -> [CTopDecl]
+> fun0Def :: Visibility -> Name -> Int -> [CTopDecl]
 > fun0Def vb f n =
->   [fun0Decl f | vb == CPublic] ++
->   [CVarDef vb (CConstType "struct closure_node") (constFunc f)
->            (CStruct [CInit (info f n),CStruct [CInit CNull]])]
+>   [fun0Decl f | vb == Exported] ++
+>   [CVarDef (cVis vb) (CConstType "struct closure_node") (constFunc f)
+>            (Just (CStruct [CInit (info f n),CStruct [CInit CNull]]))]
 >   where info f n
 >           | n == 0 = addr (nodeInfo f)
 >           | otherwise = CExpr (pappInfoTable f)
@@ -441,14 +437,14 @@
 > pappInfo :: Name -> Int -> Int -> CInitializer
 > pappInfo f i n = CStruct (map CInit funinfo)
 >   where funinfo =
->           [CExpr "PAPP_KIND",CInt (n - i),closureNodeSize i,gcPointerTable,
+>           [CExpr "PAPP_KIND",int (n - i),closureNodeSize i,gcPointerTable,
 >            CString (undecorate (demangle f)),CExpr "eval_whnf",
 >            CExpr (applyFunc i n),CExpr (cName f),notFinalized]
 
 > funInfo :: Name -> Int -> CInitializer
 > funInfo f n = CStruct (map CInit funinfo)
 >   where funinfo =
->           [CExpr "LAZY_KIND",CExpr "NOUPD_TAG",closureNodeSize n,
+>           [CExpr "FAPP_KIND",CExpr "EVAL_TAG",closureNodeSize n,
 >            gcPointerTable,CString (undecorate (demangle f)),
 >            CExpr (evalFunc n),noApply,CExpr (cName f),notFinalized]
 
@@ -461,8 +457,8 @@
 the suspend node associated with the abstract machine code function.
 \begin{verbatim}
 
-> function :: CVisibility -> Name -> [Name] -> Stmt -> [CTopDecl]
-> function vb f vs st = funcDefs vb f vs (cpsFunction f vs st)
+> function :: Visibility -> Name -> [Name] -> Stmt -> [CTopDecl]
+> function vb f vs st = funcDefs vb (cpsFunction f vs st)
 
 > applyFunction :: Int -> Int -> CTopDecl
 > applyFunction m n = CFuncDef CPrivate (applyFunc m n) (applyCode m n)
@@ -473,79 +469,78 @@
 > lazyFunction :: Int -> CTopDecl
 > lazyFunction n = CFuncDef CPrivate (lazyFunc n) (lazyCode n)
 
-> conFunction :: CVisibility -> Name -> Int -> [CTopDecl]
+> conFunction :: Visibility -> Name -> Int -> [CTopDecl]
 > conFunction vb f n = function vb f vs (Return (Constr f vs))
 >   where vs = [Name ('v' : show i) | i <- [1..n]]
 
 > apFunction :: Name -> Int -> [CTopDecl]
-> apFunction f n = funcDefs CPrivate f vs (cpsApply f vs)
+> apFunction f n = funcDefs Private (cpsApply f vs)
 >   where vs = [Name ('v' : show i) | i <- [1..n]]
 
-> instFunction :: CVisibility -> Name -> Int -> CTopDecl
-> instFunction vb c n =
->   CFuncDef vb (instFunc c)
->            (funCode False (cpsInst (Name "") v (ConstrCase c vs)))
+> instFunction :: Visibility -> Name -> Int -> CTopDecl
+> instFunction vb c n = funcDef vb (cpsInst v (ConstrCase c vs))
 >   where v:vs = [Name ('v' : show i) | i <- [0..n]]
 
 > litInstFunction :: Literal -> CTopDecl
-> litInstFunction l =
->   CFuncDef CPrivate (litInstFunc l)
->            (funCode False (cpsInst (Name "") (Name "v0") (LitCase l)))
-
-> funcDefs :: CVisibility -> Name -> [Name] -> [CPSFunction] -> [CTopDecl]
-> funcDefs vb f vs (k:ks) =
->   map privFuncDecl ks ++ entryDef vb f vs k : map funcDef ks
-
-> privFuncDecl :: CPSFunction -> CTopDecl
-> privFuncDecl k = CFuncDecl CPrivate (cpsName k)
-
-> entryDef :: CVisibility -> Name -> [Name] -> CPSFunction -> CTopDecl
-> entryDef vb f vs k
->   | null (cpsEnv k) =
->       CFuncDef vb (cpsName k) (entryCode f (length vs) : funCode True k)
->   | otherwise = error ("internal error: entryDef " ++ demangle f)
-
-> funcDef :: CPSFunction -> CTopDecl
-> funcDef k = CFuncDef CPrivate (cpsName k) (funCode False k)
-
-> entryCode :: Name -> Int -> CStmt
-> entryCode f n =
->   CProcCall "TRACE_FUN" [CString (undecorate (demangle f)),CInt n]
+> litInstFunction l = funcDef Private (cpsInst (Name "v0") (LitCase l))
+
+> funcDefs :: Visibility -> CPSFunction -> [CTopDecl]
+> funcDefs vb f =
+>   map privFuncDecl ks ++ entryDef vb f : map (funcDef Private) ks
+>   where ks = continuations f
+
+> privFuncDecl :: CPSContinuation -> CTopDecl
+> privFuncDecl (CPSContinuation f _ _ _) = CFuncDecl CPrivate (contName f)
+
+> entryDef :: Visibility -> CPSFunction -> CTopDecl
+> entryDef vb (CPSFunction f vs st) =
+>   CFuncDef (cVis vb) (cName f)
+>            (entryCode f vs ++ funCode f (vs,CPSReturn) st)
+
+> funcDef :: Visibility -> CPSContinuation -> CTopDecl
+> funcDef vb (CPSContinuation f vs ws st) =
+>   CFuncDef (cVis vb) (contName f)
+>            (funCode (name f) (vs,CPSCont f ws CPSReturn) st)
+>   where name (CPSContFun f _) = f
+>         name (CPSInst _) = Name ""
+>         name (CPSApply _) = Name ""
+>         name CPSUpdate = Name ""
+
+> entryCode :: Name -> [Name] -> [CStmt]
+> entryCode f vs =
+>   [procCall "C_STACK_CHECK" [cName f],
+>    CProcCall "TRACE_FUN" [CString (undecorate (demangle f)),int (length vs)]]
 
 \end{verbatim}
 The compiler generates a C function from every CPS function. At the
 beginning of a function, stack and heap checks are performed if
 necessary. After the heap check, the function's arguments and local
-variables are loaded from the argument registers and the stack. When
-generating code for the cases in a \texttt{switch} statement, we try
-to reuse these variables. However, if the case code performs a heap
-check, the variables have to be reloaded because the garbage collector
-does not trace local variables. Note that the code generated by
-\texttt{caseCode} is enclosed in a \texttt{CBlock} so that the
-declarations generated by \texttt{loadVars} are not moved to a place
-where they might inadvertently shadow the variables loaded at the
-beginning of the function.
-\begin{verbatim}
-
-> funCode :: Bool -> CPSFunction -> [CStmt]
-> funCode ent (CPSFunction f _ vs ws st) =
->   elimUnused (stackCheck us st ++ heapCheck us (allocSize consts ds tys) ++
->               loadVars us ++ constDefs consts ds ++ cCode f consts us st [])
->   where us = (ent,vs,ws)
->         ds = concat dss
->         (tys,dss) = allocs st
+variables are loaded from the argument registers and the stack. The
+code for an alternative of a \texttt{switch} statement is similar
+except that we avoid loading the matched variable again -- unless a
+heap check is performed.
+\begin{verbatim}
+
+> funCode :: Name -> ([Name],CPSCont) -> CPSStmt -> [CStmt]
+> funCode f vs st =
+>   elimUnused (concatMap prepAlloc ds' ++ stackCheck vs st ++ heapCheck vs n ++
+>               loadVars vs ++ constDefs consts ds ++ cCode f consts vs st)
+>   where ds = concat dss
+>         (tys,ds',dss) = allocs st
 >         consts = constants dss
+>         n = allocSize consts ds ds' tys
 
-> caseCode :: Name -> (Bool,[Name],[Name]) -> Name -> CPSTag -> CPSStmt
->          -> [CStmt]
+> caseCode :: Name -> ([Name],CPSCont) -> Name -> CPSTag -> CPSStmt -> [CStmt]
 > caseCode f vs v t st =
->   [CBlock (stackCheck vs st ++ heapCheck' vs (allocSize consts ds tys) ++
->            fetchArgs v t ++ constDefs consts ds ++ cCode f consts vs st [])]
+>   concatMap prepAlloc ds' ++ stackCheck vs st ++ heapCheck vs n ++
+>   skip (n == CInt 0) v (loadVars vs) ++ fetchArgs v t ++
+>   constDefs consts ds ++ cCode f consts vs st
 >   where ds = concat dss
->         (tys,dss) = allocs st
+>         (tys,ds',dss) = allocs st
 >         consts = constants dss
->         heapCheck' vs n = if null sts then [] else sts ++ loadVars vs
->           where sts = heapCheck vs n
+>         n = allocSize consts ds ds' tys
+>         skip True v = filter (\(CLocalVar _ v' _) -> show v /= v')
+>         skip False _ = id
 
 \end{verbatim}
 The evaluation code for non-updatable lazy application nodes just
@@ -559,16 +554,17 @@
 stack, the suspended application node is overwritten with an
 indirection node pointing to the queue-me node from the update frame
 and no additional update frame is pushed onto the stack. This avoids a
-potential stack overflow when performing tail calls to a variable
+potential stack overflow when performing a tail call to a variable
 instead of a known function.
 
 The application entry points of partial application nodes use a
 special calling convention where the additional arguments and the
 return address are expected on the stack rather than in argument
 registers and the return address register, respectively. This calling
-convention is used because it allows the code to move the additional
-arguments only once in the common case where a partial application is
-applied to exactly its missing arguments.
+convention is used so that the application entry points do not need to
+shift the additional arguments to argument registers with higher
+indices when loading the arguments from the partial application node
+into their respective argument registers.
 \begin{verbatim}
 
 > applyCode :: Int -> Int -> [CStmt]
@@ -581,7 +577,6 @@
 >    gotoExpr (field v "info->entry")]
 >   where v = Name "clos"
 >         arg = element (field v "c.args")
->         setArg i f j = setReg i (f j)
 
 > evalCode :: Int -> [CStmt]
 > evalCode n =
@@ -593,129 +588,128 @@
 
 > lazyCode :: Int -> [CStmt]
 > lazyCode n =
->   CIf (CFunCall "!is_local_space" [CField (reg 0) "s.spc"])
->       [CProcCall "suspend_search" [CInt 1,CField (reg 0) "s.spc"]]
->       [] :
 >   loadVars vs0 ++
 >   CLocalVar labelType "entry" (Just (field v "info->entry")) :
->   zipWith fetchArg vs [0..] ++
->   CIf (CRel (var retIpName) "==" (CExpr "update"))
+>   [setReg i (arg i) | i <- [0..n-1]] ++
+>   CIf (CRel (contAddr vs0 CPSReturn) "==" (CExpr "update"))
 >       (localVar v' (Just (stk 0)) : lockIndir v v')
->       (stackCheck vs0 (CPSWithCont k (CPSExec undefined vs)) ++
->        saveCont vs0 [] [] [k] ++
->        [setRet (CExpr "update")] ++
+>       (stackCheck vs0 (CPSExec (CPSEval False v) k [v]) ++
+>        saveVars vs0 (contVars vs0 [] [] k) ++
+>        setRet (contAddr vs0 k) :
 >        lock v) :
->   zipWith setArg [0..] vs ++
 >   [goto "entry"]
 >   where v = Name "susp"
 >         v' = Name "que"
->         vs = [Name ('v' : show i) | i <- [1..n]]
->         vs0 = (True,[v],[])
->         k = CPSCont (CPSFunction (Name (lazyFunc n)) 0 [] [v] undefined)
->         arg = element (field v "s.args")
->         fetchArg v i = localVar v (Just (arg i))
->         setArg i v = setReg i (var v)
+>         vs0 = ([v],CPSReturn)
+>         k = CPSCont CPSUpdate [v] CPSReturn
+>         arg = element (field v "c.args")
 
 \end{verbatim}
-The CPS entry function of an abstract machine code function receives
-its return address in the return address register, whereas all
-continuation functions must load the return address from the stack. In
-order to hide this difference from the remaining code, we load the
-return address into a local variable when the function's arguments are
-loaded.
-
-When saving the arguments and local variables before leaving a
-function, we avoid saving variables that were loaded from the same
-register or the same offset in the stack because the optimizer of the
-Gnu C compiler does not detect such redundant save operations.
-Furthermore, \texttt{saveVars} takes care of saving the return address
-to the stack and keeping it on the stack as appropriate.
-\begin{verbatim}
-
-> loadVars :: (Bool,[Name],[Name]) -> [CStmt]
-> loadVars (ent,vs,ws) =
->   zipWith (loadVar reg) vs [0..] ++
->   zipWith (loadVar stk) ws [0..] ++
->   [CLocalVar labelType (show retIpName) (Just (retIp ent))]
+At the beginning of a function or switch alternative, all arguments
+and environment variables are loaded into local variables so that the
+compiler can freely use the argument registers and stack slots. If the
+return address is saved on the stack, it is loaded into a temporary
+variable, too.
+
+When saving the arguments and environment variables of a continuation
+before leaving a function, we avoid saving variables that were loaded
+from the same register or the same offset in the stack because the
+optimizer of the C compiler may be unable to detect such redundant
+operations. Note that \texttt{saveVars} never sets the return address
+register, since this is not necessary when calling the return
+continuation.
+\begin{verbatim}
+
+> loadVars :: ([Name],CPSCont) -> [CStmt]
+> loadVars (vs,k) = loadArgs vs ++ loadEnv k
 >   where loadVar f v i = localVar v (Just (f i))
->         retIp True = regRet
->         retIp False = CCast labelType (stk (length ws))
+>         loadRet ret = CLocalVar labelType (show retIpName) (Just ret)
+>         loadArgs vs = zipWith (loadVar reg) vs [0..]
+>         loadEnv CPSReturn = []
+>         loadEnv (CPSCont _ ws _) =
+>           zipWith (loadVar stk) ws [0..] ++
+>           [loadRet (CCast labelType (stk (length ws)))]
 
 > fetchArgs :: Name -> CPSTag -> [CStmt]
 > fetchArgs _ (CPSLitCase _) = []
 > fetchArgs v (CPSConstrCase _ vs) =
->   assertRel (CFunCall "closure_argc" [var v]) "==" (CInt (length vs)) :
+>   assertRel (CFunCall "closure_argc" [var v]) "==" (int (length vs)) :
 >   zipWith fetchArg vs [0..]
 >   where arg = element (field v "c.args")
 >         fetchArg v i = localVar v (Just (arg i))
 > fetchArgs _ CPSFreeCase = []
 > fetchArgs _ CPSDefaultCase = []
 
-> saveVars :: (Bool,[Name],[Name]) -> Bool -> [CExpr] -> [CExpr] -> [CStmt]
-> saveVars (ent,vs0,ws0) ret vs ws =
+> saveVars :: ([Name],CPSCont) -> ([Name],CPSCont) -> [CStmt]
+> saveVars (vs0,k0) (vs,k) =
 >   [incrSp d | d /= 0] ++
->   [setReg i v | (i,v0,v) <- zip3 [0..] vs0' vs, v0 /= v] ++
->   [setStk i w | (i,w0,w) <- zip3 [0..] ws0'' ws', w0 /= w]
->   where d = length ws0' - length ws'
->         ws' = ws ++ [retIpExpr | not ret]
+>   [setReg i v | (i,v0,v) <- zip3 [0..] vs0' vs', v0 /= v] ++
+>   [setStk i w | (i,w0,w) <- zip3 [0..] ws0' ws, w0 /= w]
+>   where d = length ws0 - length ws
+>         vs' = map var vs
 >         vs0' = map var vs0 ++ repeat (CExpr "")
->         ws0' = map var ws0 ++ [retIpExpr | not ent]
->         ws0'' =
->           if d >= 0 then drop d ws0' else replicate (-d) (CExpr "") ++ ws0'
->         retIpExpr = asNode (var retIpName)
-
-> updVar :: (Bool,[Name],[Name]) -> Name -> CStmt
-> updVar (_,vs,ws) v =
->   case (elemIndex v vs,elemIndex v ws) of
+>         ws = contFrame (vs0,k0) k
+>         ws0 = contFrame (vs0,k0) k0
+>         ws0' = if d >= 0 then drop d ws0 else replicate (-d) (CExpr "") ++ ws0
+
+> updVar :: ([Name],CPSCont) -> Name -> CStmt
+> updVar (vs,k) v =
+>   case (elemIndex v vs,elemIndex v (envVars k)) of
 >     (Just n,_) -> setReg n (var v)
 >     (_,Just n) -> setStk n (var v)
 >     _ -> error ("updVar " ++ show v)
+>   where envVars CPSReturn = []
+>         envVars (CPSCont _ ws _) = ws
 
 \end{verbatim}
-When computing the heap requirements of a function, we have to take
-into account nodes that are allocated explicitly in \texttt{return}
-and \texttt{let} statements and implicitly for the results of
-\texttt{ccall} statements, but can ignore nodes which are allocated
-outside of the heap, i.e., literal constants and character nodes.
-
-Note that we use the same temporary name for the node allocated in
-\texttt{CPSReturn} and \texttt{CPSUnify} statements. This is safe
-because constants are allocated per block, not per CPS function.
-\begin{verbatim}
-
-> heapCheck :: (Bool,[Name],[Name]) -> CExpr -> [CStmt]
-> heapCheck (_,vs,_) n =
->   [CProcCall "CHECK_HEAP" [CInt (length vs),n] | n /= CInt 0]
+When computing the allocation requirements of a function, we have to
+take nodes into account that are allocated explicitly in
+\texttt{return} and \texttt{let} statements and implicitly for the
+results of \texttt{ccall} statements, but can ignore nodes which are
+allocated outside of the heap, i.e., all constant nodes. In addition,
+we handle the dynamic allocation of partial application nodes by a
+\texttt{CPSLetPapp} statement here.
+\begin{verbatim}
 
-> allocSize :: FM Name CExpr -> [Bind] -> [CArgType] -> CExpr
-> allocSize consts ds tys =
+> heapCheck :: ([Name],CPSCont) -> CExpr -> [CStmt]
+> heapCheck (vs,_) n =
+>   [CProcCall "CHECK_HEAP" [int (length vs),n] | n /= CInt 0]
+
+> allocSize :: FM Name CExpr -> [Bind] -> [BindPapp] -> [CArgType] -> CExpr
+> allocSize consts ds ds' tys =
 >   foldr add (CInt 0)
 >         ([ctypeSize ty | ty <- tys] ++
->          [nodeSize n | Bind v n <- ds, not (isConstant consts v)])
+>          [nodeSize n | Bind v n <- ds, not (isConstant consts v)] ++
+>          [partialNodeSize v vs | BindPapp _ v vs <- ds'])
 
-> allocs :: CPSStmt -> ([CArgType],[[Bind]])
-> allocs (CPSReturn e) = ([],[[Bind resName e]])
-> allocs (CPSCCall (Just ty) _) = ([ty],[])
-> allocs (CPSUnify _ e) = ([],[[Bind resName e]])
-> allocs (CPSDelayNonLocal _ st) = allocs st
-> allocs (CPSSeq st1 st2) = allocs0 st1 (allocs st2)
->   where allocs0 (v :<- Return e) ~(tys,dss) = (tys,[Bind v e]:dss)
->         allocs0 (_ :<- CCall _ (Just ty) _) ~(tys,dss) = (ty:tys,dss)
->         allocs0 (v :<- Seq st1 st2) as = allocs0 st1 (allocs0 (v :<- st2) as)
->         allocs0 (Let ds) ~(tys,dss) = (tys,ds:dss)
->         allocs0 _ as = as
-> allocs (CPSWithCont _ st) = allocs st
-> allocs _ = ([],[])
+> allocs :: CPSStmt -> ([CArgType],[BindPapp],[[Bind]])
+> allocs (CPSLet ds st) = (tys,ds',ds:dss)
+>   where (tys,ds',dss) = allocs st
+> allocs (CPSLetC (BindC _ ty _) st) = (maybe id (:) ty tys,ds,dss)
+>   where (tys,ds,dss) = allocs st
+> allocs (CPSLetPapp d st) = (tys,d:ds,dss)
+>   where (tys,ds,dss) = allocs st
+> allocs (CPSLetCont _ st) = allocs st
+> allocs _ = ([],[],[])
 
 > nodeSize :: Expr -> CExpr
 > nodeSize (Lit _) = CInt 0
 > nodeSize (Constr _ vs) = closureNodeSize (length vs)
 > nodeSize (Papp _ vs) = closureNodeSize (length vs)
 > nodeSize (Closure _ vs) = closureNodeSize (length vs)
-> nodeSize (Lazy f vs) = suspendNodeSize (length vs)
+> nodeSize (Lazy _ vs) = suspendNodeSize (length vs)
 > nodeSize Free = CExpr "variable_node_size"
 > nodeSize (Var _) = CInt 0
 
+> prepAlloc :: BindPapp -> [CStmt]
+> prepAlloc (BindPapp _ v vs) =
+>   [assertRel (nodeTag v) ">" (CInt (toInteger (length vs))),
+>    CLocalVar uintType (argcVar v) (Just (CFunCall "closure_argc" [var v])),
+>    CLocalVar uintType (szVar v) (Just (CFunCall "node_size" [var v]))]
+
+> partialNodeSize :: Name -> [Name] -> CExpr
+> partialNodeSize v vs = CExpr (szVar v) `CAdd` CInt (toInteger (length vs))
+
 > ctypeSize :: CArgType -> CExpr
 > ctypeSize TypeBool = CInt 0
 > ctypeSize TypeChar = CExpr "char_node_size"
@@ -727,42 +721,37 @@
 > ctypeSize TypeNodePtr = CInt 0
 
 > closureNodeSize, suspendNodeSize :: Int -> CExpr
-> closureNodeSize n = CFunCall "closure_node_size" [CInt n]
-> suspendNodeSize n = CFunCall "suspend_node_size" [CInt n]
+> closureNodeSize n = CFunCall "closure_node_size" [int n]
+> suspendNodeSize n = CFunCall "suspend_node_size" [int n]
 
 \end{verbatim}
 The maximum stack depth of a function is simply the difference between
 the number of variables saved on the stack when the function is
 entered and the number of variables pushed onto the stack when calling
-the continuation. Note that the stack check must take the return
-address into account, which is saved on the stack except in the CPS
-entry function of an abstract machine code function. In case of a
-\texttt{CPSSwitch} statement, every alternative is responsible for
-performing a stack check.
+the continuation. In case of the various \texttt{CPSSwitch}
+statements, each alternative is responsible for performing a stack
+check.
 \begin{verbatim}
 
-> stackCheck :: (Bool,[Name],[Name]) -> CPSStmt -> [CStmt]
-> stackCheck (ent,_,ws) st = [CProcCall "CHECK_STACK" [CInt depth] | depth > 0]
->   where depth = stackDepth st - length (ws ++ [retIpName | not ent])
+> stackCheck :: ([Name],CPSCont) -> CPSStmt -> [CStmt]
+> stackCheck (_,k) st = [CProcCall "CHECK_STACK" [int depth] | depth > 0]
+>   where depth = stackDepth st - stackDepthCont k
 
 > stackDepth :: CPSStmt -> Int
-> stackDepth (CPSJump k) = stackDepthCont k
-> stackDepth (CPSReturn _) = 0
-> stackDepth (CPSEnter _) = 0
-> stackDepth (CPSExec _ _) = 0
-> stackDepth (CPSCCall _ _) = 0
-> stackDepth (CPSApply _ vs) = 2 + length vs
-> stackDepth (CPSUnify _ _) = 0
-> stackDepth (CPSDelay _) = 0
-> stackDepth (CPSDelayNonLocal _ st) = stackDepth st
-> stackDepth (CPSSeq _ st) = stackDepth st
-> stackDepth (CPSWithCont k st) = stackDepthCont k + stackDepth st
+> stackDepth CPSFail = 0
+> stackDepth (CPSExecCont k _) = stackDepthCont k
+> stackDepth (CPSExec _ k _) = stackDepthCont k
+> stackDepth (CPSLet _ st) = stackDepth st
+> stackDepth (CPSLetC _ st) = stackDepth st
+> stackDepth (CPSLetPapp _ st) = stackDepth st
+> stackDepth (CPSLetCont _ st) = stackDepth st
 > stackDepth (CPSSwitch _ _ _) = 0
-> stackDepth (CPSChoices _ ks) =
->   if null ks then 0 else 1 + stackDepthCont (head ks)
+> stackDepth (CPSSwitchVar _ _ _) = 0
+> stackDepth (CPSSwitchArity _ _) = 0
+> stackDepth (CPSChoice _ ks) = 1 + stackDepthCont (head ks)
 
 > stackDepthCont :: CPSCont -> Int
-> stackDepthCont k = 1 + length (contVars k)
+> stackDepthCont k = length (contFrame undefined k)
 
 \end{verbatim}
 All constants that are used in a function are preallocated in a static
@@ -795,9 +784,10 @@
 >         init o (v,Closure f vs)
 >           | null vs = (o,(v,constRef (constFunc f)))
 >           | otherwise = (o + length vs + 1,(v,constant o))
->         init o (v,Var v') = (o,(v,var v'))
+>         init o (v,Var v') =
+>           (o,(v,if v == v' then constRef "blackHole" else var v'))
 >         init _ (v,n) = error ("internal error: constants.init" ++ show n)
->         constant = asNode . add (CExpr constArray) . CInt
+>         constant = asNode . add (CExpr constArray) . int
 
 > constVars :: [[Bind]] -> Set Name
 > constVars = foldl_strict addConst zeroSet
@@ -815,6 +805,7 @@
 > literal :: Literal -> CExpr
 > literal (Char c) = CExpr (constChar c)
 > literal (Int i) = CExpr (constInt i)
+> literal (Integer i) = CExpr (constInteger i)
 > literal (Float f) = constRef (constFloat f)
 
 > constDefs :: FM Name CExpr -> [Bind] -> [CStmt]
@@ -829,7 +820,7 @@
 >               addr (nodeInfo c) : map arg vs ++ is
 >         constInit (Bind v (Papp f vs)) is
 >           | not (null vs) && isConstant consts v =
->               CExpr (pappInfoTable f) `add` CInt (length vs) :
+>               CExpr (pappInfoTable f) `add` int (length vs) :
 >               map arg vs ++ is
 >         constInit (Bind v (Closure f vs)) is
 >           | not (null vs) && isConstant consts v =
@@ -837,10 +828,6 @@
 >         constInit _ is = is
 >         arg v = fromJust (lookupFM v consts)
 
-> freshNode :: FM Name CExpr -> Name -> Expr -> [CStmt]
-> freshNode consts v n = allocNode consts d ++ initNode consts d
->   where d = Bind v n
-
 > allocNode :: FM Name CExpr -> Bind -> [CStmt]
 > allocNode consts (Bind v n) =
 >   case lookupFM v consts of
@@ -851,8 +838,22 @@
 >         Var v' -> [localVar v (Just (var v'))]
 >         _ -> [localVar v (Just alloc),incrAlloc (nodeSize n)]
 
+> allocPartial :: BindPapp -> [CStmt]
+> allocPartial (BindPapp r v vs) =
+>   [localVar r (Just alloc),incrAlloc (partialNodeSize v vs)]
+
 > initNode :: FM Name CExpr -> Bind -> [CStmt]
-> initNode _ (Bind v (Lit _)) = []
+> initNode _ (Bind _ (Lit l)) =
+>   case l of
+>     Integer i ->
+>       [CppCondStmts (isLargeInt i)
+>          [CProcCall initINTEGER [CExpr (constInteger i),CInt i]]
+>          []]
+>       where (isLargeInt,initINTEGER)
+>               | fits32bits i = (\i -> "is_large_int("++show i++")","INIT_INTEGER32")
+>               | fits64bits i = (\i -> "is_large_int_32_64("++show i++")","INIT_INTEGER64")
+>               | otherwise = (const "1","INIT_INTEGER")
+>     _ -> []
 > initNode consts (Bind v (Constr c vs))
 >   | isConstant consts v = []
 >   | otherwise = initConstr v c vs
@@ -864,7 +865,21 @@
 >   | otherwise = initClosure v f vs
 > initNode _ (Bind v (Lazy f vs)) = initLazy v f vs
 > initNode _ (Bind v Free) = initFree v
-> initNode _ (Bind v (Var _)) = []
+> initNode _ (Bind _ (Var _)) = []
+
+> initInteger :: Name -> Integer -> CStmt
+> initInteger v i =
+>   CIf (CRel (field v "info") "==" CNull)
+>       [setField v "info" (addr "bigint_info"),initMpz (field v "bi.mpz") i]
+>       []
+>   where initMpz v i
+>           | fits32bits i = initMpzInt v i
+>           | fits64bits i =
+>               CppCondStmts condLP64 [initMpzInt v i] [initMpzString v i]
+>           | otherwise = initMpzString v i
+>         initMpzInt v i = CProcCall "mpz_init_set_si" [v,CInt i]
+>         initMpzString v i =
+>           CProcCall "mpz_init_set_str" [v,CString (show i),CInt 10]
 
 > initConstr :: Name -> Name -> [Name] -> [CStmt]
 > initConstr v c vs =
@@ -872,7 +887,7 @@
 
 > initPapp :: Name -> Name -> [Name] -> [CStmt]
 > initPapp v f vs =
->   setField v "info" (CExpr (pappInfoTable f) `add` CInt (length vs)) :
+>   setField v "info" (CExpr (pappInfoTable f) `add` int (length vs)) :
 >   initArgs v "c.args" vs
 
 > initClosure :: Name -> Name -> [Name] -> [CStmt]
@@ -882,19 +897,24 @@
 > initLazy :: Name -> Name -> [Name] -> [CStmt]
 > initLazy v f vs =
 >   setField v "info" (CExpr (lazyInfoTable f)) :
->   setField v "s.spc" (CExpr "regs.ss") :
 >   if null vs then
->     [setElem (lfield v "s.args") 0 CNull]
+>     [setElem (lfield v "c.args") 0 CNull]
 >   else
->     initArgs v "s.args" vs
+>     initArgs v "c.args" vs
 
 > initFree :: Name -> [CStmt]
 > initFree v =
 >   [setField v "info" (CExpr "variable_info_table"),
->    setField v "v.spc" (CExpr "regs.ss"),
 >    setField v "v.wq" CNull,
 >    setField v "v.cstrs" CNull]
 
+> initPartial :: BindPapp -> [CStmt]
+> initPartial (BindPapp r v vs) =
+>   wordCopy (var r) (var v) (szVar v) :
+>   CIncrBy (lfield r "info") (CInt (toInteger (length vs))) :
+>   zipWith (initArg (lfield r "c.args") (CExpr (argcVar v))) [0..] vs
+>   where initArg v1 n i v2 = CAssign (LElem v1 (n `add` int i)) (var v2)
+
 > initArgs :: Name -> String -> [Name] -> [CStmt]
 > initArgs v f vs = zipWith (initArg (lfield v f)) [0..] vs
 >   where initArg v1 i v2 = setElem v1 i (var v2)
@@ -904,81 +924,79 @@
 translation function.
 \begin{verbatim}
 
-> cCode :: Name -> FM Name CExpr -> (Bool,[Name],[Name]) -> CPSStmt -> [CPSCont]
->       -> [CStmt]
-> cCode _ _ vs0 (CPSJump k) ks = jump vs0 k ks
-> cCode _ consts vs0 (CPSReturn e) ks =
->   case e of
->     Var v -> ret vs0 v ks
->     _ -> freshNode consts resName e ++ ret vs0 resName ks
-> cCode _ _ vs0 (CPSEnter v) ks = enter vs0 v ks
-> cCode _ _ vs0 (CPSExec f vs) ks = exec vs0 f vs ks
-> cCode _ _ vs0 (CPSCCall ty cc) ks = cCall ty resName cc ++ ret vs0 resName ks
-> cCode _ _ vs0 (CPSApply v vs) ks = apply vs0 v vs ks
-> cCode _ consts vs0 (CPSUnify v e) ks =
->   case e of
->     Var v' -> unifyVar vs0 v v' ks
->     _ -> freshNode consts resName e ++ unifyVar vs0 v resName ks
-> cCode _ _ vs0 (CPSDelay v) ks = delay vs0 v ks
-> cCode f consts vs0 (CPSDelayNonLocal v st) ks =
->   delayNonLocal vs0 v ks ++ cCode f consts vs0 st ks
-> cCode f consts vs0 (CPSSeq st1 st2) ks =
->   cCode0 consts st1 ++ cCode f consts vs0 st2 ks
-> cCode f consts vs0 (CPSWithCont k st) ks = cCode f consts vs0 st (k:ks)
-> cCode f _ vs0 (CPSSwitch tagged v cases) [] =
+> cCode :: Name -> FM Name CExpr -> ([Name],CPSCont) -> CPSStmt -> [CStmt]
+> cCode f _ _ CPSFail = failAndBacktrack (undecorate (demangle f))
+> cCode _ _ vs0 (CPSExecCont k vs) = execCont vs0 vs k
+> cCode _ _ vs0 (CPSExec f k vs) = exec vs0 f vs k
+> cCode f consts vs0 (CPSLet ds st) =
+>   concatMap (allocNode consts) ds ++ concatMap (initNode consts) ds ++
+>   cCode f consts vs0 st
+> cCode f consts vs0 (CPSLetC d st) = cCall d ++ cCode f consts vs0 st
+> cCode f consts vs0 (CPSLetPapp d st) =
+>   allocPartial d ++ initPartial d ++ cCode f consts vs0 st
+> cCode f consts vs0 (CPSLetCont _ st) = cCode f consts vs0 st
+> cCode f _ vs0 (CPSSwitch tagged v cases) =
 >   switchOnTerm f tagged vs0 v
 >                [(t,caseCode f vs0 v t st) | CaseBlock t st <- cases]
-> cCode f _ vs0 (CPSChoices v ks) ks' = choices f vs0 v ks ks'
-
-> cCode0 :: FM Name CExpr -> Stmt0 -> [CStmt]
-> cCode0 _ (Lock v) = lock v
-> cCode0 _ (Update v1 v2) = update v1 v2
-> cCode0 consts (v :<- Return e) = freshNode consts v e
-> cCode0 consts (v :<- CCall _ ty cc) = cCall ty v cc
-> cCode0 consts (v :<- Seq st1 st2) =
->   cCode0 consts st1 ++ cCode0 consts (v :<- st2)
-> cCode0 consts (Let ds) =
->   concatMap (allocNode consts) ds ++ concatMap (initNode consts) ds
-
-> jump :: (Bool,[Name],[Name]) -> CPSCont -> [CPSCont] -> [CStmt]
-> jump vs0 k ks = saveCont vs0 [] [] (k:ks) ++ [gotoRet vs0 (k:ks)]
-
-> ret :: (Bool,[Name],[Name]) -> Name -> [CPSCont] -> [CStmt]
-> ret vs0 v ks = saveCont vs0 [v] [] ks ++ [gotoRet vs0 ks]
-
-> enter :: (Bool,[Name],[Name]) -> Name -> [CPSCont] -> [CStmt]
-> enter vs0 v ks =
->   saveCont vs0 [v] [] ks ++
->   [kindSwitch v [updVar (null ks,[v],[]) v] taggedSwitch
->               [CCase "LAZY_KIND"
->                      (saveRet vs0 ks ++ [goto vs0 (field v "info->eval")])],
->    gotoRet vs0 ks]
->   where goto vs0 = if fst3 vs0 then gotoIndirExpr else gotoExpr
->         taggedSwitch switch = CIf (isTaggedPtr v) [switch] []
-
-> exec :: (Bool,[Name],[Name]) -> Name -> [Name] -> [CPSCont] -> [CStmt]
-> exec vs0 f vs ks =
->   saveCont vs0 vs [] ks ++ saveRet vs0 ks ++ [exec vs0 (cName f)]
->   where exec vs0 = if fst3 vs0 then gotoIndir else goto
-
-> saveCont :: (Bool,[Name],[Name]) -> [Name] -> [Name] -> [CPSCont] -> [CStmt]
-> saveCont vs0 vs ws ks =
->   saveVars vs0 (null ks) (map var vs) (map var ws ++ drop 1 ws')
->   where ws' = concatMap contFrame ks
->         contFrame k = asNode (CExpr (contName k)) : map var (contVars k)
-
-> saveRet :: (Bool,[Name],[Name]) -> [CPSCont] -> [CStmt]
-> saveRet (ent,_,_) [] = [setRet (var retIpName) | not ent]
-> saveRet _ (k:_) = [setRet (CExpr (contName k))]
-
-> gotoRet :: (Bool,[Name],[Name]) -> [CPSCont] -> CStmt
-> gotoRet _ [] = gotoIndir (show retIpName)
-> gotoRet vs0 (k:_) = ret vs0 (contName k)
->   where ret vs0 = if fst3 vs0 then gotoIndir else goto
+> cCode f _ vs0 (CPSSwitchVar v st1 st2) = switchOnVar v sts1' sts2'
+>   where sts1' = caseCode f vs0 v CPSFreeCase st1
+>         sts2' = caseCode f vs0 v CPSFreeCase st2
+> cCode f _ vs0 (CPSSwitchArity v sts) =
+>   switchOnArity vs0 v (map (caseCode f vs0 v CPSDefaultCase) sts)
+> cCode _ _ vs0 (CPSChoice v ks) = choice vs0 v ks
+
+> execCont :: ([Name],CPSCont) -> [Name] -> CPSCont -> [CStmt]
+> execCont vs0 vs k =
+>   saveVars vs0 (contVars vs0 vs [] k) ++ [gotoExpr (contAddr vs0 k)]
+
+> exec :: ([Name],CPSCont) -> CPSFun -> [Name] -> CPSCont -> [CStmt]
+> exec vs0 f vs k =
+>   saveVars vs0 vs0' ++
+>   case f of
+>     CPSEval tagged v ->
+>       [tagSwitch vs0' v (taggedSwitch tagged) [cCase "EVAL_TAG" sts'],
+>        gotoExpr ret]
+>     _ -> sts'
+>   where vs0' = contVars vs0 vs [] k
+>         ret = contAddr vs0 k
+>         sts' = [setRet ret | ret /= regRet] ++ [gotoExpr (entry f)]
+>         taggedSwitch tagged v switch
+>           | tagged = CIf (isTaggedPtr v) [switch] []
+>           | otherwise = switch
+
+> contVars :: ([Name],CPSCont) -> [Name] -> [Name] -> CPSCont
+>          -> ([Name],CPSCont)
+> contVars vs0 vs ws k = (vs ++ drop (length vs) (fst vs0),addVars ws k)
+>   where addVars vs CPSReturn | null vs = CPSReturn
+>         addVars vs (CPSCont f ws k) = CPSCont f (vs ++ ws) k
+
+> entry :: CPSFun -> CExpr
+> entry (CPSFun f) = CExpr (cName f)
+> entry (CPSEval _ v) = field v "info->eval"
+> entry CPSUnify = CExpr "bind_var"
+> entry CPSDelay = CExpr "sync_var"
+
+> contFrame :: ([Name],CPSCont) -> CPSCont -> [CExpr]
+> contFrame _ CPSReturn = []
+> contFrame vs0 (CPSCont _ ws k) =
+>   map var ws ++ asNode (contAddr vs0 k) : contFrame vs0 k
+
+> contAddr :: ([Name],CPSCont) -> CPSCont -> CExpr
+> contAddr vs0 CPSReturn =
+>   case snd vs0 of
+>     CPSReturn -> regRet
+>     CPSCont _ _ _ -> var retIpName
+> contAddr _ (CPSCont f _ _) = contEntry f
+
+> contEntry :: CPSContFun -> CExpr
+> contEntry (CPSContFun f n) = CExpr (contName (CPSContFun f n))
+> contEntry (CPSInst t) = CExpr (contName (CPSInst t))
+> contEntry (CPSApply v) = field v "info->apply"
+> contEntry CPSUpdate = CExpr (contName CPSUpdate)
 
 > lock :: Name -> [CStmt]
 > lock v =
->   [assertLazyNode v "UPD_TAG",
+>   [assertLazyNode v "SUSPEND_KIND",
 >    CppCondStmts "!COPY_SEARCH_SPACE"
 >      [CIf (CRel (CCast wordPtrType (var v)) "<" (CExpr "regs.hlim"))
 >           [CProcCall "DO_SAVE" [var v,CExpr "q.wq"],
@@ -987,21 +1005,9 @@
 >      [setField v "info" (CExpr "queueMe_info_table")],
 >    setField v "q.wq" CNull]
 
-> update :: Name -> Name -> [CStmt]
-> update v1 v2 =
->   [assertLazyNode v1 "QUEUEME_TAG",
->    CLocalVar (CType "ThreadQueue") wq (Just (field v1 "q.wq")),
->    CppCondStmts "!COPY_SEARCH_SPACE"
->      [CProcCall "SAVE" [var v1,CExpr "q.wq"],
->       CIncrBy (lfield v1 "info") (CInt 1)]
->      [setField v1 "info" (addr "indir_info")],
->    setField v1 "n.node" (var v2),
->    CIf (CExpr wq) [procCall "wake_threads" [wq]] []]
->   where wq = "wq"
-
 > lockIndir :: Name -> Name -> [CStmt]
 > lockIndir v1 v2 =
->   [assertLazyNode v2 "QUEUEME_TAG",
+>   [assertLazyNode v2 "QUEUEME_KIND",
 >    CppCondStmts "!COPY_SEARCH_SPACE"
 >      [CIf (CRel (CCast wordPtrType (var v1)) "<" (CExpr "regs.hlim"))
 >           [CProcCall "DO_SAVE" [var v1,CExpr "n.node"],
@@ -1011,41 +1017,21 @@
 >    setField v1 "n.node" (var v2)]
 
 > assertLazyNode :: Name -> String -> CStmt
-> assertLazyNode v tag =
->   rtsAssertList [isTaggedPtr v,CRel (nodeKind v) "==" (CExpr "LAZY_KIND"),
->                  CRel (nodeTag v) "==" (CExpr tag),
->                  CFunCall "is_local_space" [field v "s.spc"]]
-
-> unifyVar :: (Bool,[Name],[Name]) -> Name -> Name -> [CPSCont] -> [CStmt]
-> unifyVar vs0 v n ks =
->   saveCont vs0 [v,n] [] ks ++ saveRet vs0 ks ++ [goto "bind_var"]
-
-> delay :: (Bool,[Name],[Name]) -> Name -> [CPSCont] -> [CStmt]
-> delay vs0 v ks = saveCont vs0 [v] [] ks ++ saveRet vs0 ks ++ [goto "sync_var"]
-
-> delayNonLocal :: (Bool,[Name],[Name]) -> Name -> [CPSCont] -> [CStmt]
-> delayNonLocal vs0 v ks =
->   [CIf (CFunCall "!is_local_space" [field v "v.spc"])
->        (delay vs0 v ks)
->        []]
-
-> choices :: Name -> (Bool,[Name],[Name]) -> Maybe Name -> [CPSCont]
->         -> [CPSCont] -> [CStmt]
-> choices f vs0 v ks ks'
->   | null ks = failAndBacktrack (undecorate (demangle f))
->   | otherwise =
->       CStaticArray constLabelType choices
->                    (map (CInit . CExpr . contName) ks ++ [CInit CNull]) :
->       localVar ips (Just (asNode (CExpr choices))) :
->       saveCont vs0 [] [ips] (head ks : ks') ++
->       [CppCondStmts "YIELD_NONDET"
->          [CIf (CExpr "regs.rq") (yieldCall v) []]
->          [],
->        goto "regs.handlers->choices"]
+> assertLazyNode v kind =
+>   rtsAssertList [isTaggedPtr v,CRel (nodeKind v) "==" (CExpr kind)]
+
+> choice :: ([Name],CPSCont) -> Maybe Name -> [CPSCont] -> [CStmt]
+> choice vs0 v ks =
+>   CStaticArray constLabelType choices
+>                (map (CInit . contAddr vs0) ks ++ [CInit CNull]) :
+>   localVar ips (Just (asNode (CExpr choices))) :
+>   saveVars vs0 vs0' ++
+>   [CppCondStmts "!NO_STABILITY" (yieldCall v) [goto "regs.handlers->choices"]]
 >   where ips = Name "_choice_ips"
 >         choices = "_choices"
+>         vs0' = contVars vs0 [] [ips] (head ks)
 >         yieldCall (Just v) =
->           saveVars vs0 (fst3 vs0) [var v] (map var (thd3 vs0)) ++
+>           saveVars vs0' (contVars vs0' [v] [ips] (head ks)) ++
 >           [setRet (CExpr "flex_yield_resume"),
 >            goto "yield_delay_thread"]
 >         yieldCall Nothing =
@@ -1068,45 +1054,60 @@
 literals when set to a non-zero value.
 \begin{verbatim}
 
-> switchOnTerm :: Name -> Bool -> (Bool,[Name],[Name]) -> Name
->              -> [(CPSTag,[CStmt])] -> [CStmt]
+> switchOnTerm :: Name -> Bool -> ([Name],CPSCont) -> Name -> [(CPSTag,[CStmt])]
+>              -> [CStmt]
 > switchOnTerm f tagged vs0 v cases =
->   kindSwitch v [updVar vs0 v] taggedSwitch otherCases :
+>   tagSwitch vs0 v taggedSwitch (varCase ++ litCases ++ constrCases) :
 >   head (dflts ++ [failAndBacktrack (undecorate (demangle f) ++ ": no match")])
 >   where (lits,constrs,vars,dflts) = foldr partition ([],[],[],[]) cases
->         (chars,ints,floats) = foldr litPartition ([],[],[]) lits
->         taggedSwitch switch
->           | tagged && null chars && null ints =
+>         (chars,ints,integers,floats) = foldr litPartition ([],[],[],[]) lits
+>         taggedSwitch v switch
+>           | tagged && null chars && null ints && null integers =
 >               CIf (isTaggedPtr v) [switch] []
 >           | otherwise =
->               taggedCharSwitch v chars (taggedIntSwitch v ints switch)
->         otherCases =
->           map varCase vars ++ [charCase | not (null chars)] ++
->           [intCase | not (null ints)] ++ [floatCase | not (null floats)] ++
->           [constrCase | not (null constrs)]
->         varCase = CCase "LVAR_KIND"
+>               taggedCharSwitch v chars $
+>               taggedIntSwitch v ints $
+>               taggedIntegerSwitch v integers switch
+>         varCase = map (cCase "LVAR_TAG") vars
+>         litCases = map cCaseDefault $
+>           [charCase | not (null chars)] ++
+>           [intCase | not (null ints)] ++
+>           [integerCase | not (null integers)] ++
+>           [floatCase | not (null floats)]
 >         charCase =
->           CCase "CHAR_KIND"
->             [CppCondStmts "NO_POINTER_TAGS"
->                [charSwitch (field v "ch.ch") chars,CBreak]
->                [CProcCall "curry_panic"
->                           [CString "impossible: kind(%p) == CHAR_KIND\n",
->                            var v]]]
->         intCase = CCase "INT_KIND" [intSwitch (field v "i.i") ints,CBreak]
->         floatCase = CCase "FLOAT_KIND" (floatSwitch v floats ++ [CBreak])
->         constrCase = CCase "CAPP_KIND" [tagSwitch v constrs,CBreak]
+>           [CppCondStmts "NO_POINTER_TAGS"
+>              [CProcCall "assert" [CFunCall "is_char_node" [var v]],
+>               charSwitch (field v "ch.ch") chars,
+>               CBreak]
+>              [CProcCall "unexpected_tag"
+>                         [CString (undecorate (demangle f)),nodeTag v]]]
+>         intCase =
+>           [CProcCall "assert" [CFunCall "is_int_node" [var v]],
+>            intSwitch (field v "i.i") ints,
+>            CBreak]
+>         integerCase =
+>           CProcCall "assert" [CFunCall "is_bigint_node" [var v]] :
+>           integerSwitch (field v "bi.mpz") integers ++
+>           [CBreak]
+>         floatCase =
+>           CProcCall "assert" [CFunCall "is_float_node" [var v]] :
+>           floatSwitch v floats ++
+>           [CBreak]
+>         constrCases = [cCase (dataTag c) stmts | (c,stmts) <- constrs]
 >         partition (t,stmts) ~(lits,constrs,vars,dflts) =
 >           case t of
 >              CPSLitCase l -> ((l,stmts) : lits,constrs,vars,dflts)
 >              CPSConstrCase c _ -> (lits,(c,stmts) : constrs,vars,dflts)
 >              CPSFreeCase -> (lits,constrs,stmts : vars,dflts)
 >              CPSDefaultCase -> (lits,constrs,vars,stmts : dflts)
->         litPartition (Char c,stmts) ~(chars,ints,floats) =
->           ((c,stmts):chars,ints,floats)
->         litPartition (Int i,stmts) ~(chars,ints,floats) =
->           (chars,(i,stmts):ints,floats)
->         litPartition (Float f,stmts) ~(chars,ints,floats) =
->           (chars,ints,(f,stmts):floats)
+>         litPartition (Char c,stmts) ~(chars,ints,integers,floats) =
+>           ((c,stmts):chars,ints,integers,floats)
+>         litPartition (Int i,stmts) ~(chars,ints,integers,floats) =
+>           (chars,(i,stmts):ints,integers,floats)
+>         litPartition (Integer i,stmts) ~(chars,ints,integers,floats) =
+>           (chars,ints,(i,stmts):integers,floats)
+>         litPartition (Float f,stmts) ~(chars,ints,integers,floats) =
+>           (chars,ints,integers,(f,stmts):floats)
 
 > taggedCharSwitch :: Name -> [(Char,[CStmt])] -> CStmt -> CStmt
 > taggedCharSwitch v chars stmt
@@ -1119,7 +1120,7 @@
 >              [charSwitch (CFunCall "untag_char" [var v]) chars]]
 >           [stmt]
 
-> taggedIntSwitch :: Name -> [(Int,[CStmt])] -> CStmt -> CStmt
+> taggedIntSwitch :: Name -> [(Integer,[CStmt])] -> CStmt -> CStmt
 > taggedIntSwitch v ints stmt
 >   | null ints = stmt
 >   | otherwise =
@@ -1130,78 +1131,88 @@
 >              [intSwitch (CFunCall "untag_int" [var v]) ints]]
 >           [stmt]
 
-> kindSwitch :: Name -> [CStmt] -> (CStmt -> CStmt) -> [CCase] -> CStmt
-> kindSwitch v upd taggedSwitch cases =
->   CLoop [taggedSwitch (CSwitch (nodeKind v) allCases),CBreak]
+> taggedIntegerSwitch :: Name -> [(Integer,[CStmt])] -> CStmt -> CStmt
+> taggedIntegerSwitch v integers stmt
+>   | null ints64 = stmt
+>   | otherwise =
+>       CIf (isTaggedInt v)
+>           [CppCondStmts "NO_POINTER_TAGS"
+>              [CProcCall "curry_panic"
+>                         [CString "impossible: is_tagged_int(%p)\n",var v]]
+>              [condIntegerSwitch (CFunCall "untag_int" [var v]) ints32 ints64]]
+>           [stmt]
+>   where ints32 = filter (fits32bits . fst) ints64
+>         ints64 = filter (fits64bits . fst) integers
+>         condIntegerSwitch e ints32 ints64
+>           | length ints32 == length ints64 = intSwitch e ints32
+>           | null ints32 =
+>               CppCondStmts condLP64 [intSwitch e ints64] []
+>           | otherwise =
+>               CppCondStmts condLP64 [intSwitch e ints64] [intSwitch e ints32]
+
+> tagSwitch :: ([Name],CPSCont) -> Name -> (Name -> CStmt -> CStmt) -> [CCase]
+>           -> CStmt
+> tagSwitch vs0 v taggedSwitch cases =
+>   CLoop [taggedSwitch v (CSwitch (nodeTag v) allCases),CBreak]
 >   where allCases =
->           CCase "INDIR_KIND"
->             (setVar v (field v "n.node") : upd ++ [CContinue]) :
+>           cCase "INDIR_TAG"
+>                 [setVar v (field v "n.node"),updVar vs0 v,CContinue] :
 >           cases
 
 > charSwitch :: CExpr -> [(Char,[CStmt])] -> CStmt
-> charSwitch e cases =
->   CSwitch e [CCase (show (ord c)) stmts | (c,stmts) <- cases]
+> charSwitch e cases = CSwitch e [cCaseInt (ord c) stmts | (c,stmts) <- cases]
 
-> intSwitch :: CExpr -> [(Int,[CStmt])] -> CStmt
-> intSwitch e cases = CSwitch e [CCase (show i) stmts | (i,stmts) <- cases]
+> intSwitch :: CExpr -> [(Integer,[CStmt])] -> CStmt
+> intSwitch e cases = CSwitch e [CCase (CCaseInt i) stmts | (i,stmts) <- cases]
+
+> integerSwitch :: CExpr -> [(Integer,[CStmt])] -> [CStmt]
+> integerSwitch e cases = localVar k Nothing : foldr (match e) [] cases
+>   where k = Name "k"
+>         match e (i,stmts) rest
+>           | fits32bits i =
+>               [CIf (CRel (CFunCall "mpz_cmp_si" [e,CInt i]) "==" (CInt 0))
+>                    stmts
+>                    rest]
+>           | otherwise =
+>               [setVar k (CExpr (constInteger i)),
+>                CIf (CRel (CFunCall "mpz_cmp" [e,field k "bi.mpz"]) "=="
+>                          (CInt 0))
+>                    stmts
+>                    rest]
 
 > floatSwitch :: Name -> [(Double,[CStmt])] -> [CStmt]
 > floatSwitch v cases =
 >   getFloat "d" (var v) ++ foldr (match (CExpr "d")) [] cases
 >   where match v (f,stmts) rest = [CIf (CRel v "==" (CFloat f)) stmts rest]
 
-> tagSwitch :: Name -> [(Name,[CStmt])] -> CStmt
-> tagSwitch v cases =
->   CSwitch (nodeTag v) [CCase (dataTag c) stmts | (c,stmts) <- cases]
-
-\end{verbatim}
-The code for \texttt{CPSApply} statements has to check to how many
-arguments a partial application is applied. If there are too few
-arguments, a new partial application node is returned, which includes
-the additional arguments. Otherwise, the application is entered through
-its application entry point. If the closure is applied to too many
-arguments, the code generated by \texttt{apply} creates a return frame
-on the stack, which takes care of applying the result of the
-application to the surplus arguments. Note that the apply entry point
-of a partial application node is called with the additional arguments
-and return address on the stack. Only the partial application node
-itself is passed in a register.
-\begin{verbatim}
-
-> apply :: (Bool,[Name],[Name]) -> Name -> [Name] -> [CPSCont] -> [CStmt]
-> apply vs0 v vs ks =
->   CSwitch (nodeTag v)
->           [CCase (show i)
->                  (applyExec vs0 v (splitAt i vs) ks) | i <- [1..length vs]] :
->   applyPartial vs0 v vs ks
-
-> applyExec :: (Bool,[Name],[Name]) -> Name -> ([Name],[Name]) -> [CPSCont]
->           -> [CStmt]
-> applyExec vs0 v (vs,vs') ks =
->   saveCont vs0 [v] [] (apEntry : if null vs' then ks else apCont : ks) ++
->   [gotoExpr (field v "info->apply")]
->   where apEntry = cont undefined 0 [v] vs
->         apCont = cont (apName (length vs' + 1)) 1 [v] vs'
->         cont f n vs ws = CPSCont (CPSFunction f n vs ws undefined)
+\end{verbatim}
+The idiosyncratic \texttt{CPSSwitchVar} statement is used for
+distinguishing global and local free variable nodes. We assume that
+neither the code for the global variable case (first alternative) nor
+that for the local variable case (second alternative) falls through.
+\begin{verbatim}
+
+> switchOnVar :: Name -> [CStmt] -> [CStmt] -> [CStmt]
+> switchOnVar v sts1 sts2 =
+>   CIf (CRel (nodeKind v) "==" (CExpr "GVAR_KIND"))
+>       (CProcCall "assert" [CFunCall "!is_local_space" [field v "g.spc"]] :
+>        sts1)
+>       [] :
+>   sts2
 
-> applyPartial :: (Bool,[Name],[Name]) -> Name -> [Name] -> [CPSCont]
->              -> [CStmt]
-> applyPartial vs0 v vs ks =
->   [assertRel (nodeTag v) ">" (CInt 0),
->    CLocalVar uintType "argc" (Just (CFunCall "closure_argc" [var v])),
->    CLocalVar uintType "sz" (Just (CFunCall "node_size" [var v]))] ++
->   heapCheck vs0 size ++
->   [CBlock (loadVars vs0 ++
->            localVar resName (Just alloc) :
->            incrAlloc size :
->            wordCopy (var resName) (var v) "sz" :
->            CIncrBy (lfield resName "info") (CInt n) :
->            zipWith (setArg (lfield resName "c.args")) [0..] vs ++
->            ret vs0 resName ks)]
->   where n = length vs
->         size = CExpr "sz" `CAdd` CInt n
->         setArg base i v =
->           CAssign (LElem base (CExpr "argc" `add` CInt i)) (var v)
+\end{verbatim}
+The \texttt{CPSSwitchArity} statement dispatches on the arity of a
+partial application node. Recall that the first alternative,
+corresponding to arity 0, applies to an unbound logical variable node
+and that the last alternative acts as default case that is selected if
+too few arguments are supplied.
+\begin{verbatim}
+
+> switchOnArity :: ([Name],CPSCont) -> Name -> [[CStmt]] -> [CStmt]
+> switchOnArity vs0 v (sts0:stss) =
+>   tagSwitch vs0 v taggedSwitch cases : last stss
+>   where cases = cCase "LVAR_TAG" sts0 : zipWith cCaseInt [1..] (init stss)
+>         taggedSwitch _ = id
 
 \end{verbatim}
 For a foreign function call, the generated code first unboxes all
@@ -1210,8 +1221,8 @@
 first loads this address into a temporary variable and then boxes it.
 \begin{verbatim}
 
-> cCall :: CRetType -> Name -> CCall -> [CStmt]
-> cCall ty v cc = cEval ty v' cc ++ box ty v (CExpr v')
+> cCall :: BindC -> [CStmt]
+> cCall (BindC v ty cc) = cEval ty v' cc ++ box ty v (CExpr v')
 >   where v' = cRetVar v
 
 > cEval :: CRetType -> String -> CCall -> [CStmt]
@@ -1228,7 +1239,7 @@
 >   where vs = map (cArgVar . snd) xs
 
 > cAddr :: CRetType -> String -> String -> [CStmt]
-> cAddr Nothing v x = []
+> cAddr Nothing _ _ = []
 > cAddr (Just ty) v x =
 >   [CLocalVar (ctype ty) v (Just (CCast (ctype ty) (addr x)))]
 
@@ -1258,8 +1269,7 @@
 > callCFun (Just ty) v f vs = CLocalVar (ctype ty) v (Just (funCall f vs))
 
 > box :: CRetType -> Name -> CExpr -> [CStmt]
-> box Nothing v _ =
->   [localVar v (Just (constRef (constNode (mangle "()"))))]
+> box Nothing v _ = [localVar v (Just (constRef (constNode prelUnit)))]
 > box (Just TypeBool) v e =
 >   [localVar v (Just (CCond e (const prelTrue) (const prelFalse)))]
 >   where const = constRef . constNode
@@ -1331,7 +1341,8 @@
 name of a function is printed. In particular, the debugger adds the
 prefix \texttt{\_debug\#} and a suffix \texttt{\#}$n$ to the name of
 the transformed function. Note that the prefix is added to the
-unqualified name.
+unqualified name. In addition, we also drop the renaming keys that are
+appended to the names of local variables and functions.
 \begin{verbatim}
 
 > undecorate :: String -> String
@@ -1342,51 +1353,20 @@
 >       | "debug#" `isPrefixOf` cs'' -> cs' ++ undecorate (drop 6 cs'')
 >       | otherwise -> cs' ++ '_' : undecorate cs''
 >   where dropSuffix cs =
->           case break ('#' ==) cs of
+>           case break (`elem` ".#") cs of
 >             (cs',"") -> cs'
 >             (cs','#':cs'')
 >               | all isDigit cs'' -> cs'
 >               | otherwise -> cs' ++ '#' : dropSuffix cs''
-
-\end{verbatim}
-The function \texttt{isPublic} is a workaround for distinguishing
-private and exported functions without an explicit export list, which
-is not yet part of the abstract machine code syntax. This function
-uses the following heuristics. All entities whose (demangled) name
-ends with a suffix \texttt{.}$n$, where $n$ is a non-empty sequence of
-decimal digits, are considered private, since that suffix can occur
-only in renamed identifiers, and all entities whose (demangled) name
-contains one of the substrings \verb"_#lambda", \verb"_#sel", and
-\verb"_#app" are considered private, too. These names are used by the
-compiler for naming lambda abstractions, lazy pattern selection
-functions, and the implicit functions introduced for lifted argument
-expressions. Furthermore, the auxiliary functions introduced by the
-debugging transformation for partial applications of the (non-empty)
-list constructor and the tuple constructors, respectively, are
-considered private as well.
-\begin{verbatim}
-
-> isPublic, isPrivate :: Name -> Bool
-> isPublic x = not (isPrivate x)
-> isPrivate (Name x) =
->   any (\cs -> any (`isPrefixOf` cs) [app,lambda,sel,debugCons,debugTuple])
->       (tails x) ||
->   case span isDigit (reverse x) of
->     ([],_) -> False
->     (_:_,cs) -> reverse dot `isPrefixOf` cs
->   where Name dot = mangle "."
->         Name app = mangle "_#app"
->         Name lambda = mangle "_#lambda"
->         Name sel = mangle "_#sel"
->         Name debugCons = mangle "_debug#:"
->         Name debugTuple = mangle "_debug#(,"
+>             (cs','.':cs'')
+>               | not (null cs'') && all isDigit cs'' -> cs'
+>               | otherwise -> cs' ++ '.' : dropSuffix cs''
 
 \end{verbatim}
 In order to avoid some trivial name conflicts with the standard C
 library, the names of all Curry functions are prefixed with two
-underscores. The integer key of each CPS function is added to the
-name, except for the function's main entry point, whose key is
-\texttt{0}.
+underscores. The integer key of each CPS continuation function is
+appended to its name to provide a unique name.
 
 The names of the info vector for a data constructor application and
 the info table for a function are constructed by appending the
@@ -1395,21 +1375,22 @@
 used for constant constructors and functions, respectively.
 \begin{verbatim}
 
+> cVis :: Visibility -> CVisibility
+> cVis Private = CPrivate
+> cVis Exported = CPublic
+
 > cName :: Name -> String
 > cName x = "__" ++ show x
 
 > cPrivName :: Name -> Int -> String
-> cPrivName f n
->   | n == 0 = cName f
->   | otherwise = cName f ++ '_' : show n
-
-> cpsName :: CPSFunction -> String
-> cpsName (CPSFunction f n _ _ _) = cPrivName f n
-
-> contName :: CPSCont -> String
-> contName (CPSCont f) = cpsName f
-> contName (CPSInst _ (LitCase l)) = litInstFunc l
-> contName (CPSInst _ (ConstrCase c _)) = instFunc c
+> cPrivName f n = cName f ++ '_' : show n
+
+> contName :: CPSContFun -> String
+> contName (CPSContFun f n) = cPrivName f n
+> contName (CPSInst (LitCase l)) = litInstFunc l
+> contName (CPSInst (ConstrCase c _)) = instFunc c
+> --contName (CPSApply _) = error "internal error: contName (CPSApply)"
+> contName CPSUpdate = "update"
 
 > constArray :: String
 > constArray = "constants"
@@ -1427,6 +1408,7 @@
 > litInstFunc :: Literal -> String
 > litInstFunc (Char c) = constChar c ++ "_unify"
 > litInstFunc (Int i) = constInt i ++ "_unify"
+> litInstFunc (Integer i) = constInteger i ++ "_unify"
 > litInstFunc (Float f) = constFloat f ++ "_unify"
 
 > nodeInfo, pappInfoTable, lazyInfoTable :: Name -> String
@@ -1437,39 +1419,17 @@
 > dataTag :: Name -> String
 > dataTag c = cName c ++ "_tag"
 
-> closVar :: Name -> String
-> closVar v = show v ++ "_clos"
+> argcVar, szVar :: Name -> String
+> argcVar v = show v ++ "_argc"
+> szVar v = show v ++ "_sz"
 
-> cArgVar :: Name -> String
+> cArgVar, cRetVar :: Name -> String
 > cArgVar v = "_carg" ++ "_" ++ show v
-
-> cRetVar :: Name -> String
 > cRetVar v = "_cret" ++ "_" ++ show v
 
 > retIpName :: Name
 > retIpName = Name "_ret_ip"
 
-> resName :: Name
-> resName = Name "_"
-
-\end{verbatim}
-The function \texttt{tupleArity} computes the arity of a tuple
-constructor by counting the commas in the -- demangled -- name. Note
-that \texttt{()} is \emph{not} a tuple name.
-\begin{verbatim}
-
-> isTuple :: Name -> Bool
-> isTuple c = isTupleName (demangle c)
->   where isTupleName ('(':',':cs) = dropWhile (',' ==) cs == ")"
->         isTupleName _ = False
-
-> tupleArity :: Name -> Int
-> tupleArity c = arity (demangle c)
->   where arity ('(':',':cs)
->           | cs'' == ")" = length cs' + 2
->           where (cs',cs'') = span (',' ==) cs
->         arity _ = error "internal error: tupleArity"
-
 \end{verbatim}
 The function \texttt{apArity} returns the arity of an application
 function \texttt{@}$_n$. Note that \texttt{@}$_n$ has arity $n+1$
@@ -1502,11 +1462,16 @@
 > constChar :: Char -> String
 > constChar c = "char_" ++ show (ord c)
 
-> constInt :: Int -> String
+> constInt :: Integer -> String
 > constInt i = "int_" ++ mangle (show i)
 >   where mangle ('-':cs) = 'M':cs
 >         mangle cs = cs
 
+> constInteger :: Integer -> String
+> constInteger i = "integer_" ++ mangle (show i)
+>   where mangle ('-':cs) = 'M':cs
+>         mangle cs = cs
+
 > constFloat :: Double -> String
 > constFloat f = "float_" ++ map mangle (show f)
 >   where mangle '+' = 'P'
@@ -1519,10 +1484,27 @@
 > constFunc f = cName f ++ "_function"
 
 \end{verbatim}
+The functions \texttt{fits32bits} and \texttt{fits64bits} check
+whether a signed integer literal fits into 32 and 64 bits,
+respectively, and the string returned by function \texttt{condLP64} is
+used as feature test for conditional compilation on a 64 bit target.
+\begin{verbatim}
+
+> fits32bits, fits64bits :: Integer -> Bool
+> fits32bits i = -0x80000000 <= i && i <= 0x7fffffff
+> fits64bits i = -0x8000000000000000 <= i && i <= 0x7fffffffffffffff
+
+> condLP64 :: String
+> condLP64 = "defined(_LP64) || defined(__LP64__)"
+        
+\end{verbatim}
 Here are some convenience functions, which simplify the construction
 of the abstract syntax tree.
 \begin{verbatim}
 
+> int :: Int -> CExpr
+> int i = CInt (toInteger i)
+
 > var :: Name -> CExpr
 > var v = CExpr (show v)
 
@@ -1542,10 +1524,10 @@
 > setField v f = CAssign (LField (LVar (show v)) f)
 
 > element :: CExpr -> Int -> CExpr
-> element base n = CElem base (CInt n)
+> element base n = CElem base (int n)
 
 > setElem :: LVar -> Int -> CExpr -> CStmt
-> setElem base n = CAssign (LElem base (CInt n))
+> setElem base n = CAssign (LElem base (int n))
 
 > regRet :: CExpr
 > regRet = CExpr "regs.ret"
@@ -1561,11 +1543,11 @@
 > setReg n = setElem (LVar "regs.r") n
 > setStk n = setElem (LVar "regs.sp") n
 
-> incrSp, decrSp :: Int -> CStmt
+> incrSp :: Int -> CStmt
 > incrSp n
->   | n >= 0 = CIncrBy (LVar "regs.sp") (CInt n)
->   | otherwise = CDecrBy (LVar "regs.sp") (CInt (-n))
-> decrSp n = incrSp (-n)
+>   | n >= 0 = CIncrBy (LVar "regs.sp") (CInt n')
+>   | otherwise = CDecrBy (LVar "regs.sp") (CInt (-n'))
+>   where n' = toInteger n
 
 > alloc :: CExpr
 > alloc = asNode (CExpr "regs.hp")
@@ -1579,18 +1561,21 @@
 > asNode :: CExpr -> CExpr
 > asNode = CCast nodePtrType
 
+> cCase :: String -> [CStmt] -> CCase
+> cCase l = CCase (CCaseLabel l)
+
+> cCaseInt :: Int -> [CStmt] -> CCase
+> cCaseInt i = CCase (CCaseInt (toInteger i))
+
+> cCaseDefault :: [CStmt] -> CCase
+> cCaseDefault = CCase CCaseDefault
+
 > goto :: String -> CStmt
 > goto l = gotoExpr (CExpr l)
 
-> gotoIndir :: String -> CStmt
-> gotoIndir l = gotoIndirExpr (CExpr l)
-
 > gotoExpr :: CExpr -> CStmt
 > gotoExpr l = CProcCall "GOTO" [l]
 
-> gotoIndirExpr :: CExpr -> CStmt
-> gotoIndirExpr l = CProcCall "GOTO_INDIR" [l]
-
 > funCall :: String -> [String] -> CExpr
 > funCall f xs = CFunCall f (map CExpr xs)
 
@@ -1635,12 +1620,10 @@
 Frequently used types.
 \begin{verbatim}
 
-> boolType, intType, longType, uintType, ulongType, doubleType :: CType
-> boolType = CType "boolean"
+> intType, longType, uintType, doubleType :: CType
 > intType = CType "int"
 > longType = CType "long"
 > uintType = CType "unsigned int"
-> ulongType = CType "unsigned long"
 > doubleType = CType "double"
 
 > voidType, voidPtrType :: CType
@@ -1670,7 +1653,8 @@
 > prelName :: String -> Name
 > prelName x = mangleQualified ("Prelude." ++ x)
 
-> prelTrue, prelFalse :: Name
+> prelUnit, prelTrue, prelFalse :: Name
+> prelUnit = prelName "()"
 > prelTrue = prelName "True"
 > prelFalse = prelName "False"
 
Solo in curry-0.9.11-classful/: Common.lhs
Solo in curry-0.9.11: configure
diff -u curry-0.9.11/configure-bin.in curry-0.9.11-classful/configure-bin.in
--- curry-0.9.11/configure-bin.in	2007-06-15 14:16:33.000000000 +0200
+++ curry-0.9.11-classful/configure-bin.in	2010-12-20 15:27:05.000000000 +0100
@@ -1,6 +1,6 @@
-dnl $Id: configure-bin.in 2239 2007-06-10 00:46:39Z wlux $
+dnl $Id: configure-bin.in 3019 2010-12-20 08:58:21Z wlux $
 dnl
-dnl Copyright (c) 2002-2007, Wolfgang Lux
+dnl Copyright (c) 2002-2008, Wolfgang Lux
 dnl
 
 AC_INIT([%PACKAGE_NAME% for %TARGET%],[%VERSION%],[wlux@uni-muenster.de])
@@ -22,7 +22,7 @@
 
 dnl Check for Cygpath
 HC_PATH_STYLE="%HC_PATH_STYLE%"
-if test "$HC_PATH_STYLE" = Windows; then
+if test "$HC_PATH_STYLE" = windows; then
   AC_PATH_PROG(CYGPATH, cygpath)
 fi
 
@@ -31,6 +31,18 @@
 AC_SEARCH_LIBS(inet_addr, nsl)
 AC_SEARCH_LIBS(socket, socket)
 
+dnl Check for GNU MP.
+AC_CHECK_LIB(gmp, __gmpz_init,
+    	     [LIBS="-lgmp $LIBS" have_libgmp=yes],
+    	     [have_libgmp=no])
+AC_CHECK_HEADER([gmp.h], [have_gmp_h=yes], [have_gmp_h=no])
+if test $have_gmp_h = no || test $have_libgmp = no; then
+  AC_MSG_ERROR([Gnu MP library not found.  If it is installed in a
+non-standard location be sure to invoke configure with the correct
+settings for CPPFLAGS and LDFLAGS.  If not installed you can download
+the Gnu MP library from http://www.swox.com/gmp/])
+fi
+
 dnl Check for a shell, which is suitable for cyi
 CURRY_CYI_SHELL
 
diff -u curry-0.9.11/configure.in curry-0.9.11-classful/configure.in
--- curry-0.9.11/configure.in	2007-06-15 14:16:33.000000000 +0200
+++ curry-0.9.11-classful/configure.in	2012-12-29 10:58:33.000000000 +0100
@@ -1,11 +1,11 @@
-dnl $Id: configure.in 2242 2007-06-10 18:10:51Z wlux $
+dnl $Id: configure.in 3116 2012-12-29 09:54:04Z wlux $
 dnl
-dnl Copyright (c) 2002-2007, Wolfgang Lux
+dnl Copyright (c) 2002-2012, Wolfgang Lux
 dnl See LICENSE for the full license.
 dnl
 
 AC_INIT([curry],[0.9.11],[wlux@uni-muenster.de])
-AC_PREREQ(2.50)
+AC_PREREQ(2.52)
 AC_CONFIG_SRCDIR(runtime/curry.nw)
 AC_CONFIG_HEADERS(runtime/config.h, [touch runtime/.config.h.stamp])
 
@@ -14,7 +14,7 @@
 AC_CANONICAL_TARGET
 
 
-dnl Checks for programs.
+dnl Checks for programs
 AC_PROG_CC
 AC_PROG_RANLIB
 AC_PROG_LN_S
@@ -25,30 +25,69 @@
 
 dnl Check configuration options
 AC_ARG_ENABLE(trampoline,
- [  --enable-trampoline     use trampoline code to implement tail jumps])
+ [  --enable-trampoline     use trampoline code to implement tail calls])
+AC_ARG_ENABLE(cheney,
+ [  --enable-cheney=N       use Cheney on the M.T.A. technique with stack size N
+                          (default: 32k bytes)])
+cheney_default_stack_size=32*1024
+
 case $enable_trampoline in
-  yes | fast | default ) AC_DEFINE(USE_TRAMPOLINE);;
-  slow | standard )
-    AC_DEFINE(USE_TRAMPOLINE)
-    AC_DEFINE(USE_STANDARD_TRAMPOLINE);;
+  yes ) ;;
+  no )
+    case $enable_cheney in
+      "" | no ) conflict=;;
+      yes ) conflict=--enable-cheney;;
+      * ) conflict=--enable-cheney=$enable_cheney;;
+    esac
+    if test -n "$conflict"; then
+      AC_MSG_ERROR([Conflicting options specified:
+--disable-trampoline and $conflict are mutually exclusive])
+    fi;;
   "" )
-    # enable trampoline when Gnu C is not used and on systems which use
-    # position independent code
-    if test "$GCC" != "yes"; then
-      enable_trampoline=yes
-      AC_DEFINE(USE_TRAMPOLINE)
-    else
-      case $target_os in
-        darwin* )
-          enable_trampoline=yes
-          AC_DEFINE(USE_TRAMPOLINE)
-          ;;
-	* ) enable_trampoline=no;;
+    case $enable_cheney in
+      "" | no )
+    	# enable trampoline when Gnu C is not used and on systems which use
+    	# position independent code
+    	if test "$GCC" != "yes"; then
+    	  enable_trampoline=yes
+    	else
+    	  case $target_os in
+    	    darwin* ) enable_trampoline=yes;;
+    	    * ) enable_trampoline=no;;
+    	  esac
+    	fi;;
+      * ) enable_trampoline=yes;;
+    esac;;
+  * )
+    AC_MSG_ERROR([invalid argument for --enable-trampoline: $enable_trampoline]);;
+esac
+if test "$enable_trampoline" = yes; then
+  AC_DEFINE(USE_TRAMPOLINE)
+fi
+
+case $enable_cheney in
+  yes ) enable_cheney=$cheney_default_stack_size;;
+  *k ) enable_cheney=`expr "$enable_cheney" : '\(.*\)'k`'*1024';;
+  *M ) enable_cheney=`expr "$enable_cheney" : '\(.*\)'k`'*1024*1024';;
+  "" )
+    if test $enable_trampoline = yes; then
+      case $target_cpu in
+        i*86 | x86_64 ) enable_cheney=$cheney_default_stack_size;;
+        * ) enable_cheney=no;;
       esac
+    else
+      enable_cheney=no
     fi;;
-  no ) ;;
-  * ) AC_MSG_ERROR([invalid argument for --enable-trampoline: $enable_trampoline
-should be either fast (synonym: default) or slow (synonym: standard)]);;
+esac
+if test $enable_cheney != no; then
+  AC_DEFINE_UNQUOTED(C_STACK_SIZE, $enable_cheney)
+fi
+
+AC_ARG_ENABLE(longjmp,
+ [  --disable-longjmp       Cheney on the M.T.A. technique returns normally to
+                          the trampoline instead of performing a longjmp])
+case $enable_longjmp in
+  no ) AC_DEFINE(USE_RETURN);;
 esac
 
 AC_ARG_ENABLE(pointer-tags,
@@ -66,10 +105,10 @@
 esac
 
 AC_ARG_ENABLE(stability,
- [  --enable-stability      don't perform a non-deterministic computation step
-                          while other threads can run deterministic code])
+ [  --disable-stability     perform non-deterministic computation steps even if
+                          deterministic computation steps could be executed])
 case $enable_stability in
-   yes ) AC_DEFINE(YIELD_NONDET);;
+   no ) AC_DEFINE(NO_STABILITY);;
 esac
 
 AC_ARG_ENABLE(occurs-check,
@@ -124,68 +163,71 @@
 
 
 dnl Check for Haskell compilers
-AC_ARG_WITH(hc, [  --with-hc=COMP          use COMP as Haskell'98 compiler],
-	    [WithHc=$withval],[WithHc=])
-
-case $WithHc in
-  no ) AC_MSG_ERROR([Invalid argument to --with-hc: no]);;
-  "" | yes )
-    AC_MSG_CHECKING([for Haskell 98 compiler])
-    AC_MSG_RESULT([])
-    CURRY_PROG_GHC
-    if test -n "$GHC"; then
-      AC_MSG_RESULT([using $GHC for compilation])
-    else
-      CURRY_PROG_HBC
-      if test -n "$HBC"; then
-        AC_MSG_RESULT([using $HBC for compilation])
-      else
-        CURRY_PROG_NHC
-	if test -n "$NHC"; then
-	  AC_MSG_RESULT([using $NHC for compilation])
-        else
-          AC_MSG_ERROR([No Haskell 98 compiler found])
-	fi
-      fi
+dnl recognize deprecated --with-hc option but report a warning if it is used
+AC_ARG_WITH(hc,[],[HC=$withval; AC_MSG_WARN([Deprecated option --with-hc used
+  Use ``configure HC=<haskell compiler>'' instead])])
+
+AC_ARG_VAR(HC,[Haskell compiler command])
+AC_ARG_VAR(HFLAGS,[Haskell compiler flags])
+
+if test -n "$HC"; then
+  AC_MSG_CHECKING([for $HC])
+  AC_MSG_RESULT([$HC])
+  CURRY_HC_STD_HASKELL(HC,[],[])
+else
+  CURRY_PROG_GHC
+  if test -z "$HC"; then
+    CURRY_PROG_HBC
+    if test -z "$HC"; then
+      CURRY_PROG_NHC
     fi
-    ;;
-  * ) CURRY_HC_VERSION(WithHc);;
-esac
+  fi
+fi
+if test -z "$HC"; then
+  AC_MSG_ERROR([No Haskell 98 compiler found])
+fi
 
-if test -n "$GHC"; then
-  hc=ghc HC="$GHC"
-  AC_ARG_ENABLE(ghc_make,
-    [  --disable-ghc-make      ghc only: Do not use ghc --make])
-  case $enable_ghc_make in
-    no ) ;;
-    *  )
-      AC_MSG_CHECKING([whether $GHC --make works])
-      cat <<eof >conftest.hs
+CURRY_HC_VERSION(hc)
+case $hc in
+  ghc* )
+    hc=ghc
+    AC_ARG_ENABLE(ghc_make,
+      [  --disable-ghc-make      ghc only: Do not use ghc --make])
+    case $enable_ghc_make in
+      no ) ;;
+      *  )
+        AC_MSG_CHECKING([whether $HC --make works])
+        cat <<eof >conftest.hs
 main = return ()
 eof
-      if $GHC --make $HCFLAGS -o conftest conftest >/dev/null 2>&1 && test -f conftest; then
-        hc=ghc-make
-        AC_MSG_RESULT([yes])
-      else
-        AC_MSG_RESULT([no])
-      fi
-      rm -f conftest* a.out
-      ;;
-  esac
-  CURRY_HC_HLIB(GHC,
-    [HCFLAGS="$HCFLAGS -ighc"
-     IOExts_lhs=ghc/IOExts.lhs],
-    [CURRY_GHC_IOEXTS
-     IOExts_lhs=])
-elif test -n "$HBC"; then
-  hc=hbc HC="$HBC"
-  IOExts_lhs=hbc/IOExts.lhs
-elif test -n "$NHC"; then
-  hc=nhc HC="$NHC"
-  IOExts_lhs=nhc/IOExts.lhs
-else
-  AC_MSG_ERROR([Sorry, you need a Haskell 98 compiler])
-fi
+       if $HC --make $HFLAGS -o conftest conftest >&AS_MESSAGE_LOG_FD 2>&1 && test -f conftest; then
+          hc=ghc-make
+          AC_MSG_RESULT([yes])
+        else
+          AC_MSG_RESULT([no])
+        fi
+        rm -rf conftest* a.out
+        ;;
+    esac
+    CURRY_HC_HLIB(HC,
+      [HFLAGS="$HFLAGS -ighc"
+       IOExts_lhs=ghc/IOExts.lhs],
+      [CURRY_GHC_IOEXTS
+       IOExts_lhs=])
+    case "$HASKELL" in
+      hs2010 ) HFLAGS="$HFLAGS -ihs2010"
+    esac
+    ;;
+  hbc* )
+    hc=hbc
+    IOExts_lhs=hbc/IOExts.lhs
+    ;;
+  nhc* )
+    hc=nhc
+    IOExts_lhs=nhc/IOExts.lhs
+    ;;
+  * ) AC_MSG_ERROR([$HC is not supported]);;
+esac
 
 CURRY_HC_PATH_STYLE
 
@@ -197,35 +239,55 @@
 
 
 dnl Check for noweb programs
+dnl These must be present if building from the repository, but are not
+dnl required for building from a source distribution. We assume building
+dnl from a source distribution if config.h.in is present.
 AC_CHECK_PROG(TANGLE, notangle, notangle)
 AC_CHECK_PROG(WEAVE, noweave, noweave)
 AC_CHECK_PROG(CPIF, cpif, cpif)
 
-if test -z "$TANGLE" || test -z "$CPIF"; then TANGLE=':' CPIF=':'; fi
-if test -z "$WEAVE"; then WEAVE=': \#'; fi
+if test -f $srcdir/config.h.in; then
+  if test -z "$TANGLE" || test -z "$CPIF"; then TANGLE=':' CPIF=':'; fi
+  if test -z "$WEAVE"; then WEAVE=': \#'; fi
+elif test -z "$TANGLE" || test -z "$CPIF" || test -z "$WEAVE"; then
+  AC_MSG_ERROR([
+Noweb not found.  If not installed on your machine you can
+download noweb from http://www.eecs.harvard.edu/~nr/noweb/])
+fi
 
 
-dnl Checks for libraries.
+dnl Checks for libraries
 AC_SEARCH_LIBS(sin, m)
 AC_SEARCH_LIBS(inet_addr, nsl)
 AC_SEARCH_LIBS(socket, socket)
 
 
-dnl Checks for header files.
+dnl Checks for header files
 AC_CHECK_HEADERS([stdbool.h])
-AC_CHECK_HEADERS([sys/socket.h])
+AC_CHECK_HEADERS([sys/socket.h],[have_sockets_h=yes],[have_sockets_h=no])
 AC_CHECK_HEADERS([sys/resource.h])
 AC_CHECK_HEADERS([sys/mman.h],[have_sys_mman_h=yes],[have_sys_mman_h=no])
-AC_CHECK_HEADERS([winsock.h],[LIBS="$LIBS -lwsock32"])
+if test $have_sockets_h = no; then
+  AC_CHECK_HEADERS([winsock2.h],[have_sockets_h=yes; LIBS="$LIBS -lws2_32"])
+  if test $have_sockets_h = no; then
+    AC_CHECK_HEADERS([winsock.h],[have_sockets_h=yes; LIBS="$LIBS -lwsock32"])
+  fi
+fi
 AC_CHECK_HEADERS([ieeefp.h])
 AC_HEADER_SYS_WAIT
 
 
-dnl Checks for compiler characteristics.
+dnl Checks for compiler characteristics
 AC_C_CONST
 AC_C_VOLATILE
 AC_C_INLINE
+
+
+dnl Checks for target characteristics
 CURRY_UNALIGNED_DOUBLE
+if test $enable_cheney != no; then
+  CURRY_STACK_GROWSUP
+fi
 
 
 dnl Check for typedefs and structures
@@ -236,7 +298,7 @@
 #endif])
 
 
-dnl Checks for library functions.
+dnl Checks for library functions
 AC_FUNC_FORK
 AC_CHECK_FUNCS([popen])
 AC_CHECK_FUNCS([random])
@@ -251,11 +313,58 @@
 esac
 
 
+dnl Check for GNU MP or OpenSSL's libcrypto.
+AC_ARG_WITH(gmp,
+ [  --with-gmp              use Gnu MP library for multi-precision integer
+                          arithmetic (default if available)])
+AC_ARG_WITH(libcrypto,
+ [  --with-libcrypto        use libcrypto (part of OpenSSL) for multi-precision
+                          integer arithmetic (default if gmp is not available)])
+
+have_gmp=no
+if test x"$with_gmp" != xno; then
+  AC_CHECK_HEADERS([gmp.h], [have_gmp=yes])
+fi
+
+have_libcrypto=no
+if test $have_gmp = no && test x"$with_libcrypto" != xno; then
+  AC_CHECK_HEADERS([openssl/bn.h], [have_libcrypto=yes])
+fi
+
+if test $have_gmp = yes; then
+  AC_CHECK_LIB(gmp, __gmpz_init, [LIBS="-lgmp $LIBS"], [have_gmp=no])
+  if test $have_gmp = no; then
+    AC_MSG_ERROR([
+Could not find a working libgmp for gmp.h.  Check the
+CPPFLAGS and LDFLAGS environment variables, or disable
+gmp via --without-gmp if configure has found a bogus
+gmp.h.])
+  fi
+elif test $have_libcrypto = yes; then
+  AC_CHECK_LIB(crypto, BN_init, [LIBS="-lcrypto $LIBS"], [have_libcrypto=no])
+  if test $have_libcrypto = no; then
+    AC_MSG_ERROR([
+Could not find a working libcrypto for openssl/bn.h.  Check
+the CPPFLAGS and LDFLAGS environment variables, or disable
+libcrypto via --without-libcrypto if configure has found a
+bogus openssl/bn.h.])
+  fi
+else
+  AC_MSG_ERROR([
+Neither the Gnu MP library nor OpenSSL's libcrypto could be
+found.  If they are installed in a non-standard location be
+sure to invoke configure with the correct settings for
+CPPFLAGS and LDFLAGS.  If not installed you can download the
+Gnu MP library from http://gmplib.org/])
+fi
+
+
 dnl Generate output files
 AC_SUBST(CURRY_CFLAGS)
 AC_SUBST(hc)
 AC_SUBST(HC)
-AC_SUBST(HCFLAGS)
+AC_SUBST(HFLAGS)
+AC_SUBST(HASKELL)
 AC_SUBST(IOExts_lhs)
 AC_SUBST(INSTALL_DIR)
 AC_SUBST(STDLIB)
diff -u curry-0.9.11/CPretty.lhs curry-0.9.11-classful/CPretty.lhs
--- curry-0.9.11/CPretty.lhs	2007-06-15 14:16:35.000000000 +0200
+++ curry-0.9.11-classful/CPretty.lhs	2008-02-09 09:08:12.000000000 +0100
@@ -1,7 +1,7 @@
 % -*- LaTeX -*-
-% $Id: CPretty.lhs 1924 2006-05-23 16:11:37Z wlux $
+% $Id: CPretty.lhs 2620 2008-02-08 13:20:26Z wlux $
 %
-% Copyright (c) 2002-2005, Wolfgang Lux
+% Copyright (c) 2002-2008, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{CPretty.lhs}
@@ -45,9 +45,11 @@
 >   | otherwise = text "enum" $+$ block (list ppConst cs) <> semi
 > ppTopDecl (CFuncDecl vb f) =
 >   ppFunCall "DECLARE_LABEL" [ppLinkage True vb,text f] <> semi
-> ppTopDecl (CVarDef vb ty v (CInit x)) =
+> ppTopDecl (CVarDef vb ty v Nothing) =
+>   ppLinkage False vb <+> varDecl ty v <> semi
+> ppTopDecl (CVarDef vb ty v (Just (CInit x))) =
 >   ppLinkage False vb <+> varDecl ty v <> equals <> ppExpr 0 x <> semi
-> ppTopDecl (CVarDef vb ty v (CStruct xs)) =
+> ppTopDecl (CVarDef vb ty v (Just (CStruct xs))) =
 >   ppLinkage False vb <+> varDecl ty v <> equals $+$ ppInits xs <> semi
 > ppTopDecl (CArrayDef vb ty v xs) =
 >   ppLinkage False vb <+> arrayDecl ty v <> equals $+$ ppInits xs <> semi
@@ -75,7 +77,7 @@
 > ppLinkage _ CPrivate = text "static"
 
 > ppConst :: CConst -> Doc
-> ppConst (CConst c x) = text c <> maybe empty (\i -> equals <> int i) x
+> ppConst (CConst c x) = text c <> maybe empty (\i -> equals <> integer i) x
 
 > ppInits :: [CInitializer] -> Doc
 > ppInits xs = block (list ppInit xs)
@@ -89,8 +91,8 @@
 declarations and emits them at the beginning of the block. The
 function \texttt{ppBlock} can insert an arbitrary code sequence
 between the declarations and the statements. This allows inserting the
-entry-label into a function block. For nested blocks no additional
-code is inserted. As all code before the entry-point is skipped when
+entry label into a function block. For nested blocks no additional
+code is inserted. As all code before the entry point is skipped when
 using the direct jump model, \texttt{ppBlock} replaces the
 declarations by assignments to the declared variables at the places
 where they occur in the block.
@@ -173,8 +175,12 @@
 \begin{verbatim}
 
 > ppCase :: CCase -> Doc
-> ppCase (CCase c sts) = text "case" <+> text c <> colon $+$ ppCaseStmts sts
-> ppCase (CDefault sts) = text "default" <> colon $+$ ppCaseStmts sts
+> ppCase (CCase l sts) = ppCaseLabel l <> colon $+$ ppCaseStmts sts
+
+> ppCaseLabel :: CCaseLabel -> Doc
+> ppCaseLabel (CCaseLabel c) = text "case" <+> text c
+> ppCaseLabel (CCaseInt i) = text "case" <+> integer i
+> ppCaseLabel CCaseDefault = text "default"
 
 > ppCaseStmts :: [CStmt] -> Doc
 > ppCaseStmts sts = if null ds then ppStmts sts else ppStmt (CBlock sts)
@@ -197,8 +203,8 @@
 > ppExpr :: Int -> CExpr -> Doc
 > ppExpr _ CNull = text "0"
 > ppExpr p (CInt i)
->   | i < 0 = ppParens (p > 3) $ int (i + 1) <> text "-1"
->   | otherwise = int i
+>   | i < 0 = ppParens (p > 3) $ integer (i + 1) <> text "-1"
+>   | otherwise = integer i
 > ppExpr _ (CFloat f) = double f
 > ppExpr _ (CString s) = string s
 > ppExpr _ (CElem x i) = ppExpr 6 x <> brackets (ppExpr 0 i)
diff -u curry-0.9.11/CPS.lhs curry-0.9.11-classful/CPS.lhs
--- curry-0.9.11/CPS.lhs	2007-06-15 14:16:35.000000000 +0200
+++ curry-0.9.11-classful/CPS.lhs	2012-08-14 13:14:36.000000000 +0200
@@ -1,16 +1,17 @@
 % -*- LaTeX -*-
-% $Id: CPS.lhs 2116 2007-03-04 15:44:06Z wlux $
+% $Id: CPS.lhs 3096 2012-08-13 09:53:52Z wlux $
 %
-% Copyright (c) 2003-2007, Wolfgang Lux
+% Copyright (c) 2003-2012, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{CPS.lhs}
 \section{Continuation Passing Style}\label{sec:cps}
 \begin{verbatim}
 
-> module CPS(CPSFunction(..), CPSCont(..),
->            CaseBlock(..), CPSTag(..), CPSStmt(..),
->            cpsFunction, cpsApply, cpsInst, cpsEnv, contVars) where
+> module CPS(CPSFunction(..), CPSContinuation(..),
+>            CPSFun(..), CPSCont(..), CPSContFun(..),
+>            BindC(..), BindPapp(..), CaseBlock(..), CPSTag(..), CPSStmt(..),
+>            cpsFunction, cpsApply, cpsInst, continuations) where
 > import Cam
 > import List
 > import Set
@@ -27,43 +28,80 @@
 which instantiates unbound variables in flexible switch statements and
 implements stability when it is enabled.
 
-Special code is generated for the private functions that implement
-partial applications of tuple constructors and for the functions
-\texttt{@}$_n$.
+Special code is generated for the functions \texttt{@}$_n$. This code
+evaluates the first argument of the function and then matches the
+arity of the resulting partial application node. If too few arguments
+are supplied to the partial application, a new partial application
+node is returned, which includes the additional arguments. Otherwise,
+the application is entered through its application entry point. If the
+closure is applied to too many arguments the application entry point
+is entered with the expected number of arguments and the supplied
+continuation takes care of applying its result to the remaining
+arguments.
 
 An abstract machine code function may be transformed into more than
 one CPS function. In order to avoid name conflicts, the compiler
-assigns distinct integer keys to all CPS functions generated from an
-abstract machine code function. By convention, the CPS function that
-corresponds to the entry point of an abstract machine code function is
-always assigned key 0.
-
-A CPS function has two argument lists. The first contains the proper
-arguments of the function and the second the free variables of the
-function's body. Note that neither \texttt{CPSJump} nor
-\texttt{CPSChoices} allow passing arguments to their continuations, so
-these continuation must not have proper function arguments (cf.
-\texttt{cpsInst} below).
+assigns a distinct integer key to each continuation defined in a CPS
+function.
+
+A CPS continuation function has two argument lists. The first contains
+the proper arguments of the function and the second the free variables
+of the function's body. Note that \texttt{CPSChoice} does not allow
+passing arguments to its continuations, so these continuations must
+not have proper function arguments (cf. \texttt{cpsInst} below). The
+continuation argument of a continuation function provides the context
+in which it is defined and called. At present, we make use of this
+feature only to provide a more efficient calling sequence for the code
+that instantiates variables in a flexible switch.
+
+The idiosyncratic \texttt{CPSSwitchVar} statement allows
+distinguishing local and global unbound logical variables of a search
+goal within an encapsulated search. The first alternative is chosen
+for a global unbound variable, which must not be instantiated, and the
+second is chosen for a local unbound variable, which can be
+instantiated.
+
+A statement \texttt{CPSSwitchArity \char`\{\ 0:$st_0$; \dots;
+  n:$st_n$; \_:$st_{n+1}$ \char`\}} dispatches on the arity, i.e., the
+number of missing arguments, of a matched partial application node.
+The first statement $st_0$, corresponding to arity 0, is selected when
+an unbound logical variable is matched, and the last statement
+$st_{n+1}$ is selected if the arity of the matched node is greater
+than $n$. This default case will allocate a fresh partial application
+node combining the arguments of the matched node and the supplied
+arguments with a \texttt{CPSLetPapp} statement.
 \begin{verbatim}
 
-> data CPSFunction = CPSFunction Name Int [Name] [Name] CPSStmt deriving Show
+> data CPSFunction = CPSFunction Name [Name] CPSStmt deriving Show
+> data CPSContinuation =
+>   CPSContinuation CPSContFun [Name] [Name] CPSStmt
+>   deriving Show
 > data CPSStmt =
->     CPSJump CPSCont
->   | CPSReturn Expr
->   | CPSEnter Name
->   | CPSExec Name [Name]
->   | CPSCCall CRetType CCall
->   | CPSApply Name [Name]
->   | CPSUnify Name Expr
->   | CPSDelay Name
->   | CPSDelayNonLocal Name CPSStmt
->   | CPSSeq Stmt0 CPSStmt
->   | CPSWithCont CPSCont CPSStmt
+>     CPSFail
+>   | CPSExecCont CPSCont [Name]
+>   | CPSExec CPSFun CPSCont [Name]
+>   | CPSLet [Bind] CPSStmt
+>   | CPSLetC BindC CPSStmt
+>   | CPSLetPapp BindPapp CPSStmt
+>   | CPSLetCont CPSContinuation CPSStmt
 >   | CPSSwitch Bool Name [CaseBlock]
->   | CPSChoices (Maybe Name) [CPSCont]
+>   | CPSSwitchVar Name CPSStmt CPSStmt
+>   | CPSSwitchArity Name [CPSStmt]
+>   | CPSChoice (Maybe Name) [CPSCont]
+>   deriving Show
+
+> data CPSFun =
+>   CPSFun Name | CPSEval Bool Name | CPSUnify | CPSDelay deriving Show
+> data CPSCont = CPSReturn | CPSCont CPSContFun [Name] CPSCont deriving Show
+> data CPSContFun =
+>     CPSContFun Name Int
+>   | CPSInst Tag
+>   | CPSApply Name
+>   | CPSUpdate
 >   deriving Show
 
-> data CPSCont = CPSCont CPSFunction | CPSInst Name Tag
+> data BindC = BindC Name CRetType CCall deriving Show
+> data BindPapp = BindPapp Name Name [Name] deriving Show
 > data CaseBlock = CaseBlock CPSTag CPSStmt deriving Show
 > data CPSTag =
 >     CPSLitCase Literal
@@ -72,43 +110,42 @@
 >   | CPSDefaultCase
 >   deriving Show
 
-> instance Eq CPSFunction where
->   CPSFunction f1 n1 _ _ _ == CPSFunction f2 n2 _ _ _ = f1 == f2 && n1 == n2
-> instance Ord CPSFunction where
->   CPSFunction f1 n1 _ _ _ `compare` CPSFunction f2 n2 _ _ _ =
->     case f1 `compare` f2 of
->       EQ -> n1 `compare` n2
->       ne -> ne
-
-> instance Show CPSCont where
->   showsPrec p (CPSCont (CPSFunction f n _ ws _)) = showParen (p > 10) $
->     showString "CPSCont " . shows f . showChar ' ' . shows n .
->     showChar ' ' . showList ws
->   showsPrec p (CPSInst v t) = showParen (p > 10) $
->     showString "CPSInst " . shows v . showChar ' ' . showsPrec 11 t
-
-> cpsFunction :: Name -> [Name] -> Stmt -> [CPSFunction]
-> cpsFunction f vs st = linearize (snd (cps f Nothing vs 0 st))
-
-> cpsApply :: Name -> [Name] -> [CPSFunction]
-> cpsApply f (v:vs) = [k0,k1]
->   where k0 = CPSFunction f 0 (v:vs) [] (CPSWithCont (CPSCont k1) (CPSEnter v))
->         k1 = CPSFunction f 1 [v] vs
->                (CPSSwitch False v
->                   [CaseBlock CPSFreeCase
->                              (CPSWithCont (CPSCont k1) (CPSDelay v)),
->                    CaseBlock CPSDefaultCase (CPSApply v vs)])
+> cpsFunction :: Name -> [Name] -> Stmt -> CPSFunction
+> cpsFunction f vs st
+>   | null ws = CPSFunction f vs st'
+>   | otherwise = error ("internal error: cpsFunction " ++ demangle f)
+>   where ws = filter (`notElem` vs) (freeVars st CPSReturn)
+>         (_,st') = cpsStmt f Nothing (True,CPSReturn) 1 st
+
+> cpsApply :: Name -> [Name] -> CPSFunction
+> cpsApply f (v:vs) =
+>   CPSFunction f (v:vs) (CPSLetCont f' (CPSExec (CPSEval False v) k' [v]))
+>   where f' = CPSContinuation (CPSContFun f 1) [v] vs (CPSSwitchArity v cases)
+>         k' = cpsCont f'
+>         cases =
+>           cpsRigidCase k' v :
+>           [CPSExecCont (apply v i vs CPSReturn) [v] | i <- [1..length vs]] ++
+>           [CPSLetPapp (BindPapp tmp v vs) (CPSExecCont CPSReturn [tmp])]
+>         apply v i vs = CPSCont (CPSApply v) vs' . applyCont vs''
+>           where (vs',vs'') = splitAt i vs
+>         applyCont vs
+>           | null vs = id
+>           | otherwise = CPSCont (CPSContFun (apName (length vs)) 1) vs
+>         apName n = mangle ('@' : if n == 1 then "" else show n)
+
+> cpsInst :: Name -> Tag -> CPSContinuation
+> cpsInst v t =
+>   CPSContinuation (CPSInst t) [] [v] $
+>   foldr (CPSLet . return) (CPSExec CPSUnify CPSReturn [v,tmp])
+>         (cpsFresh tmp t)
 
-> cpsInst :: Name -> Name -> Tag -> CPSFunction
-> cpsInst f v t = CPSFunction f 0 [] [v] (cpsFresh v t)
-
-> cpsEnv :: CPSFunction -> [Name]
-> cpsEnv (CPSFunction _ _ _ ws _) = ws
+> cpsCont :: CPSContinuation -> CPSCont
+> cpsCont (CPSContinuation f _ ws _) = CPSCont f ws CPSReturn
 
 \end{verbatim}
-The transformation into CPS code is implemented by a top-down
+The transformation into CPS code is implemented by a one-pass top-down
 algorithm. The abstract machine code statements \texttt{return},
-\texttt{enter}, \texttt{exec}, and \texttt{ccall} are transformed
+\texttt{eval}, \texttt{exec}, and \texttt{ccall} are transformed
 directly into their CPS equivalents. Statement sequences $x$
 \texttt{<-} \emph{st$_1$}\texttt{;} \emph{st$_2$}, where \emph{st$_1$}
 is neither a \texttt{return} nor a \texttt{ccall} statement, are
@@ -129,22 +166,19 @@
 function that performs the switch, and the \texttt{switch} statement is
 transformed into a jump to that function.
 
-The translation of a \texttt{choices} statement has to ensure that all
+The translation of a \texttt{choice} statement has to ensure that all
 alternatives use the same input variables so that the runtime system
 does not need to construct separate closures for each of them.
-
-Note that the transformation ensures that the unique key of every CPS
-function is greater than that of its predecessor. This is used below
-when transforming a CPS graph into a linear sequence of CPS functions.
 \begin{verbatim}
 
-> cps :: Name -> Maybe CPSCont -> [Name] -> Int -> Stmt -> (Int,CPSFunction)
+> cps :: Name -> (Bool,CPSCont) -> [Name] -> Int -> Stmt
+>     -> (Int,CPSContinuation)
 > cps f k vs n st = (n',f')
->   where f' = CPSFunction f n vs ws st'
->         ws = filter (`notElem` vs) (nub (freeVars st k))
->         (n',st') = cpsStmt f (Just (CPSCont f')) k (n + 1) st
+>   where f' = CPSContinuation (CPSContFun f n) vs ws st'
+>         ws = filter (`notElem` vs) (freeVars st (snd k))
+>         (n',st') = cpsStmt f (Just (cpsCont f')) k (n + 1) st
 
-> cpsCase :: Name -> Maybe CPSCont -> Int -> Case -> (Int,CaseBlock)
+> cpsCase :: Name -> (Bool,CPSCont) -> Int -> Case -> (Int,CaseBlock)
 > cpsCase f k n (Case t st) = (n',CaseBlock (cpsTag t) st')
 >   where (n',st') = cpsStmt f Nothing k n st
 
@@ -153,105 +187,120 @@
 > cpsTag (ConstrCase c vs) = CPSConstrCase c vs
 > cpsTag DefaultCase = CPSDefaultCase
 
-> cpsStmt :: Name -> Maybe CPSCont -> Maybe CPSCont -> Int -> Stmt
+> cpsStmt :: Name -> Maybe CPSCont -> (Bool,CPSCont) -> Int -> Stmt
 >         -> (Int,CPSStmt)
-> cpsStmt _ _ k n (Return e) = (n,maybe id CPSWithCont k (CPSReturn e))
-> cpsStmt _ _ k n (Enter v) = (n,maybe id CPSWithCont k (CPSEnter v))
-> cpsStmt _ _ k n (Exec f vs) = (n,maybe id CPSWithCont k (CPSExec f vs))
-> cpsStmt _ _ k n (CCall _ ty cc) = (n,maybe id CPSWithCont k (CPSCCall ty cc))
-> cpsStmt f k0 k n (Seq st1 st2) =
+> cpsStmt _ _ k n (Return e) =
+>   case e of
+>     Var v -> (n,CPSExecCont (snd k) [v])
+>     _ -> (n,CPSLet [Bind tmp e] (CPSExecCont (snd k) [tmp]))
+> cpsStmt _ _ k n (Eval v) = (n,CPSExec (CPSEval (fst k) v) (snd k) [v])
+> cpsStmt _ _ k n (Exec f vs) = (n,CPSExec (CPSFun f) (snd k) vs)
+> cpsStmt _ _ k n (CCall _ ty cc) =
+>   (n,CPSLetC (BindC tmp ty cc) (CPSExecCont (snd k) [tmp]))
+> cpsStmt f k0 k n (Seq (v :<- st1) st2) =
 >   case st1 of
->     Lock _ -> (n',CPSSeq st1 st2')
->       where (n',st2') = cpsStmt f Nothing k n st2
->     Update _ _ -> (n',CPSSeq st1 st2')
+>     Seq st1' st2' -> cpsStmt f k0 k n (Seq st1' (Seq (v :<- st2') st2))
+>     Let ds st1' -> cpsStmt f k0 k n (Let ds (Seq (v :<- st1') st2))
+>     Return e -> (n',CPSLet [Bind v e] st2')
 >       where (n',st2') = cpsStmt f Nothing k n st2
->     v :<- Seq st1' st2' -> cpsStmt f k0 k n (Seq st1' (Seq (v :<- st2') st2))
->     v :<- Return e -> (n',CPSSeq st1 st2')
+>     CCall _ ty cc -> (n',CPSLetC (BindC v ty cc) st2')
 >       where (n',st2') = cpsStmt f Nothing k n st2
->     v :<- CCall h ty cc -> (n',CPSSeq st1 st2')
->       where (n',st2') = cpsStmt f Nothing k n st2
->     v :<- st -> (n'',st1')
->       where (n',st1') = cpsStmt f k0 (Just (CPSCont f')) n st
+>     _ -> (n'',CPSLetCont f' st1')
+>       where (n',st1') = cpsStmt f k0 (tagged f',cpsCont f') n st1
 >             (n'',f') = cps f k [v] n' st2
->     Let ds -> (n',foldr (CPSSeq . Let) st2' (scc bound free ds))
->       where (n',st2') = cpsStmt f Nothing k n st2
->             bound (Bind v _) = [v]
->             free (Bind _ n) = exprVars n
+>             tagged (CPSContinuation _ vs _ (CPSSwitch tagged v _)) =
+>               vs /= [v] || tagged
+>             tagged (CPSContinuation _ vs _ (CPSSwitchArity v _)) = vs /= [v]
+>             tagged _ = True
+> cpsStmt f _ k n (Let ds st) = (n',foldr CPSLet st' (scc bound free ds))
+>   where (n',st') = cpsStmt f Nothing k n st
+>         bound (Bind v _) = [v]
+>         free (Bind _ n) = exprVars n
 > cpsStmt f k0 k n (Switch rf v cases) =
 >   maybe (cpsJumpSwitch f) (cpsSwitch f) k0 k n rf v cases
-> cpsStmt f _ k n (Choices alts) =
->   (n',CPSChoices Nothing (map (CPSCont . updEnv ws) ks))
+> cpsStmt f k0 k n (Choice alts) =
+>   case alts of
+>     [] -> (n,CPSFail)
+>     [st] -> cpsStmt f k0 k n st
+>     _ -> (n',foldr CPSLetCont (CPSChoice Nothing (map cpsCont ks')) ks')
 >   where (n',ks) = mapAccumL (cps f k []) n alts
->         ws = nub (freeVars (Choices alts) k)
->         updEnv ws (CPSFunction f n vs _ st) = CPSFunction f n vs ws st
+>         ks' = map (updEnv (freeVars (Choice alts) (snd k))) ks
+>         updEnv ws (CPSContinuation f vs _ st) = CPSContinuation f vs ws st
 
-> cpsJumpSwitch :: Name -> Maybe CPSCont -> Int -> RF -> Name -> [Case]
+> cpsJumpSwitch :: Name -> (Bool,CPSCont) -> Int -> RF -> Name -> [Case]
 >               -> (Int,CPSStmt)
-> cpsJumpSwitch f k n rf v cases = (n',CPSWithCont k' (CPSReturn (Var v)))
->   where k' = CPSCont (CPSFunction f n [v] ws st')
->         ws = filter (v /=) (nub (freeVars (Switch rf v cases) k))
+> cpsJumpSwitch f k n rf v cases = (n',CPSLetCont f' (CPSExecCont k' [v]))
+>   where f' = CPSContinuation (CPSContFun f n) [v] ws st'
+>         k' = cpsCont f'
+>         ws = filter (v /=) (freeVars (Switch rf v cases) (snd k))
 >         (n',st') = cpsSwitch f k' k (n + 1) rf v cases
 
-> cpsSwitch :: Name -> CPSCont -> Maybe CPSCont -> Int -> RF -> Name -> [Case]
+> cpsSwitch :: Name -> CPSCont -> (Bool,CPSCont) -> Int -> RF -> Name -> [Case]
 >           -> (Int,CPSStmt)
 > cpsSwitch f k0 k n rf v cases = (n',CPSSwitch tagged v (vcase ++ cases'))
->   where vcase =
->           map (CaseBlock CPSFreeCase . CPSWithCont k0) (cpsVarCase rf v ts)
+>   where vcase = map (CaseBlock CPSFreeCase) (cpsVarCase rf k0 v ts)
 >         (n',cases') = mapAccumL (cpsCase f k) n cases
 >         ts = [t | Case t _ <- cases, t /= DefaultCase]
 >         tagged = taggedSwitch ts
 
-> cpsVarCase :: RF -> Name -> [Tag] -> [CPSStmt]
-> cpsVarCase Rigid v _ = [CPSDelay v]
-> cpsVarCase Flex v ts
->   | null ts = []
->   | otherwise = [CPSDelayNonLocal v (cpsFlexCase v ts)]
-
-> cpsFlexCase :: Name -> [Tag] -> CPSStmt
-> cpsFlexCase v [t] = CPSJump (CPSInst v t)
-> cpsFlexCase v ts = CPSChoices (Just v) (map (CPSInst v) ts)
+> cpsVarCase :: RF -> CPSCont -> Name -> [Tag] -> [CPSStmt]
+> cpsVarCase Rigid k v _ = [cpsRigidCase k v]
+> cpsVarCase Flex k v ts =
+>   [CPSSwitchVar v (cpsRigidCase k v) (cpsFlexCase k v ts) | not (null ts)]
+
+> cpsRigidCase :: CPSCont -> Name -> CPSStmt
+> cpsRigidCase k v = CPSExec CPSDelay k [v]
+
+> cpsFlexCase :: CPSCont -> Name -> [Tag] -> CPSStmt
+> cpsFlexCase k v ts = cpsFlexChoice v [CPSCont (CPSInst t) [v] k | t <- ts]
+
+> cpsFlexChoice :: Name -> [CPSCont] -> CPSStmt
+> cpsFlexChoice _ [k] = CPSExecCont k []
+> cpsFlexChoice v ks = CPSChoice (Just v) ks
 
-> cpsFresh :: Name -> Tag -> CPSStmt
-> cpsFresh v (LitCase l) = CPSUnify v (Lit l)
+> cpsFresh :: Name -> Tag -> [Bind]
+> cpsFresh v (LitCase l) = [Bind v (Lit l)]
 > cpsFresh v (ConstrCase c vs) =
->   foldr CPSSeq (CPSUnify v (Constr c vs)) (map freshVar vs)
->   where freshVar v = Let [Bind v Free]
+>   [Bind v Free | v <- vs] ++ [Bind v (Constr c vs)]
 
 > taggedSwitch :: [Tag] -> Bool
 > taggedSwitch = foldr tagged True
 >   where tagged (LitCase (Char _)) _ = True
 >         tagged (LitCase (Int _)) _ = True
+>         tagged (LitCase (Integer _)) _ = True
 >         tagged (LitCase (Float _)) _ = False
 >         tagged (ConstrCase _ _) _ = False
 >         tagged DefaultCase t = t
 
+> freeVars :: Stmt -> CPSCont -> [Name]
+> freeVars st k = nub (stmtVars st (contVars k))
+
 > contVars :: CPSCont -> [Name]
-> contVars (CPSCont k) = cpsEnv k
-> contVars (CPSInst v _) = [v]
+> contVars CPSReturn = []
+> contVars (CPSCont f ws k) = contFunVars f ++ ws ++ contVars k
 
-> freeVars :: Stmt -> Maybe CPSCont -> [Name]
-> freeVars st k = stmtVars st (maybe [] contVars k)
+> contFunVars :: CPSContFun -> [Name]
+> contFunVars (CPSContFun _ _) = []
+> contFunVars (CPSInst _) = []
+> contFunVars (CPSApply v) = [v]
+> contFunVars CPSUpdate = []
 
 > stmtVars :: Stmt -> [Name] -> [Name]
 > stmtVars (Return e) vs = exprVars e ++ vs
-> stmtVars (Enter v) vs = v : vs
+> stmtVars (Eval v) vs = v : vs
 > stmtVars (Exec _ vs) vs' = vs ++ vs'
 > stmtVars (CCall _ _ cc) vs = ccallVars cc ++ vs
-> stmtVars (Seq st1 st2) vs = stmt0Vars st1 (stmtVars st2 vs)
-> stmtVars (Switch _ v cases) vs = v : concatMap (flip caseVars vs) cases
-> stmtVars (Choices alts) vs = concatMap (flip stmtVars vs) alts
-
-> stmt0Vars :: Stmt0 -> [Name] -> [Name]
-> stmt0Vars (Lock v) vs = v : vs
-> stmt0Vars (Update v1 v2) vs = v1 : v2 : vs
-> stmt0Vars (v :<- st) vs = stmtVars st (filter (v /=) vs)
-> stmt0Vars (Let ds) vs = filter (`notElemSet` bvs) (fvs ++ vs)
+> stmtVars (Seq (v :<- st1) st2) vs =
+>   stmtVars st1 [] ++ filter (v /=) (stmtVars st2 vs)
+> stmtVars (Let ds st) vs = filter (`notElemSet` bvs) (fvs ++ stmtVars st vs)
 >   where bvs = fromListSet [v | Bind v _ <- ds]
 >         fvs = concat [exprVars n | Bind _ n <- ds]
+> stmtVars (Switch _ v cases) vs = v : concatMap caseVars cases ++ vs
+> stmtVars (Choice alts) vs = concatMap (flip stmtVars []) alts ++ vs
 
-> caseVars :: Case -> [Name] -> [Name]
-> caseVars (Case t st) vs =
->   filter (`notElemSet` fromListSet (tagVars t)) (stmtVars st vs)
+> caseVars :: Case -> [Name]
+> caseVars (Case t st) =
+>   filter (`notElemSet` fromListSet (tagVars t)) (stmtVars st [])
 
 > ccallVars :: CCall -> [Name]
 > ccallVars (StaticCall _ xs) = map snd xs
@@ -272,47 +321,32 @@
 > tagVars (ConstrCase _ vs) = vs
 > tagVars DefaultCase = []
 
+> tmp :: Name
+> tmp = Name "_"
+
 \end{verbatim}
-After computing the CPS graph, the CPS functions are linearized in
-ascending order. The code uses the unique identifier in order to avoid
-duplication of shared continuations.
+The function \texttt{continuations} returns all local continuation
+functions defined in a transformed function.
 \begin{verbatim}
 
-> linearize :: CPSFunction -> [CPSFunction]
-> linearize = linearizeFun minBound
+> continuations :: CPSFunction -> [CPSContinuation]
+> continuations (CPSFunction _ _ st) = contsStmt st
+
+> contsCont :: CPSContinuation -> [CPSContinuation]
+> contsCont (CPSContinuation _ _ _ st) = contsStmt st
 
-> linearizeFun :: Int -> CPSFunction -> [CPSFunction]
-> linearizeFun n0 (CPSFunction f n vs ws st)
->   | n > n0 = CPSFunction f n vs ws st : linearizeStmt n st
->   | otherwise = []
-
-> linearizeCont :: Int -> CPSCont -> [CPSFunction]
-> linearizeCont n (CPSCont f) = linearizeFun n f
-> linearizeCont _ (CPSInst _ _) = []
-
-> linearizeStmt :: Int -> CPSStmt -> [CPSFunction]
-> linearizeStmt n (CPSJump k) = linearizeCont n k
-> linearizeStmt _ (CPSReturn _) = []
-> linearizeStmt _ (CPSEnter _) = []
-> linearizeStmt _ (CPSExec _ _) = []
-> linearizeStmt _ (CPSCCall _ _) = []
-> linearizeStmt _ (CPSApply _ _) = []
-> linearizeStmt _ (CPSUnify _ _) = []
-> linearizeStmt _ (CPSDelay _) = []
-> linearizeStmt n (CPSDelayNonLocal _ st) = linearizeStmt n st
-> linearizeStmt n (CPSSeq _ st) = linearizeStmt n st
-> linearizeStmt n (CPSWithCont k st) =
->   linMerge [linearizeCont n k,linearizeStmt n st]
-> linearizeStmt n (CPSSwitch _ _ cases) =
->   linMerge [linearizeStmt n st | CaseBlock _ st <- cases]
-> linearizeStmt n (CPSChoices _ ks) = linMerge (map (linearizeCont n) ks)
-
-> linMerge :: [[CPSFunction]] -> [CPSFunction]
-> linMerge kss = merge (sort kss)
->   where merge [] = []
->         merge [ks] = ks
->         merge ([] : kss) = merge kss
->         merge ((k:ks) : kss) =
->           k : merge (sort (ks : filter ((k /=) . head) kss))
+> contsStmt :: CPSStmt -> [CPSContinuation]
+> contsStmt CPSFail = []
+> contsStmt (CPSExecCont _ _) = []
+> contsStmt (CPSExec _ _ _) = []
+> contsStmt (CPSLet _ st) = contsStmt st
+> contsStmt (CPSLetC _ st) = contsStmt st
+> contsStmt (CPSLetPapp _ st) = contsStmt st
+> contsStmt (CPSLetCont k st) = k : contsCont k ++ contsStmt st
+> contsStmt (CPSSwitch _ _ cases) =
+>   concat [contsStmt st | CaseBlock _ st <- cases]
+> contsStmt (CPSSwitchVar _ st1 st2) = contsStmt st1 ++ contsStmt st2
+> contsStmt (CPSSwitchArity _ sts) = concatMap contsStmt sts
+> contsStmt (CPSChoice _ _) = []
 
 \end{verbatim}
Sottodirectory in comune: curry-0.9.11/curry e curry-0.9.11-classful/curry
diff -u curry-0.9.11/curry.bib curry-0.9.11-classful/curry.bib
--- curry-0.9.11/curry.bib	2007-06-15 14:16:33.000000000 +0200
+++ curry-0.9.11-classful/curry.bib	2013-01-04 10:23:05.000000000 +0100
@@ -9,6 +9,30 @@
   month =	 {January}
 }
 
+@InProceedings{AntoyHanus05:FunctionPattern,
+  author =	 {Sergio Antoy and Michael Hanus},
+  title =	 {Declarative Programming with Function Patterns},
+  booktitle =	 {Proc. LOPSTR 2005},
+  pages =	 {6--22},
+  year =	 2006,
+  editor =	 {Patricia M. Hill},
+  volume =	 3901,
+  series =	 {LNCS},
+  publisher =	 {Springer}
+}
+
+@InProceedings{AntoyHanus06:Overlapping,
+  author =	 {Sergio Antoy and Michael Hanus},
+  title =	 {Overlapping Rules and Logic Variables in Functional Logic Programs},
+  booktitle =	 {Proc. ICLP'06},
+  pages =	 {87--101},
+  year =	 2006,
+  editor =	 {Sandro Etalle and Miroslaw Truszczynski},
+  volume =	 4079,
+  series =	 {LNCS},
+  publisher =	 {Springer}
+}
+
 @Article{Baker95:CheneyMTA,
   author = 	 {Henry G. Baker},
   title = 	 {CONS Should Not CONS Its Arguments, Part II: Cheney on the M.T.A.},
@@ -144,9 +168,9 @@
 
 @Misc{Hanus:Report,
   author =	 {Michael Hanus},
-  title =	 {{Curry}: An Integrated Functional Logic Language (Version 0.8.2)},
-  howpublished = {\url{http://www.informatik.uni-kiel.de/~curry/report.html}},
-  year =	 2006
+  title =	 {{Curry}: An Integrated Functional Logic Language (Version 0.8.3)},
+  howpublished = {\url{http://www-ps.informatik.uni-kiel.de/currywiki/documentation/report}},
+  year =	 2011
 }
 
 @InProceedings{HendersonConwaySomogyi95:Portable,
@@ -198,6 +222,15 @@
   year = 	 1996
 }
 
+@InProceedings{Jones99:THiH,
+  author = 	 {Mark P. Jones},
+  title = 	 {Typing {Haskell} in {Haskell}},
+  booktitle = {Proceedings of the 1999 Haskell Workshop},
+  year = 	 1999,
+  series = 	 {Technical Report UU-CS-1999-28},
+  publisher = {University of Utrecht}
+}
+
 @Article{Jonkers79:Garbage,
   author = 	 {H.B.M. Jonkers},
   title = 	 {A fast garbage compaction algorithm},
@@ -287,6 +320,18 @@
   publisher =	 {Springer}
 }
 
+@InProceedings{PetersonJones93:TypeClasses,
+  author = 	 {John Peterson and Mark P. Jones},
+  title = 	 {Implementing Type Classes},
+  booktitle =	 {Proceedings of the ACM SIGPLAN'93 Conference on Programming Language Design and Implementation},
+  pages = 	 {227--236},
+  year = 	 1993,
+  volume = 	 28,
+  number = 	 6,
+  series = 	 {SIGPLAN Notices},
+  publisher =	 {ACM}
+}
+
 @Book{PeytonJones87:Book,
   author =	 {Simon L. {Peyton Jones}},
   title = 	 {The Implementation of Functional Programmming Languages},
@@ -311,6 +356,13 @@
   year =	 1992
 }
 
+@Book{PeytonJones03:Haskell,
+  editor = 	 {Simon L. Peyton Jones},
+  title = 	 {Haskell 98 Language and Libraries -- The Revised Report},
+  publisher = 	 {Cambridge University Press},
+  year = 	 2003
+}
+
 @Article{SchinzOdersky01:TailCall,
   author = 	 {Michel Schinz and Martin Odersky},
   title = 	 {Tail call eliminiation on the {Java} {Virtual} {Machine}},
diff -u curry-0.9.11/CurryDeps.lhs curry-0.9.11-classful/CurryDeps.lhs
--- curry-0.9.11/CurryDeps.lhs	2007-06-15 14:16:35.000000000 +0200
+++ curry-0.9.11-classful/CurryDeps.lhs	2012-06-05 15:03:15.000000000 +0200
@@ -1,29 +1,29 @@
 % -*- LaTeX -*-
-% $Id: CurryDeps.lhs 2226 2007-06-01 15:58:58Z wlux $
+% $Id: CurryDeps.lhs 3077 2012-06-05 12:53:44Z wlux $
 %
-% Copyright (c) 2002-2007, Wolfgang Lux
+% Copyright (c) 2002-2012, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{CurryDeps.lhs}
-\section{Building Programs}
+\section{Building Programs}\label{sec:dependencies}
 This module implements the functions to compute the dependency
 information between Curry modules. This is used to create Makefile
 dependencies and to update programs composed of multiple modules.
 \begin{verbatim}
 
-> module CurryDeps where
-> import Ident
-> import Unlit
-> import CurrySyntax hiding(Interface(..))
-> import CurryParser(parseHeader)
-> import SCC
+> module CurryDeps(buildScript, makeDepend, findModules) where
+> import Curry hiding(Interface(..))
+> import CurryParser
 > import Env
+> import Error
+> import IO
 > import List
 > import Maybe
 > import Monad
-> import Error
-> import IO
+> import PredefIdent
 > import PathUtils
+> import SCC
+> import Unlit
 
 > data Source = Source FilePath [ModuleIdent]
 >             | Interface FilePath
@@ -39,21 +39,22 @@
 or interface file for each module.
 \begin{verbatim}
 
-> buildScript :: Bool -> Bool -> Bool -> [(Bool,FilePath)] -> Maybe FilePath
->             -> FilePath -> IO [String]
-> buildScript clean debug linkAlways paths target fn =
+> buildScript :: Bool -> Bool -> [(Bool,FilePath)] -> Maybe String
+>             -> Maybe FilePath -> FilePath -> IO [String]
+> buildScript clean debug paths goal output fn =
 >   do
 >     (ms,es) <- fmap (flattenDeps . sortDeps) (deps paths emptyEnv fn)
->     when (null es) (putStr (makeScript clean debug linkAlways outputFile ms))
+>     when (null es) $
+>       maybe putStr writeFile output (makeScript clean debug goal target ms)
 >     return es
->   where outputFile
+>   where target
 >           | extension fn `elem` moduleExts ++ [oExt] = Nothing
->           | otherwise = target `mplus` Just fn
+>           | otherwise = Just fn
 >         makeScript clean = if clean then makeCleanScript else makeBuildScript
 
 > makeDepend :: [(Bool,FilePath)] -> Maybe FilePath -> [FilePath] -> IO ()
-> makeDepend paths target ms =
->   foldM (deps paths) emptyEnv ms >>= maybe putStr writeFile target . makeDeps
+> makeDepend paths output ms =
+>   foldM (deps paths) emptyEnv ms >>= maybe putStr writeFile output . makeDeps
 
 > deps :: [(Bool,FilePath)] -> SourceEnv -> FilePath -> IO SourceEnv
 > deps paths mEnv fn
@@ -71,9 +72,9 @@
 >   where m = mkMIdent [fn]
 
 > findModules :: [(Bool,FilePath)] -> Maybe FilePath -> [FilePath] -> IO ()
-> findModules paths target ms =
+> findModules paths output ms =
 >   mapM (\fn -> liftM ((fn ++ ": ") ++) (findModule paths fn)) ms >>=
->   maybe putStr writeFile target . unlines
+>   maybe putStr writeFile output . unlines
 
 > findModule :: [(Bool,FilePath)] -> FilePath -> IO FilePath
 > findModule paths fn
@@ -149,7 +150,7 @@
 >   | otherwise = id
 
 \end{verbatim}
-It is quite straight forward to generate Makefile dependencies from
+It is quite straightforward to generate Makefile dependencies from
 the dependency environment. In order for these dependencies to work,
 the Makefile must include a rule
 \begin{verbatim}
@@ -165,12 +166,10 @@
 
 > makeDeps :: SourceEnv -> String
 > makeDeps mEnv =
->   unlines (filter (not . null) (map (depsLine . snd) (envToList mEnv)))
->   where depsLine (Source fn ms) =
+>   unlines [depsLine fn ms | Source fn ms <- map snd (envToList mEnv)]
+>   where depsLine fn ms =
 >           objectName False fn ++ ": " ++ fn ++ " " ++
 >           unwords (filter (not . null) (map interf ms))
->         depsLine (Interface _) = []
->         depsLine Unknown = []
 >         interf m = maybe [] interfFile (lookupEnv m mEnv)
 >         interfFile (Source fn _) = interfName fn
 >         interfFile (Interface fn) = fn
@@ -214,31 +213,53 @@
 \end{verbatim}
 The function \texttt{makeBuildScript} returns a shell script that
 rebuilds a program given a sorted list of module informations. The
-script uses the commands \verb|compile| and \verb|link| to build the
-program. They should be defined to reasonable values in the
-environment where the script is executed. The script deliberately uses
-the \verb|-e| shell option so that the script is terminated upon the
-first error.
+generated script uses commands of the form
+\begin{quote}
+  \texttt{compile} $i$ $n$ \emph{source} \emph{interface}
+  \emph{object} \emph{interface$_1$} \dots{} \emph{interface$_k$}
+\end{quote}
+and
+\begin{quote}
+  \texttt{link} $i$ $n$ \emph{target} \emph{module-list}
+  \emph{object$_1$} \dots{} \emph{object$_l$}
+\end{quote}
+where \emph{source} is a source file, \emph{interface} and
+\emph{object} are the interface and object files to be generated,
+\emph{interface$_1$}, \dots, \emph{interface$_k$} are the interface
+files on which \emph{source} depends, \emph{target} is the executable,
+and \emph{object$_1$}, \dots, \emph{object$_l$} are the object files
+to be linked. The \emph{module-list} is equal to
+\texttt{-M}\emph{target} if no explicit goal has been specified on the
+commmand line and equal to \texttt{-M}\emph{module$_1$} \dots{}
+\texttt{-M}\emph{module$_m$}, where \emph{module$_1$}, \dots,
+\emph{module$_m$} are the modules of the program, otherwise. The
+numbers $i$ and $n$ give the index of the current command and the
+total number of commands in the build script, respectively. These
+numbers can be used to provide feedback to the user about the progress
+of building the target. Note that the index of the first command is 1,
+not 0. The number $i$ actually is redundant for a \texttt{link}
+command since it will always be the last command of a build script. Of
+course, the commands \verb|compile| and \verb|link| must be defined in
+the environment where the script is executed.
+
+\ToDo{Provide support for an equivalent of \texttt{make -k}.}
 \begin{verbatim}
 
-> makeBuildScript :: Bool -> Bool -> Maybe FilePath -> [(ModuleIdent,Source)]
->                 -> String
-> makeBuildScript debug linkAlways target mEnv =
->   unlines ("set -e" : concatMap (compCommands . snd) mEnv ++
->            maybe [] linkCommands target)
->   where compCommands (Source fn ms) =
->           [newer ofn (fn : catMaybes (map interf ms)) ++ " || \\",compile fn]
->           where ofn = objectName debug fn
->         compCommands (Interface _) = []
->         compCommands Unknown = []
->         linkCommands fn
->           | linkAlways = [link fn ms os]
->           | otherwise = [newer fn os ++ " || \\", link fn ms os]
->           where ms = catMaybes (map modul mEnv)
->                 os = reverse (catMaybes (map (object . snd) mEnv))
->         newer fn fns = unwords ("$CURRY_PATH/newer" : fn : fns)
->         compile fn = unwords ["compile","-c",fn,"-o",objectName debug fn]
->         link fn ms os = unwords ("link" : "-o" : fn : ms ++ os)
+> makeBuildScript :: Bool -> Maybe String -> Maybe FilePath
+>                 -> [(ModuleIdent,Source)] -> String
+> makeBuildScript debug goal target mEnv = unlines cmds
+>   where n = length cmds
+>         sources = [(fn,ms) | (_,Source fn ms) <- mEnv]
+>         cmds = zipWith compile [1..] sources ++ map link (maybeToList target)
+>         compile i (fn,ms) =
+>           command ("compile" : show i : show n : fn : ifn : ofn : ifns)
+>           where ifn = interfName fn
+>                 ofn = objectName debug fn
+>                 ifns = catMaybes (map interf ms)
+>         link fn = command ("link" : show n : show n : fn : ms ++ os)
+>           where m0 = (undefined,Source fn undefined)
+>                 ms = catMaybes (map modul (maybe [m0] (const mEnv) goal))
+>                 os = reverse (map (objectName debug . fst) sources)
 >         modul (_,Source fn _) = Just ("-M" ++ fn)
 >         modul (m,Interface _) = Just ("-M" ++ moduleName m)
 >         modul (_,Unknown) = Nothing
@@ -248,21 +269,29 @@
 >             Just (Interface fn) -> Just fn
 >             Just Unknown -> Nothing
 >             Nothing -> Nothing
->         object (Source fn _) = Just (objectName debug fn)
->         object (Interface _) = Nothing
->         object Unknown = Nothing
+
+> command :: [String] -> String
+> command = unwords . map quote
+
+> quote :: String -> String
+> quote cs = "'" ++ foldr quoteChar "'" cs
+>   where quoteChar c cs = if c == '\'' then "'\\''" ++ cs else c:cs
 
 \end{verbatim}
 The function \texttt{makeCleanScript} returns a shell script that
-removes all compiled files for a module. The script uses the command
-\verb|remove| to delete the files. It should be defined to a
-reasonable value in the environment where the script is executed.
+removes all compiled files for a module. The generated script consists
+of commands of the form
+\begin{quote}
+  \texttt{remove} \emph{file$_1$} \dots{} \emph{file$_n$}
+\end{quote}
+where the \verb|remove| command must be defined in the environment
+where the script is executed.
 \begin{verbatim}
 
-> makeCleanScript :: Bool -> Bool -> Maybe FilePath -> [(ModuleIdent,Source)]
->                 -> String
+> makeCleanScript :: Bool -> Maybe String -> Maybe FilePath
+>                 -> [(ModuleIdent,Source)] -> String
 > makeCleanScript debug _ target mEnv =
->   unwords ("remove" : foldr (files . snd) (maybeToList target) mEnv)
+>   command ("remove" : foldr (files . snd) (maybeToList target) mEnv)
 >   where d = if debug then 2 else 0
 >         files (Source fn _) fs =
 >           drop d [interfName fn,objectName False fn,objectName True fn] ++ fs
Solo in curry-0.9.11-classful/: curry.htm
diff -u curry-0.9.11/CurryLexer.lhs curry-0.9.11-classful/CurryLexer.lhs
--- curry-0.9.11/CurryLexer.lhs	2007-06-15 14:16:35.000000000 +0200
+++ curry-0.9.11-classful/CurryLexer.lhs	2011-10-08 12:42:57.000000000 +0200
@@ -1,7 +1,7 @@
 % -*- LaTeX -*-
-% $Id: CurryLexer.lhs 2148 2007-04-02 13:56:20Z wlux $
+% $Id: CurryLexer.lhs 3056 2011-10-07 16:27:03Z wlux $
 %
-% Copyright (c) 1999-2007, Wolfgang Lux
+% Copyright (c) 1999-2011, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{CurryLexer.lhs}
@@ -31,7 +31,7 @@
 
 > data Category =
 >   -- literals
->     CharTok | IntTok | FloatTok | StringTok
+>     CharTok | IntTok | RatTok | StringTok
 >   -- identifiers
 >   | Id | QId | Sym | QSym
 >   -- punctuation symbols
@@ -40,24 +40,28 @@
 >   -- virtual punctation (inserted by layout)
 >   | VSemicolon | VRightBrace
 >   -- reserved identifiers
->   | KW_case | KW_data | KW_do | KW_else | KW_foreign | KW_free | KW_if
->   | KW_import | KW_in | KW_infix | KW_infixl | KW_infixr | KW_let
->   | KW_module | KW_newtype | KW_of | KW_then | KW_type | KW_where
+>   | KW_case | KW_class | KW_data | KW_default | KW_deriving | KW_do
+>   | KW_else | KW_fcase | KW_foreign | KW_free | KW_if | KW_import | KW_in
+>   | KW_infix | KW_infixl | KW_infixr | KW_instance | KW_let | KW_module
+>   | KW_newtype | KW_of | KW_then | KW_type | KW_where
 >   -- reserved operators
 >   | At | Colon | DotDot | DoubleColon | Equals | Backslash | Bar
->   | LeftArrow | RightArrow | Tilde
+>   | LeftArrow | RightArrow | DoubleRightArrow | Tilde
 >   -- special identifiers
 >   | Id_as | Id_ccall | Id_forall | Id_hiding | Id_interface
 >   | Id_primitive | Id_qualified | Id_rawcall | Id_safe | Id_unsafe
 >   -- pragmas
 >   | PragmaBegin Pragma | PragmaEnd
 >   -- special operators
->   | Sym_Dot | Sym_Minus | Sym_MinusDot
+>   | Sym_Dot | Sym_Minus | Sym_Star
 >   -- end-of-file token
 >   | EOF
 >   deriving (Eq,Ord)
 
-> data Pragma = ArityPragma | SuspectPragma | TrustPragma deriving (Eq,Ord)
+> data Pragma =
+>     ArityPragma | ClassPragma | DataPragma | HidingPragma | ModulePragma
+>   | SuspectPragma | TrustPragma
+>   deriving (Eq,Ord)
 
 \end{verbatim}
 There are different kinds of attributes associated with tokens.
@@ -71,8 +75,8 @@
 > data Attributes =
 >     NoAttributes
 >   | CharAttributes{ cval :: Char }
->   | IntAttributes{ ival :: Int }
->   | FloatAttributes{ fval :: Double }
+>   | IntAttributes{ ival :: Integer }
+>   | RatAttributes{ rval :: Rational }
 >   | StringAttributes{ sval :: String }
 >   | IdentAttributes{ modul :: [String], sval :: String }
 
@@ -80,7 +84,7 @@
 >   showsPrec _ NoAttributes = showChar '_'
 >   showsPrec _ (CharAttributes cval) = shows cval
 >   showsPrec _ (IntAttributes ival) = shows ival
->   showsPrec _ (FloatAttributes fval) = shows fval
+>   showsPrec _ (RatAttributes rval) = shows rval
 >   showsPrec _ (StringAttributes sval) = shows sval
 >   showsPrec _ (IdentAttributes mIdent ident) =
 >     showString ("`" ++ concat (intersperse "." (mIdent ++ [ident])) ++ "'")
@@ -99,13 +103,13 @@
 > charTok :: Char -> Token
 > charTok c = Token CharTok CharAttributes{ cval = c }
 
-> intTok :: Int -> String -> Token
+> intTok :: Integer -> String -> Token
 > intTok base digits =
 >   Token IntTok IntAttributes{ ival = convertIntegral base digits }
 
-> floatTok :: String -> String -> Int -> Token
-> floatTok mant frac exp =
->   Token FloatTok FloatAttributes{ fval = convertFloating mant frac exp }
+> ratTok :: String -> String -> Int -> Token
+> ratTok mant frac exp =
+>   Token RatTok RatAttributes{ rval = convertFloat mant frac exp }
 
 > stringTok :: String -> Token
 > stringTok cs = Token StringTok StringAttributes{ sval = cs }
@@ -121,7 +125,7 @@
 >   showsPrec _ (Token Sym a) = showString "operator " . shows a
 >   showsPrec _ (Token QSym a) = showString "qualified operator " . shows a
 >   showsPrec _ (Token IntTok a) = showString "integer " . shows a
->   showsPrec _ (Token FloatTok a) = showString "float " . shows a
+>   showsPrec _ (Token RatTok a) = showString "rational " . shows a
 >   showsPrec _ (Token CharTok a) = showString "character " . shows a
 >   showsPrec _ (Token StringTok a) = showString "string " . shows a
 >   showsPrec _ (Token LeftParen _) = showString "`('"
@@ -147,14 +151,19 @@
 >   showsPrec _ (Token Bar _) = showString "`|'"
 >   showsPrec _ (Token LeftArrow _) = showString "`<-'"
 >   showsPrec _ (Token RightArrow _) = showString "`->'"
+>   showsPrec _ (Token DoubleRightArrow _) = showString "`=>'"
 >   showsPrec _ (Token Tilde _) = showString "`~'"
 >   showsPrec _ (Token Sym_Dot _) = showString "operator `.'"
 >   showsPrec _ (Token Sym_Minus _) = showString "operator `-'"
->   showsPrec _ (Token Sym_MinusDot _) = showString "operator `-.'"
+>   showsPrec _ (Token Sym_Star _) = showString "operator `*'"
 >   showsPrec _ (Token KW_case _) = showString "`case'"
+>   showsPrec _ (Token KW_class _) = showString "`class'"
 >   showsPrec _ (Token KW_data _) = showString "`data'"
+>   showsPrec _ (Token KW_default _) = showString "`default'"
+>   showsPrec _ (Token KW_deriving _) = showString "`deriving'"
 >   showsPrec _ (Token KW_do _) = showString "`do'"
 >   showsPrec _ (Token KW_else _) = showString "`else'"
+>   showsPrec _ (Token KW_fcase _) = showString "`fcase'"
 >   showsPrec _ (Token KW_foreign _) = showString "`foreign'"
 >   showsPrec _ (Token KW_free _) = showString "`free'"
 >   showsPrec _ (Token KW_if _) = showString "`if'"
@@ -163,6 +172,7 @@
 >   showsPrec _ (Token KW_infix _) = showString "`infix'"
 >   showsPrec _ (Token KW_infixl _) = showString "`infixl'"
 >   showsPrec _ (Token KW_infixr _) = showString "`infixr'"
+>   showsPrec _ (Token KW_instance _) = showString "`instance'"
 >   showsPrec _ (Token KW_let _) = showString "`let'"
 >   showsPrec _ (Token KW_module _) = showString "`module'"
 >   showsPrec _ (Token KW_newtype _) = showString "`newtype'"
@@ -187,6 +197,10 @@
 
 > instance Show Pragma where
 >   showsPrec _ ArityPragma = showString "ARITY"
+>   showsPrec _ ClassPragma = showString "CLASS"
+>   showsPrec _ DataPragma = showString "DATA"
+>   showsPrec _ HidingPragma = showString "HIDING"
+>   showsPrec _ ModulePragma = showString "MODULE"
 >   showsPrec _ SuspectPragma = showString "SUSPECT"
 >   showsPrec _ TrustPragma = showString "TRUST"
 
@@ -206,35 +220,41 @@
 >     ("|",  Bar),
 >     ("<-", LeftArrow),
 >     ("->", RightArrow),
+>     ("=>", DoubleRightArrow),
 >     ("~",  Tilde)
 >   ]
 > reserved_and_special_ops = foldr (uncurry addToFM) reserved_ops [
 >     (".",  Sym_Dot),
 >     ("-",  Sym_Minus),
->     ("-.", Sym_MinusDot)
+>     ("*",  Sym_Star)
 >   ]
 
 > reserved_ids, reserved_and_special_ids :: FM String Category
 > reserved_ids = fromListFM [
->     ("case",    KW_case),
->     ("data",    KW_data),
->     ("do",      KW_do),
->     ("else",    KW_else),
->     ("foreign", KW_foreign),
->     ("free",    KW_free),
->     ("if",      KW_if),
->     ("import",  KW_import),
->     ("in",      KW_in),
->     ("infix",   KW_infix),
->     ("infixl",  KW_infixl),
->     ("infixr",  KW_infixr),
->     ("let",     KW_let),
->     ("module",  KW_module),
->     ("newtype", KW_newtype),
->     ("of",      KW_of),
->     ("then",    KW_then),
->     ("type",    KW_type),
->     ("where",   KW_where)
+>     ("case",     KW_case),
+>     ("class",    KW_class),
+>     ("data",     KW_data),
+>     ("default",  KW_default),
+>     ("deriving", KW_deriving),
+>     ("do",       KW_do),
+>     ("else",     KW_else),
+>     ("fcase",    KW_fcase),
+>     ("foreign",  KW_foreign),
+>     ("free",     KW_free),
+>     ("if",       KW_if),
+>     ("import",   KW_import),
+>     ("in",       KW_in),
+>     ("infix",    KW_infix),
+>     ("infixl",   KW_infixl),
+>     ("infixr",   KW_infixr),
+>     ("instance", KW_instance),
+>     ("let",      KW_let),
+>     ("module",   KW_module),
+>     ("newtype",  KW_newtype),
+>     ("of",       KW_of),
+>     ("then",     KW_then),
+>     ("type",     KW_type),
+>     ("where",    KW_where)
 >   ]
 > reserved_and_special_ids = foldr (uncurry addToFM) reserved_ids [
 >     ("as",        Id_as),
@@ -252,6 +272,10 @@
 > pragma_keywords :: FM String Pragma
 > pragma_keywords = fromListFM [
 >     ("ARITY",   ArityPragma),
+>     ("CLASS",   ClassPragma),
+>     ("DATA",    DataPragma),
+>     ("HIDING",  HidingPragma),
+>     ("MODULE",  ModulePragma),
 >     ("SUSPECT", SuspectPragma),
 >     ("TRUST",   TrustPragma)
 >   ]
@@ -430,13 +454,13 @@
 >   | c `elem` "oO" = lexNonDecimal 8 isOctit cont nullCont (incr p 2) cs
 >   | c `elem` "xX" = lexNonDecimal 16 isHexit cont nullCont (incr p 2) cs
 >   where nullCont _ _ = cont (intTok 10 "0") (next p) (c:cs)
-> lexNumber cont p cs = lexOptFraction float int p' rest
+> lexNumber cont p cs = lexOptFraction rat int p' rest
 >   where p' = incr p (length digits)
 >         (digits,rest) = span isDigit cs
 >         int _ _ = cont (intTok 10 digits) p' rest
->         float frac exp = cont (floatTok digits frac exp)
+>         rat frac exp = cont (ratTok digits frac exp)
 
-> lexNonDecimal :: Int -> (Char -> Bool) -> (Token -> L a) -> L a -> L a
+> lexNonDecimal :: Integer -> (Char -> Bool) -> (Token -> L a) -> L a -> L a
 > lexNonDecimal base isDigit cont nullCont p cs
 >   | null digits = nullCont p cs
 >   | otherwise = cont (intTok base digits) (incr p (length digits)) rest
Solo in curry-0.9.11-classful/: Curry.lhs
diff -u curry-0.9.11/CurryParser.lhs curry-0.9.11-classful/CurryParser.lhs
--- curry-0.9.11/CurryParser.lhs	2007-06-15 14:16:35.000000000 +0200
+++ curry-0.9.11-classful/CurryParser.lhs	2011-10-08 12:42:57.000000000 +0200
@@ -1,7 +1,7 @@
 % -*- LaTeX -*-
-% $Id: CurryParser.lhs 2235 2007-06-08 10:12:15Z wlux $
+% $Id: CurryParser.lhs 3056 2011-10-07 16:27:03Z wlux $
 %
-% Copyright (c) 1999-2007, Wolfgang Lux
+% Copyright (c) 1999-2011, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{CurryParser.lhs}
@@ -10,15 +10,14 @@
 combinators described in appendix~\ref{sec:ll-parsecomb}.
 \begin{verbatim}
 
-> module CurryParser where
-> import Ident
-> import Position
+> module CurryParser(parseSource, parseHeader, parseInterface, parseGoal) where
 > import Error
 > import LexComb
 > import LLParseComb
-> import CurrySyntax
+> import Curry
 > import CurryLexer
 > import PathUtils
+> import PredefIdent
 
 > instance Symbol Token where
 >   isEOF (Token c _) = c == EOF
@@ -27,22 +26,24 @@
 \paragraph{Modules}
 \begin{verbatim}
 
-> parseSource :: FilePath -> String -> Error Module
+> parseSource :: FilePath -> String -> Error (Module ())
 > parseSource fn = applyParser (parseModule fn) lexer fn
 
-> parseHeader :: FilePath -> String -> Error Module
+> parseHeader :: FilePath -> String -> Error (Module ())
 > parseHeader fn = prefixParser (moduleHeader fn <*->
->                                (leftBrace `opt` NoAttributes) <*>
->                                many (importDecl <*-> many semicolon) <*>
+>                                (leftBrace <|> layoutOn) <*>
+>                                importDecls <*>
 >                                succeed [])
 >                               lexer
 >                               fn
+>   where importDecls = (:) <$> importDecl <*> importDecls' `opt` []
+>         importDecls' = semicolon <-*> importDecls `opt` []
 
-> parseModule :: FilePath -> Parser Token Module a
+> parseModule :: FilePath -> Parser Token (Module ()) a
 > parseModule fn = uncurry <$> moduleHeader fn <*> layout moduleDecls
 
 > moduleHeader :: FilePath
->              -> Parser Token ([ImportDecl] -> [TopDecl] -> Module) a
+>              -> Parser Token ([ImportDecl] -> [TopDecl ()] -> Module ()) a
 > moduleHeader fn = Module <$-> token KW_module
 >                          <*> (mIdent <?> "module name expected")
 >                          <*> option exportSpec
@@ -59,11 +60,11 @@
 >   where spec = ExportTypeAll <$-> token DotDot
 >            <|> flip ExportTypeWith <$> con `sepBy` comma
 
-> moduleDecls :: Parser Token ([ImportDecl],[TopDecl]) a
-> moduleDecls = impDecl <$> importDecl
->                       <*> (semicolon <-*> moduleDecls `opt` ([],[]))
->           <|> (,) [] <$> topDecl `sepBy` semicolon
->   where impDecl i (is,ds) = (i:is,ds)
+> moduleDecls :: Parser Token ([ImportDecl],[TopDecl ()]) a
+> moduleDecls = imp <$> importDecl <?*> semiBlock moduleDecls ([],[])
+>           <|> top <$> topDecl <*> semiBlock (block topDecl) []
+>   where imp i ~(is,ds) = (i:is,ds)
+>         top d ds = ([],d:ds)
 
 > importDecl :: Parser Token ImportDecl a
 > importDecl =
@@ -109,10 +110,10 @@
 >                  <?> "module name expected"
 
 > intfDecls :: Parser Token ([IImportDecl],[IDecl]) a
-> intfDecls = impDecl <$> iImportDecl
->                     <*> (semicolon <-*> intfDecls `opt` ([],[]))
->         <|> (,) [] <$> intfDecl `sepBy` semicolon
->   where impDecl i (is,ds) = (i:is,ds)
+> intfDecls = imp <$> iImportDecl <?*> semiBlock intfDecls ([],[])
+>         <|> intf <$> intfDecl <*> semiBlock (block intfDecl) []
+>   where imp i ~(is,ds) = (i:is,ds)
+>         intf d ds = ([],d:ds)
 
 > iImportDecl :: Parser Token IImportDecl a
 > iImportDecl = IImportDecl <$> position <*-> token KW_import <*> mIdent
@@ -121,108 +122,176 @@
 \paragraph{Goals}
 \begin{verbatim}
 
-> parseGoal :: String -> Error Goal
+> parseGoal :: String -> Error (Goal ())
 > parseGoal s = applyParser goal lexer "" s
 
-> goal :: Parser Token Goal a
-> goal = Goal <$> position <*> expr <*> localDefs
+> goal :: Parser Token (Goal ()) a
+> goal = Goal <$> position <*> expr <*> whereClause localDecl
 
 \end{verbatim}
 \paragraph{Declarations}
 \begin{verbatim}
 
-> topDecl :: Parser Token TopDecl a
-> topDecl = dataDecl <|> newtypeDecl <|> typeDecl <|> BlockDecl <$> blockDecl
->   where blockDecl = infixDecl <|> functionDecl <|> foreignDecl
+> topDecl :: Parser Token (TopDecl ()) a
+> topDecl = dataDecl <|> newtypeDecl <|> typeDecl
+>       <|> classDecl <|> instanceDecl <|> defaultDecl
+>       <|> BlockDecl <$> blockDecl
+>   where blockDecl = infixDecl <|> typeSig <|?> functionDecl <|> foreignDecl
 >                 <|> trustAnnotation
 
-> localDefs :: Parser Token [Decl] a
-> localDefs = token KW_where <-*> layout valueDecls
->       `opt` []
-
-> valueDecls :: Parser Token [Decl] a
-> valueDecls = localDecl `sepBy` semicolon
->   where localDecl = infixDecl <|> valueDecl <|> foreignDecl
->                 <|> trustAnnotation
+> whereClause :: Parser Token a b -> Parser Token [a] b
+> whereClause d = token KW_where <-*> layout (block d)
+>           `opt` []
+
+> localDecls :: Parser Token [Decl ()] a
+> localDecls = layout (block localDecl)
+
+> localDecl :: Parser Token (Decl ()) a
+> localDecl = infixDecl <|> typeSig <|?> valueDecl <|?> freeDecl <|> foreignDecl
+>         <|> trustAnnotation
 
-> dataDecl :: Parser Token TopDecl a
-> dataDecl = typeDeclLhs DataDecl KW_data <*> constrs
+> dataDecl :: Parser Token (TopDecl ()) a
+> dataDecl = dataDeclLhs DataDecl KW_data <*> constrs <*> deriv
 >   where constrs = equals <-*> constrDecl `sepBy1` bar
 >             `opt` []
 
-> newtypeDecl :: Parser Token TopDecl a
-> newtypeDecl = typeDeclLhs NewtypeDecl KW_newtype <*-> equals <*> newConstrDecl
-
-> typeDecl :: Parser Token TopDecl a
-> typeDecl = typeDeclLhs TypeDecl KW_type <*-> equals <*> type0
-
-> typeDeclLhs :: (Position -> Ident -> [Ident] -> a) -> Category
->             -> Parser Token a b
-> typeDeclLhs f kw = f <$> position <*-> token kw <*> tycon <*> many typeVar
+> newtypeDecl :: Parser Token (TopDecl ()) a
+> newtypeDecl =
+>   dataDeclLhs NewtypeDecl KW_newtype <*-> equals <*> newConstrDecl <*> deriv
+
+> typeDecl :: Parser Token (TopDecl ()) a
+> typeDecl = typeDeclLhs (uncurry . TypeDecl) KW_type id <*-> equals <*> type0
+
+> dataDeclLhs :: (Position -> [ClassAssert] -> Ident -> [Ident] -> a)
+>             -> Category -> Parser Token a b
+> dataDeclLhs f kw = typeDeclLhs f' kw (withContext (,))
+>   where f' p = uncurry (uncurry . f p)
+
+> typeDeclLhs :: (Position -> a -> b) -> Category
+>             -> (Parser Token (Ident,[Ident]) c -> Parser Token a c)
+>             -> Parser Token b c
+> typeDeclLhs f kw g =
+>   f <$> position <*-> token kw <*> g ((,) <$> gtycon <*> many typeVar)
 >   where typeVar = tyvar <|> anonId <$-> token Underscore
+>         gtycon = tycon <|> ptycon
+
+> ptycon :: Parser Token Ident a
+> ptycon = brackets (succeed listId) <|> parens (rightArrow <|> tupleCommas)
 
 > constrDecl :: Parser Token ConstrDecl a
-> constrDecl = position <**> (existVars <**> constr)
+> constrDecl = position <**> (existVars <**> withContext (flip ($)) constr)
 >   where existVars = token Id_forall <-*> many1 tyvar <*-> dot `opt` []
 >         constr = conId <**> identDecl
 >              <|> leftParen <-*> parenDecl
->              <|> type1 <\> conId <\> leftParen <**> opDecl
+>              <|> leftBracket <-*> bracketDecl
+>              <|> type1 <\> conId <\> leftParen <\> leftBracket <**> opDecl
 >         identDecl = many type2 <**> (conType <$> opDecl `opt` conDecl)
->         parenDecl = flip conDecl <$> conSym <*-> rightParen <*> many type2
->                 <|> tupleType <*-> rightParen <**> opDecl
->         opDecl = conOpDecl <$> conop <*> type1
->         conType f tys c = f (ConstructorType (qualify c) tys)
->         conDecl tys c tvs p = ConstrDecl p tvs c tys
->         conOpDecl op ty2 ty1 tvs p = ConOpDecl p tvs ty1 op ty2
+>                 <|> recDecl <$> fields
+>         parenDecl = (conSym <|> colon) <*-> rightParen <**> opSymDecl
+>                 <|> tupleCommas <*-> rightParen <**> identDecl
+>                 <|> applyType <$> parenType <*-> rightParen <*> many type2
+>                               <**> opDecl
+>         bracketDecl = nilId <$-> rightBracket <**> identDecl
+>                   <|> applyType <$> listType <*-> rightBracket <*> many type2
+>                                 <**> opDecl
+>         opSymDecl = conDecl <$> many type2
+>                 <|> recDecl <$> fields
+>         parenType = tupleType <|> ConstructorType . qualify <$> rightArrow
+>         listType = ListType <$> type0
+>         opDecl = conOpDecl <$> (conop <|> colon) <*> type1
+>         fields = braces (fieldDecl `sepBy` comma)
+>         conType f tys c = f (applyType (ConstructorType (qualify c)) tys)
+>         conDecl tys c cx tvs p = ConstrDecl p tvs cx c tys
+>         conOpDecl op ty2 ty1 cx tvs p = ConOpDecl p tvs cx ty1 op ty2
+>         recDecl fs c cx tvs p = RecordDecl p tvs cx c fs
+>         applyType = foldl ApplyType
+
+> fieldDecl :: Parser Token FieldDecl a
+> fieldDecl = FieldDecl <$> position <*> labels <*-> token DoubleColon <*> type0
+>   where labels = fun `sepBy1` comma
 
 > newConstrDecl :: Parser Token NewConstrDecl a
-> newConstrDecl = NewConstrDecl <$> position <*> con <*> type2
-
-> infixDecl :: Parser Token Decl a
-> infixDecl = infixDeclLhs InfixDecl <*> option int <*> funop `sepBy1` comma
+> newConstrDecl = position <**> (con <**> newConstr)
+>   where newConstr = newConDecl <$> type2
+>                 <|> newRecDecl <$> braces newFieldDecl
+>         newConDecl ty c p = NewConstrDecl p c ty
+>         newRecDecl (l,ty) c p = NewRecordDecl p c l ty
+
+> newFieldDecl :: Parser Token (Ident,TypeExpr) a
+> newFieldDecl = (,) <$> fun <*-> token DoubleColon <*> type0
+
+> deriv :: Parser Token [DClass] a
+> deriv = token KW_deriving <-*> classes
+>   `opt` []
+>   where classes = return <$> dclass
+>               <|> parens (dclass `sepBy` comma)
+>         dclass = DClass <$> position <*> qtycls
+
+> classDecl :: Parser Token (TopDecl ()) a
+> classDecl = classInstDecl ClassDecl KW_class tycls tyvar methodDecl
+>   where methodDecl = infixDecl <|> typeSig <|?> functionDecl
+>                  <|> trustAnnotation
+
+> instanceDecl :: Parser Token (TopDecl ()) a
+> instanceDecl = classInstDecl InstanceDecl KW_instance qtycls type2 methodDecl
+>   where methodDecl = functionDecl <|> trustAnnotation
+
+> classInstDecl :: (Position -> [ClassAssert] -> a -> b -> [c] -> TopDecl ())
+>               -> Category -> Parser Token a d -> Parser Token b d
+>               -> Parser Token c d -> Parser Token (TopDecl ()) d
+> classInstDecl f kw cls ty d =
+>   f' <$> position <*> classInstHead kw cls ty <*> whereClause d
+>   where f' p = uncurry (uncurry . f p)
+
+> classInstHead :: Category -> Parser Token a c -> Parser Token b c
+>               -> Parser Token ([ClassAssert],(a,b)) c
+> classInstHead kw cls ty = token kw <-*> withContext (,) ((,) <$> cls <*> ty)
+>   -- NB Don't try to ``optimize'' this into withContext (,,) cls <*> ty
+>   --    as this will yield a parse error if the context is omitted
+
+> defaultDecl :: Parser Token (TopDecl ()) a
+> defaultDecl =
+>   DefaultDecl <$> position <*-> token KW_default
+>               <*> parens (type0 `sepBy` comma)
+
+> infixDecl :: Parser Token (Decl ()) a
+> infixDecl =
+>   infixDeclLhs InfixDecl <*> option integer <*> (funop <|> colon) `sepBy1`
+>   comma
 
 > infixDeclLhs :: (Position -> Infix -> a) -> Parser Token a b
 > infixDeclLhs f = f <$> position <*> tokenOps infixKW
 >   where infixKW = [(KW_infix,Infix),(KW_infixl,InfixL),(KW_infixr,InfixR)]
 
-> functionDecl :: Parser Token Decl a
-> functionDecl = position <**> decl
->   where decl = fun `sepBy1` comma <**> funListDecl
->           <|?> funDecl <$> lhs <*> declRhs
->         lhs = (\f -> (f,FunLhs f [])) <$> fun
+> typeSig :: Parser Token (Decl ()) a
+> typeSig =
+>   TypeSig <$> position <*> fun `sepBy1` comma
+>           <*-> token DoubleColon <*> qualType
+
+> functionDecl :: Parser Token (Decl ()) a
+> functionDecl = funDecl <$> position <*> lhs <*> declRhs
+>   where lhs = (\f -> (f,FunLhs f [])) <$> fun
 >          <|?> funLhs
 
-> valueDecl :: Parser Token Decl a
-> valueDecl = position <**> decl
->   where decl = var `sepBy1` comma <**> valListDecl
->           <|?> valDecl <$> constrTerm0 <*> declRhs
->           <|?> funDecl <$> curriedLhs <*> declRhs
->         valDecl (ConstructorPattern c ts)
->           | not (isConstrId c) = funDecl (f,FunLhs f ts)
+> valueDecl :: Parser Token (Decl ()) a
+> valueDecl = valDecl <$> position <*> constrTerm0 <*> declRhs
+>        <|?> funDecl <$> position <*> curriedLhs <*> declRhs
+>   where valDecl p (ConstructorPattern _ c ts)
+>           | not (isConstrId c) = funDecl p (f,FunLhs f ts)
 >           where f = unqualify c
->         valDecl t = opDecl id t
->         opDecl f (InfixPattern t1 op t2)
->           | isConstrId op = opDecl (f . InfixPattern t1 op) t2
->           | otherwise = funDecl (op',OpLhs (f t1) op' t2)
+>         valDecl p t = opDecl p id t
+>         opDecl p f (InfixPattern a1 t1 (InfixConstr a2 op) t2)
+>           | isConstrId op =
+>               opDecl p (f . InfixPattern a1 t1 (InfixConstr a2 op)) t2
+>           | otherwise = funDecl p (op',OpLhs (f t1) op' t2)
 >           where op' = unqualify op
->         opDecl f t = patDecl (f t)
->         isConstrId c = c == qConsId || isQualified c || isQTupleId c
+>         opDecl p f t = PatternDecl p (f t)
+>         isConstrId c = isQualified c || isPrimDataId (unqualify c)
 
-> funDecl :: (Ident,Lhs) -> Rhs -> Position -> Decl
-> funDecl (f,lhs) rhs p = FunctionDecl p f [Equation p lhs rhs]
+> funDecl :: Position -> (Ident,Lhs ()) -> Rhs () -> Decl ()
+> funDecl p (f,lhs) rhs = FunctionDecl p () f [Equation p lhs rhs]
 
-> patDecl :: ConstrTerm -> Rhs -> Position -> Decl
-> patDecl t rhs p = PatternDecl p t rhs
-
-> funListDecl :: Parser Token ([Ident] -> Position -> Decl) a
-> funListDecl = typeSig <$-> token DoubleColon <*> type0
->   where typeSig ty vs p = TypeSig p vs ty
-
-> valListDecl :: Parser Token ([Ident] -> Position -> Decl) a
-> valListDecl = funListDecl
->           <|> flip FreeDecl <$-> token KW_free
-
-> funLhs :: Parser Token (Ident,Lhs) a
+> funLhs :: Parser Token (Ident,Lhs ()) a
 > funLhs = funLhs <$> fun <*> many1 constrTerm2
 >     <|?> flip ($ id) <$> constrTerm1 <*> opLhs'
 >     <|?> curriedLhs
@@ -234,25 +303,30 @@
 >                            <*> opLhs'
 >         funLhs f ts = (f,FunLhs f ts)
 >         opLhs op t2 f t1 = (op,OpLhs (f t1) op t2)
->         infixPat op t2 f g t1 = f (g . InfixPattern t1 op) t2
+>         infixPat op t2 f g t1 =
+>           f (g . InfixPattern () t1 (InfixConstr () op)) t2
 
-> curriedLhs :: Parser Token (Ident,Lhs) a
+> curriedLhs :: Parser Token (Ident,Lhs ()) a
 > curriedLhs = apLhs <$> parens funLhs <*> many1 constrTerm2
 >   where apLhs (f,lhs) ts = (f,ApLhs lhs ts)
 
-> declRhs :: Parser Token Rhs a
+> declRhs :: Parser Token (Rhs ()) a
 > declRhs = rhs equals
 
-> rhs :: Parser Token a b -> Parser Token Rhs b
-> rhs eq = rhsExpr <*> localDefs
+> rhs :: Parser Token a b -> Parser Token (Rhs ()) b
+> rhs eq = rhsExpr <*> whereClause localDecl
 >   where rhsExpr = SimpleRhs <$-> eq <*> position <*> expr
 >               <|> GuardedRhs <$> many1 (condExpr eq)
 
-> foreignDecl :: Parser Token Decl a
+> freeDecl :: Parser Token (Decl ()) a
+> freeDecl = FreeDecl <$> position <*> fvar `sepBy1` comma <*-> token KW_free
+>   where fvar = FreeVar () <$> var
+
+> foreignDecl :: Parser Token (Decl ()) a
 > foreignDecl =
 >   mkDecl <$> position <*-> token KW_foreign <*-> token KW_import
 >          <*> callConv <*> entitySpec <*-> token DoubleColon <*> type0
->   where mkDecl p cc (s,ie,f) ty = ForeignDecl p cc s ie f ty
+>   where mkDecl p cc (s,ie,f) ty = ForeignDecl p (cc,s,ie) () f ty
 >         callConv = CallConvPrimitive <$-> token Id_primitive
 >                <|> CallConvCCall <$-> token Id_ccall
 >                <|> CallConvRawCall <$-> token Id_rawcall
@@ -265,14 +339,14 @@
 >         withSafety s Nothing =  (Nothing,Nothing,mkIdent (sval (snd s)))
 >         withoutSafety (ie,f) = (Nothing,ie,f)
 
-> trustAnnotation :: Parser Token Decl a
+> trustAnnotation :: Parser Token (Decl ()) a
 > trustAnnotation =
 >   TrustAnnot <$> position <*> tokenOps pragmaKW <*> funList
 >              <*-> token PragmaEnd
 >   where pragmaKW = [(PragmaBegin SuspectPragma,Suspect),
 >                     (PragmaBegin TrustPragma,Trust)]
->         funList = Nothing <$-> token Underscore
->               <|> Just <$> fun `sepBy1` comma
+>         funList = fun `sepBy` comma
+>               <|> [] <$-> token Underscore            -- backward compability
 
 \end{verbatim}
 \paragraph{Interface declarations}
@@ -280,56 +354,142 @@
 
 > intfDecl :: Parser Token IDecl a
 > intfDecl = iInfixDecl
->        <|> iHidingDecl <|> iDataDecl <|> iNewtypeDecl <|> iTypeDecl
->        <|> iFunctionDecl <\> token Id_hiding
+>        <|> hidingDataDecl <|> iDataDecl <|> iNewtypeDecl <|> iTypeDecl
+>        <|> hidingClassDecl <|> iClassDecl <|> iInstanceDecl <|> iFunctionDecl
 
 > iInfixDecl :: Parser Token IDecl a
-> iInfixDecl = infixDeclLhs IInfixDecl <*> int <*> qfunop
+> iInfixDecl = infixDeclLhs IInfixDecl <*> integer <*> (qfunop <|> qcolon)
 
-> iHidingDecl :: Parser Token IDecl a
-> iHidingDecl = position <*-> token Id_hiding <**> (dataDecl <|> funcDecl)
->   where dataDecl = hiddenData <$-> token KW_data <*> qtycon <*> many tyvar
->         funcDecl = hidingFunc <$-> token DoubleColon <*> option iFunctionArity
->                               <*> type0
->         hiddenData tc tvs p = HidingDataDecl p tc tvs
->         hidingFunc n ty p = IFunctionDecl p hidingId n ty
->         hidingId = qualify (mkIdent "hiding")
+> hidingDataDecl :: Parser Token IDecl a
+> hidingDataDecl = position <**> pragma DataPragma hidingDecl
+>   where hidingDecl = dataDecl <$> withKind qtycon <*> many tyvar
+>         dataDecl (tc,k) tvs p = HidingDataDecl p tc k tvs
 
 > iDataDecl :: Parser Token IDecl a
-> iDataDecl = iTypeDeclLhs IDataDecl KW_data <*> constrs
->   where constrs = equals <-*> iConstrDecl `sepBy1` bar
+> iDataDecl = iDataDeclLhs IDataDecl KW_data <*> constrs <*> iHidden
+>   where constrs = equals <-*> constrDecl `sepBy1` bar
 >             `opt` []
->         iConstrDecl = Just <$> constrDecl <\> token Underscore
->                   <|> Nothing <$-> token Underscore
 
 > iNewtypeDecl :: Parser Token IDecl a
 > iNewtypeDecl =
->   iTypeDeclLhs INewtypeDecl KW_newtype <*-> equals <*> newConstrDecl
+>   iDataDeclLhs INewtypeDecl KW_newtype <*-> equals <*> newConstrDecl
+>                                        <*> iHidden
 
 > iTypeDecl :: Parser Token IDecl a
-> iTypeDecl = iTypeDeclLhs ITypeDecl KW_type <*-> equals <*> type0
+> iTypeDecl = iTypeDeclLhs typeDecl KW_type id <*-> equals <*> type0
+>   where typeDecl = uncurry . uncurry . ITypeDecl
 
-> iTypeDeclLhs :: (Position -> QualIdent -> [Ident] -> a) -> Category
->              -> Parser Token a b
-> iTypeDeclLhs f kw = f <$> position <*-> token kw <*> qtycon <*> many tyvar
+> iDataDeclLhs :: (Position -> [ClassAssert] -> QualIdent -> Maybe KindExpr
+>                  -> [Ident] -> a)
+>              -> Category -> Parser Token a b
+> iDataDeclLhs f kw = iTypeDeclLhs f' kw (withContext (,))
+>   where f' p = uncurry (uncurry . uncurry . f p)
+
+> iTypeDeclLhs :: (Position -> a -> b) -> Category
+>              -> (Parser Token ((QualIdent,Maybe KindExpr),[Ident]) c
+>                  -> Parser Token a c)
+>              -> Parser Token b c
+> iTypeDeclLhs f kw g =
+>   f <$> position <*-> token kw <*> g ((,) <$> withKind gtycon <*> many tyvar)
+>   where gtycon = qtycon <|> qualify <$> ptycon
+
+> iHidden :: Parser Token [Ident] a
+> iHidden = pragma HidingPragma (con `sepBy` comma)
+>     `opt` []
+
+> hidingClassDecl :: Parser Token IDecl a
+> hidingClassDecl = position <**> pragma ClassPragma hidingDecl
+>   where hidingDecl = withContext classDecl ((,) <$> withKind qtycls <*> tyvar)
+>         classDecl cx ((cls,k),tv) p = HidingClassDecl p cx cls k tv
+
+> iClassDecl :: Parser Token IDecl a
+> iClassDecl =
+>   iClassInstDecl classDecl KW_class (withKind qtycls) tyvar <*> methodDefs
+>   where classDecl p cx (cls,k) = uncurry . IClassDecl p cx cls k
+>         methodDefs = token KW_where <-*> braces methodDecls
+>                `opt` ([],[])
+>         methodDecls = meth <$> iMethodDecl <?*> semiBlock methodDecls ([],[])
+>                   <|> flip (,) <$> pragma HidingPragma (con `sepBy` comma)
+>                                <*> semiBlock (block iMethodDecl) []
+>         meth d ~(ds,fs) = (d:ds,fs)
+
+> iInstanceDecl :: Parser Token IDecl a
+> iInstanceDecl =
+>   uncurry <$> iClassInstDecl IInstanceDecl KW_instance qtycls type2
+>           <*> pragmas
+>   where pragmas = ((,) . Just <$> iInstModule <*> (iInstArity `opt` [])
+>               <|> flip (,) <$> iInstArity <*> option iInstModule
+>             `opt` (Nothing,[]))
+>         iInstModule = pragma ModulePragma mIdent
+>         iInstArity = pragma ArityPragma (many ((,) <$> fun <*> integer))
+
+> iClassInstDecl :: (Position -> [ClassAssert] -> a -> b -> c) -> Category
+>                -> Parser Token a d -> Parser Token b d -> Parser Token c d
+> iClassInstDecl f kw cls ty = f' <$> position <*> classInstHead kw cls ty
+>   where f' p = uncurry (uncurry . f p)
 
 > iFunctionDecl :: Parser Token IDecl a
-> iFunctionDecl = IFunctionDecl <$> position <*> qfun <*-> token DoubleColon
->                               <*> option iFunctionArity <*> type0
+> iFunctionDecl = iFunDecl IFunctionDecl qfun
+
+> iMethodDecl :: Parser Token IMethodDecl a
+> iMethodDecl = iFunDecl IMethodDecl fun
+
+> iFunDecl :: (Position -> a -> Maybe Integer -> QualTypeExpr -> b)
+>          -> Parser Token a c -> Parser Token b c
+> iFunDecl f fun =
+>   f <$> position <*> fun <*-> token DoubleColon
+>     <*> option iFunctionArity <*> qualType
 
-> iFunctionArity :: Parser Token Int a
-> iFunctionArity = token (PragmaBegin ArityPragma) <-*> int <*-> token PragmaEnd
+> iFunctionArity :: Parser Token Integer a
+> iFunctionArity = pragma ArityPragma integer
+
+> pragma :: Pragma -> Parser Token a b -> Parser Token a b
+> pragma kw p = token (PragmaBegin kw) <-*> p <*-> token PragmaEnd
+
+\end{verbatim}
+\paragraph{Kinds}
+\begin{verbatim}
+
+> withKind :: Parser Token a b -> Parser Token (a,Maybe KindExpr) b
+> withKind p = implicitKind <$> p
+>         <|?> parens (explicitKind <$> p <*-> token DoubleColon <*> kind0)
+>   where implicitKind x = (x,Nothing)
+>         explicitKind x k = (x,Just k)
+
+> kind0 :: Parser Token KindExpr a
+> kind0 = kind1 `chainr1` (ArrowKind <$-> token RightArrow)
+
+> kind1 :: Parser Token KindExpr a
+> kind1 = Star <$-> token Sym_Star
+>     <|> parens kind0
 
 \end{verbatim}
 \paragraph{Types}
 \begin{verbatim}
 
+> qualType :: Parser Token QualTypeExpr a
+> qualType = withContext QualTypeExpr type0
+
+> withContext :: ([ClassAssert] -> a -> b) -> Parser Token a c
+>             -> Parser Token b c
+> withContext f p = f <$> context <*-> token DoubleRightArrow <*> p
+>              <|?> f [] <$> p
+
+> context :: Parser Token [ClassAssert] a
+> context = return <$> classAssert
+>       <|> parens (classAssert `sepBy` comma)
+
+> classAssert :: Parser Token ClassAssert a
+> classAssert = ClassAssert <$> qtycls <*> classType
+>   where classType = VariableType <$> tyvar
+>                 <|> parens (applyTypeVar <$> tyvar <*> many1 type2)
+>         applyTypeVar = foldl ApplyType . VariableType
+
 > type0 :: Parser Token TypeExpr a
 > type0 = type1 `chainr1` (ArrowType <$-> token RightArrow)
 
 > type1 :: Parser Token TypeExpr a
-> type1 = ConstructorType <$> qtycon <*> many type2
->     <|> type2 <\> qtycon
+> type1 = foldl ApplyType <$> type2 <*> many type2
 
 > type2 :: Parser Token TypeExpr a
 > type2 = anonType <|> identType <|> parenType <|> listType
@@ -339,18 +499,21 @@
 
 > identType :: Parser Token TypeExpr a
 > identType = VariableType <$> tyvar
->         <|> flip ConstructorType [] <$> qtycon <\> tyvar
+>         <|> ConstructorType <$> qtycon <\> tyvar
 
 > parenType :: Parser Token TypeExpr a
-> parenType = parens tupleType
+> parenType = parens (tupleType <|> ConstructorType <$> gtyconId)
 
 > tupleType :: Parser Token TypeExpr a
-> tupleType = type0 <??> (tuple <$> many1 (comma <-*> type0))
->       `opt` ConstructorType qUnitId []
+> tupleType = type0 <**?> (tuple <$> many1 (comma <-*> type0))
 >   where tuple tys ty = TupleType (ty:tys)
 
 > listType :: Parser Token TypeExpr a
-> listType = ListType <$> brackets type0
+> listType =
+>   brackets (ListType <$> type0 `opt` ConstructorType (qualify listId))
+
+> gtyconId :: Parser Token QualIdent a
+> gtyconId = qualify <$> (rightArrow <|> tupleCommas)
 
 \end{verbatim}
 \paragraph{Literals}
@@ -358,67 +521,66 @@
 
 > literal :: Parser Token Literal a
 > literal = Char <$> char
->       <|> Int anonId <$> int
->       <|> Float <$> float
+>       <|> Integer <$> integer
+>       <|> Rational <$> rational
 >       <|> String <$> string
 
 \end{verbatim}
 \paragraph{Patterns}
 \begin{verbatim}
 
-> constrTerm0 :: Parser Token ConstrTerm a
-> constrTerm0 = constrTerm1 `chainr1` (flip InfixPattern <$> gconop)
+> constrTerm0 :: Parser Token (ConstrTerm ()) a
+> constrTerm0 = constrTerm1 `chainr1` (infixPat <$> infixCon)
+>   where infixPat op t1 t2 = InfixPattern () t1 op t2
 
-> constrTerm1 :: Parser Token ConstrTerm a
+> constrTerm1 :: Parser Token (ConstrTerm ()) a
 > constrTerm1 = varId <**> identPattern
->           <|> constrPattern (qConId <\> varId)
->           <|> minus <**> negNum
->           <|> fminus <**> negFloat
+>           <|> qConId <\> varId <**> constrPattern
+>           <|> minus <-*> negLit
 >           <|> leftParen <-*> parenPattern
 >           <|> constrTerm2 <\> qConId <\> leftParen
 >   where identPattern = optAsPattern
->                    <|> conPattern <$> many1 constrTerm2
->         constrPattern p = ConstructorPattern <$> p <*> many constrTerm2
->         parenPattern = minus <**> minusPattern negNum
->                    <|> fminus <**> minusPattern negFloat
->                    <|> funSym <\> minus <\> fminus <*-> rightParen
->                                                    <**> identPattern
->                    <|> constrPattern (gconSym <\> funSym <*-> rightParen)
->                    <|> parenTuplePattern <\> minus <\> fminus <*-> rightParen
->         minusPattern p = rightParen <-*> identPattern
->                      <|> parenMinusPattern p <*-> rightParen
->         conPattern ts = flip ConstructorPattern ts . qualify
+>                    <|> conPattern qualify <$> many1 constrTerm2
+>         constrPattern = conPattern id <$> many1 constrTerm2
+>                     <|> optRecPattern
+>         parenPattern = minus <**> minusPattern
+>                    <|> funSym <\> minus <*-> rightParen <**> identPattern
+>                    <|> gconSym <\> funSym <*-> rightParen <**> constrPattern
+>                    <|> parenTuplePattern <\> minus <*-> rightParen
+>         minusPattern = rightParen <-*> identPattern
+>                    <|> parenMinusPattern <*-> rightParen
+>         conPattern f ts c = ConstructorPattern () (f c) ts
 
-> constrTerm2 :: Parser Token ConstrTerm a
+> constrTerm2 :: Parser Token (ConstrTerm ()) a
 > constrTerm2 = literalPattern <|> anonPattern <|> identPattern
 >           <|> parenPattern <|> listPattern <|> lazyPattern
 
-> literalPattern :: Parser Token ConstrTerm a
-> literalPattern = LiteralPattern <$> literal
+> infixCon :: Parser Token (InfixOp ()) a
+> infixCon = InfixConstr () <$> gconop
+
+> literalPattern :: Parser Token (ConstrTerm ()) a
+> literalPattern = LiteralPattern () <$> literal
 
-> anonPattern :: Parser Token ConstrTerm a
-> anonPattern = VariablePattern anonId <$-> token Underscore
+> anonPattern :: Parser Token (ConstrTerm ()) a
+> anonPattern = VariablePattern () anonId <$-> token Underscore
 
-> identPattern :: Parser Token ConstrTerm a
+> identPattern :: Parser Token (ConstrTerm ()) a
 > identPattern = varId <**> optAsPattern
->            <|> flip ConstructorPattern [] <$> qConId <\> varId
+>            <|> qConId <\> varId <**> optRecPattern
 
-> parenPattern :: Parser Token ConstrTerm a
+> parenPattern :: Parser Token (ConstrTerm ()) a
 > parenPattern = leftParen <-*> parenPattern
->   where parenPattern = minus <**> minusPattern negNum
->                    <|> fminus <**> minusPattern negFloat
->                    <|> funSym <\> minus <\> fminus <*-> rightParen
->                                                    <**> optAsPattern
->                    <|> flip ConstructorPattern [] <$> (gconSym <\> funSym)
->                                                   <*-> rightParen
->                    <|> parenTuplePattern <\> minus <\> fminus <*-> rightParen
->         minusPattern p = rightParen <-*> optAsPattern
->                      <|> parenMinusPattern p <*-> rightParen
+>   where parenPattern = minus <**> minusPattern
+>                    <|> funSym <\> minus <*-> rightParen <**> optAsPattern
+>                    <|> (gconSym <\> funSym) <*-> rightParen <**> optRecPattern
+>                    <|> parenTuplePattern <\> minus <*-> rightParen
+>         minusPattern = rightParen <-*> optAsPattern
+>                    <|> parenMinusPattern <*-> rightParen
 
-> listPattern :: Parser Token ConstrTerm a
-> listPattern = ListPattern <$> brackets (constrTerm0 `sepBy` comma)
+> listPattern :: Parser Token (ConstrTerm ()) a
+> listPattern = ListPattern () <$> brackets (constrTerm0 `sepBy` comma)
 
-> lazyPattern :: Parser Token ConstrTerm a
+> lazyPattern :: Parser Token (ConstrTerm ()) a
 > lazyPattern = LazyPattern <$-> token Tilde <*> constrTerm2
 
 \end{verbatim}
@@ -427,138 +589,165 @@
 \begin{verbatim}
 
 > gconSym :: Parser Token QualIdent a
-> gconSym = gConSym <|> tupleCommas
+> gconSym = gConSym <|> qualify <$> tupleCommas
 
-> negNum,negFloat :: Parser Token (Ident -> ConstrTerm) a
-> negNum = flip NegativePattern <$> (Int anonId <$> int <|> Float <$> float)
-> negFloat = flip NegativePattern . Float <$> (fromIntegral <$> int <|> float)
+> negLit :: Parser Token (ConstrTerm ()) a
+> negLit =
+>   NegativePattern () <$> (Integer <$> integer <|> Rational <$> rational)
 
-> optAsPattern :: Parser Token (Ident -> ConstrTerm) a
+> optAsPattern :: Parser Token (Ident -> ConstrTerm ()) a
 > optAsPattern = flip AsPattern <$-> token At <*> constrTerm2
->          `opt` VariablePattern
+>            <|> flip (RecordPattern () . qualify) <$> fields constrTerm0
+>          `opt` VariablePattern ()
 
-> optInfixPattern :: Parser Token (ConstrTerm -> ConstrTerm) a
-> optInfixPattern = infixPat <$> gconop <*> constrTerm0
+> optRecPattern :: Parser Token (QualIdent -> ConstrTerm ()) a
+> optRecPattern = recPattern <$> fields constrTerm0
+>           `opt` conPattern
+>   where conPattern c = ConstructorPattern () c []
+>         recPattern fs c = RecordPattern () c fs
+
+> optInfixPattern :: Parser Token (ConstrTerm () -> ConstrTerm ()) a
+> optInfixPattern = infixPat <$> infixCon <*> constrTerm0
 >             `opt` id
->   where infixPat op t2 t1 = InfixPattern t1 op t2
+>   where infixPat op t2 t1 = InfixPattern () t1 op t2
 
-> optTuplePattern :: Parser Token (ConstrTerm -> ConstrTerm) a
+> optTuplePattern :: Parser Token (ConstrTerm () -> ConstrTerm ()) a
 > optTuplePattern = tuple <$> many1 (comma <-*> constrTerm0)
 >             `opt` ParenPattern
 >   where tuple ts t = TuplePattern (t:ts)
 
-> parenMinusPattern :: Parser Token (Ident -> ConstrTerm) a
->                   -> Parser Token (Ident -> ConstrTerm) a
-> parenMinusPattern p = p <.> optInfixPattern <.> optTuplePattern
+> parenMinusPattern :: Parser Token (Ident -> ConstrTerm ()) a
+> parenMinusPattern = const <$> negLit <.> optInfixPattern <.> optTuplePattern
 
-> parenTuplePattern :: Parser Token ConstrTerm a
+> parenTuplePattern :: Parser Token (ConstrTerm ()) a
 > parenTuplePattern = constrTerm0 <**> optTuplePattern
->               `opt` ConstructorPattern qUnitId []
 
 \end{verbatim}
 \paragraph{Expressions}
 \begin{verbatim}
 
-> condExpr :: Parser Token a b -> Parser Token CondExpr b
+> condExpr :: Parser Token a b -> Parser Token (CondExpr ()) b
 > condExpr eq = CondExpr <$> position <*-> bar <*> expr0 <*-> eq <*> expr
 
-> expr :: Parser Token Expression a
-> expr = expr0 <??> (flip Typed <$-> token DoubleColon <*> type0)
+> expr :: Parser Token (Expression ()) a
+> expr = expr0 <**?> (flip Typed <$-> token DoubleColon <*> qualType)
 
-> expr0 :: Parser Token Expression a
+> expr0 :: Parser Token (Expression ()) a
 > expr0 = expr1 `chainr1` (flip InfixApply <$> infixOp)
 
-> expr1 :: Parser Token Expression a
-> expr1 = UnaryMinus <$> (minus <|> fminus) <*> expr2
+> expr1 :: Parser Token (Expression ()) a
+> expr1 = UnaryMinus <$-> minus <*> expr2
 >     <|> expr2
 
-> expr2 :: Parser Token Expression a
+> expr2 :: Parser Token (Expression ()) a
 > expr2 = lambdaExpr <|> letExpr <|> doExpr <|> ifExpr <|> caseExpr
 >     <|> foldl1 Apply <$> many1 expr3
 
-> expr3 :: Parser Token Expression a
-> expr3 = constant <|> variable <|> parenExpr <|> listExpr
-
-> constant :: Parser Token Expression a
-> constant = Literal <$> literal
-
-> variable :: Parser Token Expression a
-> variable = Variable <$> qFunId
-
-> parenExpr :: Parser Token Expression a
-> parenExpr = parens pExpr
->   where pExpr = (minus <|> fminus) <**> minusOrTuple
->             <|> Constructor <$> tupleCommas
->             <|> leftSectionOrTuple <\> minus <\> fminus
->             <|> opOrRightSection <\> minus <\> fminus
->           `opt` Constructor qUnitId
->         minusOrTuple = flip UnaryMinus <$> expr1 <.> infixOrTuple
->                  `opt` Variable . qualify
+> expr3 :: Parser Token (Expression ()) a
+> expr3 = foldl RecordUpdate <$> expr4 <*> many recUpdate
+>   where recUpdate = braces (field expr0 `sepBy1` comma)
+
+> expr4 :: Parser Token (Expression ()) a
+> expr4 = constant <|> anonVar <|> variable <|> parenExpr <|> listExpr
+
+> constant :: Parser Token (Expression ()) a
+> constant = Literal () <$> literal
+
+> anonVar :: Parser Token (Expression ()) a
+> anonVar = Variable () (qualify anonId) <$-> token Underscore
+
+> variable :: Parser Token (Expression ()) a
+> variable = qFunId <**> optRecord
+>   where optRecord = flip (Record ()) <$> fields expr0
+>               `opt` Variable ()
+
+> parenExpr :: Parser Token (Expression ()) a
+> parenExpr = leftParen <-*> pExpr
+>   where pExpr = minus <**> minusOrTuple
+>             <|> leftSectionOrTuple <\> minus <*-> rightParen
+>             <|> opOrRightSection <\> minus
+>             <|> Constructor () . qualify <$> tupleCommas <*-> rightParen
+>         minusOrTuple = const . UnaryMinus <$> expr1 <.> infixOrTuple
+>                                           <*-> rightParen
+>                    <|> rightParen <-*> optRecord qualify Variable
 >         leftSectionOrTuple = expr1 <**> infixOrTuple
 >         infixOrTuple = ($ id) <$> infixOrTuple'
 >         infixOrTuple' = infixOp <**> leftSectionOrExp
 >                     <|> (.) <$> (optType <.> tupleExpr)
 >         leftSectionOrExp = expr1 <**> (infixApp <$> infixOrTuple')
 >                      `opt` leftSection
->         optType = flip Typed <$-> token DoubleColon <*> type0
+>         optType = flip Typed <$-> token DoubleColon <*> qualType
 >             `opt` id
 >         tupleExpr = tuple <$> many1 (comma <-*> expr)
 >               `opt` Paren
->         opOrRightSection = qFunSym <**> optRightSection
->                        <|> colon <**> optCRightSection
+>         opOrRightSection = qFunSym <**> optRightSection InfixOp Variable
+>                        <|> qcolon <**> optRightSection InfixConstr Constructor
 >                        <|> infixOp <\> colon <\> qFunSym <**> rightSection
->         optRightSection = (. InfixOp) <$> rightSection `opt` Variable
->         optCRightSection = (. InfixConstr) <$> rightSection `opt` Constructor
+>                                                          <*-> rightParen
+>         optRightSection op var = (. op ()) <$> rightSection <*-> rightParen
+>                              <|> rightParen <-*> optRecord id var
 >         rightSection = flip RightSection <$> expr0
+>         optRecord f var = flip (Record () . f) <$> fields expr0
+>                     `opt` var () . f
 >         infixApp f e2 op g e1 = f (g . InfixApply e1 op) e2
 >         leftSection op f e = LeftSection (f e) op
 >         tuple es e = Tuple (e:es)
 
-> infixOp :: Parser Token InfixOp a
-> infixOp = InfixOp <$> qfunop
->       <|> InfixConstr <$> colon
+> infixOp :: Parser Token (InfixOp ()) a
+> infixOp = InfixOp () <$> qfunop
+>       <|> InfixConstr () <$> qcolon
 
-> listExpr :: Parser Token Expression a
-> listExpr = brackets (elements `opt` List [])
+> listExpr :: Parser Token (Expression ()) a
+> listExpr = brackets (elements `opt` List () [])
 >   where elements = expr <**> rest
 >         rest = comprehension
 >            <|> enumeration (flip EnumFromTo) EnumFrom
 >            <|> comma <-*> expr <**>
 >                (enumeration (flip3 EnumFromThenTo) (flip EnumFromThen)
->                <|> (\es e2 e1 -> List (e1:e2:es)) <$> many (comma <-*> expr))
->          `opt` (\e -> List [e])
+>                <|> (\es e2 e1 -> List () (e1:e2:es)) <$>
+>                    many (comma <-*> expr))
+>          `opt` (\e -> List () [e])
 >         comprehension = flip ListCompr <$-> bar <*> quals
 >         enumeration enumTo enum =
 >           token DotDot <-*> (enumTo <$> expr `opt` enum)
 >         flip3 f x y z = f z y x
 
-> lambdaExpr :: Parser Token Expression a
-> lambdaExpr = Lambda <$-> token Backslash <*> many1 constrTerm2
+> lambdaExpr :: Parser Token (Expression ()) a
+> lambdaExpr = Lambda <$> position <*-> token Backslash <*> many1 constrTerm2
 >                     <*-> (token RightArrow <?> "-> expected") <*> expr
 
-> letExpr :: Parser Token Expression a
-> letExpr = Let <$-> token KW_let <*> layout valueDecls
+> letExpr :: Parser Token (Expression ()) a
+> letExpr = Let <$-> token KW_let <*> localDecls
 >               <*-> (token KW_in <?> "in expected") <*> expr
 
-> doExpr :: Parser Token Expression a
+> doExpr :: Parser Token (Expression ()) a
 > doExpr = uncurry Do <$-> token KW_do <*> layout stmts
 
-> ifExpr :: Parser Token Expression a
+> ifExpr :: Parser Token (Expression ()) a
 > ifExpr = IfThenElse <$-> token KW_if <*> expr
 >                     <*-> (token KW_then <?> "then expected") <*> expr
 >                     <*-> (token KW_else <?> "else expected") <*> expr
 
-> caseExpr :: Parser Token Expression a
-> caseExpr = Case <$-> token KW_case <*> expr
->                 <*-> (token KW_of <?> "of expected") <*> layout alts
+> caseExpr :: Parser Token (Expression ()) a
+> caseExpr =
+>   tokenOps caseKW <*> expr <*-> (token KW_of <?> "of expected")
+>                   <*> layout alts
+>   where caseKW = [(KW_case,Case),(KW_fcase,Fcase)]
+
+> alts :: Parser Token [Alt ()] a
+> alts = (:) <$> alt <*> semiBlock (block alt) []
+>    <|> semicolon <-*> alts
 
-> alts :: Parser Token [Alt] a
-> alts = alt `sepBy1` semicolon
-
-> alt :: Parser Token Alt a
+> alt :: Parser Token (Alt ()) a
 > alt = Alt <$> position <*> constrTerm0
 >           <*> rhs (token RightArrow <?> "-> expected")
 
+> fields :: Parser Token a b -> Parser Token [Field a] b
+> fields p = braces (field p `sepBy` comma)
+
+> field :: Parser Token a b -> Parser Token (Field a) b
+> field p = Field <$> qfun <*-> equals <*> p
+
 \end{verbatim}
 \paragraph{Statements in list comprehensions and \texttt{do} expressions}
 Parsing statements is a bit difficult because the syntax of patterns
@@ -570,35 +759,41 @@
 prefix of a let expression.
 \begin{verbatim}
 
-> stmts :: Parser Token ([Statement],Expression) a
+> stmts :: Parser Token ([Statement ()],Expression ()) a
 > stmts = stmt reqStmts optStmts
+>     <|> semicolon <-*> stmts
 
-> reqStmts :: Parser Token (Statement -> ([Statement],Expression)) a
+> reqStmts :: Parser Token (Statement () -> ([Statement ()],Expression ())) a
 > reqStmts = (\(sts,e) st -> (st : sts,e)) <$-> semicolon <*> stmts
 
-> optStmts :: Parser Token (Expression -> ([Statement],Expression)) a
-> optStmts = succeed StmtExpr <.> reqStmts
+> optStmts :: Parser Token (Expression () -> ([Statement ()],Expression ())) a
+> optStmts = semicolon <-*> optStmts'
 >      `opt` (,) []
+> optStmts' = (\(sts,e) st -> (StmtExpr st : sts,e)) <$> stmts
+>       `opt` ((,) [])
 
-> quals :: Parser Token [Statement] a
+> quals :: Parser Token [Statement ()] a
 > quals = stmt (succeed id) (succeed StmtExpr) `sepBy1` comma
 
-> stmt :: Parser Token (Statement -> a) b -> Parser Token (Expression -> a) b
+> stmt :: Parser Token (Statement () -> a) b
+>      -> Parser Token (Expression () -> a) b
 >      -> Parser Token a b
 > stmt stmtCont exprCont = letStmt stmtCont exprCont
 >                      <|> exprOrBindStmt stmtCont exprCont
 
-> letStmt :: Parser Token (Statement -> a) b -> Parser Token (Expression -> a) b
+> letStmt :: Parser Token (Statement () -> a) b
+>         -> Parser Token (Expression () -> a) b
 >         -> Parser Token a b
-> letStmt stmtCont exprCont = token KW_let <-*> layout valueDecls <**> optExpr
+> letStmt stmtCont exprCont = token KW_let <-*> localDecls <**> optExpr
 >   where optExpr = flip Let <$-> token KW_in <*> expr <.> exprCont
 >               <|> succeed StmtDecl <.> stmtCont
 
-> exprOrBindStmt :: Parser Token (Statement -> a) b
->                -> Parser Token (Expression -> a) b
+> exprOrBindStmt :: Parser Token (Statement () -> a) b
+>                -> Parser Token (Expression () -> a) b
 >                -> Parser Token a b
 > exprOrBindStmt stmtCont exprCont =
->        StmtBind <$> constrTerm0 <*-> leftArrow <*> expr <**> stmtCont
+>        StmtBind <$> position <*> constrTerm0 <*-> leftArrow <*> expr
+>                 <**> stmtCont
 >   <|?> expr <\> token KW_let <**> exprCont
 
 \end{verbatim}
@@ -608,21 +803,23 @@
 > char :: Parser Token Char a
 > char = cval <$> token CharTok
 
-> int :: Parser Token Int a
-> int = ival <$> token IntTok
+> integer :: Parser Token Integer a
+> integer = ival <$> token IntTok
 
-> float :: Parser Token Double a
-> float = fval <$> token FloatTok
+> rational :: Parser Token Rational a
+> rational = rval <$> token RatTok
 
 > string :: Parser Token String a
 > string = sval <$> token StringTok
 
-> tycon, tyvar :: Parser Token Ident a
+> tycon, tycls, tyvar :: Parser Token Ident a
 > tycon = conId
+> tycls = conId
 > tyvar = varId
 
-> qtycon :: Parser Token QualIdent a
+> qtycon,qtycls :: Parser Token QualIdent a
 > qtycon = qConId
+> qtycls = qConId
 
 > varId, funId, conId :: Parser Token Ident a
 > varId = ident
@@ -649,7 +846,7 @@
 > qFunSym, qConSym :: Parser Token QualIdent a
 > qFunSym = qSym
 > qConSym = qSym
-> gConSym = qConSym <|> colon
+> gConSym = qConSym <|> qcolon
 
 > qfun, qcon :: Parser Token QualIdent a
 > qfun = qFunId <|> parens (qFunSym <?> "operator symbol expected")
@@ -663,7 +860,7 @@
 > specialIdents, specialSyms :: [Category]
 > specialIdents = [Id_as,Id_ccall,Id_forall,Id_hiding,Id_interface,
 >                  Id_primitive,Id_qualified,Id_rawcall,Id_safe,Id_unsafe]
-> specialSyms = [Sym_Dot,Sym_Minus,Sym_MinusDot]
+> specialSyms = [Sym_Dot,Sym_Minus,Sym_Star]
 
 > ident :: Parser Token Ident a
 > ident = mkIdent . sval <$> tokens (Id : specialIdents)
@@ -683,17 +880,20 @@
 > qSym = qualify <$> sym <|> mkQIdent <$> token QSym
 >   where mkQIdent a = qualifyWith (mkMIdent (modul a)) (mkIdent (sval a))
 
-> colon :: Parser Token QualIdent a
-> colon = qConsId <$-> token Colon
+> colon :: Parser Token Ident a
+> colon = consId <$-> token Colon
+
+> qcolon :: Parser Token QualIdent a
+> qcolon = qualify <$> colon
+
+> rightArrow :: Parser Token Ident a
+> rightArrow = arrowId <$-> token RightArrow
 
 > minus :: Parser Token Ident a
 > minus = minusId <$-> token Sym_Minus
 
-> fminus :: Parser Token Ident a
-> fminus = fminusId <$-> token Sym_MinusDot
-
-> tupleCommas :: Parser Token QualIdent a
-> tupleCommas = qTupleId . (1 + ) . length <$> many1 comma
+> tupleCommas :: Parser Token Ident a
+> tupleCommas = tupleId . (1 + ) . length <$> many1 comma `opt` unitId
 
 \end{verbatim}
 \paragraph{Layout}
@@ -701,9 +901,17 @@
 
 > layout :: Parser Token a b -> Parser Token a b
 > layout p = braces p
->        <|> layoutOn <-*> (p <\> token VRightBrace) <*-> layoutEnd
+>        <|> layoutOn <-*> (p <\> token VRightBrace <\> token VSemicolon)
+>                     <*-> layoutEnd
 >                     <*-> (token VRightBrace `opt` NoAttributes)
 
+> block :: Parser Token a b -> Parser Token [a] b
+> block p = q
+>   where q = (:) <$> p <?*> semiBlock q []
+
+> semiBlock :: Parser Token a b -> a -> Parser Token a b
+> semiBlock ds z = semicolon <-*> ds `opt` z
+
 \end{verbatim}
 \paragraph{More combinators}
 Note that the \texttt{braces} combinator turns off layout processing
diff -u curry-0.9.11/CurryPP.lhs curry-0.9.11-classful/CurryPP.lhs
--- curry-0.9.11/CurryPP.lhs	2007-06-15 14:16:34.000000000 +0200
+++ curry-0.9.11-classful/CurryPP.lhs	2011-10-08 12:42:57.000000000 +0200
@@ -1,7 +1,7 @@
 % -*- LaTeX -*-
-% $Id: CurryPP.lhs 2235 2007-06-08 10:12:15Z wlux $
+% $Id: CurryPP.lhs 3056 2011-10-07 16:27:03Z wlux $
 %
-% Copyright (c) 1999-2007, Wolfgang Lux
+% Copyright (c) 1999-2011, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{CurryPP.lhs}
@@ -12,16 +12,16 @@
 \begin{verbatim}
 
 > module CurryPP(module CurryPP, Doc) where
-> import Ident
-> import CurrySyntax
+> import Curry
 > import Char
+> import PredefIdent
 > import Pretty
 
 \end{verbatim}
 Pretty print a module
 \begin{verbatim}
 
-> ppModule :: Module -> Doc
+> ppModule :: Module a -> Doc
 > ppModule (Module m es is ds) =
 >   vcat (ppModuleHeader m es : map ppImportDecl is ++ map ppTopDecl ds)
 
@@ -62,24 +62,41 @@
 Declarations
 \begin{verbatim}
 
-> ppTopDecl :: TopDecl -> Doc
-> ppTopDecl (DataDecl _ tc tvs cs) =
->   sep (ppTypeDeclLhs "data" tc tvs :
->        map indent (zipWith (<+>) (equals : repeat vbar) (map ppConstr cs)))
-> ppTopDecl (NewtypeDecl _ tc tvs nc) =
->   sep [ppTypeDeclLhs "newtype" tc tvs <+> equals,indent (ppNewConstr nc)]
+> ppTopDecl :: TopDecl a -> Doc
+> ppTopDecl (DataDecl _ cx tc tvs cs clss) =
+>   sep (ppTypeDeclLhs "data" cx tc tvs :
+>        map indent (zipWith (<+>) (equals : repeat vbar) (map ppConstr cs) ++
+>                    [ppDeriving clss]))
+> ppTopDecl (NewtypeDecl _ cx tc tvs nc clss) =
+>   sep (ppTypeDeclLhs "newtype" cx tc tvs <+> equals :
+>        map indent [ppNewConstr nc,ppDeriving clss])
 > ppTopDecl (TypeDecl _ tc tvs ty) =
->   sep [ppTypeDeclLhs "type" tc tvs <+> equals,indent (ppTypeExpr 0 ty)]
+>   sep [ppTypeDeclLhs "type" [] tc tvs <+> equals,indent (ppTypeExpr 0 ty)]
+> ppTopDecl (ClassDecl _ cx cls tv ds) =
+>   ppClassInstDecl (ppClassHead cx (ppIdent cls) tv) (map ppDecl ds)
+> ppTopDecl (InstanceDecl _ cx cls ty ds) =
+>   ppClassInstDecl (ppInstanceHead cx cls ty) (map ppDecl ds)
+> ppTopDecl (DefaultDecl _ tys) =
+>   text "default" <+> parenList (map (ppTypeExpr 0) tys)
 > ppTopDecl (BlockDecl d) = ppDecl d
 
-> ppTypeDeclLhs :: String -> Ident -> [Ident] -> Doc
-> ppTypeDeclLhs kw tc tvs = text kw <+> ppIdent tc <+> hsep (map ppIdent tvs)
+> ppTypeDeclLhs :: String -> [ClassAssert] -> Ident -> [Ident] -> Doc
+> ppTypeDeclLhs kw cx tc tvs =
+>   text kw <+> sep [ppContext cx, ppIdent tc <+> hsep (map ppIdent tvs)]
 
 > ppConstr :: ConstrDecl -> Doc
-> ppConstr (ConstrDecl _ tvs c tys) =
->   sep [ppExistVars tvs,ppIdent c <+> fsep (map (ppTypeExpr 2) tys)]
-> ppConstr (ConOpDecl _ tvs ty1 op ty2) =
->   sep [ppExistVars tvs,ppTypeExpr 1 ty1,ppInfixOp op <+> ppTypeExpr 1 ty2]
+> ppConstr (ConstrDecl _ tvs cx c tys) =
+>   sep [ppExistVars tvs <+> ppContext cx,
+>        ppIdent c <+> fsep (map (ppTypeExpr 2) tys)]
+> ppConstr (ConOpDecl _ tvs cx ty1 op ty2) =
+>   sep [ppExistVars tvs <+> ppContext cx,
+>        ppTypeExpr 1 ty1,ppInfixOp op <+> ppTypeExpr 1 ty2]
+> ppConstr (RecordDecl _ tvs cx c fs) =
+>   sep [ppExistVars tvs <+> ppContext cx,
+>        ppIdent c <+> braces (list (map ppFieldDecl fs))]
+
+> ppFieldDecl :: FieldDecl -> Doc
+> ppFieldDecl (FieldDecl p ls ty) = ppDecl (TypeSig p ls (QualTypeExpr [] ty))
 
 > ppExistVars :: [Ident] -> Doc
 > ppExistVars tvs
@@ -88,55 +105,77 @@
 
 > ppNewConstr :: NewConstrDecl -> Doc
 > ppNewConstr (NewConstrDecl _ c ty) = ppIdent c <+> ppTypeExpr 2 ty
+> ppNewConstr (NewRecordDecl p c l ty) =
+>   ppIdent c <+> braces (ppDecl (TypeSig p [l] (QualTypeExpr [] ty)))
+
+> ppDeriving :: [DClass] -> Doc
+> ppDeriving [] = empty
+> ppDeriving [cls] = text "deriving" <+> ppDClass cls
+> ppDeriving clss = text "deriving" <+> parenList (map ppDClass clss)
+
+> ppDClass :: DClass -> Doc
+> ppDClass (DClass _ cls) = ppQIdent cls
+
+> ppClassHead :: [ClassAssert] -> Doc -> Ident -> Doc
+> ppClassHead cx cls tv = text "class" <+> sep [ppContext cx,cls <+> ppIdent tv]
+
+> ppInstanceHead :: [ClassAssert] -> QualIdent -> TypeExpr -> Doc
+> ppInstanceHead cx cls ty =
+>   text "instance" <+> sep [ppContext cx,ppClassAssert (ClassAssert cls ty)]
+
+> ppClassInstDecl :: Doc -> [Doc] -> Doc
+> ppClassInstDecl head ds
+>   | null ds = head
+>   | otherwise = head <+> text "where" $$ indent (vcat ds)
 
-> ppBlock :: [Decl] -> Doc
+> ppBlock :: [Decl a] -> Doc
 > ppBlock = vcat . map ppDecl
 
-> ppDecl :: Decl -> Doc
+> ppDecl :: Decl a -> Doc
 > ppDecl (InfixDecl _ fix p ops) = ppPrec fix p <+> list (map ppInfixOp ops)
-> ppDecl (TypeSig _ fs ty) = ppIdentList fs <+> text "::" <+> ppTypeExpr 0 ty
-> ppDecl (FunctionDecl _ _ eqs) = vcat (map ppEquation eqs)
-> ppDecl (ForeignDecl p cc s ie f ty) =
->   sep [hsep [text "foreign import",ppCallConv cc,maybePP ppSafety s,
->              maybePP (text . show) ie],
->        indent (ppDecl (TypeSig p [f] ty))]
->   where ppCallConv CallConvPrimitive = text "primitive"
+> ppDecl (TypeSig _ fs ty) = ppIdentList fs <+> text "::" <+> ppQualTypeExpr ty
+> ppDecl (FunctionDecl _ _ _ eqs) = vcat (map ppEquation eqs)
+> ppDecl (ForeignDecl p fi _ f ty) =
+>   sep [text "foreign import" <+> ppForeignImport fi,
+>        indent (ppDecl (TypeSig p [f] (QualTypeExpr [] ty)))]
+>   where ppForeignImport (cc,s,ie) =
+>           ppCallConv cc <+> maybePP ppSafety s <+> maybePP (text . show) ie
+>         ppCallConv CallConvPrimitive = text "primitive"
 >         ppCallConv CallConvCCall = text "ccall"
 >         ppCallConv CallConvRawCall = text "rawcall"
 >         ppSafety Unsafe = text "unsafe"
 >         ppSafety Safe = text "safe"
 > ppDecl (PatternDecl _ t rhs) = ppRule (ppConstrTerm 0 t) equals rhs
-> ppDecl (FreeDecl _ vs) = ppIdentList vs <+> text "free"
-> ppDecl (TrustAnnot _ t fs) =
->   ppPragma (ppTrust t <+> maybe (char '_') ppIdentList fs)
->   where ppTrust Suspect = text "SUSPECT"
->         ppTrust Trust = text "TRUST"
+> ppDecl (FreeDecl _ vs) = ppIdentList [v | FreeVar _ v <- vs] <+> text "free"
+> ppDecl (TrustAnnot _ t fs) = ppPragma (trust t) (ppIdentList fs)
+>   where trust Suspect = "SUSPECT"
+>         trust Trust = "TRUST"
 
-> ppPragma :: Doc -> Doc
-> ppPragma p = text "{-#" <+> p <+> text "#-}"
+> ppPragma :: String -> Doc -> Doc
+> ppPragma kw p = text "{-#" <+> text kw <+> p <+> text "#-}"
 
-> ppPrec :: Infix -> Maybe Int -> Doc
-> ppPrec fix p = ppAssoc fix <+> maybe empty int p
+> ppPrec :: Infix -> Maybe Integer -> Doc
+> ppPrec fix p = ppAssoc fix <+> maybe empty integer p
 >   where ppAssoc InfixL = text "infixl"
 >         ppAssoc InfixR = text "infixr"
 >         ppAssoc Infix = text "infix"
 
-> ppEquation :: Equation -> Doc
+> ppEquation :: Equation a -> Doc
 > ppEquation (Equation _ lhs rhs) = ppRule (ppLhs lhs) equals rhs
 
-> ppLhs :: Lhs -> Doc
+> ppLhs :: Lhs a -> Doc
 > ppLhs (FunLhs f ts) = ppIdent f <+> fsep (map (ppConstrTerm 2) ts)
 > ppLhs (OpLhs t1 f t2) =
 >   ppConstrTerm 1 t1 <+> ppInfixOp f <+> ppConstrTerm 1 t2
 > ppLhs (ApLhs lhs ts) = parens (ppLhs lhs) <+> fsep (map (ppConstrTerm 2) ts)
 
-> ppRule :: Doc -> Doc -> Rhs -> Doc
+> ppRule :: Doc -> Doc -> Rhs a -> Doc
 > ppRule lhs eq (SimpleRhs _ e ds) =
 >   sep [lhs <+> eq,indent (ppExpr 0 e)] $$ ppLocalDefs ds
 > ppRule lhs eq (GuardedRhs es ds) =
 >   sep [lhs,indent (vcat (map (ppCondExpr eq) es))] $$ ppLocalDefs ds
 
-> ppLocalDefs :: [Decl] -> Doc
+> ppLocalDefs :: [Decl a] -> Doc
 > ppLocalDefs ds
 >   | null ds = empty
 >   | otherwise = indent (text "where" <+> ppBlock ds)
@@ -147,9 +186,8 @@
 
 > ppInterface :: Interface -> Doc
 > ppInterface (Interface m is ds) =
->   text "interface" <+> ppModuleIdent m <+> text "where" <+> lbrace $$
->   vcat (punctuate semi (map ppIImportDecl is ++ map ppIDecl ds)) $$
->   rbrace
+>   ppIBlock (text "interface" <+> ppModuleIdent m)
+>            (map ppIImportDecl is ++ map ppIDecl ds)
 >   where ppModuleIdent m
 >           | isMIdent m = ppMIdent m
 >           | otherwise = text (show (moduleName m))
@@ -157,38 +195,102 @@
 >           where ms = moduleQualifiers m
 >         isIdent "" = False
 >         isIdent (c:cs) = isAlpha c && all isAlphaNum_ cs
->         isAlphaNum_ c = isAlphaNum c || c == '_'
+>         isAlphaNum_ c = isAlphaNum c || c `elem` "'_"
 
 > ppIImportDecl :: IImportDecl -> Doc
 > ppIImportDecl (IImportDecl _ m) = text "import" <+> ppMIdent m
 
 > ppIDecl :: IDecl -> Doc
 > ppIDecl (IInfixDecl _ fix p op) = ppPrec fix (Just p) <+> ppQInfixOp op
-> ppIDecl (HidingDataDecl _ tc tvs) =
->   text "hiding" <+> ppITypeDeclLhs "data" tc tvs
-> ppIDecl (IDataDecl _ tc tvs cs) =
->   sep (ppITypeDeclLhs "data" tc tvs :
->        map indent (zipWith (<+>) (equals : repeat vbar) (map ppIConstr cs)))
->   where ppIConstr = maybe (char '_') ppConstr
-> ppIDecl (INewtypeDecl _ tc tvs nc) =
->   sep [ppITypeDeclLhs "newtype" tc tvs <+> equals,indent (ppNewConstr nc)]
-> ppIDecl (ITypeDecl _ tc tvs ty) =
->   sep [ppITypeDeclLhs "type" tc tvs <+> equals,indent (ppTypeExpr 0 ty)]
+> ppIDecl (HidingDataDecl _ tc k tvs) =
+>   ppPragma "DATA" (ppITypeIdent tc k <+> hsep (map ppIdent tvs))
+> ppIDecl (IDataDecl _ cx tc k tvs cs xs) =
+>   sep (ppITypeDeclLhs "data" cx tc k tvs :
+>        map indent (zipWith (<+>) (equals : repeat vbar) (map ppConstr cs)) ++
+>        [indent (ppHiding xs)])
+> ppIDecl (INewtypeDecl _ cx tc k tvs nc xs) =
+>   sep [ppITypeDeclLhs "newtype" cx tc k tvs <+> equals,
+>        indent (ppNewConstr nc),
+>        indent (ppHiding xs)]
+> ppIDecl (ITypeDecl _ tc k tvs ty) =
+>   sep [ppITypeDeclLhs "type" [] tc k tvs <+> equals,indent (ppTypeExpr 0 ty)]
+> ppIDecl (HidingClassDecl _ cx cls k tv) =
+>   ppPragma "CLASS" (sep [ppContext cx,ppITypeIdent cls k <+> ppIdent tv])
+> ppIDecl (IClassDecl _ cx cls k tv ds fs') =
+>   ppIClassDecl (ppClassHead cx (ppITypeIdent cls k) tv) ds fs'
+> ppIDecl (IInstanceDecl _ cx cls ty m fs) =
+>   sep [ppInstanceHead cx cls ty,
+>        indent (maybePP instModule m),
+>        indent (instArity fs)]
+>   where instModule m = ppPragma "MODULE" (ppMIdent m)
+>         instArity fs
+>           | null fs = empty
+>           | otherwise = ppPragma "ARITY" (fsep (map ppArity fs))
+>         ppArity (f,n) = ppIdent f <+> integer n
 > ppIDecl (IFunctionDecl _ f n ty) =
->   ppQIdent f <+> text "::" <+> maybePP ppArity n <+> ppTypeExpr 0 ty
->   where ppArity n = ppPragma (text "ARITY" <+> int n)
+>   ppQIdent f <+> text "::" <+> maybePP ppArity n <+> ppQualTypeExpr ty
+>   where ppArity n = ppPragma "ARITY" (integer n)
+
+> ppITypeDeclLhs :: String -> [ClassAssert] -> QualIdent -> Maybe KindExpr
+>                -> [Ident] -> Doc
+> ppITypeDeclLhs kw cx tc k tvs =
+>   text kw <+> sep [ppContext cx,ppITypeIdent tc k <+> hsep (map ppIdent tvs)]
+
+> ppITypeIdent :: QualIdent -> Maybe KindExpr -> Doc
+> ppITypeIdent tc (Just k) =
+>   parens (ppQIdent tc <+> text "::" <+> ppKindExpr 0 k)
+> ppITypeIdent tc Nothing = ppQIdent tc
+
+> ppIClassDecl :: Doc -> [IMethodDecl] -> [Ident] -> Doc
+> ppIClassDecl head ds fs'
+>   | null ds = head
+>   | otherwise =
+>       ppIBlock head ([ppHiding fs' | not (null fs')] ++ map ppIMethodDecl ds)
+
+> ppIMethodDecl :: IMethodDecl -> Doc
+> ppIMethodDecl (IMethodDecl p f n ty) =
+>   ppIDecl (IFunctionDecl p (qualify f) n ty)
+
+> ppIBlock :: Doc -> [Doc] -> Doc
+> ppIBlock prefix ds =
+>   prefix <+> text "where" <+> lbrace $$
+>   vcat (punctuate semi ds) $$
+>   rbrace
+
+> ppHiding :: [Ident] -> Doc
+> ppHiding xs
+>   | null xs = empty
+>   | otherwise = ppPragma "HIDING" (ppIdentList xs)
+
+\end{verbatim}
+Kinds
+\begin{verbatim}
 
-> ppITypeDeclLhs :: String -> QualIdent -> [Ident] -> Doc
-> ppITypeDeclLhs kw tc tvs = text kw <+> ppQIdent tc <+> hsep (map ppIdent tvs)
+> ppKindExpr :: Int -> KindExpr -> Doc
+> ppKindExpr _ Star = char '*'
+> ppKindExpr p (ArrowKind k1 k2) =
+>   parenExp (p > 0) (fsep (ppArrowKind (ArrowKind k1 k2)))
+>   where ppArrowKind Star = [ppKindExpr 0 Star]
+>         ppArrowKind (ArrowKind k1 k2) =
+>           ppKindExpr 1 k1 <+> rarrow : ppArrowKind k2
 
 \end{verbatim}
 Types
 \begin{verbatim}
 
+> ppQualTypeExpr :: QualTypeExpr -> Doc
+> ppQualTypeExpr (QualTypeExpr cx ty) = sep [ppContext cx,ppTypeExpr 0 ty]
+
+> ppContext :: [ClassAssert] -> Doc
+> ppContext [] = empty
+> ppContext [ca] = ppClassAssert ca <+> text "=>"
+> ppContext cas = parenList (map ppClassAssert cas) <+> text "=>"
+
+> ppClassAssert :: ClassAssert -> Doc
+> ppClassAssert (ClassAssert cls ty) = ppQIdent cls <+> ppTypeExpr 2 ty
+
 > ppTypeExpr :: Int -> TypeExpr -> Doc
-> ppTypeExpr p (ConstructorType tc tys) =
->   parenExp (p > 1 && not (null tys))
->            (ppQIdent tc <+> fsep (map (ppTypeExpr 2) tys))
+> ppTypeExpr _ (ConstructorType tc) = ppQIdent tc
 > ppTypeExpr _ (VariableType tv) = ppIdent tv
 > ppTypeExpr _ (TupleType tys) = parenList (map (ppTypeExpr 0) tys)
 > ppTypeExpr _ (ListType ty) = brackets (ppTypeExpr 0 ty)
@@ -197,6 +299,11 @@
 >   where ppArrowType (ArrowType ty1 ty2) =
 >           ppTypeExpr 1 ty1 <+> rarrow : ppArrowType ty2
 >         ppArrowType ty = [ppTypeExpr 0 ty]
+> ppTypeExpr p (ApplyType ty1 ty2) =
+>   parenExp (p > 1) (ppApplyType ty1 [ty2])
+>   where ppApplyType (ApplyType ty1 ty2) tys = ppApplyType ty1 (ty2:tys)
+>         ppApplyType ty tys =
+>            (ppTypeExpr 1 ty <+> fsep (map (ppTypeExpr 2) tys))
 
 \end{verbatim}
 Literals
@@ -204,34 +311,38 @@
 
 > ppLiteral :: Literal -> Doc
 > ppLiteral (Char c) = text (show c)
-> ppLiteral (Int _ i) = int i
-> ppLiteral (Float f) = double f
+> ppLiteral (Integer i) = integer i
+> ppLiteral (Rational r) = double (fromRational r)
 > ppLiteral (String s) = text (show s)
 
 \end{verbatim}
 Patterns
 \begin{verbatim}
 
-> ppConstrTerm :: Int -> ConstrTerm -> Doc
-> ppConstrTerm p (LiteralPattern l) =
+> ppConstrTerm :: Int -> ConstrTerm a -> Doc
+> ppConstrTerm p (LiteralPattern _ l) =
 >   parenExp (p > 1 && isNegative l) (ppLiteral l)
 >   where isNegative (Char _) = False
->         isNegative (Int _ i) = i < 0
->         isNegative (Float f) = f < 0.0
+>         isNegative (Integer i) = i < 0
+>         isNegative (Rational r) = r < 0
 >         isNegative (String _ ) = False
-> ppConstrTerm p (NegativePattern op l) =
->   parenExp (p > 1) (ppInfixOp op <> ppLiteral l)
-> ppConstrTerm _ (VariablePattern v) = ppIdent v
-> ppConstrTerm p (ConstructorPattern c ts) =
+> ppConstrTerm p (NegativePattern _ l) =
+>   parenExp (p > 1) (ppInfixOp minusId <> ppLiteral l)
+> ppConstrTerm _ (VariablePattern _ v) = ppIdent v
+> ppConstrTerm p (ConstructorPattern _ c ts) =
 >   parenExp (p > 1 && not (null ts))
 >            (ppQIdent c <+> fsep (map (ppConstrTerm 2) ts))
-> ppConstrTerm p (InfixPattern t1 c t2) =
+> ppConstrTerm p (FunctionPattern _ f ts) =
+>   parenExp (p > 1 && not (null ts))
+>            (ppQIdent f <+> fsep (map (ppConstrTerm 2) ts))
+> ppConstrTerm p (InfixPattern _ t1 op t2) =
 >   parenExp (p > 0)
->            (sep [ppConstrTerm 1 t1 <+> ppQInfixOp c,
->                  indent (ppConstrTerm 0 t2)])
+>            (sep [ppConstrTerm 1 t1 <+> ppOp op,indent (ppConstrTerm 0 t2)])
 > ppConstrTerm _ (ParenPattern t) = parens (ppConstrTerm 0 t)
+> ppConstrTerm _ (RecordPattern _ c fs) =
+>   ppRecord (ppConstrTerm 0) (ppQIdent c) fs
 > ppConstrTerm _ (TuplePattern ts) = parenList (map (ppConstrTerm 0) ts)
-> ppConstrTerm _ (ListPattern ts) = bracketList (map (ppConstrTerm 0) ts)
+> ppConstrTerm _ (ListPattern _ ts) = bracketList (map (ppConstrTerm 0) ts)
 > ppConstrTerm _ (AsPattern v t) = ppIdent v <> char '@' <> ppConstrTerm 2 t
 > ppConstrTerm _ (LazyPattern t) = char '~' <> ppConstrTerm 2 t
 
@@ -239,19 +350,21 @@
 Expressions
 \begin{verbatim}
 
-> ppCondExpr :: Doc -> CondExpr -> Doc
+> ppCondExpr :: Doc -> CondExpr a -> Doc
 > ppCondExpr eq (CondExpr _ g e) =
 >   vbar <+> sep [ppExpr 0 g <+> eq,indent (ppExpr 0 e)]
 
-> ppExpr :: Int -> Expression -> Doc
-> ppExpr _ (Literal l) = ppLiteral l
-> ppExpr _ (Variable v) = ppQIdent v
-> ppExpr _ (Constructor c) = ppQIdent c
+> ppExpr :: Int -> Expression a -> Doc
+> ppExpr _ (Literal _ l) = ppLiteral l
+> ppExpr _ (Variable _ v) = ppQIdent v
+> ppExpr _ (Constructor _ c) = ppQIdent c
 > ppExpr _ (Paren e) = parens (ppExpr 0 e)
 > ppExpr p (Typed e ty) =
->   parenExp (p > 0) (ppExpr 0 e <+> text "::" <+> ppTypeExpr 0 ty)
+>   parenExp (p > 0) (ppExpr 0 e <+> text "::" <+> ppQualTypeExpr ty)
+> ppExpr _ (Record _ c fs) = ppRecord (ppExpr 0) (ppQIdent c) fs
+> ppExpr _ (RecordUpdate e fs) = ppRecord (ppExpr 0) (ppExpr 2 e) fs
 > ppExpr _ (Tuple es) = parenList (map (ppExpr 0) es)
-> ppExpr _ (List es) = bracketList (map (ppExpr 0) es)
+> ppExpr _ (List _ es) = bracketList (map (ppExpr 0) es)
 > ppExpr _ (ListCompr e qs) =
 >   brackets (ppExpr 0 e <+> vbar <+> list (map ppStmt qs))
 > ppExpr _ (EnumFrom e) = brackets (ppExpr 0 e <+> text "..")
@@ -262,17 +375,16 @@
 > ppExpr _ (EnumFromThenTo e1 e2 e3) =
 >   brackets (ppExpr 0 e1 <> comma <+> ppExpr 0 e2
 >               <+> text ".." <+> ppExpr 0 e3)
-> ppExpr p (UnaryMinus op e) = parenExp (p > 1) (ppInfixOp op <> ppExpr 1 e)
+> ppExpr p (UnaryMinus e) = parenExp (p > 1) (ppInfixOp minusId <> ppExpr 1 e)
 > ppExpr p (Apply e1 e2) =
 >   parenExp (p > 1) (sep [ppExpr 1 e1,indent (ppExpr 2 e2)])
 > ppExpr p (InfixApply e1 op e2) =
->   parenExp (p > 0) (sep [ppExpr 1 e1 <+> ppQInfixOp (opName op),
->                          indent (ppExpr 1 e2)])
-> ppExpr _ (LeftSection e op) = parens (ppExpr 1 e <+> ppQInfixOp (opName op))
-> ppExpr _ (RightSection op e) = parens (ppQInfixOp (opName op) <+> ppExpr 1 e)
-> ppExpr p (Lambda t e) =
+>   parenExp (p > 0) (sep [ppExpr 1 e1 <+> ppOp op,indent (ppExpr 1 e2)])
+> ppExpr _ (LeftSection e op) = parens (ppExpr 1 e <+> ppOp op)
+> ppExpr _ (RightSection op e) = parens (ppOp op <+> ppExpr 1 e)
+> ppExpr p (Lambda _ ts e) =
 >   parenExp (p > 0)
->            (sep [backsl <> fsep (map (ppConstrTerm 2) t) <+> rarrow,
+>            (sep [backsl <> fsep (map (ppConstrTerm 2) ts) <+> rarrow,
 >                  indent (ppExpr 0 e)])
 > ppExpr p (Let ds e) =
 >   parenExp (p > 0)
@@ -289,24 +401,35 @@
 >   parenExp (p > 0)
 >            (text "case" <+> ppExpr 0 e <+> text "of" $$
 >             indent (vcat (map ppAlt alts)))
+> ppExpr p (Fcase e alts) =
+>   parenExp (p > 0)
+>            (text "fcase" <+> ppExpr 0 e <+> text "of" $$
+>             indent (vcat (map ppAlt alts)))
 
-> ppStmt :: Statement -> Doc
+> ppStmt :: Statement a -> Doc
 > ppStmt (StmtExpr e) = ppExpr 0 e
-> ppStmt (StmtBind t e) = sep [ppConstrTerm 0 t <+> larrow,indent (ppExpr 0 e)]
+> ppStmt (StmtBind _ t e) =
+>   sep [ppConstrTerm 0 t <+> larrow,indent (ppExpr 0 e)]
 > ppStmt (StmtDecl ds) = text "let" <+> ppBlock ds
 
-> ppAlt :: Alt -> Doc
+> ppAlt :: Alt a -> Doc
 > ppAlt (Alt _ t rhs) = ppRule (ppConstrTerm 0 t) rarrow rhs
 
-> ppOp :: InfixOp -> Doc
-> ppOp (InfixOp op) = ppQInfixOp op
-> ppOp (InfixConstr op) = ppQInfixOp op
+> ppOp :: InfixOp a -> Doc
+> ppOp (InfixOp _ op) = ppQInfixOp op
+> ppOp (InfixConstr _ op) = ppQInfixOp op
+
+> ppRecord :: (a -> Doc) -> Doc -> [Field a] -> Doc
+> ppRecord pp c fs = c <> braces (list (map (ppField pp) fs))
+
+> ppField :: (a -> Doc) -> Field a -> Doc
+> ppField pp (Field l x) = ppQIdent l <+> equals <+> pp x
 
 \end{verbatim}
 Goals
 \begin{verbatim}
 
-> ppGoal :: Goal -> Doc
+> ppGoal :: Goal a -> Doc
 > ppGoal (Goal _ e ds) = sep [ppExpr 0 e,indent (ppLocalDefs ds)]
 
 \end{verbatim}
Solo in curry-0.9.11: CurrySyntax.lhs
diff -u curry-0.9.11/curry.tex curry-0.9.11-classful/curry.tex
--- curry-0.9.11/curry.tex	2007-06-15 14:16:33.000000000 +0200
+++ curry-0.9.11-classful/curry.tex	2013-01-04 10:23:16.000000000 +0100
@@ -1,7 +1,7 @@
 \documentclass[fleqn,10pt,titlepage]{article}
 \usepackage[latin1]{inputenc}
 \usepackage[bookmarks,colorlinks]{hyperref}
-\usepackage{noweb,a4wide}
+\usepackage{noweb,a4wide,latexsym}
 
 \pagestyle{noweb}
 %\noweboptions{}
@@ -47,36 +47,57 @@
 \tableofcontents
 \newpage
 \input{Ident.lhs}
-\input{CurrySyntax.lhs}
+\input{PredefIdent.lhs}
+\input{Curry.lhs}
+\input{CurryPP.lhs}
 \input{CurryLexer.lhs}
 \input{CurryParser.lhs}
-\input{CurryPP.lhs}
+\input{CurryUtils.lhs}
 \input{Base.lhs}
+\input{IdentInfo.lhs}
 \input{ImportSyntaxCheck.lhs}
 \input{TypeSyntaxCheck.lhs}
 \input{SyntaxCheck.lhs}
 \input{ExportSyntaxCheck.lhs}
+\input{CaseCheck.lhs}
+\input{UnusedCheck.lhs}
+\input{ShadowCheck.lhs}
 \input{Renaming.lhs}
+\input{Qual.lhs}
+\input{PrecInfo.lhs}
 \input{PrecCheck.lhs}
+\input{TypeInfo.lhs}
+\input{Kinds.lhs}
+\input{KindSubst.lhs}
+\input{KindTrans.lhs}
 \input{KindCheck.lhs}
 \input{Types.lhs}
+\input{PredefTypes.lhs}
+\input{ValueInfo.lhs}
 \input{TypeSubst.lhs}
 \input{TypeTrans.lhs}
+\input{InstInfo.lhs}
+\input{InstCheck.lhs}
+\input{Deriving.lhs}
 \input{TypeCheck.lhs}
 \input{Typing.lhs}
 \input{IntfSyntaxCheck.lhs}
+\input{IntfQual.lhs}
 \input{IntfCheck.lhs}
 \input{IntfEquiv.lhs}
 \input{Imports.lhs}
 \input{Exports.lhs}
-\input{Qual.lhs}
-\input{CaseCheck.lhs}
-\input{UnusedCheck.lhs}
-\input{ShadowCheck.lhs}
 \input{OverlapCheck.lhs}
-\input{Desugar.lhs}
+\input{TrustInfo.lhs}
 \input{Trust.lhs}
+\input{Desugar.lhs}
+\input{Records.lhs}
+\input{Newtype.lhs}
+\input{LazyPatterns.lhs}
+\input{CaseMatch.lhs}
 \input{Simplify.lhs}
+\input{PatternBind.lhs}
+\input{DictTrans.lhs}
 \input{Lift.lhs}
 \input{IL.lhs}
 \input{ILPP.lhs}
@@ -89,7 +110,11 @@
 \input{CPS.lhs}
 \input{CGen.lhs}
 \input{CElim.lhs}
+\input{Interfaces.lhs}
 \input{Modules.lhs}
+\input{Goals.lhs}
+\input{Common.lhs}
+\input{SplitModule.lhs}
 \input{Options.lhs}
 \input{CurryDeps.lhs}
 \input{cam2c.lhs}
Solo in curry-0.9.11-classful/: CurryUtils.lhs
diff -u curry-0.9.11/cyc.1.in curry-0.9.11-classful/cyc.1.in
--- curry-0.9.11/cyc.1.in	2007-06-15 14:16:34.000000000 +0200
+++ curry-0.9.11-classful/cyc.1.in	2008-08-05 17:52:27.000000000 +0200
@@ -4,9 +4,9 @@
 .\"man mdoc for the short list of editing options
 .\"/usr/share/misc/mdoc.template
 .\"
-.\" $Id: cyc.1.in 2230 2007-06-06 12:35:43Z wlux $
+.\" $Id: cyc.1.in 2743 2008-08-05 15:10:42Z wlux $
 .\"
-.\" Copyright (c) 2004-2007, Wolfgang Lux
+.\" Copyright (c) 2004-2008, Wolfgang Lux
 .\" See LICENSE for the full license.
 .\"
 .Dd 17.11.05               \" DATE 
@@ -297,6 +297,10 @@
 .Fl O3
 and higher levels will fail to produce valid code for Curry modules on
 many architectures.
+.It Fl -cc Ar cmd
+Use
+.Ar cmd
+as the C compiler.
 .It Fl -ccopt Ar opt
 Passes the option
 .Ar opt
@@ -327,14 +331,18 @@
 .It Fl h Ar size
 Use
 .Ar size
-bytes for the heap of the Curry program. Note that actually twice as
-much memory is allocated for the heap because the runtime system uses
-a two-space copying collector. The abbreviations
+bytes for the heap of the Curry program. Note that the runtime system
+uses a two-space copying collector and
+.Ar size
+denotes the total size of both semi-spaces. Thus only
+.Ar size Li / 2
+bytes are available for allocation. The abbreviations
 .Ar size Ns Li k
 and
 .Ar size Ns Li M
 can be used for specifying the size in kBytes and MBytes,
-respectively. The default is to use a 4 MByte heap. 
+respectively. The default is to use a 8 MByte (16 MByte) heap on
+32-bit (64-bit) targets.
 .It Fl k Ar size
 Use
 .Ar size
@@ -343,7 +351,8 @@
 and
 .Ar size Ns Li M
 can be used for specifying the size in kBytes and MBytes,
-respectively. The default is to use a 512 kByte stack.
+respectively. The default is to use a 512 kByte (1 MByte) stack on
+32-bit (64-bit) targets.
 .It Fl t Ar size
 Use
 .Ar size
@@ -352,7 +361,8 @@
 and
 .Ar size Ns Li M
 can be used for specifying the size in kBytes and MBytes,
-respectively. The default is to use a 512 kByte trail stack.
+respectively. The default is to use a 512 kByte (1 MByte) trail stack
+on 32-bit (64-bit) targets.
 .It Fl f
 Print all failures during execution of a non-deterministic goal. If
 given multiple times, print also failures inside encapsulated search.
@@ -381,7 +391,10 @@
 .It Fl T Ar goal
 Compute the type of
 .Ar goal .
-The
+The type is written to the standard output or the file specified with
+a
+.Fl o
+option. The
 .Ar goal Ns No 's
 type is computed with respect to the modules specified with
 .Fl M
@@ -492,7 +505,15 @@
 .Fl RTS
 arguments on the command line. The
 .Fl RTS
-switch may be omitted if it is the last argument on the command line.
+switch may be omitted if it is the last argument on the command
+line. Additional runtime system options can be specified \(em without
+.Cm +RTS
+and
+.Fl RTS
+delimiters \(em in the environment variable
+.Ev CURRYRTS .
+These options are processed before those specified on the command line
+and therefore can be overridden by the latter.
 .Pp
 The Curry runtime system understands the following options:
 .Bl -tag -width -indent
@@ -516,9 +537,9 @@
 .It Fl h Ar n
 Use
 .Ar n
-bytes for the heap in this run of the program. Note that actually
-twice as much memory is allocated for the heap because the runtime
-system uses a two-space copying collector. The abbreviations
+bytes for the heap in this run of the program. Note that only half of
+the specified size is used for allocation because the runtime system
+uses a two-space copying collector. The abbreviations
 .Ar n Ns Li k
 and
 .Ar n Ns Li M
diff -u curry-0.9.11/cycc.hs curry-0.9.11-classful/cycc.hs
--- curry-0.9.11/cycc.hs	2007-06-15 14:16:34.000000000 +0200
+++ curry-0.9.11-classful/cycc.hs	2013-05-13 09:54:58.000000000 +0200
@@ -1,9 +1,10 @@
--- $Id: cycc.hs 1963 2006-08-28 11:57:32Z wlux $
+-- $Id: cycc.hs 3136 2013-05-12 15:53:27Z wlux $
 --
--- Copyright (c) 1999-2006, Wolfgang Lux
+-- Copyright (c) 1999-2013, Wolfgang Lux
 -- See LICENSE for the full license.
 
 import Modules
+import Goals
 import PathUtils
 import Options
 import Combined
@@ -13,14 +14,15 @@
 import List
 import Maybe
 import System
+import Utils
 
 main :: IO ()
 main =
   do
     prog <- getProgName
     args <- getArgs
-    importPath <- catch (getEnv "CURRY_IMPORT_PATH" >>= return . pathList)
-                        (const (return []))
+    importPath <- IO.catch (getEnv "CURRY_IMPORT_PATH" >>= return . pathList)
+                           (const (return []))
     cyc prog args importPath
 
 cyc :: String -> [String] -> [FilePath] -> IO ()
@@ -71,7 +73,3 @@
   where checkOk (Ok x) = return x
         checkOk (Errors msgs) =
           putErr (unlines (nub msgs)) >> exitWith (ExitFailure 1)
-
-putErr, putErrLn :: String -> IO ()
-putErr = hPutStr stderr
-putErrLn = hPutStr stderr . (++ "\n")
diff -u curry-0.9.11/cyc.in curry-0.9.11-classful/cyc.in
--- curry-0.9.11/cyc.in	2007-06-15 14:16:33.000000000 +0200
+++ curry-0.9.11-classful/cyc.in	2011-10-20 10:08:36.000000000 +0200
@@ -3,14 +3,14 @@
 #
 # Shell script for compiling Curry modules
 #
-# $Id: cyc.in 2238 2007-06-09 19:46:48Z wlux $
+# $Id: cyc.in 3059 2011-10-20 07:01:17Z wlux $
 #
-# Copyright (c) 2002-2007, Wolfgang Lux
+# Copyright (c) 2002-2011, Wolfgang Lux
 # See LICENSE for the full license.
 #
 
 # Configuration parameters
-cyc=`basename $0`
+cyc=`basename "$0"`
 version=@PACKAGE_VERSION@
 build="%BUILD_DATE%"
 prefix=@prefix@
@@ -25,10 +25,10 @@
 : ${CURRY_IMPORT_PATH=$CURRY_PATH}
 : ${CURRY_INCLUDE_PATH=$CURRY_PATH}
 : ${CURRY_LIBRARY_PATH=$CURRY_PATH}
-: ${CC="@CC@ @CURRY_CFLAGS@"}
 export CURRY_IMPORT_PATH
 
 # Local variables
+echo=:
 exec=
 verbose=
 toC=
@@ -38,6 +38,7 @@
 cyccopts=
 rtopts=
 debug=
+cc="@CC@"
 ccopts=
 ldopts=
 hsize=
@@ -63,8 +64,8 @@
     eval _x=\$"$2"
     case $_x in
       "" ) echo 1>&2 "$cyc: missing size after $1"; exit 1;;
-      *[kK] ) _y=`expr "$_x" : '\([0-9]*\)[kK]$'`"*k";;
-      *[mM] ) _y=`expr "$_x" : '\([0-9]*\)[mM]$'`"*M";;
+      *[kK] ) _y=`expr "$_x" : '\([0-9]*\)[kK]$'`"*1024";;
+      *[mM] ) _y=`expr "$_x" : '\([0-9]*\)[mM]$'`"*1024*1024";;
       * ) _y=`expr "$_x" : '\([0-9]*\)$'`;;
     esac
     case $_y in
@@ -79,6 +80,17 @@
     eval $1=`expr "$_x" + "$_y"`
 }
 
+quote ( ) {
+    case $1 in
+      *\'* )
+	sed "s/'/'\\\\''/g;1s/^/'/;\$s/$/'/" <<EOF
+$1
+EOF
+	;;
+      * ) printf "'%s'" "$1";;
+    esac
+}
+
 # Option processing
 while test $# -gt 0; do
   case $1 in
@@ -87,14 +99,14 @@
     -C ) toC=1;;
     -S ) toS=1;;
     -o ) ofile=$2; shift;;
-    -o* ) ofile=`expr "$1" : '-o\(.*\)'`;;
+    -o* ) ofile=`expr X"$1" : X'-o\(.*\)'`;;
     -n ) exec=echo;;
     -v ) verbose=-v; ccopts="$ccopts -v";;
     -q ) ;; # option ignored for compatibility with cymake
 
     # (C-)Preprocessor definitions
-    -[DU] ) ccopts="$ccopts $1 $2"; shift;;
-    -[DU]* ) ccopts="$ccopts $1";;
+    -[DU] ) ccopts="$ccopts $1 "`quote "$2"`; shift;;
+    -[DU]* ) ccopts="$ccopts "`quote "$1"`;;
 
     # Special definitions
     -gg ) debug=-g;;
@@ -109,12 +121,12 @@
     -save-temps ) saveTemps=$1;;
 
     # cycc options
-    -no-intf | --no-intf | -no-icurry | --no-icurry ) 
+    -no-intf | --no-intf | -no-icurry | --no-icurry )
 	cyccopts="$cyccopts --no-icurry";;
     -Whaskell ) cyccopts="$cyccopts --haskell-mode";;
     -Wprolog ) cyccopts="$cyccopts --prolog-mode";;
     -Wgoedel ) cyccopts="$cyccopts --goedel-mode";;
-    -W?* ) cyccopts=$cyccopts\ --warn-`expr "$1" : '-W\(.*\)'`;;
+    -W?* ) cyccopts=$cyccopts\ --warn-`expr X"$1" : X'-W\(.*\)'`;;
     -warn* ) cyccopts="$cyccopts -$1";;
     --warn* ) cyccopts="$cyccopts $1";;
     -dump* ) cyccopts="$cyccopts -$1";;
@@ -123,58 +135,78 @@
     -trusted | --trusted ) cyccopts="$cyccopts --trusted";;
 
     # goal options
-    -M ) modules="$modules $2"; shift;;
-    -M* ) modules=$modules\ `expr "$1" : '-M\(.*\)'`;;
+    -M ) modules="$modules "`quote "$2"`; shift;;
+    -M* ) arg=`expr X"$1" : X'-M\(.*\)'`; modules="$modules "`quote "$arg"`;;
     -e ) goal=$2; shift;;
-    -e* ) goal=`expr "$1" : '-e\(.*\)'`;;
+    -e* ) goal=`expr X"$1" : X'-e\(.*\)'`;;
     -T ) typeIt=$2; shift;;
-    -T* ) typeIt=`expr "$1" : '-T\(.*\)'`;;
+    -T* ) typeIt=`expr X"$1" : X'-T\(.*\)'`;;
 
     # C Compiler options
-    -cc ) CC=$2; shift;;
+    -cc ) cc=`quote "$2"`; shift;;
     -ccopt-* | --ccopt-* )
-      ccopts=$ccopts\ `expr "$1" : '-*ccopts*\(-.*\)'`;;
-    -ccopt | --ccopt ) ccopts="$ccopts $2"; shift;;
+      arg=`expr X"$1" : X'-*ccopt\(-.*\)'`; ccopts="$ccopts "`quote "$arg"`;;
+    -ccopt | --ccopt ) ccopts="$ccopts "`quote "$2"`; shift;;
     -ccopts-* | --ccopts-* )
-      ccopts=$ccopts\ `expr "$1" : '-*ccopts*\(-.*\)' | tr , ' '`;;
-    -ccopts | --ccopts ) ccopts=$ccopts\ `echo "$2" | tr , ' '`; shift;;
-    -arch ) ccopts="$ccopts $1 $2"; shift;;
-    -O* ) ccopts="$ccopts $1";;
+      ifs=$IFS; IFS=,
+      for arg in `expr X"$1" : X'-*ccopts*\(-.*\)'`; do
+	ccopts="$ccopts "`quote "$arg"`
+      done
+      IFS=$ifs;;
+    -ccopts | --ccopts )
+      ifs=$IFS; IFS=,
+      for arg in $2; do ccopts="$ccopts "`quote "$arg"`; done
+      IFS=$ifs; shift;;
+    -arch ) ccopts="$ccopts $1 "`quote "$2"`; shift;;
+    -O* ) ccopts="$ccopts "`quote "$1"`;;
 
     # Include files and imported modules
-    -I ) ccopts="$ccopts -I$2"; shift;;
-    -I* ) ccopts="$ccopts $1";;
-    -i ) ccopts="$ccopts -I$2"; imports="$imports -i $2"; shift;;
-    -i* ) ccopts=$ccopts\ -I`expr "$1" : '-i\(.*\)'`; imports="$imports $1";;
+    -I ) ccopts="$ccopts -I"`quote "$2"`; shift;;
+    -I* ) ccopts="$ccopts "`quote "$1"`;;
+    -i )
+      arg=`quote "$2"`; shift
+      ccopts="$ccopts -I$arg"; imports="$imports -i $arg";;
+    -i* )
+      arg=`expr X"$1" : X'-i\(.*\)'`; arg=`quote "$arg"`
+      ccopts=$ccopts\ -I$arg; imports="$imports -i$arg";;
     -P )
-      ccopts="$ccopts -I$1"; ldopts="$ldopts -L$2"
-      imports="$imports -i $2"; shift;;
+      arg=`quote "$2"`; shift
+      ccopts="$ccopts -I$arg"; ldopts="$ldopts -L$arg"
+      imports="$imports -i $arg";;
     -P* )
-      arg=`expr "$1" : '-P\(.*\)'`
+      arg=`expr X"$1" : X'-P\(.*\)'`; arg=`quote "$arg"`
       ccopts="$ccopts -I$arg"; ldopts="$ldopts -L$arg"
       imports="$imports -i $arg";;
-    -F ) ccopts="$ccopts -F$2"; shift;;
-    -F* ) ccopts="$ccopts $1";;
+    -F ) ccopts="$ccopts -F"`quote "$2"`; shift;;
+    -F* ) ccopts="$ccopts "`quote "$1"`;;
 
     # Linker options
     -ldopt-* | --ldopt-* )
-      ldopts=$ldopts\ `expr "$1" : '-*ldopts*\(-.*\)'`;;
-    -ldopt | --ldopt ) ldopts="$ldopts $2"; shift;;
+      opt=`expr X"$1" : X'-*ldopt\(-.*\)'`
+      ldopts="$ldopts "`quote "$opt"`;;
+    -ldopt | --ldopt ) ldopts="$ldopts "`quote "$2"`; shift;;
     -ldopts-* | --ldopts-* )
-      ldopts=$ldopts\ `expr "$1" : '-*ldopts*\(-.*\)' | tr , ' '`;;
-    -ldopts | --ldopts ) ldopts=$ldopts\ `echo "$2" | tr , ' '`; shift;;
-    -L ) ldopts="$ldopts -L$2"; shift;;
-    -L* ) ldopts="$ldopts $1";;
-    -l ) libs="$libs -l$2"; shift;;
-    -l* ) libs="$libs $1";;
-    -framework ) ldopts="$ldopts $1 $2"; shift;;
+      ifs=$IFS; IFS=,
+      for opt in `expr X"$1" : X'-*ldopts*\(-.*\)'`; do
+	ldopts="$ldopts "`quote "$opt"`
+      done
+      IFS=$ifs;;
+    -ldopts | --ldopts )
+      ifs=$IFS; IFS=,
+      for opt in $2; do ccopts="$ccopts "`quote "$opt"`; done
+      IFS=$ifs; shift;;
+    -[LR] ) ldopts="$ldopts $1"`quote "$2"`; shift;;
+    -[LR]* ) ldopts="$ldopts "`quote "$1"`;;
+    -l ) libs="$libs -l"`quote "$2"`; shift;;
+    -l* ) libs="$libs "`quote "$1"`;;
+    -framework ) ldopts="$ldopts $1 "`quote "$2"`; shift;;
 
     # Runtime system options for cycc
-    -H* ) rtopts="$rtopts $1";;
+    -H* ) rtopts="$rtopts "`quote "$1"`;;
     +RTS )
 	shift
-	while test $# -gt 0 -a "$1" != "-RTS"; do
-	  rtopts="$rtopts $1";
+	while test $# -gt 0 && test "$1" != "-RTS"; do
+	  rtopts="$rtopts "`quote "$1"`;
 	  shift
 	done;;
 
@@ -183,31 +215,32 @@
     -f ) incr pfail 1;;
     -p ) incr stats 1;;
     -h ) hsize=$2; shift; check_size -h hsize;;
-    -h* ) hsize=`expr "$1" : '-h\(.*\)'`; check_size -h hsize;;
+    -h* ) hsize=`expr X"$1" : X'-h\(.*\)'`; check_size -h hsize;;
     -k ) ssize=$2; shift; check_size -k ssize;;
-    -k* ) ssize=`expr "$1" : '-k\(.*\)'`; check_size -k ssize;;
+    -k* ) ssize=`expr X"$1" : X'-k\(.*\)'`; check_size -k ssize;;
     -t ) tsize=$2; shift; check_size -t tsize;;
-    -t* ) tsize=`expr "$1" : '-t\(.*\)'`; check_size -t tsize;;
+    -t* ) tsize=`expr X"$1" : X'-t\(.*\)'`; check_size -t tsize;;
 
     # Pass all other flags to the C compiler
-    -* ) ccopts="$ccopts $1";;
+    -* ) ccopts="$ccopts "`quote "$1"`;;
 
     # Save all files
-    * ) files="$files $1";;
+    * ) files="$files "`quote "$1"`;;
   esac
   shift
 done
 
 # Add runtime options to cycc
+cycc=`quote "$cycc"`
 test -n "$rtopts" && cycc="$cycc +RTS $rtopts -RTS"
 
 # Eventually display the compiler version
 if test -n "$verbose"; then
   echo 1>&2 "$cyc version $version (built on $build)"
-  test "$exec" && verbose=
+  test "$exec" || echo='echo 1>&2'
 fi
 # Check for conflicting options
-if test -n "$goal" -a -n "$typeIt"; then
+if test -n "$goal" && test -n "$typeIt"; then
   echo 1>&2 "$cyc: conflicting options -e and -T specified"
   exit 1
 fi
@@ -223,13 +256,17 @@
 ifs=$IFS
 IFS=:
 for d in $CURRY_INCLUDE_PATH; do 
-  ccopts="$ccopts -I$d"
+  ccopts="$ccopts -I"`quote "$d"`
 done
 for d in $CURRY_LIBRARY_PATH; do 
-  ldopts="$ldopts -L$d"
+  ldopts="$ldopts -L"`quote "$d"`
 done
 IFS=$ifs
 
+# Add configuration options
+ccopts="$ccopts @CPPFLAGS@ @CURRY_CFLAGS@"
+ldopts="$ldopts @LDFLAGS@"
+
 # Cygpath workaround: converts path to Windows-style
 if test -n "@CYGPATH@"; then
   CURRY_IMPORT_PATH=`@CYGPATH@ -w -p $CURRY_IMPORT_PATH`
@@ -240,25 +277,14 @@
 trap 'rc=$?; test "$temps" && rm -f $temps; exit $rc' 0 1 2 3 15
 
 # Process all files
-set dummy $files; shift
-if test -n "$ofile" -a -n "$toC$toS$toO" -a $# -gt 1; then
+eval set dummy "$files"; shift
+if test -n "$ofile" && test -n "$toC$toS$toO" && test $# -gt 1; then
   echo 1>&2 "$cyc: cannot specify -o with -c, -S, or -C and multiple input files"
   exit 1
 fi
 
-if test -n "$typeIt"; then
-  for f in $files; do
-    case $f in
-      *.curry | *.lcurry ) modules="$modules $f";;
-    esac
-  done
-  test -n "$verbose" && echo 1>&2 $cycc $imports -t \"$typeIt\" $cyccopts $modules
-  $exec $cycc $imports -t "$typeIt" $cyccopts $modules
-  exit $?
-fi
-
 i=0
-for f in $files; do
+for f in "$@"; do
   i=`expr $i + 1`
   stem=
   curry_ccopts=
@@ -266,8 +292,9 @@
   # Compile Curry source files into C code
   case $f in
     *.curry | *.lcurry )
-      curry_ccopts=-I`dirname $f`
-      modules="$modules $f"
+      dir=`dirname "$f"`
+      curry_ccopts=-I`quote "$dir"`
+      modules="$modules "`quote "$f"`
       stem=`expr "$f" : '\(.*\)\.curry'`
       stem=$stem`expr "$f" : '\(.*\)\.lcurry'`
       if test -n "$toC"; then
@@ -292,8 +319,10 @@
         target2=$target
         f2=$f
       fi
-      test -n "$verbose" && echo 1>&2 $cycc $imports $cyccopts -o $target2 $f2
-      $exec $cycc $imports $cyccopts -o $target2 $f2 || exit $?
+      target2=`quote "$target2"`
+      f2=`quote "$f2"`
+      eval $echo "$cycc" "$imports" "$cyccopts" -o "$target2" "$f2"
+      eval $exec "$cycc" "$imports" "$cyccopts" -o "$target2" "$f2" || exit $?
       f=$target
       ;;
   esac
@@ -318,29 +347,48 @@
 	  temps="$temps $target"
 	fi
       fi
-      test -n "$verbose" && echo 1>&2 $CC $debug $curry_ccopts $ccopts $saveTemps $c -o $target $f
-      $exec $CC $debug $curry_ccopts $ccopts $saveTemps $c -o $target $f || exit $?
+      target2=`quote "$target"`
+      f2=`quote "$f"`
+      eval $echo "$cc" $debug "$curry_ccopts" "$ccopts" $saveTemps $c -o "$target2" "$f2"
+      eval $exec "$cc" $debug "$curry_ccopts" "$ccopts" $saveTemps $c -o "$target2" "$f2" || exit $?
       f=$target
       ;;
   esac
   test -n "$toS$toO" && continue
 
   # Add all files for the link step
-  linkfiles="$linkfiles $f"
+  linkfiles="$linkfiles "`quote "$f"`
 done
 
-# Eventually link the program
-if test -z "$toC$toS$toO"; then
-  temps="$temps /tmp/cyc$$.c"
+# Eventually link the program or compute the goal's type
+if test -n "$typeIt"; then
+  if test -n "$ofile"; then
+    # Cygpath workaround: converts path to Windows-style
+    if test -n "@CYGPATH@"; then
+      ofile2=`@CYGPATH@ -w $ofile`
+    else
+      ofile2=$ofile
+    fi
+    target="-o "`quote "$ofile2"`
+  else
+    target=
+  fi
+  typeIt2=`quote "$typeIt"`
+  eval $echo "$cycc" "$imports" "$cyccopts" -t"\\\"$typeIt2\\\"" "$modules" "$target" || exit $?
+  eval $exec "$cycc" "$imports" "$cyccopts" -t"$typeIt2" "$modules" "$target" || exit $? || exit $?
+elif test -z "$toC$toS$toO"; then
   target=/tmp/cyc$$.c
+  test -n "$debug$saveTemps" || temps="$temps $target"
   # Cygpath workaround: converts path to Windows-style
   if test -n "@CYGPATH@"; then
     target2=`@CYGPATH@ -w $target`
   else
     target2=$target
   fi
-  test -n "$verbose" && echo 1>&2 $cycc $imports $cyccopts -e\"$goal\" $modules -o $target2
-  $exec $cycc $imports $cyccopts -e"$goal" $modules -o $target2 || exit $?
+  goal=`quote "$goal"`
+  target2=`quote "$target2"`
+  eval $echo "$cycc" "$imports" "$cyccopts" -e"\\\"$goal\\\"" "$modules" -o "$target2"
+  eval $exec "$cycc" "$imports" "$cyccopts" -e"$goal" "$modules" -o "$target2" || exit $?
 
   test -n "$hsize" && ldopts="$ldopts -DDEFAULT_HEAPSIZE=$hsize"
   test -n "$ssize" && ldopts="$ldopts -DDEFAULT_STACKSIZE=$ssize"
@@ -348,9 +396,9 @@
   test -n "$pfail" && ldopts="$ldopts -DDEFAULT_PRINT_FAIL=$pfail"
   test -n "$stats" && ldopts="$ldopts -DDEFAULT_SHOW_STATS=$stats"
   test -n "$trace" && ldopts="$ldopts -DDEFAULT_DO_TRACE=$trace"
-  test -n "$ofile" && ldopts="$ldopts -o $ofile"
-  test -n "$verbose" && echo 1>&2 $CC $debug $ccopts $ldopts /tmp/cyc$$.c $linkfiles $libs $dbglib -lcurry @LDFLAGS@ @LIBS@
-  $exec $CC $debug $ccopts $ldopts /tmp/cyc$$.c $linkfiles $libs $dbglib -lcurry @LDFLAGS@ @LIBS@ || exit $?
+  test -n "$ofile" && ldopts="$ldopts -o "`quote "$ofile"`
+  eval $echo "$cc" $debug "$ccopts" "$ldopts" /tmp/cyc$$.c "$linkfiles" "$libs" $dbglib -lcurry @LIBS@
+  eval $exec "$cc" $debug "$ccopts" "$ldopts" /tmp/cyc$$.c "$linkfiles" "$libs" $dbglib -lcurry @LIBS@ || exit $?
 fi
 
 # done
diff -u curry-0.9.11/cyi.1.in curry-0.9.11-classful/cyi.1.in
--- curry-0.9.11/cyi.1.in	2007-06-15 14:16:34.000000000 +0200
+++ curry-0.9.11-classful/cyi.1.in	2010-06-11 15:08:48.000000000 +0200
@@ -4,9 +4,9 @@
 .\"man mdoc for the short list of editing options
 .\"/usr/share/misc/mdoc.template
 .\"
-.\" $Id: cyi.1.in 2241 2007-06-10 18:06:01Z wlux $
+.\" $Id: cyi.1.in 2945 2010-06-11 10:39:16Z wlux $
 .\"
-.\" Copyright (c) 2004-2007, Wolfgang Lux
+.\" Copyright (c) 2004-2010, Wolfgang Lux
 .\" See LICENSE for the full license.
 .\"
 .Dd 17.11.05               \" DATE 
@@ -241,6 +241,17 @@
 .Dl \& \& For instance, use \(rs\(rsx -> x for a lambda abstraction
 .Dl \& \& and '\(rs\(rsn' for the linefeed character.
 .Pp
+Due to the way the
+.Nm
+shell script processes commands entered at its prompt, it is necessary
+to escape single quotes in module names and paths. E.g., in order to
+load module
+.Li Module'
+you must enter the command line
+.Li :load Module\(rs' .
+Similarly, white space in paths must be escaped or quoted (between
+single or double quotes).
+.Pp
 Command line editing and history require support from the
 .Ic read
 command of the shell, which executes the
@@ -248,9 +259,3 @@
 script. This is available only for Gnu Bash and Korn shells except for
 the public domain version. Command line editing also works for the Z
 shell, but without history.
-.Pp
-Changing the compiler's search path for library modules with the
-.Ic :set
-command does not change the search path used by the
-.Ic :load
-command.
diff -u curry-0.9.11/cyi.in curry-0.9.11-classful/cyi.in
--- curry-0.9.11/cyi.in	2007-06-15 14:16:33.000000000 +0200
+++ curry-0.9.11-classful/cyi.in	2011-10-20 10:08:37.000000000 +0200
@@ -3,9 +3,9 @@
 #
 # A poor (wo)man's interactive top-level for Curry
 #
-# $Id: cyi.in 2230 2007-06-06 12:35:43Z wlux $
+# $Id: cyi.in 3059 2011-10-20 07:01:17Z wlux $
 #
-# Copyright (c) 2002-2007, Wolfgang Lux
+# Copyright (c) 2002-2011, Wolfgang Lux
 # See LICENSE for the full license.
 #
 
@@ -43,14 +43,19 @@
 editor=${VISUAL-${EDITOR-/usr/bin/vi}}
 srcdir=
 source=
+target=
 cyopts=
 interfaces=
 module=
-objects=
-dobjects=
+command=
+dcommand=
 prompt='> '
 goal=
 
+# NB On some systems (e.g., Mac OS X 10.5) bash turns on SYSV echo style
+#    by default when it is run as /bin/sh. The following command turns this
+#    off by unsetting the respective shell option if it is available.
+( shopt -u xpg_echo ) 2>/dev/null && shopt -u xpg_echo
 case `echo "echo\c"` in
   echo ) echo_c='\c';;		# SYSV style
   *    ) echo_c= ;;
@@ -122,16 +127,27 @@
   test $rawread = yes || backslash_warning
 }
 
+quote ( ) {
+  case $1 in
+    *\'* ) echo "$1" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/$/'/";;
+    * ) echo "'$1'";;
+  esac
+}
+
 compile_source ( ) {
-  test -z "$source" || (cd "$srcdir" && $cymake $* $cyopts $source)
+  test -z "$source" || (cd "$srcdir" && "$cymake" $* $cyopts "$source")
 }
 
 compile_target ( ) {
-  (cd "$srcdir" && $cyc $cyopts $interfaces -M "$source" "$@")
+  if test -n "$target"; then
+    (cd "$srcdir" && "$cymake" -q $cyopts "$@" "$target")
+  else
+    (cd "${srcdir:-.}" && "$cymake" -q $cyopts $interfaces "$@")
+  fi
 }
 
 find_module ( ) {
-  $cymake --find $cyopts "$1" | sed 's/^.*: //'
+  "$cymake" --find $cyopts "$1" | sed 's/^.*: //'
 }
 
 set_goal ( ) {
@@ -143,23 +159,16 @@
 	return 1
       fi
       ;;
-    * ) goal=$1;;
+    * ) goal=$1; qgoal=`quote "$goal"`;;
   esac
 }
 
-trap 'rc=$?; rm -f /tmp/cyi$$@EXEEXT@; exit $rc' 0 1 15
-trap 'rm -f /tmp/cyi$$@EXEEXT@' 2 3
-run_goal ( ) {
-  compile_target -e "$goal" $* -o /tmp/cyi$$ && /tmp/cyi$$
-  rm -f /tmp/cyi$$@EXEEXT@
-}
-
 set_module ( ) {
     case $1 in
       *.curry ) stem=`expr "$1" : '\(.*\).curry'`;;
       *.lcurry ) stem=`expr "$1" : '\(.*\).lcurry'`;;
-      *.icurry ) stem=`expr "$m" : '\(.*\)'.icurry`;;
-      *.o ) stem=`expr "$m" : '\(.*\)'.o`;;
+      *.icurry ) stem=`expr "$1" : '\(.*\)'.icurry`;;
+      *.o ) stem=`expr "$1" : '\(.*\)'.o`;;
       * ) stem=$1;;
     esac
     read line < $stem.icurry
@@ -169,15 +178,16 @@
 }
 
 load ( ) {
-  eval set dummy $1; shift
+  eval set dummy "$1"; shift
   case $# in
     0 )
-      srcdir=.
+      srcdir=
       source=
+      target=
       module=Prelude
       interfaces=
-      objects=
-      dobjects=
+      command=
+      dcommand=
       prompt="$module> "
       ;;
     1 )
@@ -186,17 +196,26 @@
         "" ) echo "missing source file for $1";;
 	*.curry | *.lcurry )
 	    if test -f "$m"; then
-              srcdir=`pwd`; source=$m
+              srcdir=`pwd`
+	      source=$m
+	      interfaces=
+	      case $m in
+		*.curry ) target=`expr "$m" : '\(.*\)\.curry'`;;
+		*.lcurry ) target=`expr "$m" : '\(.*\)\.lcurry'`;;
+	      esac
+	      command=
+	      dcommand=
+	      reload
             else
 	      echo "source file $m does not exist"
-	    fi
-	    reload;;
+	    fi;;
 	*.icurry )
 	    srcdir=`pwd`
 	    source=
 	    interfaces=-M$m
-	    objects=
-	    dobjects=
+	    target=
+	    command=
+	    dcommand=
 	    set_module "$m";;
 	* )
 	  echo >&2 "$cyi: internal error: unexpected result from cymake --find"
@@ -209,18 +228,22 @@
 reload ( ) {
   if test -n "$source"; then
     compile_source || return
-    set dummy `compile_source -M | sed 's/.*\.curry / /;s/.*\.lcurry / /'`
-    shift
-    interfaces=
-    for m in $*; do
-      case "$interfaces " in
-        *" -M$m "* ) ;;
-        * ) interfaces="$interfaces -M$m";;
+    set_module "$source"
+    command=
+    dcommand=
+    # NB The -e _ option is necessary to force cymake into generating a link
+    #    command for the target, which includes -M options that bring the
+    #    entities of all imported interfaces into scope within the goal. The
+    #    goal expression itself is irrelevant here but must be a non-empty
+    #    string.
+    eval set dummy "`compile_target -e _ -### | tail -1`"; shift
+    while test $# -gt 0; do
+      case $1 in
+	-o | -e ) shift;;
+	* ) command="$command "`quote "$1"`
       esac
+      shift
     done
-    objects=`compile_source -M | sed 's/:.*$//'`
-    dobjects=
-    set_module "$source"
   fi
 }
 
@@ -229,10 +252,10 @@
 }
 
 interface ( ) {
-  eval set dummy $1; shift
+  eval set dummy "$1"; shift
   case $# in
-    0 ) d=$srcdir; if test -n "$source"; then m=$source; else m=$module; fi;;
-    1 ) d=.; m=$1;;
+    0 ) d=${srcdir:-.}; if test -n "$source"; then m=$source; else m=$module; fi;;
+    1 ) d=. m=$1;;
     * ) echo "too many modules"; return;;
   esac
   i=`cd "$d" && find_module "$m"`
@@ -246,7 +269,7 @@
       return;;
   esac
   if test -n "$i" && (cd "$d" && test -f "$i"); then
-    (cd "$d"; $pager $i)
+    (cd "$d"; $pager "$i")
   else
     echo "Interface of module $m not found";
     return 1
@@ -254,7 +277,7 @@
 }
 
 edit ( ) {
-  eval set dummy $1; shift
+  eval set dummy "$1"; shift
   case $# in
     0 ) test -n "$source" || { echo "no source file"; return; }
 	(cd "$srcdir" && $editor "$source");;
@@ -263,23 +286,37 @@
   esac
 }
 
+trap 'rc=$?; rm -f /tmp/cyi$$@EXEEXT@; exit $rc' 0 1 15
+trap 'rm -f /tmp/cyi$$@EXEEXT@' 2 3
 evaluate ( ) {
-  set_goal "$1" && run_goal $objects
+  set_goal "$1" || return
+  eval "${command:-compile_target}" -e "$qgoal" -o /tmp/cyi$$ && /tmp/cyi$$
+  rm -f /tmp/cyi$$@EXEEXT@
 }
 
 debug ( ) {
+  set_goal "$1" || return
   if test -n "$source"; then
-    echo "Preparing $source for debugging; this may take some time..."
-    if test -z "$dobjects"; then
+    if test -z "$dcommand"; then
+      echo "Preparing $source for debugging; this may take some time..."
       compile_source --debug || return
-      dobjects=`compile_source -M | sed 's/\.o:.*$/.d.o/'`
+      eval set dummy "`compile_target -a --debug -### | tail -1`"; shift
+      while test $# -gt 0; do
+	case $1 in
+	  -o ) shift;;
+	  * ) dcommand="$dcommand "`quote "$1"`
+	esac
+	shift
+      done
     fi
   fi
-  set_goal "$1" && run_goal --debug $dobjects
+  eval "${dcommand:-compile_target --debug}" -e "$qgoal" -o /tmp/cyi$$ && /tmp/cyi$$
+  rm -f /tmp/cyi$$@EXEEXT@
 }
 
 type_goal ( ) {
-  set_goal "$1" && compile_target -T "$goal"
+  set_goal "$1" || return
+  eval "${command:-compile_target}" -T "$qgoal"
 }
 
 show_options ( ) {
@@ -310,29 +347,29 @@
 }
 
 chdir ( ) {
-  set dummy $line; shift
+  set dummy "$1" $1; shift
   case $# in
-    0 ) pwd;;
+    1 ) pwd;;
     * )
      # First check whether we can change to the new directory in a subshell.
      # This is a workaround for some brain-dead old Bourne shells that
      # exit immediately when an internal command like cd fails.
-     ( eval cd $line ) && eval cd $line;;
+     ( eval cd "$1" ) && eval cd "$1";;
   esac
 }
 
 system ( ) {
-  set dummy $line; shift
+  set dummy "$1" $1; shift
   case $# in
-    0 ) ${SHELL-/bin/sh};;
-    * ) /bin/sh -c "$line";;
+    1 ) ${SHELL-/bin/sh};;
+    * ) /bin/sh -c "$1";;
   esac
 }
 
 while test $# -gt 0; do
   case $1 in
     -[ilDILU] ) cyopts="$cyopts $1 $2"; shift;;
-    -[ilDILOU]* ) cyopts="$option $1";;
+    -[ilDILOU]* ) cyopts="$cyopts $1";;
     -* ) echo "$cyi: unknown option $1"; exit 1;;
     * ) break;;
   esac
@@ -394,7 +431,7 @@
     :u | :un | :unset ) shift; unset_options $*;;
     :cd ) line=`expr "$line" : $1'\([^;]*\)'`; chdir "$line";;
     :!* ) line=`expr "$line" : ':![ 	]*\(.*\)'`; system "$line";;
-    :v | :version ) $cyc -v;;
+    :v | :version ) "$cyc" -v;;
     :q | :quit ) quit;;
     :d ) line=`expr "$line" : ':d\(.*\)'`; debug "  $line";;
     :debug ) line=`expr "$line" : ':debug\(.*\)'`; debug "      $line";;
diff -u curry-0.9.11/cymake.1.in curry-0.9.11-classful/cymake.1.in
--- curry-0.9.11/cymake.1.in	2007-06-15 14:16:34.000000000 +0200
+++ curry-0.9.11-classful/cymake.1.in	2010-06-11 15:08:48.000000000 +0200
@@ -4,9 +4,9 @@
 .\"man mdoc for the short list of editing options
 .\"/usr/share/misc/mdoc.template
 .\"
-.\" $Id: cymake.1.in 2230 2007-06-06 12:35:43Z wlux $
+.\" $Id: cymake.1.in 2945 2010-06-11 10:39:16Z wlux $
 .\"
-.\" Copyright (c) 2004-2007, Wolfgang Lux
+.\" Copyright (c) 2004-2010, Wolfgang Lux
 .\" See LICENSE for the full license.
 .\"
 .Dd 17.11.05               \" DATE 
@@ -75,6 +75,12 @@
 .Bl -tag -width -indent
 .It Fl n
 No execution mode. Print commands but do not execute them.
+.It Fl ###
+No execution mode. Print commands but do not execute them. Differs
+from
+.Fl n
+in that all arguments are quoted. This allows to capture the commands
+and execute them in another shell.
 .It Fl q
 Quiet mode. Do not print commands before executing them.
 .It Fl M
@@ -102,18 +108,27 @@
 is empty. 
 .It Fl a
 Always link the executable, even if it is not out of date with respect
-to its object files. This is useful if only the goal to be evaluated
-by the program is changed.
+to its object files.
+.Pp
+This option is deprecated. Use
+.Fl e Li main
+(or any other goal) to force relinking.
 .It Fl e Ar goal
 Evaluate
 .Ar goal
 instead of function
 .Li main .
-This option cannot be used when compiling more than one module.
+The executable is always relinked, even if it appears to be not out of
+date with respect to its object files. This option cannot be used when
+compiling more than one module.
 .It Fl T Ar goal
 Compute the type of
 .Ar goal .
-This option cannot be used when compiling more than one module.
+The type is written to the standard output or the file specified with
+a
+.Fl o
+option. This option cannot be used when compiling more than one
+module.
 .It Fl -debug
 Compile the program for use with the debugger. As object files
 compiled with
diff -u curry-0.9.11/cymake.in curry-0.9.11-classful/cymake.in
--- curry-0.9.11/cymake.in	2007-06-15 14:16:33.000000000 +0200
+++ curry-0.9.11-classful/cymake.in	2012-06-05 15:03:15.000000000 +0200
@@ -3,9 +3,9 @@
 #
 # Shell script for building Curry programs
 #
-# $Id: cymake.in 2230 2007-06-06 12:35:43Z wlux $
+# $Id: cymake.in 3077 2012-06-05 12:53:44Z wlux $
 #
-# Copyright (c) 2002-2007, Wolfgang Lux
+# Copyright (c) 2002-2012, Wolfgang Lux
 # See LICENSE for the full license.
 #
 
@@ -33,9 +33,12 @@
 verbose=
 cyc=$CYC
 cymk=$CURRY_PATH/cymk
+newer=$CURRY_PATH/newer
+progress=${CURRY_CYMAKE_PROGRESS-:}
 mkopts=
 cyopts=
 ldopts=
+linkAlways=
 goal=
 typeIt=
 output=
@@ -48,7 +51,27 @@
 temps=
 
 # Functions
-noecho ( ) { return 0; }
+quote1 ( ) {
+  case $1 in
+    *\'* )
+      sed "s/'/'\\\\''/g;1s/^/'/;\$s/$/'/" <<EOF
+$1
+EOF
+      ;;
+    * ) printf "'%s'" "$1";;
+  esac
+}
+
+quote ( ) {
+  res=
+  for arg in "$@"; do
+    case $arg in
+      *\'* ) res="$res${res:+ }"`quote1 "$arg"`;;
+      * ) res="$res${res:+ }'$arg'";;
+    esac
+  done
+  echo "$res"
+}
 
 check_source ( ) {
   stem=`expr "$1" : '\(.*\)'$2`
@@ -60,7 +83,12 @@
 }
 
 remove ( ) {
+  case $f in	## Dirty trick to remove the correct executable with -o FILENAME
+    *.curry | *.lcurry | *.o ) target=;;
+    * ) target=$f;;
+  esac
   for f in "$@"; do
+    if test "$target" = "$f" && test -n "$output"; then f=$output; fi
     if test -f "$f"; then
       $echo rm -f "$f"
       $exec rm -f "$f"
@@ -69,20 +97,38 @@
 }
 
 compile ( ) {
-  $echo $cyc $cyopts "$@"
-  $exec $cyc $cyopts "$@"
+  i=$1 n=$2 source=$3 interf=$4 object=$5; shift 5
+  if test -f "$interf" && "$newer" "$object" "$source" "$@"; then
+    $progress $i $n skipping "$source"
+  else
+    $progress $i $n compiling "$source"
+    source=`quote1 "$source"` object=`quote1 "$object"`
+    eval $echo "$cyc" "$cyopts" -c "$source" -o "$object"
+    eval $exec "$cyc" "$cyopts" -c "$source" -o "$object" || exit $?
+  fi
 }
 
 link ( ) {
+  if test -n "$output"; then target=$output; else target=$3; fi;
+  i=$1 n=$2; shift 3; objs=`quote "$@"`
   if test -n "$goal"; then
-    $echo $cyc $cyopts $ldopts -e "$goal" "$@" $libs
-    $exec $cyc $cyopts $ldopts -e "$goal" "$@" $libs
+    $progress $i $n linking "$target"
+    goal=`quote1 "$goal"` target=`quote1 "$target"`
+    eval $echo "$cyc" "$cyopts" "$ldopts" -e "\\\"$goal\\\"" -o "$target" "$objs" "$libs"
+    eval $exec "$cyc" "$cyopts" "$ldopts" -e "$goal" -o "$target" "$objs" "$libs" || exit $?
   elif test -n "$typeIt"; then
-    $echo $cyc $cyopts -T "$typeIt" "$@"
-    $exec $cyc $cyopts -T "$typeIt" "$@"
+    $progress $i $n linking ""
+    if test -n "$output"; then objs="-o "`quote1 "$output"`" $objs"; shift; fi
+    typeIt=`quote1 "$typeIt"`
+    eval $echo "$cyc" "$cyopts" -T "\\\"$typeIt\\\"" "$objs"
+    eval $exec "$cyc" "$cyopts" -T "$typeIt" "$objs" || exit $?
+  elif test -z "$linkAlways" && "$newer" "$target" "$@"; then
+    $progress $i $n skipping ""
   else
-    $echo $cyc $cyopts $ldopts "$@" $libs
-    $exec $cyc $cyopts $ldopts "$@" $libs
+    $progress $i $n linking "$target"
+    target=`quote1 "$target"`
+    eval $echo "$cyc" "$cyopts" "$ldopts" -o "$target" "$objs" "$libs"
+    eval $exec "$cyc" "$cyopts" "$ldopts" -o "$target" "$objs" "$libs" || exit $?
   fi
 }
 
@@ -92,52 +138,58 @@
     # Overall options
     -M | --depend ) depend=$1;;
     -[cCS] ) echo 1>&2 "$cymake: unsupported option $1"; exit 1;;
-    -a ) mkopts="$mkopts $1";;
+    -a ) linkAlways="$1";;
     -e ) goal=$2; shift;;
-    -e* ) goal=`expr "$1" : '-e\(.*\)'`;;
+    -e* ) goal=`expr X"$1" : X'-e\(.*\)'`;;
     -T ) typeIt=$2; shift;;
-    -T* ) typeIt=`expr "$1" : '-T\(.*\)'`;;
+    -T* ) typeIt=`expr X"$1" : X'-T\(.*\)'`;;
     -g | --debug ) mkopts="$mkopts $1"; cyopts="$cyopts $1";;
     --clean ) clean=--clean;;
     --find ) find=--find;;
-    -o ) mkopts="$mkopts -o $2"; output="$2"; shift;;
-    -o* ) mkopts="$mkopts $1"; output=`expr "$1" : '-o\(.*\)'`;;
+    -o ) output="$2"; shift;;
+    -o* ) output=`expr X"$1" : X'-o\(.*\)'`;;
     -n ) exec=echo;;
+    -###) exec=quote;;
     -v ) verbose=-v; echo=echo cyopts="$cyopts -v";;
-    -q ) echo=noecho;;
+    -q ) echo=:;;
 
     # Include files and imported modules
-    -i | -P ) cyopts="$cyopts $1 $2"; imports="$imports $1 $2"; shift;;
-    -i* | -P* ) cyopts="$cyopts $1"; imports="$imports $1";;
+    -i | -P )
+      arg=`quote1 "$2"`; shift
+      cyopts="$cyopts $1 $arg"; imports="$imports $1 $arg";;
+    -i* | -P* )
+      arg=`quote1 "$1"`; cyopts="$cyopts $arg"; imports="$imports $arg";;
 
     # Linker options
-    -ldopt-* | -ldopts-* | --ldopt-* | --ldopts-* ) ldopts="$ldopts $1";;
-    -ldopt | -ldopts | --ldopt | --ldopts ) ldopts="$ldopts $1 $2"; shift;;
-    -L ) ldopts="$ldopts -L$2"; shift;;
-    -L* ) ldopts="$ldopts $1";;
-    -l ) libs="$libs -l$2"; shift;;
-    -l* ) libs="$libs $1";;
+    -ldopt-* | -ldopts-* | --ldopt-* | --ldopts-* )
+      ldopts="$ldopts "`quote1 "$1"`;;
+    -ldopt | -ldopts | --ldopt | --ldopts )
+      ldopts="$ldopts $1 "`quote1 "$2"`; shift;;
+    -[LR] ) ldopts="$ldopts $1"`quote1 "$2"`; shift;;
+    -[LR]* ) ldopts="$ldopts "`quote1 "$1"`;;
+    -l ) libs="$libs -l"`quote1 "$2"`; shift;;
+    -l* ) libs="$libs "`quote1 "$1"`;;
 
     # Pass all other flags to the Curry compiler
     # NB some options require an argument; must keep this list in sync with cyc
     -[DUIFhkt] | -cc | -ccopt | --ccopt | -ccopts | --ccopts | -arch | -framework )
-	 cyopts="$cyopts $1 $2"; shift;;
-    -* ) cyopts="$cyopts $1";;
+	 cyopts="$cyopts $1 "`quote1 "$2"`; shift;;
+    -* ) cyopts="$cyopts "`quote1 "$1"`;;
 
     +RTS )
 	shift
 	cyopts="$cyopts +RTS"
-	while test $# -gt 0 -a "$1" != "-RTS"; do
-	  cyopts="$cyopts $1";
+	while test $# -gt 0 && test "$1" != "-RTS"; do
+	  cyopts="$cyopts "`quote1 "$1"`;
 	  shift
 	done
 	cyopts="$cyopts -RTS";;
 
     # Pass archive files and shared libraries to the linker
-    *.a | *.so | *.dylib | *.dll ) libs="$libs $1";;
+    *.a | *.so | *.dylib | *.dll ) libs="$libs "`quote1 "$1"`;;
 
     # Save all files
-    * ) files="$files $1";;
+    * ) files="$files "`quote1 "$1"`;;
   esac
   shift
 done
@@ -146,10 +198,12 @@
   echo 1>&2 "$cymake: specify only one of -M, --clean, and --find"
   exit 1
 fi
+cyc=`quote1 "$cyc"`
+cymk=`quote1 "$cymk"`
 
 # Eventually display the compiler version
 test -n "$verbose" && echo 1>&2 "$cymake version $version (built on $build)"
-test "$exec" && verbose= echo=noecho
+test "$exec" && verbose= echo=:
 
 # Generate only dependencies if requested
 if test -n "$depend$find"; then
@@ -157,8 +211,10 @@
     echo 1>&2 "$cymake: no targets"
     exit 1
   fi
-  test -n "$verbose" && echo 1>&2 $cymk $depend $find $mkopts $imports $files
-  $exec $cymk $depend $find $mkopts $imports $files
+  test -n "$output" && mkopts="$mkopts -o "`quote1 "$output"`
+  test -n "$verbose" && \
+    eval echo 1>&2 "$cymk" $depend $find "$mkopts" "$imports" "$files"
+  eval $exec "$cymk" $depend $find "$mkopts" "$imports" "$files"
   exit $?
 fi
 
@@ -173,36 +229,37 @@
 trap 'rc=$?; rm -f /tmp/cymake$$; exit $rc' 0 1 2 3 15
 
 # Process all targets
-set dummy $files; shift
-if test -n "$output" -a $# -gt 1; then
+eval set dummy "$files"; shift
+if test -n "$output" && test $# -gt 1; then
   echo 1>&2 "$cymake: cannot specify -o with multiple targets"
   exit 1
 fi
-if test -n "$goal" -a $# -gt 1; then
+if test -n "$goal" && test $# -gt 1; then
   echo 1>&2 "$cymake: cannot specify -e with multiple targets"
   exit 1
 fi
-if test -n "$typeIt" -a $# -gt 1; then
+if test -n "$typeIt" && test $# -gt 1; then
   echo 1>&2 "$cymake: cannot specify -T with multiple targets"
   exit 1
 fi
-if test -n "$goal" -a -n "$typeIt"; then
+if test -n "$goal" && test -n "$typeIt"; then
   echo 1>&2 "$cymake: conflicting options -e and -T specified"
   exit 1
 fi
 
 
 if test $# -eq 0; then
-  test -n "$output" || output=a.out
   if test -n "$clean"; then
-    remove $output
+    test -n "$output" || output=a.out
+    remove "$output"
   else
-    link -o $output
+    link 1 1 a.out
   fi
   exit $?
 fi
 
-for f in $files; do
+eval set dummy "$files"; shift
+for f in "$@"; do
   suffixes=".lcurry .curry"
   case $f in
     *.curry ) suffix=.curry suffixes=.curry;;
@@ -211,11 +268,19 @@
     * ) suffix=;;
   esac
   check_source "$f" "$suffix" "$suffixes" || exit $?
-  test -n "$verbose" && echo 1>&2 $cymk $clean $mkopts $imports $f
-  $cymk $clean $mkopts $imports $f > /tmp/cymake$$
+  f=`quote1 "$f"`
+  if test -n "$goal$typeIt"; then
+    g=`quote1 "$goal$typeIt"`
+    test -n "$verbose" && \
+      eval echo 1>&2 "$cymk" $clean "$mkopts" -e "\\\"$g\\\"" "$imports" "$f"
+    eval "$cymk" $clean "$mkopts" -e "$g" -o /tmp/cymake$$ "$imports" "$f"
+  else
+    test -n "$verbose" && \
+      eval echo 1>&2 "$cymk" $clean "$mkopts" "$imports" "$f"
+    eval "$cymk" $clean "$mkopts" -o /tmp/cymake$$ "$imports" "$f"
+  fi
 
   . /tmp/cymake$$
-  set +e
 done
 
 # done
diff -u curry-0.9.11/cymk.hs curry-0.9.11-classful/cymk.hs
--- curry-0.9.11/cymk.hs	2007-06-15 14:16:35.000000000 +0200
+++ curry-0.9.11-classful/cymk.hs	2013-05-13 09:54:58.000000000 +0200
@@ -1,22 +1,23 @@
--- $Id: cymk.hs 2226 2007-06-01 15:58:58Z wlux $
+-- $Id: cymk.hs 3136 2013-05-12 15:53:27Z wlux $
 --
--- Copyright (c) 2002-2007, Wolfgang Lux
+-- Copyright (c) 2002-2013, Wolfgang Lux
 -- See LICENSE for the full license.
 
 import CurryDeps
 import GetOpt
+import IO
 import Maybe
 import Monad
-import IO
 import PathUtils
 import System
+import Utils
 
 data Options =
   Options{
     importPaths :: [(Bool,FilePath)],
     output :: Maybe FilePath,
+    goal :: Maybe String,
     debug :: Bool,
-    linkAlways :: Bool,
     mkDepend :: Bool,
     mkClean :: Bool,
     find :: Bool
@@ -26,8 +27,8 @@
   Options{
     importPaths = [],
     output = Nothing,
+    goal = Nothing,
     debug = False,
-    linkAlways = False,
     mkDepend = False,
     mkClean = False,
     find = False
@@ -35,12 +36,10 @@
 
 data Option =
     Help | ImportPath FilePath | LibPath FilePath | Output FilePath
-  | Debug | LinkAlways | Clean | Depend | Find
+  | Goal String | Debug | Clean | Depend | Find
   deriving Eq
 
 options = [
-    Option "a" ["link-always"] (NoArg LinkAlways)
-           "always relink the target file",
     Option "g" ["debug"] (NoArg Debug)
            "compile with debugging information",
     Option "i" ["import-dir"] (ReqArg ImportPath "DIR")
@@ -49,6 +48,8 @@
            "create Makefile dependencies for all targets",
     Option "o" ["output"] (ReqArg Output "FILE")
            "output goes to FILE",
+    Option "e" ["goal"] (ReqArg Goal "GOAL")
+           "executable evaluates GOAL",
     Option "P" ["lib-dir"] (ReqArg LibPath "DIR")
            "search for library interfaces in DIR",
     Option ""  ["clean"] (NoArg Clean)
@@ -64,8 +65,8 @@
 selectOption (LibPath dir) opts =
   opts{ importPaths = (False,dir) : importPaths opts }
 selectOption (Output file) opts = opts{ output = Just file }
+selectOption (Goal g) opts = opts{ goal = Just g }
 selectOption Debug opts = opts{ debug = True }
-selectOption LinkAlways opts = opts{ linkAlways = True }
 selectOption Depend opts = opts{ mkDepend = True }
 selectOption Clean opts = opts{ mkClean = True }
 selectOption Find opts = opts{ find = True }
@@ -75,8 +76,8 @@
   do
     prog <- getProgName
     args <- getArgs
-    importPath <- catch (getEnv "CURRY_IMPORT_PATH" >>= return . pathList)
-                        (const (return []))
+    importPath <- IO.catch (getEnv "CURRY_IMPORT_PATH" >>= return . pathList)
+                           (const (return []))
     cymk prog args importPath
 
 cymk :: String -> [String] -> [FilePath] -> IO ()
@@ -94,7 +95,7 @@
 printUsage prog =
   do
     putStrLn (usageInfo (unlines header) options)
-    exitWith (ExitSuccess)
+    exitWith ExitSuccess
   where header = ["usage: " ++ prog ++ " [OPTION]... MODULE ..."]
 
 badUsage :: String -> [String] -> IO ()
@@ -118,9 +119,5 @@
       do
         es <- fmap concat (mapM script files)
 	unless (null es) (mapM putErrLn es >> exitWith (ExitFailure 2))
-  where script = buildScript (mkClean opts) (debug opts) (linkAlways opts)
-			     (importPaths opts) (output opts)
-
-putErr, putErrLn :: String -> IO ()
-putErr = hPutStr stderr
-putErrLn = hPutStr stderr . (++ "\n")
+  where script = buildScript (mkClean opts) (debug opts) (importPaths opts)
+			     (goal opts) (output opts)
Solo in curry-0.9.11-classful/: _darcs.htm
Solo in curry-0.9.11-classful/: Deriving.lhs
diff -u curry-0.9.11/Desugar.lhs curry-0.9.11-classful/Desugar.lhs
--- curry-0.9.11/Desugar.lhs	2007-06-15 14:16:34.000000000 +0200
+++ curry-0.9.11-classful/Desugar.lhs	2013-01-04 10:23:16.000000000 +0100
@@ -1,213 +1,128 @@
 % -*- LaTeX -*-
-% $Id: Desugar.lhs 2182 2007-04-28 20:46:11Z wlux $
+% $Id: Desugar.lhs 3122 2013-01-03 17:14:00Z wlux $
 %
-% Copyright (c) 2001-2007, Wolfgang Lux
+% Copyright (c) 2001-2013, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{Desugar.lhs}
-\section{Desugaring Curry Expressions}
-The desugaring pass removes all syntactic sugar from the module. In
+\section{Desugaring Curry Expressions}\label{sec:desugar}
+The desugaring pass removes most syntactic sugar from the module. In
 particular, the output of the desugarer will have the following
 properties.
 \begin{itemize}
-\item No guarded right hand sides occur in equations, pattern
-  declarations, and case alternatives. In addition, the declaration
-  lists of the right hand sides are empty; local declarations are
-  transformed into let expressions.
-\item Patterns in equations and case alternatives are composed only of
+\item Patterns in equations and (f)case alternatives are composed of only
   \begin{itemize}
   \item literals,
   \item variables,
-  \item constructor applications, and
-  \item as patterns.
+  \item constructor applications,
+  \item function applications (function patterns),
+  \item record patterns,
+  \item as-patterns, and
+  \item lazy patterns.
   \end{itemize}
-\item Expressions are composed only of
+\item Expressions are composed of only
   \begin{itemize}
   \item literals,
   \item variables,
   \item constructors,
+  \item record constructions and updates,
   \item (binary) applications,
+  \item lambda abstractions,
   \item let expressions, and
-  \item case expressions.
+  \item (f)case expressions.
   \end{itemize}
-\item Patterns in case expression are restricted further in that all
-  arguments of a constructor pattern are variable patterns.
-\item Applications $N\:x$ in patterns and expressions, where $N$ is a
-  newtype constructor, are replaced by a $x$. Note that neither the
-  newtype declaration itself nor partial applications of newtype
-  constructors are changed.\footnote{It were possible to replace
-  partial applications of newtype constructor by \texttt{Prelude.id}.
-  However, our solution yields a more accurate output when the result
-  of a computation includes partial applications.}
 \end{itemize}
+Note that some syntactic sugar remains. In particular, we do not
+replace boolean guards by if-then-else cascades and we do not
+transform where clauses into let expressions. Both will happen only
+after flattening patterns in case expressions, as this allows us to
+handle the fall through behavior of boolean guards in case expressions
+without introducing a special pattern match failure primitive (see
+Sect.~\ref{sec:flatcase}). We also do not desugar lazy patterns and
+the record syntax here. These are taken care of by ensuing compiler
+phases.
 
-\ToDo{Use a different representation for the restricted code instead
-of using the syntax tree from \texttt{CurrySyntax}.}
-
-\textbf{As we are going to insert references to real prelude entities,
+\textbf{As we are going to insert references to real Prelude entities,
 all names must be properly qualified before calling this module.}
 \begin{verbatim}
 
-> module Desugar(desugar,goalModule) where
+> module Desugar(desugar) where
 > import Base
 > import Combined
+> import Curry
+> import CurryUtils
 > import List
 > import Monad
-> import TopEnv
+> import PredefIdent
+> import PredefTypes
+> import Ratio
+> import Types
 > import Typing
-> import Utils
-
-\end{verbatim}
-New identifiers may be introduced while desugaring pattern
-declarations, case and $\lambda$-expressions, and list comprehensions.
-As usual, we use a state monad transformer for generating unique
-names. In addition, the state is also used for passing through the
-type environment, which must be augmented with the types of these new
-variables.
-\begin{verbatim}
-
-> type DesugarState a = StateT ValueEnv (ReaderT TCEnv (StateT Int Id)) a
-
-> run :: DesugarState a -> TCEnv -> ValueEnv -> a
-> run m tcEnv tyEnv = runSt (callRt (callSt m tyEnv) tcEnv) 1
 
 \end{verbatim}
-During desugaring, the compiler transforms constraint guards into case
-expressions matching the guards against the constructor
-\texttt{Success}, which is defined in the runtime system. Thus, the
-compiler assumes that the type \texttt{Success} is defined by
+New identifiers may be introduced while desugaring list
+comprehensions. As usual, we use a state monad transformer for
+generating unique names.
 \begin{verbatim}
-  data Success = Success
-\end{verbatim}
-Since the internal constructor \texttt{Success} occurs in the
-desugared code, its type is added to the type environment.
 
-Note that the definition of \texttt{Success} is not included in the
-prelude because the \texttt{Success} constructor would not be
-accessible in any module other than the prelude unless the constructor
-were also exported from the prelude. However, that would be
-incompatible with the Curry report, which deliberately defines
-\texttt{Success} as an abstract type.
-\begin{verbatim}
-
-> bindSuccess :: ValueEnv -> ValueEnv
-> bindSuccess = localBindTopEnv successId successCon
->   where successCon =
->           DataConstructor (qualify successId) 0 (polyType successType)
+> type DesugarState a = StateT Int Id a
 
 \end{verbatim}
 The desugaring phase keeps only the type, function, and value
-declarations of the module. As type declarations are not desugared and
-cannot occur in local declaration groups they are filtered out
-separately.
-
-Actually, the transformation is slightly more general than necessary,
-as it allows pattern and free variable declarations at the top-level
-of a module.
-\begin{verbatim}
-
-> desugar :: TCEnv -> ValueEnv -> Module -> (Module,ValueEnv)
-> desugar tcEnv tyEnv (Module m es is ds) = (Module m es is ds',tyEnv')
->   where (ds',tyEnv') = run (desugarModule m ds) tcEnv (bindSuccess tyEnv)
-
-> desugarModule :: ModuleIdent -> [TopDecl] -> DesugarState ([TopDecl],ValueEnv)
-> desugarModule m ds =
->   do
->     vds' <- desugarDeclGroup m [d | BlockDecl d <- vds]
->     tyEnv' <- fetchSt
->     return (tds ++ map BlockDecl vds',tyEnv')
->   where (tds,vds) = partition isTypeDecl ds
-
-\end{verbatim}
-Goals are desugared by converting them into a module containing just a
-single function declaration and desugaring the resulting module.
-Goals with type \texttt{IO \_} are executed directly by the runtime
-system. All other goals are evaluated under control of an interactive
-top-level, which displays the solutions of the goal and in particular
-the bindings of the free variables. For this reason, the free
-variables declared in the \texttt{where} clause of a goal are
-translated into free variables of the goal. In addition, the goal is
-transformed into a first order expression by performing a unification
-with another variable. Thus, a goal
-\begin{quote}
- \emph{expr}
- \texttt{where} $v_1$,\dots,$v_n$ \texttt{free}; \emph{decls}
-\end{quote}
-where no free variable declarations occur in \emph{decls} is
-translated into the function
-\begin{quote}
-  \emph{f} $v_0$ $v_1$ \dots{} $v_n$ \texttt{=}
-    $v_0$ \texttt{=:=} \emph{expr}
-    \texttt{where} \emph{decls}
-\end{quote}
-where $v_0$ is a fresh variable. This transformation is not performed
-when generating code for the declarative debugger since the debugging
-transformation will supply its own main function (see
-Sect.~\ref{sec:dtrans}).
-\begin{verbatim}
-
-> goalModule :: Bool -> ValueEnv -> ModuleIdent -> Ident -> Goal
->            -> (Maybe [Ident],Module,ValueEnv)
-> goalModule debug tyEnv m g (Goal p e ds)
->   | debug || isIO ty =
->       (Nothing,
->        mkModule m p g [] (Let ds e),
->        bindFun m g 0 (polyType ty) tyEnv)
->   | otherwise =
->       (Just vs,
->        mkModule m p g (v0:vs) (apply prelUnif [mkVar v0,e']),
->        bindFun m v0 0 (monoType ty) (bindFun m g n (polyType ty') tyEnv))
->   where ty = typeOf tyEnv e
->         v0 = anonId
->         (vs,e') = liftGoalVars (if null ds then e else Let ds e)
->         ty' = TypeArrow ty (foldr (TypeArrow . typeOf tyEnv) successType vs)
->         n = 1 + length vs
->         isIO (TypeConstructor tc [_]) = tc == qIOId
->         isIO _ = False
-
-> mkModule :: ModuleIdent -> Position -> Ident -> [Ident] -> Expression
->          -> Module
-> mkModule m p g vs e =
->    Module m Nothing [] [BlockDecl (funDecl p g (map VariablePattern vs) e)]
-
-> liftGoalVars :: Expression -> ([Ident],Expression)
-> liftGoalVars (Let ds e) = (concat [vs | FreeDecl _ vs <- vds],Let ds' e)
->   where (vds,ds') = partition isFreeDecl ds
-> liftGoalVars e = ([],e)
-
-\end{verbatim}
-Within a declaration group, all fixity declarations, type signatures
-and trust annotations are discarded. First, the patterns occurring in
-the left hand sides are desugared. Due to lazy patterns this may add
-further declarations to the group that must be desugared as well.
-\begin{verbatim}
-
-> desugarDeclGroup :: ModuleIdent -> [Decl] -> DesugarState [Decl]
-> desugarDeclGroup m ds =
->   do
->     dss' <- mapM (desugarDeclLhs m) (filter isValueDecl ds)
->     mapM (desugarDeclRhs m) (concat dss')
-
-> desugarDeclLhs :: ModuleIdent -> Decl -> DesugarState [Decl]
-> desugarDeclLhs m (PatternDecl p t rhs) =
->   do
->     (ds',t') <- desugarTerm m p [] t
->     dss' <- mapM (desugarDeclLhs m) ds'
->     return (PatternDecl p t' rhs : concat dss')
-> desugarDeclLhs _ d = return [d]
-
-\end{verbatim}
-The import entity specification of foreign functions using the
-\texttt{ccall} and \texttt{rawcall} calling conventions is expanded to
-always include the kind of the declaration (either \texttt{static} or
-\texttt{dynamic}) and the name of the imported function.
-\begin{verbatim}
-
-> desugarDeclRhs :: ModuleIdent -> Decl -> DesugarState Decl
-> desugarDeclRhs m (FunctionDecl p f eqs) =
->   liftM (FunctionDecl p f) (mapM (desugarEquation m) eqs)
-> desugarDeclRhs _ (ForeignDecl p cc s ie f ty) =
->   return (ForeignDecl p cc (s `mplus` Just Safe) (desugarImpEnt cc ie) f ty)
+declarations of the module. At the top-level of a module, we just
+desugar data constructor and type class and instance method
+declarations. The top-level function declarations are treated like a
+global declaration group.
+\begin{verbatim}
+
+> desugar :: Module QualType -> Module QualType
+> desugar (Module m es is ds) = Module m es is (runSt (desugarModule ds) 1)
+
+> desugarModule :: [TopDecl QualType] -> DesugarState [TopDecl QualType]
+> desugarModule ds =
+>   do
+>     tds' <- mapM desugarTopDecl tds
+>     vds' <- desugarDeclGroup [d | BlockDecl d <- vds]
+>     return (tds' ++ map BlockDecl vds')
+>   where (vds,tds) = partition isBlockDecl ds
+
+> desugarTopDecl :: TopDecl QualType -> DesugarState (TopDecl QualType)
+> desugarTopDecl (DataDecl p cx tc tvs cs clss) =
+>   return (DataDecl p cx tc tvs (map desugarConstrDecl cs) clss)
+>   where desugarConstrDecl (ConstrDecl p evs cx c tys) =
+>           ConstrDecl p evs cx c tys
+>         desugarConstrDecl (ConOpDecl p evs cx ty1 op ty2) =
+>           ConstrDecl p evs cx op [ty1,ty2]
+>         desugarConstrDecl (RecordDecl p evs cx c fs) =
+>           RecordDecl p evs cx c fs
+> desugarTopDecl (NewtypeDecl p cx tc tvs nc clss) =
+>   return (NewtypeDecl p cx tc tvs nc clss)
+> desugarTopDecl (TypeDecl p tc tvs ty) = return (TypeDecl p tc tvs ty)
+> desugarTopDecl (ClassDecl p cx cls tv ds) =
+>   liftM (ClassDecl p cx cls tv . (tds ++)) (desugarDeclGroup vds)
+>   where (tds,vds) = partition isTypeSig ds
+> desugarTopDecl (InstanceDecl p cx cls ty ds) =
+>   liftM (InstanceDecl p cx cls ty) (desugarDeclGroup ds)
+> desugarTopDecl (DefaultDecl p tys) = return (DefaultDecl p tys)
+> --desugarTopDecl (BlockDecl d) = return (BlockDecl d)
+
+\end{verbatim}
+Within a declaration group, all fixity declarations, type signatures,
+and trust annotations are discarded. The import entity specification
+of foreign function declarations using the \texttt{ccall} and
+\texttt{rawcall} calling conventions is expanded to always include the
+kind of the declaration (either \texttt{static} or \texttt{dynamic})
+and the name of the imported function.
+\begin{verbatim}
+
+> desugarDeclGroup :: [Decl QualType] -> DesugarState [Decl QualType]
+> desugarDeclGroup ds = mapM desugarDecl (filter isValueDecl ds)
+
+> desugarDecl :: Decl QualType -> DesugarState (Decl QualType)
+> desugarDecl (FunctionDecl p ty f eqs) =
+>   liftM (FunctionDecl p ty f) (mapM desugarEquation eqs)
+> desugarDecl (ForeignDecl p (cc,s,ie) ty f ty') =
+>   return (ForeignDecl p (cc,s `mplus` Just Safe,desugarImpEnt cc ie) ty f ty')
 >   where desugarImpEnt cc ie
 >           | cc == CallConvPrimitive = ie `mplus` Just (name f)
 >           | otherwise = Just (unwords (kind (maybe [] words ie)))
@@ -225,548 +140,368 @@
 >           | otherwise = [h,x]
 >         ident [h,amp,f] = [h,amp,f]
 >         ident _ = internalError "desugarImpEnt"
-> desugarDeclRhs m (PatternDecl p t rhs) =
->   liftM (PatternDecl p t) (desugarRhs m p rhs)
-> desugarDeclRhs _ (FreeDecl p vs) = return (FreeDecl p vs)
-
-> desugarEquation :: ModuleIdent -> Equation -> DesugarState Equation
-> desugarEquation m (Equation p lhs rhs) =
->   do
->     (ds',ts') <- mapAccumM (desugarTerm m p) [] ts
->     rhs' <- desugarRhs m p (addDecls ds' rhs)
->     return (Equation p (FunLhs f ts') rhs')
+> desugarDecl (PatternDecl p t rhs) =
+>   liftM2 (PatternDecl p) (desugarTerm t) (desugarRhs rhs)
+> desugarDecl (FreeDecl p vs) = return (FreeDecl p vs)
+
+> desugarEquation :: Equation QualType -> DesugarState (Equation QualType)
+> desugarEquation (Equation p lhs rhs) =
+>   liftM2 (Equation p . FunLhs f) (mapM desugarTerm ts) (desugarRhs rhs)
 >   where (f,ts) = flatLhs lhs
 
 \end{verbatim}
-The transformation of patterns is straight forward except for lazy
-patterns. A lazy pattern \texttt{\~}$t$ is replaced by a fresh
-variable $v$ and a new local declaration $t$~\texttt{=}~$v$ in the
-scope of the pattern. In addition, as-patterns $v$\texttt{@}$t$ where
-$t$ is a variable or an as-pattern are replaced by $t$ in combination
-with a local declaration for $v$.
-\begin{verbatim}
-
-> desugarLiteral :: Literal -> DesugarState (Either Literal [Literal])
-> desugarLiteral (Char c) = return (Left (Char c))
-> desugarLiteral (Int v i) = liftM (Left . fixType) fetchSt
->   where fixType tyEnv
->           | typeOf tyEnv v == floatType = Float (fromIntegral i) 
->           | otherwise = Int v i
-> desugarLiteral (Float f) = return (Left (Float f))
-> desugarLiteral (String cs) = return (Right (map Char cs))
-
-> desugarTerm :: ModuleIdent -> Position -> [Decl] -> ConstrTerm
->             -> DesugarState ([Decl],ConstrTerm)
-> desugarTerm m p ds (LiteralPattern l) =
->   desugarLiteral l >>=
->   either (return . (,) ds . LiteralPattern)
->          (desugarTerm m p ds . ListPattern . map LiteralPattern)
-> desugarTerm m p ds (NegativePattern _ l) =
->   desugarTerm m p ds (LiteralPattern (negateLiteral l))
->   where negateLiteral (Int v i) = Int v (-i)
->         negateLiteral (Float f) = Float (-f)
->         negateLiteral _ = internalError "negateLiteral"
-> desugarTerm _ _ ds (VariablePattern v) = return (ds,VariablePattern v)
-> desugarTerm m p ds (ConstructorPattern c [t]) =
->   do
->     tyEnv <- fetchSt
->     liftM (if isNewtypeConstr tyEnv c then id else apSnd (constrPat c))
->           (desugarTerm m p ds t)
->   where constrPat c t = ConstructorPattern c [t]
-> desugarTerm m p ds (ConstructorPattern c ts) =
->   liftM (apSnd (ConstructorPattern c)) (mapAccumM (desugarTerm m p) ds ts)
-> desugarTerm m p ds (InfixPattern t1 op t2) =
->   desugarTerm m p ds (ConstructorPattern op [t1,t2])
-> desugarTerm m p ds (ParenPattern t) = desugarTerm m p ds t
-> desugarTerm m p ds (TuplePattern ts) =
->   desugarTerm m p ds (ConstructorPattern (qTupleId (length ts)) ts)
-> desugarTerm m p ds (ListPattern ts) =
->   liftM (apSnd (foldr cons nil)) (mapAccumM (desugarTerm m p) ds ts)
->   where nil = ConstructorPattern qNilId []
->         cons t ts = ConstructorPattern qConsId [t,ts]
-> desugarTerm m p ds (AsPattern v t) =
->   liftM (desugarAs p v) (desugarTerm m p ds t)
-> desugarTerm m p ds (LazyPattern t) = desugarLazy m p ds t
-
-> desugarAs :: Position -> Ident -> ([Decl],ConstrTerm) -> ([Decl],ConstrTerm)
-> desugarAs p v (ds,t) =
->  case t of
->    VariablePattern v' -> (varDecl p v (mkVar v') : ds,t)
->    AsPattern v' _ -> (varDecl p v (mkVar v') : ds,t)
->    _ -> (ds,AsPattern v t)
-
-> desugarLazy :: ModuleIdent -> Position -> [Decl] -> ConstrTerm
->             -> DesugarState ([Decl],ConstrTerm)
-> desugarLazy m p ds t =
->   case t of
->     VariablePattern _ -> return (ds,t)
->     ParenPattern t' -> desugarLazy m p ds t'
->     AsPattern v t' -> liftM (desugarAs p v) (desugarLazy m p ds t')
->     LazyPattern t' -> desugarLazy m p ds t'
->     _ ->
->       do
->         v' <- freshVar m "_#lazy" t
->         return (patDecl p t (mkVar v') : ds,VariablePattern v')
-
-\end{verbatim}
-A list of boolean guards is expanded into a nested if-then-else
-expression, whereas a constraint guard is replaced by a case
-expression. Note that if the guard type is \texttt{Success} only a
-single guard is allowed for each equation.\footnote{This change was
-introduced in version 0.8 of the Curry report.} We check for the
-type \texttt{Bool} of the guard because the guard's type defaults to
-\texttt{Success} if it is not restricted by the guard expression.
+We expand each string literal in a pattern or expression into a list
+of characters.
 \begin{verbatim}
 
-> desugarRhs :: ModuleIdent -> Position -> Rhs -> DesugarState Rhs
-> desugarRhs m p rhs =
->   do
->     tyEnv <- fetchSt
->     e' <- desugarExpr m p (expandRhs tyEnv prelFailed rhs)
->     return (SimpleRhs p e' [])
-
-> expandRhs :: ValueEnv -> Expression -> Rhs -> Expression
-> expandRhs tyEnv _ (SimpleRhs _ e ds) = Let ds e
-> expandRhs tyEnv e0 (GuardedRhs es ds) = Let ds (expandGuards tyEnv e0 es)
-
-> expandGuards :: ValueEnv -> Expression -> [CondExpr] -> Expression
-> expandGuards tyEnv e0 es
->   | booleanGuards tyEnv es = foldr mkIfThenElse e0 es
->   | otherwise = mkCase es
->   where mkIfThenElse (CondExpr _ g e) = IfThenElse g e
->         mkCase [CondExpr p g e] = Case g [caseAlt p successPattern e]
-
-> booleanGuards :: ValueEnv -> [CondExpr] -> Bool
-> booleanGuards _ [] = False
-> booleanGuards tyEnv (CondExpr _ g _ : es) =
->   not (null es) || typeOf tyEnv g == boolType
-
-> desugarExpr :: ModuleIdent -> Position -> Expression
->             -> DesugarState Expression
-> desugarExpr m p (Literal l) =
->   desugarLiteral l >>=
->   either (return . Literal) (desugarExpr m p . List . map Literal)
-> desugarExpr _ _ (Variable v) = return (Variable v)
-> desugarExpr _ _ (Constructor c) = return (Constructor c)
-> desugarExpr m p (Paren e) = desugarExpr m p e
-> desugarExpr m p (Typed e _) = desugarExpr m p e
-> desugarExpr m p (Tuple es) =
->   liftM (apply (Constructor (qTupleId (length es))))
->         (mapM (desugarExpr m p) es)
-> desugarExpr m p (List es) = liftM (foldr cons nil) (mapM (desugarExpr m p) es)
->   where nil = Constructor qNilId
->         cons = Apply . Apply (Constructor qConsId)
-> desugarExpr m p (ListCompr e []) = desugarExpr m p (List [e])
-> desugarExpr m p (ListCompr e (q:qs)) = desugarQual m p q (ListCompr e qs)
-> desugarExpr m p (EnumFrom e) = liftM (Apply prelEnumFrom) (desugarExpr m p e)
-> desugarExpr m p (EnumFromThen e1 e2) =
->   liftM (apply prelEnumFromThen) (mapM (desugarExpr m p) [e1,e2])
-> desugarExpr m p (EnumFromTo e1 e2) =
->   liftM (apply prelEnumFromTo) (mapM (desugarExpr m p) [e1,e2])
-> desugarExpr m p (EnumFromThenTo e1 e2 e3) =
->   liftM (apply prelEnumFromThenTo) (mapM (desugarExpr m p) [e1,e2,e3])
-> desugarExpr m p (UnaryMinus op e) =
->   do
->     tyEnv <- fetchSt
->     liftM (Apply (unaryMinus op (typeOf tyEnv e))) (desugarExpr m p e)
->   where unaryMinus op ty
->           | op == minusId =
->               if ty == floatType then prelNegateFloat else prelNegate
->           | op == fminusId = prelNegateFloat
->           | otherwise = internalError "unaryMinus"
-> desugarExpr m p (Apply (Constructor c) e) =
->   do
->     tyEnv <- fetchSt
->     liftM (if isNewtypeConstr tyEnv c then id else (Apply (Constructor c)))
->           (desugarExpr m p e)
-> desugarExpr m p (Apply e1 e2) =
->   do
->     e1' <- desugarExpr m p e1
->     e2' <- desugarExpr m p e2
->     return (Apply e1' e2')
-> desugarExpr m p (InfixApply e1 op e2) =
->   do
->     op' <- desugarExpr m p (infixOp op)
->     e1' <- desugarExpr m p e1
->     e2' <- desugarExpr m p e2
+> desugarLiteralTerm :: QualType -> Literal
+>                    -> Either (ConstrTerm QualType) (ConstrTerm QualType)
+> desugarLiteralTerm ty (Char c) = Right (LiteralPattern ty (Char c))
+> desugarLiteralTerm ty (Integer i) =
+>   Right (LiteralPattern ty (fixLiteral (unqualType ty) i))
+>   where fixLiteral (TypeConstrained tys _) = fixLiteral (head tys)
+>         fixLiteral ty
+>           | ty == floatType = Rational . toRational
+>           | otherwise = Integer
+> desugarLiteralTerm ty (Rational r) = Right (LiteralPattern ty (Rational r))
+> desugarLiteralTerm ty (String cs) =
+>   Left (ListPattern ty (map (LiteralPattern ty' . Char) cs))
+>   where ty' = qualType (elemType (unqualType ty))
+
+> desugarTerm :: ConstrTerm QualType -> DesugarState (ConstrTerm QualType)
+> desugarTerm (LiteralPattern ty l) =
+>   either desugarTerm return (desugarLiteralTerm ty l)
+> desugarTerm (NegativePattern ty l) =
+>   desugarTerm (LiteralPattern ty (negateLiteral l))
+>   where negateLiteral (Integer i) = Integer (-i)
+>         negateLiteral (Rational r) = Rational (-r)
+>         negateLiteral _ = internalError "negateLiteral"
+> desugarTerm (VariablePattern ty v) = return (VariablePattern ty v)
+> desugarTerm (ConstructorPattern ty c ts) =
+>   liftM (ConstructorPattern ty c) (mapM desugarTerm ts)
+> desugarTerm (FunctionPattern ty f ts) =
+>   liftM (FunctionPattern ty f) (mapM desugarTerm ts)
+> desugarTerm (InfixPattern ty t1 op t2) = desugarTerm (desugarOp ty op [t1,t2])
+>   where desugarOp ty (InfixConstr _ op) = ConstructorPattern ty op
+>         desugarOp ty (InfixOp _ op) = FunctionPattern ty op
+> desugarTerm (ParenPattern t) = desugarTerm t
+> desugarTerm (RecordPattern ty c fs) =
+>   liftM (RecordPattern ty c) (mapM (desugarField desugarTerm) fs)
+> desugarTerm (TuplePattern ts) =
+>   desugarTerm (ConstructorPattern ty (qTupleId (length ts)) ts)
+>   where ty = qualType (tupleType (map typeOf ts))
+> desugarTerm (ListPattern ty ts) = liftM (foldr cons nil) (mapM desugarTerm ts)
+>   where nil = ConstructorPattern ty qNilId []
+>         cons t ts = ConstructorPattern ty qConsId [t,ts]
+> desugarTerm (AsPattern v t) = liftM (AsPattern v) (desugarTerm t)
+> desugarTerm (LazyPattern t) = liftM LazyPattern (desugarTerm t)
+
+\end{verbatim}
+Anonymous identifiers in expressions are replaced by an expression
+\texttt{let x free in x} where \texttt{x} is a fresh variable.
+However, we must be careful with this transformation because the
+compiler uses an anonymous identifier also for the name of the
+program's initial goal (cf.\ Sect.~\ref{sec:goals}). This variable
+must remain a free variable of the goal expression and therefore must
+not be replaced.
+\begin{verbatim}
+
+> desugarRhs :: Rhs QualType -> DesugarState (Rhs QualType)
+> desugarRhs (SimpleRhs p e ds) =
+>   do
+>     ds' <- desugarDeclGroup ds
+>     e' <- desugarExpr p e
+>     return (SimpleRhs p e' ds')
+> desugarRhs (GuardedRhs es ds) =
+>   do
+>     ds' <- desugarDeclGroup ds
+>     es' <- mapM desugarCondExpr es
+>     return (GuardedRhs es' ds')
+
+> desugarCondExpr :: CondExpr QualType -> DesugarState (CondExpr QualType)
+> desugarCondExpr (CondExpr p g e) =
+>   liftM2 (CondExpr p) (desugarExpr p g) (desugarExpr p e)
+
+> desugarLiteral :: QualType -> Literal
+>                -> Either (Expression QualType) (Expression QualType)
+> desugarLiteral ty (Char c) = Right (Literal ty (Char c))
+> desugarLiteral ty (Integer i) = Right (fixLiteral (unqualType ty) i)
+>   where fixLiteral (TypeConstrained tys _) = fixLiteral (head tys)
+>         fixLiteral ty'
+>           | ty' `elem` [intType,integerType] = Literal ty . Integer
+>           | ty' == floatType = Literal ty . Rational . fromInteger
+>           | ty' == rationalType = desugarRatio . fromInteger
+>           | otherwise =
+>               Apply (prelFromInteger (unqualType ty)) .
+>               Literal qualIntegerType . Integer
+> desugarLiteral ty (Rational r) = Right (fixLiteral (unqualType ty) r)
+>   where fixLiteral (TypeConstrained tys _) = fixLiteral (head tys)
+>         fixLiteral ty'
+>           | ty' == floatType = Literal ty . Rational
+>           | ty' == rationalType = desugarRatio
+>           | otherwise =
+>               Apply (prelFromRational (unqualType ty)) . desugarRatio
+> desugarLiteral ty (String cs) = Left (List ty (map (Literal ty' . Char) cs))
+>   where ty' = qualType (elemType (unqualType ty))
+
+> desugarRatio :: Rational -> Expression QualType
+> desugarRatio r =
+>   foldl applyToInteger (ratioConstr integerType) [numerator r,denominator r]
+>   where applyToInteger e = Apply e . Literal qualIntegerType . Integer
+
+> desugarExpr :: Position -> Expression QualType
+>             -> DesugarState (Expression QualType)
+> desugarExpr p (Literal ty l) =
+>   either (desugarExpr p) return (desugarLiteral ty l)
+> desugarExpr p (Variable ty v)
+>   -- NB The name of the initial goal is anonId (not renamed, cf. goalModule
+>   --    in module Goals) and must not be changed
+>   | isRenamed v' && unRenameIdent v' == anonId =
+>       do
+>         v'' <- freshVar "_#var" (unqualType ty)
+>         return (Let [FreeDecl p [uncurry FreeVar v'']] (uncurry mkVar v''))
+>   | otherwise = return (Variable ty v)
+>   where v' = unqualify v
+> desugarExpr _ (Constructor ty c) = return (Constructor ty c)
+> desugarExpr p (Paren e) = desugarExpr p e
+> desugarExpr p (Typed e _) = desugarExpr p e
+> desugarExpr p (Record ty c fs) =
+>   liftM (Record ty c) (mapM (desugarField (desugarExpr p)) fs)
+> desugarExpr p (RecordUpdate e fs) =
+>   liftM2 RecordUpdate
+>          (desugarExpr p e)
+>          (mapM (desugarField (desugarExpr p)) fs)
+> desugarExpr p (Tuple es) =
+>   liftM (apply (Constructor ty (qTupleId (length es))))
+>         (mapM (desugarExpr p) es)
+>   where ty = qualType (foldr TypeArrow (tupleType tys) tys)
+>         tys = map typeOf es
+> desugarExpr p (List ty es) = liftM (foldr cons nil) (mapM (desugarExpr p) es)
+>   where nil = Constructor ty qNilId
+>         cons = Apply . Apply (Constructor ty' qConsId)
+>         ty' = qualType (consType (elemType (unqualType ty)))
+> desugarExpr p (ListCompr e qs) = desugarListCompr e qs z >>= desugarExpr p
+>   where z = List (qualType (typeOf (ListCompr e qs))) []
+> desugarExpr p (EnumFrom e) =
+>   liftM (Apply (prelEnumFrom (typeOf e))) (desugarExpr p e)
+> desugarExpr p (EnumFromThen e1 e2) =
+>   liftM (apply (prelEnumFromThen (typeOf e1))) (mapM (desugarExpr p) [e1,e2])
+> desugarExpr p (EnumFromTo e1 e2) =
+>   liftM (apply (prelEnumFromTo (typeOf e1))) (mapM (desugarExpr p) [e1,e2])
+> desugarExpr p (EnumFromThenTo e1 e2 e3) =
+>   liftM (apply (prelEnumFromThenTo (typeOf e1)))
+>         (mapM (desugarExpr p) [e1,e2,e3])
+> desugarExpr p (UnaryMinus e) =
+>   liftM (Apply (prelNegate (typeOf e))) (desugarExpr p e)
+> desugarExpr p (Apply e1 e2) =
+>   liftM2 Apply (desugarExpr p e1) (desugarExpr p e2)
+> desugarExpr p (InfixApply e1 op e2) =
+>   do
+>     op' <- desugarExpr p (infixOp op)
+>     e1' <- desugarExpr p e1
+>     e2' <- desugarExpr p e2
 >     return (Apply (Apply op' e1') e2')
-> desugarExpr m p (LeftSection e op) =
+> desugarExpr p (LeftSection e op) =
 >   do
->     op' <- desugarExpr m p (infixOp op)
->     e' <- desugarExpr m p e
+>     op' <- desugarExpr p (infixOp op)
+>     e' <- desugarExpr p e
 >     return (Apply op' e')
-> desugarExpr m p (RightSection op e) =
->   do
->     op' <- desugarExpr m p (infixOp op)
->     e' <- desugarExpr m p e
->     return (Apply (Apply prelFlip op') e')
-> desugarExpr m p (Lambda ts e) =
+> desugarExpr p (RightSection op e) =
 >   do
->     f <- freshFun m "_#lambda" (length ts) (Lambda ts e)
->     desugarExpr m p (Let [funDecl p f ts e] (mkVar f))
-> desugarExpr m p (Let ds e) =
->   do
->     ds' <- desugarDeclGroup m ds
->     e' <- desugarExpr m p e
->     return (if null ds' then e' else Let ds' e')
-> desugarExpr m p (Do sts e) = desugarExpr m p (foldr desugarStmt e sts)
->   where desugarStmt (StmtExpr e) e' = apply prelBind_ [e,e']
->         desugarStmt (StmtBind t e) e' = apply prelBind [e,Lambda [t] e']
->         desugarStmt (StmtDecl ds) e' = Let ds e'
-> desugarExpr m p (IfThenElse e1 e2 e3) =
->   do
->     e1' <- desugarExpr m p e1
->     e2' <- desugarExpr m p e2
->     e3' <- desugarExpr m p e3
->     return (Case e1' [caseAlt p truePattern e2',caseAlt p falsePattern e3'])
-> desugarExpr m p (Case e alts) =
->   do
->     v <- freshVar m "_#case" (head ts)
->     e' <- desugarExpr m p e
->     liftM (mkCase m v e') 
->           (mapM (liftM fromAlt . desugarAltLhs m) alts >>=
->            desugarCase m id [v])
->   where ts = [t | Alt p t rhs <- alts]
->         fromAlt (Alt p t rhs) = (p,id,[t],rhs)
->         mkCase m v e (Case e' alts)
->           | mkVar v == e' && v `notElem` qfv m alts = Case e alts
->         mkCase _ v e e' = Let [varDecl p v e] e'
-
-\end{verbatim}
-Case expressions with nested patterns are transformed into nested case
-expressions where each expression uses only flat patterns. The
-algorithm used here is a variant of the algorithm used for
-transforming pattern matching of function heads into case expressions
-(see Sect.~\ref{sec:il-trans}). In contrast to the algorithm presented
-in Sect.~5 of~\cite{PeytonJones87:Book}, the code generated by our
-algorithm will not perform redundant matches. Furthermore, we do not
-need a special pattern match failure primitive and fatbar expressions
-in order to catch such failures. On the other hand, our algorithm can
-cause code duplication. We do not care about that because most pattern
-matching in Curry programs occurs in function heads and not in case
-expressions.
-
-The essential difference between pattern matching in case expressions
-and function heads is that in case expressions, alternatives are
-matched from top to bottom and evaluation commits to the first
-alternative with a matching pattern. As an extension, we support
-constraint and boolean guards in case expressions. If all boolean
-guards of an alternative fail, pattern matching continues with the
-next alternative as if the pattern did not match. No such fall-through
-behavior applies to constraint guards since it cannot be implemented
-without negation of constraints. For instance, the expression
-\begin{verbatim}
-  case x of
-    Left y | y >= 0 -> 1
-    Right z | z =/= 0.0 -> 2
-    _ -> 3
-\end{verbatim}
-reduces to 3 if \texttt{x} is bound to an application of \texttt{Left}
-to a negative number because pattern matching continues when the
-boolean guard \texttt{y >= 0} reduces to \texttt{False}. On the other
-hand, the case expression does not reduce to 3 if \texttt{x} is bound
-to \texttt{Right 0.0} because pattern matching does not continue after
-the constraint guard \texttt{z =/= 0.0} fails. Instead, the whole case
-expression fails in this case.
-
-Our algorithm scans the arguments of the first alternative from left
-to right until finding a literal or a constructor application. If such
-a position is found, the alternatives are partitioned into groups such
-that all alternatives in one group have a term with the same root at
-the selected position and all groups are defined by mutually distinct
-roots. Furthermore, alternatives with a variable pattern at the
-selected position are included in all groups, which causes the
-aforementioned code duplication, and the variables are replaced by a
-fresh instance of the pattern defining the group. If no such position
-is found, the first alternative is selected and the remaining
-alternatives are used in order to define a default (case) expression
-when the selected alternative is defined with a list of boolean
-guards.
-
-The algorithm also removes redundant default alternatives in case
-expressions. As a simple example, consider the expression
-\begin{verbatim}
-  case x of
-    Left y -> y
-    Right z -> z
-    _ -> undefined
-\end{verbatim}
-In this expression, the last alternative is never selected because the
-first two alternatives already match all terms of type
-\texttt{Either}. Since alternatives are partitioned according to the
-roots of the terms at the selected position, we only need to compare
-the number of groups of alternatives with the number of constructors
-of the matched expression's type in order to check whether the default
-pattern is redundant. This works also for characters and numbers, as
-there are no constructors associated with the corresponding types and,
-therefore, default alternatives are never considered redundant when
-matching against literals.
-
-Note that the default case may no longer be redundant if there are
-guarded alternatives, e.g.
-\begin{verbatim}
-  case x of
-    Left y | y > 0 -> y
-    Right z | z > 0 -> z
-    _ -> 0
-\end{verbatim}
-Nevertheless, we do not need to treat such case expressions
-differently with respect to the completeness test because the default
-case is duplicated into the \texttt{Left} and \texttt{Right}
-alternatives. Thus, the example is effectively transformed into
-\begin{verbatim}
-  case x of
-    Left y -> if y > 0 then y else 0
-    Right z -> if z > 0 then z else 0
-    _ -> 0
-\end{verbatim}
-where the default alternative is redundant.
-\begin{verbatim}
-
-> type Match = (Position,[ConstrTerm] -> [ConstrTerm],[ConstrTerm],Rhs)
-
-> pattern :: Ident -> ConstrTerm -> ConstrTerm
-> pattern v (LiteralPattern l) = AsPattern v (LiteralPattern (canon l))
->   where canon (Int _ i) = Int anonId i
->         canon l = l
-> pattern v (VariablePattern _) = VariablePattern v
-> pattern v (ConstructorPattern c ts) = AsPattern v (ConstructorPattern c ts')
->   where ts' = zipWith (const . VariablePattern) (repeat anonId) ts
-> pattern v (AsPattern _ t) = pattern v t
-
-> arguments :: ConstrTerm -> [ConstrTerm]
-> arguments (LiteralPattern _) = []
-> arguments (VariablePattern _) = []
-> arguments (ConstructorPattern _ ts) = ts
-> arguments (AsPattern _ t) = arguments t
-
-> bindVars :: Position -> Ident -> ConstrTerm -> Rhs -> Rhs
-> bindVars _ _ (LiteralPattern _) = id
-> bindVars p v (VariablePattern v')
->   | v /= v' = addDecls [varDecl p v' (mkVar v)]
->   | otherwise = id
-> bindVars _ _ (ConstructorPattern _ _) = id
-> bindVars p v (AsPattern v' t) =
->   addDecls [varDecl p v' (mkVar v)] . bindVars p v t
-
-> desugarAltLhs :: ModuleIdent -> Alt -> DesugarState Alt
-> desugarAltLhs m (Alt p t rhs) =
->   do
->     (ds',t') <- desugarTerm m p [] t
->     return (Alt p t' (addDecls ds' rhs))
+>     op' <- desugarExpr p (infixOp op)
+>     e' <- desugarExpr p e
+>     return (Apply (Apply (prelFlip ty1 ty2 ty3) op') e')
+>   where TypeArrow ty1 (TypeArrow ty2 ty3) = typeOf (infixOp op)
+> desugarExpr _ (Lambda p ts e) =
+>   liftM2 (Lambda p) (mapM desugarTerm ts) (desugarExpr p e)
+> desugarExpr p (Let ds e) = liftM2 Let (desugarDeclGroup ds) (desugarExpr p e)
+> desugarExpr p (Do sts e) = desugarStmts sts e (typeOf e) >>= desugarExpr p
+> desugarExpr p (IfThenElse e1 e2 e3) =
+>   liftM3 mkCase (desugarExpr p e1) (desugarExpr p e2) (desugarExpr p e3)
+>   where mkCase e1 e2 e3 =
+>           Case e1 [caseAlt p truePattern e2,caseAlt p falsePattern e3]
+> desugarExpr p (Case e as) = liftM2 Case (desugarExpr p e) (mapM desugarAlt as)
+> desugarExpr p (Fcase e as) =
+>   liftM2 Fcase (desugarExpr p e) (mapM desugarAlt as)
+
+> desugarAlt :: Alt QualType -> DesugarState (Alt QualType)
+> desugarAlt (Alt p t rhs) = liftM2 (Alt p) (desugarTerm t) (desugarRhs rhs)
+
+> desugarField :: (a -> DesugarState a) -> Field a -> DesugarState (Field a)
+> desugarField desugar (Field l e) = liftM (Field l) (desugar e)
+
+\end{verbatim}
+List comprehensions are desugared with the following optimized
+translation scheme, which constructs the denoted list with (nested)
+foldr applications.
+\begin{displaymath}
+  \newcommand{\semant}[2]{\mathcal{#1}[\![#2]\!]}
+  \renewcommand{\arraystretch}{1.2}
+  \begin{array}{r@{\;}c@{\;}l}
+    \semant{D}{\texttt{[$e$|$qs$]}} &=&
+      \semant{L}{\texttt{[$e$|$qs$]}}(\texttt{[]}) \\
+    \semant{L}{\texttt{[$e$|]}}(z) &=& \texttt{$e$:$z$} \\
+    \semant{L}{\texttt{[$e$|$b$,$qs$]}}(z) &=&
+      \hbox{\texttt{if} $b$ \texttt{then} $\semant{L}{\texttt{[$e$|$qs$]}}(z)$ \texttt{else} $z$} \\
+    \semant{L}{\texttt{[$e$|$t$<-$l$,$qs$]}}(z) &=&
+    \hbox{\texttt{foldr} \texttt{(\bs}$x$ $y$ \texttt{->} \texttt{case} $x$ \texttt{of} \texttt{\lb}
+          $t$ \texttt{->} $\semant{L}{\texttt{[$e$|$qs$]}}(y)$\texttt{;} \_ \texttt{->} $y$ \texttt{\rb)} $z$ $l$}\\
+     \textrm{where} & \multicolumn{2}{@{}l}{\textrm{$x$, $y$ are fresh identifiers}} \\
+    \semant{L}{\texttt{[$e$|let $ds$,$qs$]}}(z) &=&
+      \hbox{\texttt{let} $ds$ \texttt{in} $\semant{L}{\texttt{[$e$|$qs$]}}(z)$} \\
+  \end{array}
+\end{displaymath}
+Note that the transformation scheme uses a rigid case expression to
+match the pattern of a \texttt{$t$<-$l$} qualifier, which differs from
+the Curry report (cf.\ Sect.~5.2 in~\cite{Hanus:Report}). We use a
+rigid match here because it makes the translation scheme simpler,
+since we do not need to compute the set of patterns that are
+incompatible with $t$ and we do not need a special case for literal
+patterns. In addition, it looks dubious to have list comprehension
+qualifiers generate fresh instances of $t$ that do not contribute to
+the list at all.
+\begin{verbatim}
+
+> desugarListCompr :: Expression QualType -> [Statement QualType]
+>                  -> Expression QualType -> DesugarState (Expression QualType)
+> desugarListCompr e [] z =
+>   return (apply (Constructor (qualType (consType (typeOf e))) qConsId) [e,z])
+> desugarListCompr e (q:qs) z =
+>   desugarQual q z >>= \(y,f) -> desugarListCompr e qs y >>= return . f
+
+> desugarQual :: Statement QualType -> Expression QualType
+>             -> DesugarState (Expression QualType,
+>                              Expression QualType -> Expression QualType)
+> desugarQual (StmtExpr b) z = return (z,\e -> IfThenElse b e z)
+> desugarQual (StmtBind p t l) z =
+>   do
+>     x <- freshVar "_#var" (typeOf t)
+>     y <- freshVar "_#var" (typeOf z)
+>     return (uncurry mkVar y,
+>             \e -> apply (prelFoldr (unqualType (fst x)) (unqualType (fst y)))
+>                         [foldFunct x y e,z,l])
+>   where foldFunct v l e =
+>           Lambda p [uncurry VariablePattern v,uncurry VariablePattern l]
+>             (Case (uncurry mkVar v)
+>                   [caseAlt p t e,
+>                    caseAlt p (uncurry VariablePattern v) (uncurry mkVar l)])
+> desugarQual (StmtDecl ds) z = return (z,Let ds)
 
-> desugarAltRhs :: ModuleIdent -> Alt -> Expression -> DesugarState Expression
-> desugarAltRhs m (Alt p _ rhs) e0 =
->   do
->     tyEnv <- fetchSt
->     desugarExpr m p (expandRhs tyEnv e0 rhs)
-
-> desugarCase :: ModuleIdent -> ([Ident] -> [Ident]) -> [Ident] -> [Match]
->             -> DesugarState Expression
-> desugarCase _ _ _ [] = return prelFailed
-> desugarCase m prefix [] (alt : alts) =
->   desugarCase m id vs (map resetArgs alts) >>=
->   desugarAltRhs m (toAlt vs alt)
->   where vs = prefix []
->         resetArgs (p,prefix,ts,rhs) = (p,id,prefix ts,rhs)
->         toAlt vs (p,prefix,_,rhs) =
->           Alt p (VariablePattern anonId)
->               (foldr2 (bindVars p) rhs vs (prefix []))
-> desugarCase m prefix (v:vs) alts
->   | isVarPattern (fst (head alts')) =
->       if all isVarPattern (map fst (tail alts')) then
->         desugarCase m prefix vs (map dropArg alts)
->       else
->         desugarCase m (prefix . (v:)) vs (map skipArg alts)
->   | otherwise =
->       do
->         tcEnv <- liftSt envRt
->         tyEnv <- fetchSt
->         liftM (Case (mkVar v))
->               (mapM (desugarAlt m prefix vs alts')
->                     (if allCases tcEnv tyEnv v ts then ts else ts ++ ts'))
->   where alts' = map tagAlt alts
->         (ts',ts) = partition isVarPattern (nub (map fst alts'))
->         tagAlt (p,prefix,t:ts,rhs) =
->           (pattern v t,(p,prefix,t:ts,bindVars p v t rhs))
->         skipArg (p,prefix,t:ts,rhs) = (p,prefix . (t:),ts,rhs)
->         dropArg (p,prefix,t:ts,rhs) = (p,prefix,ts,bindVars p v t rhs)
->         allCases tcEnv tyEnv v ts = length cs == length ts
->           where TypeConstructor tc _ = fixType (typeOf tyEnv v)
->                 cs = constructors tc tcEnv
->         fixType (TypeConstrained (ty:_) _) = ty
->         fixType ty = ty
-
-> desugarAlt :: ModuleIdent -> ([Ident] -> [Ident]) -> [Ident]
->            -> [(ConstrTerm,Match)] -> ConstrTerm -> DesugarState Alt
-> desugarAlt m prefix vs alts t =
->   do
->     vs' <- mapM (freshVar m "_#case") (arguments t')
->     liftM (caseAlt (pos (snd (head alts')))
->                    (renameArgs vs' (fixLiteralType t' t)))
->           (desugarCase m id (prefix (vs' ++ vs))
->                        (map (expandArgs vs' . snd) alts'))
->   where alts' = filter (matchedBy t . fst) alts
->         t' = matchedArg (snd (head (filter ((t ==) . fst) alts')))
->         t1 `matchedBy` t2 = t1 == t2 || isVarPattern t2
->         pos (p,_,_,_) = p
->         matchedArg (_,_,t:_,_) = t
->         expandArgs vs (p,prefix,t:ts,rhs) =
->           (p,id,prefix (expandPatternArgs vs t ++ ts),rhs)
->         expandPatternArgs vs t
->           | isVarPattern t = map VariablePattern vs
->           | otherwise = arguments t
-
-> fixLiteralType :: ConstrTerm -> ConstrTerm -> ConstrTerm
-> fixLiteralType (LiteralPattern (Int v _)) (LiteralPattern (Int _ i)) =
->   LiteralPattern (Int v i)
-> fixLiteralType (AsPattern _ t1) t2 = fixLiteralType t1 t2
-> fixLiteralType t1 (AsPattern v t2) = AsPattern v (fixLiteralType t1 t2)
-> fixLiteralType _ t = t
-
-> renameArgs :: [Ident] -> ConstrTerm -> ConstrTerm
-> renameArgs _ (LiteralPattern l) = LiteralPattern l
-> renameArgs _ (VariablePattern v) = VariablePattern v
-> renameArgs vs (ConstructorPattern c _) =
->   ConstructorPattern c (map VariablePattern vs)
-> renameArgs vs (AsPattern v t) = AsPattern v (renameArgs vs t)
-
-\end{verbatim}
-In general, a list comprehension of the form
-\texttt{[}$e$~\texttt{|}~$t$~\texttt{<-}~$l$\texttt{,}~\emph{qs}\texttt{]}
-is transformed into an expression \texttt{foldr}~$f$~\texttt{[]}~$l$ where $f$
-is a new function defined as
+\end{verbatim}
+The do notation provides syntactic sugar for sequences of I/O
+actions. It is desugared according to the following rules.
 \begin{quote}
-  \begin{tabbing}
-    $f$ $x$ \emph{xs} \texttt{=} \\
-    \quad \= \texttt{case} $x$ \texttt{of} \\
-          \> \quad \= $t$ \texttt{->} \texttt{[}$e$ \texttt{|} \emph{qs}\texttt{]} \texttt{++} \emph{xs} \\
-          \>       \> \texttt{\_} \texttt{->} \emph{xs}
-  \end{tabbing}
+  \begin{tabular}{r@{ }c@{ }l}
+    \texttt{do} \texttt{\lb} \textit{expr} \texttt{\rb}
+    & $\leadsto$
+    & \textit{expr} \\
+    \texttt{do} \texttt{\lb} \textit{expr}\texttt{;} \textit{stmts} \texttt{\rb}
+    & $\leadsto$
+    & \textit{expr} \texttt{>>}
+      \texttt{do} \texttt{\lb} \textit{stmts} \texttt{\rb} \\
+    \texttt{do} \texttt{\lb} $p$ \texttt{<-} \textit{expr}\texttt{;}
+      \textit{stmts} \texttt{\rb}
+    & $\leadsto$
+    & \textit{expr} \texttt{>>=} \texttt{\bs}$z$ \texttt{->}
+      \texttt{case} $z$ \texttt{of} \texttt{\lb} \\
+    & & \quad \begin{tabular}[t]{@{}l@{ \texttt{->} }l}
+      $p$ & \texttt{do} \texttt{\lb} \textit{stmts} \texttt{\rb}\texttt{;} \\
+      \texttt{\_} & \texttt{Prelude.fail} \texttt{"$\dots$"}
+    \end{tabular} \\
+    & & \texttt{\rb} \\
+    where & \multicolumn{2}{@{}l}{$z$ is a fresh identifier} \\
+    \texttt{do} \texttt{\lb}
+      \texttt{let} \texttt{\lb} \textit{decls} \texttt{\rb}\texttt{;}
+      \textit{stmts} \texttt{\rb}
+    & $\leadsto$
+    & \texttt{let} \texttt{\lb} \textit{decls} \texttt{\rb} \texttt{in}
+      \texttt{do} \texttt{\lb} \textit{stmts} \texttt{\rb} \\
+  \end{tabular}
 \end{quote}
-Note that this translation evaluates the elements of $l$ rigidly,
-whereas the translation given in the Curry report is flexible.
-However, it does not seem very useful to have the comprehension
-generate instances of $t$ which do not contribute to the list.
-
-Actually, we generate slightly better code in a few special cases.
-When $t$ is a plain variable, the \texttt{case} expression degenerates
-into a let-binding and the auxiliary function thus becomes an alias
-for \texttt{(++)}. Instead of \texttt{foldr~(++)} we use the
-equivalent prelude function \texttt{concatMap}. In addition, if the
-remaining list comprehension in the body of the auxiliary function has
-no qualifiers -- i.e., if it is equivalent to \texttt{[$e$]} -- we
-avoid the construction of the singleton list by calling \texttt{(:)}
-instead of \texttt{(++)} and \texttt{map} in place of
-\texttt{concatMap}, respectively.
-\begin{verbatim}
-
-> desugarQual :: ModuleIdent -> Position -> Statement -> Expression
->             -> DesugarState Expression
-> desugarQual m p (StmtExpr b) e = desugarExpr m p (IfThenElse b e (List []))
-> desugarQual m p (StmtBind t l) e
->   | isVarPattern t = desugarExpr m p (qualExpr t e l)
->   | otherwise =
->       do
->         tyEnv <- fetchSt
->         v <- freshVar m "_#var" t
->         l' <- freshVar m "_#var" e
->         desugarExpr m p (apply prelFoldr [foldFunct v l' e,List [],l])
->   where qualExpr v (ListCompr e []) l = apply prelMap [Lambda [v] e,l]
->         qualExpr v e l = apply prelConcatMap [Lambda [v] e,l]
->         foldFunct v l e =
->           Lambda (map VariablePattern [v,l])
->             (Case (mkVar v)
->                   [caseAlt p t (append e (mkVar l)),
->                    caseAlt p (VariablePattern v) (mkVar l)])
->         append (ListCompr e []) l = apply (Constructor qConsId) [e,l]
->         append e l = apply prelAppend [e,l]
-> desugarQual m p (StmtDecl ds) e = desugarExpr m p (Let ds e)
-
-\end{verbatim}
-Generation of fresh names
-\begin{verbatim}
-
-> freshIdent :: ModuleIdent -> String -> Int -> TypeScheme -> DesugarState Ident
-> freshIdent m prefix n ty =
->   do
->     x <- liftM (mkName prefix) (liftSt (liftRt (updateSt (1 +))))
->     updateSt_ (bindFun m x n ty)
->     return x
->   where mkName pre n = mkIdent (pre ++ show n)
-
-> freshVar :: Typeable a => ModuleIdent -> String -> a -> DesugarState Ident
-> freshVar m prefix x =
->   do
->     tyEnv <- fetchSt
->     freshIdent m prefix 0 (monoType (typeOf tyEnv x))
-
-> freshFun :: Typeable a => ModuleIdent -> String -> Int -> a
->          -> DesugarState Ident
-> freshFun m prefix n x =
->   do
->     tyEnv <- fetchSt
->     freshIdent m prefix n (polyType (typeOf tyEnv x))
-
-\end{verbatim}
-Prelude entities
-\begin{verbatim}
-
-> prelUnif = Variable $ preludeIdent "=:="
-> prelBind = Variable $ preludeIdent ">>="
-> prelBind_ = Variable $ preludeIdent ">>"
-> prelFlip = Variable $ preludeIdent "flip"
-> prelEnumFrom = Variable $ preludeIdent "enumFrom"
-> prelEnumFromTo = Variable $ preludeIdent "enumFromTo"
-> prelEnumFromThen = Variable $ preludeIdent "enumFromThen"
-> prelEnumFromThenTo = Variable $ preludeIdent "enumFromThenTo"
-> prelFailed = Variable $ preludeIdent "failed"
-> prelMap = Variable $ preludeIdent "map"
-> prelFoldr = Variable $ preludeIdent "foldr"
-> prelAppend = Variable $ preludeIdent "++"
-> prelConcatMap = Variable $ preludeIdent "concatMap"
-> prelNegate = Variable $ preludeIdent "negate"
-> prelNegateFloat = Variable $ preludeIdent "negateFloat"
-
-> truePattern = ConstructorPattern qTrueId []
-> falsePattern = ConstructorPattern qFalseId []
-> successPattern = ConstructorPattern (qualify successId) []
-
-> preludeIdent :: String -> QualIdent
-> preludeIdent = qualifyWith preludeMIdent . mkIdent
-
-\end{verbatim}
-Auxiliary definitions
-\begin{verbatim}
-
-> isVarPattern :: ConstrTerm -> Bool
-> isVarPattern (VariablePattern _) = True
-> isVarPattern (ParenPattern t) = isVarPattern t
-> isVarPattern (AsPattern _ t) = isVarPattern t
-> isVarPattern (LazyPattern _) = True
-> isVarPattern _ = False
-
-> funDecl :: Position -> Ident -> [ConstrTerm] -> Expression -> Decl
-> funDecl p f ts e =
->   FunctionDecl p f [Equation p (FunLhs f ts) (SimpleRhs p e [])]
-
-> patDecl :: Position -> ConstrTerm -> Expression -> Decl
-> patDecl p t e = PatternDecl p t (SimpleRhs p e [])
-
-> varDecl :: Position -> Ident -> Expression -> Decl
-> varDecl p = patDecl p . VariablePattern
-
-> addDecls :: [Decl] -> Rhs -> Rhs
-> addDecls ds (SimpleRhs p e ds') = SimpleRhs p e (ds ++ ds')
-> addDecls ds (GuardedRhs es ds') = GuardedRhs es (ds ++ ds')
-
-> caseAlt :: Position -> ConstrTerm -> Expression -> Alt
-> caseAlt p t e = Alt p t (SimpleRhs p e [])
-
-> apply :: Expression -> [Expression] -> Expression
-> apply = foldl Apply
-
-> mkVar :: Ident -> Expression
-> mkVar = Variable . qualify
+Note that our translation of bindings statements $p$ \texttt{<-}
+\textit{expr} uses a rigid case expression to match the pattern $p$,
+which once again differs from the Curry report (cf.\ Sect.~7.2
+in~\cite{Hanus:Report}). The advantage of our translation scheme is
+that it allows catching match failures as in Haskell.
+\begin{verbatim}
+
+> desugarStmts :: [Statement QualType] -> Expression QualType -> Type
+>              -> DesugarState (Expression QualType)
+> desugarStmts [] e _ = return e
+> desugarStmts (st:sts) e ty =
+>   desugarStmt st ty >>= \f -> desugarStmts sts e ty >>= return . f
+
+> desugarStmt :: Statement QualType -> Type
+>             -> DesugarState (Expression QualType -> Expression QualType)
+> desugarStmt (StmtExpr e) ty =
+>   return (\e' -> apply (prelBind_ (typeOf e) ty) [e,e'])
+> desugarStmt (StmtBind p t e) ty =
+>   do
+>     z <- freshVar "_#var" (typeOf t)
+>     return (\e' -> apply (prelBind (typeOf e) (unqualType (fst z)) ty)
+>                          [e,bindFunct z e'])
+>   where bindFunct v e =
+>           Lambda p [uncurry VariablePattern v]
+>             (Case (uncurry mkVar v)
+>                   [caseAlt p t e,
+>                    caseAlt p (uncurry VariablePattern v) (failedMatch ty)])
+>         failedMatch ty =
+>           apply (prelFail ty) 
+>                 [Literal (qualType stringType) (String "match failed")]
+> desugarStmt (StmtDecl ds) _ = return (Let ds)
+
+\end{verbatim}
+Generation of fresh names.
+\begin{verbatim}
+
+> freshVar :: String -> Type -> DesugarState (QualType,Ident)
+> freshVar prefix ty =
+>   do
+>     v <- liftM (mkName prefix) (updateSt (1 +))
+>     return (qualType ty,v)
+>   where mkName pre n = renameIdent (mkIdent (pre ++ show n)) n
+
+\end{verbatim}
+Prelude entities.
+\begin{verbatim}
+
+> prelFromInteger a = preludeFun [integerType] a "fromInteger"
+> prelFromRational a = preludeFun [rationalType] a "fromRational"
+> prelBind ma a mb = preludeFun [ma,a `TypeArrow` mb] mb ">>="
+> prelBind_ ma mb = preludeFun [ma,mb] mb ">>"
+> prelFail ma = preludeFun [stringType] ma "fail"
+> prelFlip a b c = preludeFun [a `TypeArrow` (b `TypeArrow` c),b,a] c "flip"
+> prelEnumFrom a = preludeFun [a] (listType a) "enumFrom"
+> prelEnumFromTo a = preludeFun [a,a] (listType a) "enumFromTo"
+> prelEnumFromThen a = preludeFun [a,a] (listType a) "enumFromThen"
+> prelEnumFromThenTo a = preludeFun [a,a,a] (listType a) "enumFromThenTo"
+> prelFoldr a b =
+>   preludeFun [a `TypeArrow` (b `TypeArrow` b),b,listType a] b "foldr"
+> prelNegate a = preludeFun [a] a "negate"
+
+> preludeFun :: [Type] -> Type -> String -> Expression QualType
+> preludeFun tys ty f =
+>   Variable (qualType (foldr TypeArrow ty tys))
+>            (qualifyWith preludeMIdent (mkIdent f))
+
+> ratioConstr :: Type -> Expression QualType
+> ratioConstr ty =
+>   Constructor (qualType (TypeArrow ty (TypeArrow ty (ratioType ty))))
+>               (qualifyWith ratioMIdent (mkIdent ":%"))
+
+> truePattern, falsePattern :: ConstrTerm QualType
+> truePattern = ConstructorPattern qualBoolType qTrueId []
+> falsePattern = ConstructorPattern qualBoolType qFalseId []
+
+\end{verbatim}
+Auxiliary definitions.
+\begin{verbatim}
+
+> consType :: Type -> Type
+> consType a = TypeArrow a (TypeArrow (listType a) (listType a))
+
+> elemType :: Type -> Type
+> elemType (TypeApply (TypeConstructor tc) ty) | tc == qListId = ty
+> elemType ty = internalError ("elemType " ++ show ty)
 
 \end{verbatim}
Solo in curry-0.9.11-classful/: DictTrans.lhs
Sottodirectory in comune: curry-0.9.11/doc e curry-0.9.11-classful/doc
Solo in curry-0.9.11-classful/: doc.htm
diff -u curry-0.9.11/DTransform.lhs curry-0.9.11-classful/DTransform.lhs
--- curry-0.9.11/DTransform.lhs	2007-06-15 14:16:34.000000000 +0200
+++ curry-0.9.11-classful/DTransform.lhs	2011-10-08 12:42:57.000000000 +0200
@@ -1,8 +1,8 @@
 % -*- LaTeX -*-
-% $Id: DTransform.lhs 2155 2007-04-19 09:38:44Z wlux $
+% $Id: DTransform.lhs 3056 2011-10-07 16:27:03Z wlux $
 %
 % Copyright (c) 2001-2002, Rafael Caballero
-% Copyright (c) 2003-2007, Wolfgang Lux
+% Copyright (c) 2003-2011, Wolfgang Lux
 %
 % 2002/04/10 19:00:00 Added emptyNode as constructor in type cTree
 \nwfilename{DTransform.lhs}
@@ -20,15 +20,15 @@
 \begin{verbatim}
 
 > module DTransform(dTransform, dAddMain) where
-> import Ident
-> import Maybe
-> import List
 > import IL
+> import List
+> import Maybe
+> import PredefIdent
 
 \end{verbatim}
 
 All the new and auxiliary names in the transformed module will have 
-{\tt debugPrefix}
+\texttt{debugPrefix}
 prefix to avoid conflicts with user-names. Auxiliary data types and functions
 will be imported from the debug prelude, whose name is defined below, and that
 will be imported by all the transformed modules.
@@ -40,7 +40,6 @@
 > debugFunctionName   =  "startDebugging"
 > debugIOFunctionName =  "startIODebugging"
 
-
 \end{verbatim}
 
 Next is the principal  function of the module. The argument function
@@ -52,112 +51,100 @@
 \begin{verbatim}
 
 > dTransform :: (QualIdent -> Bool) -> Module -> Module
-> dTransform trusted (Module m is ds) = Module m (i:is) (debugDecls m trusted ds)
->       where 
->       i   =  debugPreludeModule
+> dTransform trusted (Module m es is ds) =
+>   Module m es' is' (ds' ++ generateAuxFuncs m (numAuxFuncs m ds'))
+>   where ms = m:is
+>         es' = map (debugRenameExport (constrs ds)) es
+>         is' = imp preludeMIdent ++ imp debugPreludeMIdent ++ is
+>         ds' = debugDecls trusted m ds
+>         imp m = [m | m `notElem` ms]
+>         constrs ds = [c | DataDecl _ _ cs <- ds, ConstrDecl c _ <- cs]
+>         debugRenameExport cs x = if x `elem` cs then x else debugRenameqId x
 
 \end{verbatim}
 
-We can divide the declarations in the transformed program in five different
-groups:
-\begin{itemize}
-\item New data types and functions: Introduced in order to represent 
-      and deal with computation tress. This is done by adding de degugging
-      prelude to the list of import modules, and included a new function 
-      {\tt main} in the module main (the older will be renamed).
-\item Foreign declarations: The same as in the source program.
-\item Data types: The same as in the source program.
-\item New auxliary functions: Introduced to represent partial applications of 
-      constructors and (maybe foreign) functions.
-\item Transformed functions: The rules of the source program transformed. 
-      In the final program they will return a computation tree, as well as their
-      the same result they did in the source program.
-\end{itemize}
+The debugging transformation is applied independently to each
+declaration in the module. Type declarations are not changed by the
+transformation except for the types of higher order arguments of data
+constructors, which are transformed in order to ensure a type correct
+transformed program. Function declarations are changed by the program
+transformation. Finally, foreign function declarations cannot be
+transformed at all, but a wrapper function pairing the result of the
+foreign function with a suitable computation tree is introduced for
+each foreign function.
 
 \begin{verbatim}
 
-> debugDecls :: ModuleIdent -> (QualIdent -> Bool) -> [Decl] -> [Decl]
-> debugDecls m  trusted lDecls = 
->       foreigns  ++
->       debugTypes types ++
->       debugAuxiliary m lTypes ++ 
->       secondPhase 
->       where
->          (types,functions,foreigns) = debugSplitDecls lDecls
->          lTypes = collectSymbolTypes types functions foreigns []
->          lForeign = map (\(ForeignDecl id cc s t) -> id) foreigns
->          firstPhase = debugFirstPhase  m lForeign functions
->          secondPhase =  map (debugFunction trusted) firstPhase
+> debugDecls :: (QualIdent -> Bool) -> ModuleIdent -> [Decl] -> [Decl]
+> debugDecls trusted m ds = concatMap (debugDecl trusted m) ds
 
+> debugDecl :: (QualIdent -> Bool) -> ModuleIdent -> Decl -> [Decl]
+> debugDecl _ _ (DataDecl tc n cs) = [DataDecl tc n cs']
+>   where cs' = [ConstrDecl c (map transformType tys) | ConstrDecl c tys <- cs]
+> debugDecl _ _ (TypeDecl tc n ty) = [TypeDecl tc n (transformType ty)]
+> debugDecl trusted m (FunctionDecl f vs ty e) =
+>   [debugFunction trusted m f vs ty e]
+> debugDecl _ _ (ForeignDecl f cc s ty) = generateForeign f cc s n' ty
+>   where n = typeArity ty
+>         n' = if isIOType (resultType ty) then n + 1 else n
 
 \end{verbatim}
 
 
-Some auxiliar functions widely used throughout the module
+Some auxiliary functions widely used throughout the module.
 
 %Function that builds a qualified name from the name of the module and a string 
 %standing for the name we are going to represent.
 \begin{verbatim}
 
 > newIdName :: Int -> String -> Ident
-> newIdName n name =  mkIdent (debugPrefix++name++(show n))
-
-> newModuleName :: ModuleIdent -> String -> QualIdent
-> newModuleName m name = qualifyWith m (mkIdent (debugPrefix ++ name))
-
-> debugQualPrelude :: Ident -> QualIdent
-> debugQualPrelude  = qualifyWith debugPreludeModule
+> newIdName n name = mkIdent (debugPrefix++name++show n)
 
-> debugQualPreludeName :: String  -> QualIdent
-> debugQualPreludeName  name = debugQualPrelude (mkIdent name)
+> qualPreludeName :: String -> QualIdent
+> qualPreludeName name = qualifyWith preludeMIdent (mkIdent name)
 
-> debugPreludeModule :: ModuleIdent
-> debugPreludeModule   = debugPreludeMIdent
+> debugQualPreludeName :: String -> QualIdent
+> debugQualPreludeName name = qualifyWith debugPreludeMIdent (mkIdent name)
 
 > debugFunctionqId :: QualIdent
-> debugFunctionqId = debugQualPrelude (mkIdent debugFunctionName)
+> debugFunctionqId = debugQualPreludeName debugFunctionName
 
 > debugIOFunctionqId :: QualIdent
-> debugIOFunctionqId = debugQualPrelude (mkIdent debugIOFunctionName)
-
-> debugRenameId :: String -> Ident -> Ident
-> debugRenameId suffix ident =
->   renameIdent (mkIdent (debugPrefix ++ name ident ++ suffix)) (uniqueId ident)
+> debugIOFunctionqId = debugQualPreludeName debugIOFunctionName
 
+> debugRenameId :: Ident -> Ident
+> debugRenameId ident =
+>   renameIdent (mkIdent (debugPrefix ++ name ident)) (uniqueId ident)
+
+> debugRenameqId :: QualIdent -> QualIdent
+> debugRenameqId qIdent =
+>   maybe qualify qualifyWith mIdent' (debugRenameId ident')
+>   where (mIdent',ident') = splitQualIdent qIdent
 
 \end{verbatim}
 
 Qualified data types representing some useful types in the transformed program:
-{\tt [a], (a,b), Char, [Char], CTree} and {\tt [Ctree]}. Also function for
+{\tt [a], (a,b), Char, [Char], CTree} and {\tt [Ctree]}. Also functions for
 constructing expressions of the form (a,b) and the name of function 
 {\tt clean}.
 
 \begin{verbatim}
 
-> typeCons :: Type
-> typeCons = TypeArrow (TypeVariable 0) 
->               (TypeArrow (debugTypeList (TypeVariable 0))  
->                          (debugTypeList (TypeVariable 0)))
-
-> typeTuple :: Int -> Type
-> typeTuple n = foldr TypeArrow (debugTypeTuple ts) ts
->   where ts = [TypeVariable i | i <- [0 .. n - 1]]
-
 > debugTypeList :: Type -> Type
 > debugTypeList t = TypeConstructor qListId [t]
 
 > debugTypePair :: Type -> Type -> Type
-> debugTypePair a b = TypeConstructor debugIdentPair [a,b]
+> debugTypePair a b = TypeConstructor qPairId [a,b]
 
 > debugTypeTuple :: [Type] -> Type
-> debugTypeTuple ts = TypeConstructor (debugIdentTuple (length ts)) ts
+> debugTypeTuple ts = TypeConstructor (qTupleId (length ts)) ts
 
-> debugTypeChar,debugTypeString:: Type
+> debugTypeChar,debugTypeString :: Type
 > debugTypeChar   = TypeConstructor qCharId []
 > debugTypeString = debugTypeList debugTypeChar
 
 
-> debugTypeCTree,debugTypeLCTree,debugTypeCleanTree,debugTypeLCleanTree:: Type
+> debugTypeCTree,debugTypeLCTree,debugTypeCleanTree,debugTypeLCleanTree :: Type
 > debugTypeCTree   = TypeConstructor (debugQualPreludeName "CTree") []
 > debugTypeLCTree  = debugTypeList debugTypeCTree
 > debugTypeCleanTree = debugTypePair debugTypeString debugTypeCTree
@@ -169,388 +156,250 @@
 
 
 
-> debugIdentPair :: QualIdent
-> debugIdentPair = debugIdentTuple 2
-
-> debugIdentTuple :: Int -> QualIdent
-> debugIdentTuple n = qTupleId n
-
-> debugIdentCons :: QualIdent
-> debugIdentCons = qConsId
-
-> debugIdentNil :: QualIdent
-> debugIdentNil = qNilId
+> qPairId :: QualIdent
+> qPairId = qTupleId 2
 
 > debugNil :: Expression
-> debugNil = Constructor debugIdentNil 0
+> debugNil = Constructor qNilId 0
 
 > debugBuildPairExp :: Expression -> Expression -> Expression
-> debugBuildPairExp e1 e2 = Apply (Apply (Constructor debugIdentPair 2) e1) e2
+> debugBuildPairExp e1 e2 = Apply (Apply (Constructor qPairId 2) e1) e2
 
 
 > debugClean :: QualIdent 
-> debugClean  = debugQualPreludeName "clean"
-
-> debugTry :: QualIdent 
-> debugTry  = debugQualPreludeName "try'"
-
-> debugReturn :: QualIdent
-> debugReturn  = debugQualPreludeName "return'"
-
-> debugBind :: QualIdent
-> debugBind  = debugQualPreludeName "bind'"
-
-> debugBind_ :: QualIdent
-> debugBind_  = debugQualPreludeName "bind_'"
-
-> debugCatch :: QualIdent
-> debugCatch  = debugQualPreludeName "catch'"
-
-> debugFixIO :: QualIdent
-> debugFixIO  = debugQualPreludeName "fixIO'"
-
-> debugEncapsulate :: QualIdent
-> debugEncapsulate  = debugQualPreludeName "encapsulate'"
+> debugClean = debugQualPreludeName "clean"
 
 
 > dEvalApply :: Expression -> Expression
-> dEvalApply = Apply (Function dEvalId 1)
-
-> dEvalId :: QualIdent
-> dEvalId =  debugQualPreludeName "dEval"
+> dEvalApply = Apply (Function (debugQualPreludeName "dEval") 1)
 
 
 > void :: Expression
-> void =  Constructor (qualifyWith debugPreludeModule  (mkIdent "CTreeVoid")) 0
-
-> emptyNode :: Expression-> Expression
-> emptyNode  children = 
->          createApply ( 
->               Constructor (qualifyWith debugPreludeModule  
->                                 (mkIdent "EmptyCTreeNode")) 1)
->                        [children]
+> void = Constructor (debugQualPreludeName "CTreeVoid") 0
 
-
-> createEmptyNode ::  [Expression] -> Expression
-> createEmptyNode trees = 
->       emptyNode  clean
->       where
->       clean   = Apply (Function debugClean 1) (debugBuildList trees)
+> emptyNode :: Expression -> Expression
+> emptyNode children =
+>   Apply (Constructor (debugQualPreludeName "EmptyCTreeNode") 1) children
 
 
 > debugBuildList :: [Expression] -> Expression
-> debugBuildList l = foldr Apply  debugNil (map (Apply cons) l)
->       where
->        cons = Constructor debugIdentCons 2
+> debugBuildList l = foldr (Apply . Apply (Constructor qConsId 2)) debugNil l
 
 
-> node :: Expression -> Expression -> Expression -> Expression -> Expression ->
->         Expression
+> node :: Expression -> Expression -> Expression -> Expression -> Expression
+>      -> Expression
 > node name args result number children =
->      createApply (Constructor (qualifyWith debugPreludeModule 
->                                                (mkIdent "CTreeNode")) 5)
->                [name, args, result, number, children]
-
-\end{verbatim}
-
-We distinguish three classes of declarations: types, functions and foreigns.
-Each class needs an specific treatment, and therefore we split the initial
-list of declarations in three.
-\begin{verbatim}
-
-> debugSplitDecls :: [Decl] -> ([Decl],[Decl],[Decl])
-> debugSplitDecls []     = ([],[],[])
-> debugSplitDecls (x:xs) = case x of
->                      DataDecl     _ _ _   -> (x:types,functions,foreigns)
->                      TypeDecl     _ _ _   -> (x:types,functions,foreigns)
->                      FunctionDecl _ _ _ _ -> (types,x:functions,foreigns)
->                      ForeignDecl  _ _ _ _ -> (types,functions,x:foreigns)
->                   where
->                       (types,functions,foreigns) = debugSplitDecls xs 
-
-\end{verbatim}
-
-The newMain is only added if we are in the module main. 
-It will start the debugging process.
-
-Its definition depends on the goal's type. If the goal's type is
-\texttt{IO}~$t$, the new main function simply executes the transformed
-goal under control of the debugger.
-
-\begin{verbatim}
-
-
-main.main = DebugPrelude.startIODebugging main._debug#main
+>   createApply (Constructor (debugQualPreludeName "CTreeNode") 5)
+>               [name, args, result, number, children]
 
 \end{verbatim}
 
-Otherwise, the goal must be solved using encapsulated search and
-navigation then allows picking a wrong solution. In order to make this
-work, the transformed goal function must be converted into a form that
-is suitable as argument to the encapsulated search primitive
-\texttt{try}. Therefore, we use the following definition for the new
-main function.
-
-\begin{verbatim}
-
-
-main.main = DebugPrelude.startDebugging 
-                (\(x,ct)-> let (r,ct') = main._debug#main in x=:=r &> ct=:=ct')
-
-\end{verbatim}
-
-We have to introduce an auxiliary function for the lambda in the intermediate code.
+When compiling a goal, the debugging transformation must provide a new
+main function that starts the debugging process. Depending on the
+goal's type this is done by applying either
+\texttt{DebugPrelude.startDebugging} or
+\texttt{DebugPrelude.startIODebugging} to the transformed goal.
+
+A subtle issue with IO goals is that the simplifier may or may not
+$\eta$-expand them. Without $\eta$-expansion the transformed goal's
+type is \texttt{(IO ($\tau'$,CTree), CTree)}, whereas it lacks the
+outer computation tree with $\eta$-expansion, i.e., the type is just
+\texttt{IO ($\tau'$,CTree)}. In order to accomodate this difference,
+\texttt{debugMain} first applies \texttt{DebugPrelude.performIO} to
+the transformed goal if it is a nullary function. Note that the
+desugarer transforms all non-IO goals \emph{goal} into unary functions
+equivalent to \texttt{\char`\\z -> z =:= }\emph{goal} when generating
+code for the debugger (cf. Sect.~\ref{sec:desugar}).
 
 \begin{verbatim}
 
 > dAddMain :: Ident -> Module -> Module
-> dAddMain goalId (Module m is ds) = Module m is (fMain ++ ds)
->   where (arity,ty) = head [(length lVars,ty) | FunctionDecl f lVars ty _ <- ds, f == debugOldMainId]
->         fMain = if isIOType ty || isIOType (debugResultType ty)
->                 then newMainIO m goalId arity
->                 else newMain m goalId
->         debugOldMainId = qualifyWith m (debugRenameId "" goalId)
->         debugResultType (TypeConstructor debugIdentPair [ty,_]) = ty
-
-> newMainIO :: ModuleIdent -> Ident -> Int -> [Decl]
-> newMainIO m f n = [fMain]
->       where 
->       fMain = FunctionDecl fId [] fType fBody
->       fId   = qualifyWith m f
->       fType = TypeConstructor qIOId [TypeConstructor qUnitId []]
->       fApp  = if n==0
->               then Function debugOldMainId n
->               else debugBuildPairExp (Function debugOldMainId n) void
->       fBody = Apply (Function debugIOFunctionqId 1) fApp
->       debugOldMainId = qualifyWith m (debugRenameId "" f)
-
-> newMain :: ModuleIdent -> Ident -> [Decl]
-> newMain m f = [fMain,auxMain]
->       where 
->       fMain = FunctionDecl fId [] fType fBody
->       fId   = qualifyWith m f
->       fType = TypeConstructor qIOId [TypeConstructor qUnitId []]
->       fBody = Apply (Function debugFunctionqId 1) (Function debugAuxMainId 1)
->       fType' = debugTypeMainAux
->       r   = mkIdent "r"
->       ct' = mkIdent "ct'"
->       x   = mkIdent "x"
->       ct   = mkIdent "ct"
->       param  = mkIdent "x_ct"
->       eq1 = createApply equalFunc  [Variable x, Variable r]
->       eq2 = createApply equalFunc  [Variable ct, Variable ct']        
->       equalFunc = Function (qualifyWith preludeMIdent (mkIdent "=:=")) 2
->       seqAndFunc = Function (qualifyWith preludeMIdent (mkIdent "&>")) 2
->       expression =  createApply seqAndFunc [eq1,eq2]
->       alt'     = Alt (ConstructorPattern debugIdentPair [x,ct]) expression
->       caseExpr = Case Flex (Variable param) [alt']
->       alt      = Alt (ConstructorPattern debugIdentPair [r,ct']) caseExpr
->       fBody'   = Case Rigid  (Function debugOldMainId 0) [alt]
->       auxMain = FunctionDecl debugAuxMainId [param] fType' fBody'
->       debugOldMainId = qualifyWith m (debugRenameId "" f)
->       debugAuxMainId = qualifyWith m (debugRenameId "#Aux" f)
-
-
-
-\end{verbatim}
-
-The first phase of the transformation process performs two diferent tasks:
-\begin{itemize}
-\item Transform the type of the function.
-\item Change the function applications by their new names.
-\end{itemize}
-
-\begin{verbatim}
-
-> debugFirstPhase ::  ModuleIdent -> [QualIdent] -> [Decl] ->[Decl]
-> debugFirstPhase mName lForeigns [] = []
-> debugFirstPhase m l ((FunctionDecl ident lVars fType fExp) :xs)
->   | isQSelectorId ident = (FunctionDecl ident lVars fType fExp:xs'')
->   | otherwise           = (FunctionDecl ident lVars fType' exp':xs'')
->   where 
->     exp'   = firstPhaseExp m 0 l fExp
->     xs''   = debugFirstPhase m l xs
->     fType' = transformType (length lVars) fType
+> dAddMain goalId (Module m es is ds) =
+>   Module m (mainId:es) is (FunctionDecl mainId [] mainType mainExpr : ds)
+>   where (arity,ty) =
+>           head [(length vs,ty) | FunctionDecl f vs ty _ <- ds, f == mainId']
+>         mainId = qualifyWith m goalId
+>         mainId' = qualifyWith m (debugRenameId goalId)
+>         mainType = TypeConstructor qIOId [TypeConstructor qUnitId []]
+>         mainExpr = debugMain arity ty (Function mainId' arity)
+
+> debugMain :: Int -> Type -> Expression -> Expression
+> debugMain arity ty
+>   | arity == 0 = Apply startIODebugging . Apply debugPerformIO
+>   | isIOType ty = Apply startIODebugging
+>   | otherwise = Apply startDebugging
+>   where startDebugging = Function debugFunctionqId 1
+>         startIODebugging = Function debugIOFunctionqId 2
+
+
+\end{verbatim}
+The implementation of foreign functions is not known and must be
+trusted. For first order foreign functions this means that the
+transformed function simply should pair the result of the foreign
+function with a void computation tree. Therefore, given a foreign
+function $f :: \tau_1 \rightarrow \dots \rightarrow \tau_n \rightarrow
+\tau$, the debugging transformation just adds an auxiliary function
+$f' \, x_1 \dots x_n = (f \, x_1 \dots x_n, \texttt{Void})$ to the
+program. First order foreign functions in the \texttt{IO} monad are
+handled similarly, except that the computation tree is lifted into the
+\texttt{IO} monad. Thus, given a foreign function $f :: \tau_1
+\rightarrow \dots \rightarrow \tau_n \rightarrow \texttt{IO}\,\tau$,
+the transformation defines an auxiliary function $f' \, x_1 \dots x_n
+= f \, x_1 \dots x_n \;\texttt{>>=} \; \texttt{return'}$ where the
+auxiliary function \texttt{return' x = (x, Void)} is defined in module
+\texttt{DebugPrelude}. As a minor optimization, using the monad law
+$\texttt{return}\,x \; \texttt{>>=} \; k \equiv k\,x$, we transform
+the \texttt{return} primitive directly into \texttt{return'}.
+
+Higher order foreign functions like the encapsulated search primitive
+\texttt{try} or the monadic bind operator \texttt{(>>=)} cannot be
+handled in that way since they can invoke arbitrary computations. In
+order to integrate such functions into the program transformation
+approach, suitable wrapper functions, which collect the computation
+trees of the subcomputations performed by the foreign function and
+return them along with the function's result, must be defined in
+module \texttt{DebugPrelude}. These wrappers are then used in the
+transformed program instead of the original function. Fortunately,
+there is only a small number of such primitives making this approach
+feasible.
+
+\textbf{Note}: The code below assumes that the wrapper functions for
+higher order primitives defined in \texttt{DebugPrelude} indeed have
+the same arity as the original primitives.
+\begin{verbatim}
+
+> generateForeign :: QualIdent -> CallConv -> String -> Int -> Type -> [Decl]
+> generateForeign f cc s n ty = FunctionDecl f' vs ty' e : ds
+>   where f' = changeFunctionqId f
+>         vs = map (mkIdent . ("_"++) . show) [0..n-1]
+>         ty' = transformFunType n ty
+>         (e,ds) = debugForeign f cc s n (map Variable vs) ty
+
+> debugForeign :: QualIdent -> CallConv -> String -> Int -> [Expression] -> Type
+>              -> (Expression,[Decl])
+> debugForeign f cc s n vs ty =
+>   case foreignWrapper cc s of
+>     Just f' -> (createApply (Function (debugQualPreludeName f') n) vs,[])
+>     Nothing -> (debugForeign1 s ty (Function f n) vs,[ForeignDecl f cc s ty])
+
+> debugForeign1 :: String -> Type -> Expression -> [Expression] -> Expression
+> debugForeign1 s ty f vs
+>   | any isFunctType (argumentTypes ty) =
+>       error ("debugForeign: unknown higher order primitive " ++ s)
+>   | isIOType (resultType ty) =
+>       createApply preludeBind [createApply f (init vs),debugReturn,last vs]
+>   | otherwise = debugBuildPairExp (createApply f vs) void
+>   where preludeBind = Function (debugQualPreludeName ">>=") 3
+>         debugReturn = Function (debugQualPreludeName "return'") 2
+>         isFunctType ty = isArrowType ty || isIOType ty
 
-> -----------------------------------------------------------------------------
-> firstPhaseExp :: ModuleIdent -> Int ->  [QualIdent] -> Expression -> Expression
->
-> firstPhaseExp m d l (Function qIdent n)
->   | isQSelectorId qIdent = Function qIdent n
->   | otherwise            = firstPhaseQual m n d l qIdent True
->
-> firstPhaseExp m d l (Constructor qIdent n) = firstPhaseQual m n d l qIdent False
->
-> firstPhaseExp m d l (Apply e1 e2) = Apply e1' e2'
->    where
->       e1' = firstPhaseExp m (d+1) l e1
->       e2' = firstPhaseExp m 0 l e2 
->
-> firstPhaseExp m d l (Case eval expr lAlts) = Case eval e1' lAlts'
->     where
->       e1'    = firstPhaseExp m 0 l expr
->       lAlts' =  foldr aux [] lAlts
->       aux (Alt term expr) xs = Alt term (firstPhaseExp m d l expr):xs
-
->
-> firstPhaseExp m d l (Or e1 e2) = (Or e1' e2')
->    where
->       e1' = firstPhaseExp m d l e1
->       e2' = firstPhaseExp m d l e2 
->
-> firstPhaseExp m d l (Exist ident e) = Exist ident e'
->    where
->       e' = firstPhaseExp m d l e
->
-> firstPhaseExp m d l (Let binding e) = Let binding' e'
->    where
->       binding'= firstPhaseBinding m  0 l binding
->       e'      = firstPhaseExp m d l e
->
->
-> firstPhaseExp m d l (Letrec lbind e) = Letrec lbind' e'
->    where
->       lbind'   = map  (firstPhaseBinding m 0 l) lbind
->       e'       = firstPhaseExp m d l e
-
-> firstPhaseExp m d l input = input
-
-> firstPhaseBinding:: ModuleIdent -> Int -> [QualIdent] -> Binding -> Binding
-> firstPhaseBinding m d l (Binding ident expr) =(Binding ident expr')
->    where
->       expr' = firstPhaseExp m d l expr
-
-
-> firstPhaseQual ::  ModuleIdent -> Int -> Int -> [QualIdent] -> 
->                   QualIdent -> Bool -> Expression
-> firstPhaseQual m arity nArgs lForeign  qIdent isFunction =
->   if mustBeChanged then reconstructExpr isFunction qIdent' arity'
->   else reconstructExpr isFunction qIdent'' arity
->   where
->       (idModule,ident) = splitQualIdent qIdent
->       mustBeChanged =  if not isFunction  then nArgs < arity
->                             else nArgs < arity-1
->       idModule' = maybe m id idModule
->       arity'    = nArgs+1
->       ident'    = idAuxiliarFunction ident nArgs
->       ident''   = debugRenameId "" ident
->       qIdent'   = qualifyWith idModule' ident'
->       qIdent''  = if not isFunction 
->                   then qIdent 
->                   else qualifyWith idModule' ident''
-
-\end{verbatim}
-
-Next function  gets the current module identifier, 
- a qualifier, its type, its arity {\tt n}, and a boolean value indicating
- if it is a function definded in the module, and generates 
-{\tt n} new auxiliar functions in the current module.
-
-\begin{verbatim}
-
-> generateAuxFuncs m (qId,(sType,n,fType)) = 
->       if isQSelectorId qId then []
->       else case sType of
->              IsForeign cc s -> generateForeign m qId cc s n fType : auxiliary
->              _              -> auxiliary
->       where
->         k = if  sType==IsConstructor then n-1 else n-2 
->         auxiliary = map (generateAuxFunc m (qId,(sType,k,fType))) [0..k]
-
-> generateForeign :: ModuleIdent -> QualIdent -> CallConv -> String -> Int -> Type -> Decl
-> generateForeign m qId cc s n fType = 
->       FunctionDecl qId' varsId fType' body
->       where
->       qId'             = changeFunctionqId qId
->       isIO             = isIOType (resultType fType)
->       varsId           = map (mkIdent.("_"++).show) [0..n-1]
->       vars             = map Variable varsId
->       vars'            = init vars
->       fType'           = transformType n  fType
->       bind             = qualifyWith preludeMIdent (mkIdent ">>=")
->       finalApp         = case foreignWrapper cc s of
->                            Just qId'' -> createApply (Function qId'' n) vars
->                            Nothing
->                              | any isFunctType (argumentTypes fType) ->
->                                  error ("generateForeign: unsupported higher order primitive " ++ s)
->                              | otherwise -> createApply (Function qId n) vars
->       finalAppIO       = case foreignWrapper cc s of
->                            Just qId'' -> createApply (Function qId'' n) vars'
->                            Nothing
->                              | any isFunctType (argumentTypes fType) ->
->                                  error ("generateForeign: unsupported higher order primitive " ++ s)
->                              | otherwise ->
->                                  createApply (Function bind 3)
->                                              [createApply (Function qId n) vars',
->                                               Function debugReturn 2]
->       body             = if cc==Primitive && s=="unsafePerformIO"
->                          then createApply (Function qId n) vars
->                          else if isIO
->                               then Apply finalAppIO (last vars)
->                               else debugBuildPairExp finalApp void
->       isFunctType ty   = isArrowType ty || isIOType ty
-
-> foreignWrapper :: CallConv -> String -> Maybe QualIdent
+> foreignWrapper :: CallConv -> String -> Maybe String
 > foreignWrapper Primitive s
->   | s=="try"             = Just debugTry
->   | s=="return"          = Just debugReturn
->   | s==">>="             = Just debugBind
->   | s==">>"              = Just debugBind_
->   | s=="catch"           = Just debugCatch
->   | s=="fixIO"           = Just debugFixIO
->   | s=="encapsulate"     = Just debugEncapsulate
+>   | s=="try"             = Just "try'"
+>   | s=="return"          = Just "return'"
+>   | s==">>="             = Just "bind'"
+>   | s==">>"              = Just "bind_'"
+>   | s=="catch"           = Just "catch'"
+>   | s=="fixIO"           = Just "fixIO'"
+>   | s=="encapsulate"     = Just "encapsulate'"
+>   | s=="unsafePerformIO" = Just "unsafePerformIO'"
 >   | otherwise            = Nothing
 > foreignWrapper CCall   _ = Nothing
 > foreignWrapper RawCall _ = Nothing
 
+\end{verbatim}
 
-> generateAuxFunc :: ModuleIdent ->(QualIdent, (SymbolType,Int,Type)) -> Int -> Decl
-> generateAuxFunc m (qId,(sType,n,fType)) i =
->       FunctionDecl qIdent' varsId fType' exp'
->       where
->       (idModule,ident) = splitQualIdent qId
->       qId'             = changeFunctionqId qId
->       ident'           = idAuxiliarFunction ident i
->       ident''          = idAuxiliarFunction ident (i+1)
->       qIdent'          = qualifyWith m ident'
->       qIdent''         = qualifyWith m ident''
->       varsId           = map (mkIdent.("_"++).show) [0..i]
->       vars             = map Variable varsId
->       fType'           = transformType (i+1)  fType
->       finalApp         = if sType==IsConstructor
->                          then createApply (Constructor qId (i+1)) vars
->                          else createApply (Function qId' (i+2)) vars
->       nextApp          = createApply (Function qIdent'' (i+2)) vars
->       exp'             = if (i==n)
->                          then  debugBuildPairExp finalApp void
->                          else  debugBuildPairExp nextApp void
-
-> idAuxiliarFunction :: Ident -> Int -> Ident
-> idAuxiliarFunction ident n = debugRenameId ('#':show n) ident
-
-> extractApply :: Expression -> [Expression] -> (Expression,[Expression])
-> extractApply (Apply e1 e2) l = extractApply e1 (e2:l)
-> extractApply e1 l =  (e1,l)
-
-                                           
-> createApply :: Expression  -> [Expression] -> Expression 
-> createApply exp lExp  = foldl Apply exp lExp
-
+Auxiliary functions are introduced to deal with higher order parameter
+applications. In particular, the transformation replaces every partial
+application $C\,e_1\dots e_k$ of a constructor with arity $n>k$ by an
+application $@_{n-k}\;(C\,e_1\dots e_k)$ and every partial application
+$f\,e_1\dots e_k$ of a (foreign or user defined) function with arity
+$n>k+1$ by an application $@_{n-k-1}\;(f\,e_1\dots e_k)$. The family
+of auxiliary functions $@_i$ is defined by the equations
+\begin{eqnarray*}
+  @_1\, f\, x &=& (f\, x, \texttt{Void}) \\
+  @_{i+1}\, f\, x &=& (@_i (f x), \texttt{Void})
+\end{eqnarray*}
+and is necessary in order to make the transformed program type
+correct.
+
+\begin{verbatim}
+
+> generateAuxFuncs :: ModuleIdent -> Int -> [Decl]
+> generateAuxFuncs m n = map (generateAuxFunc m) [1..n]
+
+> generateAuxFunc :: ModuleIdent -> Int -> Decl
+> generateAuxFunc m i = FunctionDecl f [v1,v2] ty' e
+>   where f = qIdAuxiliaryFunction m i
+>         v1 = mkIdent "f"; v2 = mkIdent "x"
+>         ty = foldr1 TypeArrow (map TypeVariable [0..i])
+>         ty' = TypeArrow ty (transformFunType 1 ty)
+>         e = debugBuildPairExp (wrapPartial m (i - 1) (apply v1 v2)) void
+>         apply v1 v2 = Apply (Variable v1) (Variable v2)
+
+> wrapPartial :: ModuleIdent -> Int -> Expression -> Expression
+> wrapPartial m d
+>   | d > 0 = Apply (Function (qIdAuxiliaryFunction m d) 2)
+>   | otherwise = id
+
+> qIdAuxiliaryFunction :: ModuleIdent -> Int -> QualIdent
+> qIdAuxiliaryFunction m n =
+>   qualifyWith m (debugRenameId (mkIdent (if n == 1 then "@" else '@':show n)))
+
+\end{verbatim}
+
+The compiler determines the needed auxiliary functions by looking for
+applications of the form $(@_n \, e)$ in the transformed code and
+computing the maximum index $n$ being used.
+
+\begin{verbatim}
+
+> numAuxFuncs :: ModuleIdent -> [Decl] -> Int
+> numAuxFuncs m ds =
+>   maximum (0 : usedAuxFuncs (qualName (qIdAuxiliaryFunction m 1)) ds)
+
+> class AuxFuncs a where
+>   usedAuxFuncs :: String -> a -> [Int]
+
+> instance AuxFuncs a => AuxFuncs [a] where
+>   usedAuxFuncs pre = concatMap (usedAuxFuncs pre)
+
+> instance AuxFuncs Decl where
+>   usedAuxFuncs _ (DataDecl _ _ _) = []
+>   usedAuxFuncs _ (TypeDecl _ _ _) = []
+>   usedAuxFuncs pre (FunctionDecl _ _ _ e) = usedAuxFuncs pre e
+>   usedAuxFuncs _ (ForeignDecl _ _ _ _) = []
+
+> instance AuxFuncs Expression where
+>   usedAuxFuncs _ (Literal _) = []
+>   usedAuxFuncs _ (Variable _) = []
+>   usedAuxFuncs pre (Function f n) =
+>     [index (drop (length pre) f') | n == 2 && pre `isPrefixOf` f']
+>     where f' = qualName f
+>           index cs = if null cs then 1 else read cs
+>   usedAuxFuncs _ (Constructor _ _) = []
+>   usedAuxFuncs pre (Apply e1 e2) = usedAuxFuncs pre e1 ++ usedAuxFuncs pre e2
+>   usedAuxFuncs pre (Case _ e as) = usedAuxFuncs pre e ++ usedAuxFuncs pre as
+>   usedAuxFuncs pre (Choice es) = usedAuxFuncs pre es
+>   usedAuxFuncs pre (Exist _ e) = usedAuxFuncs pre e
+>   usedAuxFuncs pre (Let _ ds e) = usedAuxFuncs pre ds ++ usedAuxFuncs pre e
+>   usedAuxFuncs pre (SrcLoc _ e) = usedAuxFuncs pre e
+
+> instance AuxFuncs Alt where
+>   usedAuxFuncs pre (Alt _ e) = usedAuxFuncs pre e
 
-> reconstructExpr :: Bool -> QualIdent -> Int-> Expression
-> reconstructExpr isFunction qId n = if isFunction then (Function qId n)
->                                    else (Constructor qId n)
+> instance AuxFuncs Binding where
+>   usedAuxFuncs pre (Binding _ e) = usedAuxFuncs pre e
 
 \end{verbatim}
 
-
-The function \texttt{transformType} transforms the type
+The function \texttt{transformFunType} transforms the type
 $\tau_1 \rightarrow \dots \rightarrow \tau_n \rightarrow \tau$
 of a function with arity $n$ into
 $\tau'_1 \rightarrow \dots \rightarrow \tau'_n \rightarrow (\tau',\texttt{CTree})$.
-The arity $n$ is passed as first argument to \texttt{transformType}.
+The arity $n$ is passed as first argument to \texttt{transformFunType}.
 
-The function \texttt{transformType'} implements the basic
+The function \texttt{transformType} implements the basic
 transformation of types:
 \begin{displaymath}
   \begin{array}{rcll}
@@ -576,526 +425,395 @@
 for \texttt{IO}.
 \begin{verbatim}
 
-> ---------------------------------------------------------------------------
-> transformType :: Int ->  Type -> Type
-> transformType 0  fType =  debugTypePair fType' debugTypeCTree
->     where fType' = transformType'  fType
-> transformType n  (TypeArrow type1 type2) =  TypeArrow type1' type2'
->     where 
->       type1' = transformType' type1
->       type2' = transformType (n-1) type2
-> transformType n  fType = transformType'  fType
-
-> transformType' ::  Type -> Type
-> transformType'  t@(TypeArrow type1 type2) = transformType 1  t
-> transformType'  (TypeConstructor ident lTypes) = 
->    if ident == qIOId
->    then TypeConstructor ident [transformType 0 (head lTypes)]
->    else TypeConstructor ident (map transformType'  lTypes)
-> transformType'  (TypeVariable v) = TypeVariable v
+> transformFunType :: Int -> Type -> Type
+> transformFunType 0 ty = debugTypePair (transformType ty) debugTypeCTree
+> transformFunType _ ty@(TypeArrow ty1 (TypeConstructor tc [ty2,ty3]))
+>   | tc == qPairId && ty1 == TypeConstructor qWorldId [] && ty1 == ty3 =
+>       transformType ty
+> transformFunType n (TypeArrow ty1 ty2) =
+>   TypeArrow (transformType ty1) (transformFunType (n-1) ty2)
+> transformFunType _ ty = transformType ty
+
+> transformType :: Type -> Type
+> transformType (TypeArrow ty1 (TypeConstructor tc [ty2,ty3]))
+>   | tc == qPairId && ty1 == TypeConstructor qWorldId [] && ty1 == ty3 =
+>       TypeArrow ty1 (TypeConstructor tc [transformFunType 0 ty2,ty3])
+> transformType ty@(TypeArrow _ _) = transformFunType 1 ty
+> transformType (TypeConstructor tc tys)
+>   | tc `elem` [qPtrId,qFunPtrId,qStablePtrId] = TypeConstructor tc tys
+>   | tc == qIOId && length tys == 1 =
+>       TypeConstructor tc [transformFunType 0 (head tys)]
+>   | otherwise = TypeConstructor tc (map transformType tys)
+> transformType (TypeVariable v) = TypeVariable v
 
 > typeArity :: Type -> Int
 > typeArity ty = length (argumentTypes ty)
 
 > argumentTypes :: Type -> [Type]
+> argumentTypes (TypeArrow ty1 (TypeConstructor tc [ty2,ty3]))
+>   | tc == qPairId && ty1 == TypeConstructor qWorldId [] && ty1 == ty3 = []
 > argumentTypes (TypeArrow ty1 ty2) = ty1 : argumentTypes ty2
 > argumentTypes _                   = []
 
 > resultType :: Type -> Type
+> resultType (TypeArrow ty1 (TypeConstructor tc [ty2,ty3]))
+>   | tc == qPairId && ty1 == TypeConstructor qWorldId [] && ty1 == ty3 =
+>       TypeConstructor qIOId [ty2]
 > resultType (TypeArrow _ ty) = resultType ty
 > resultType ty               = ty
 
 > isIOType :: Type -> Bool
+> isIOType (TypeArrow ty1 (TypeConstructor tc [_,ty2])) =
+>   tc == qPairId && ty1 == TypeConstructor qWorldId [] && ty1 == ty2
 > isIOType (TypeConstructor tc [_]) = tc == qIOId
 > isIOType _                        = False
 
 > isArrowType :: Type -> Bool
+> isArrowType (TypeArrow ty1 (TypeConstructor tc [_,ty2])) =
+>   not (tc == qPairId && ty1 == TypeConstructor qWorldId [] && ty1 == ty2)
 > isArrowType (TypeArrow _ _) = True
 > isArrowType _               = False
-> ---------------------------------------------------------------------------
 
+> qWorldId :: QualIdent
+> qWorldId = qualify (mkIdent "World")
 
 \end{verbatim}
 
-Here we collect the types  of all the data constructors and functions
-defined in the program. They will be needed in order to generate the 
-corresponding auxiliar functions. Also an integer is paired with the type,
-representing the symbol arity, and a boolean value indicating if the symbol
-is a module function.
-
-
-\begin{verbatim}
-
-> data SymbolType = IsFunction | IsConstructor | IsForeign CallConv String deriving (Eq,Show)
-
-> type DebugTypeList = [(QualIdent,(SymbolType,Int,Type))]
-
-> collectSymbolTypes:: [Decl] -> [Decl] -> [Decl] -> 
->                      DebugTypeList -> DebugTypeList
-> collectSymbolTypes types functions foreigns env =
->  nub (typesPredefined functions) ++
->  ((typesFunctions functions).(typesData types).(typesForeigns foreigns)) env
-
-
-> typesFunctions,typesData,typesForeigns::[Decl]-> DebugTypeList -> DebugTypeList
-> typesFunctions  functions env = foldr typesFunction env functions
-> typesData       types env     = foldr typesDatum env types    
-        
-
-> typesForeigns  foreigns env = foldr typesForeign env foreigns
-
-
-> typesFunction,typesDatum,typesForeign:: Decl ->DebugTypeList -> DebugTypeList
-> typesFunction (FunctionDecl qId l ftype exp)  env  = 
->       (qId,(IsFunction,length l,ftype)):env
->
-> typesDatum (DataDecl qId n l) env  = foldr (typesConst qId n)  env l
-> typesDatum (TypeDecl _ _ _) env = env
->
-> typesForeign (ForeignDecl qId cc s ftype) env  = 
->       (qId,(IsForeign cc s,m,ftype)):env
->       where m = if isIOType (resultType ftype) then n + 1 else n
->             n = typeArity ftype
-
-> typesConst:: QualIdent -> Int -> ConstrDecl -> DebugTypeList -> DebugTypeList
-> typesConst dataId n (ConstrDecl qId lTypes) env  = 
->       (qId,(IsConstructor, length lTypes, normalizeType cType)):env
->       where
->       vars  = map TypeVariable [0..n-1]
->       cType = foldr TypeArrow (TypeConstructor dataId vars)  lTypes
-
-
-> normalizeType :: Type -> Type
-> normalizeType ty = rename (nub (tvars ty)) ty
->   where rename tvs (TypeConstructor c tys) =
->           TypeConstructor c (map (rename tvs) tys)
->         rename tvs (TypeVariable tv) =
->           TypeVariable (fromJust (elemIndex tv tvs))
->         rename tvs (TypeArrow ty1 ty2) =
->           TypeArrow (rename tvs ty1) (rename tvs ty2)
->         tvars (TypeConstructor _ tys) = concatMap tvars tys
->         tvars (TypeVariable tv) = [tv]
->         tvars (TypeArrow ty1 ty2) = tvars ty1 ++ tvars ty2
+The transformation of user defined functions is performed in two
+phases.
 
-\end{verbatim}
-
-The transformation must add auxiliary functions for all partial applications
-of the list constructor and tuple constructors which are used in the module.
-These constructors are defined implicitly in every module, therefore we collect
-these definitions here. Generating auxiliary functions for the list
-constructor only if it used helps to avoid a name conflict when the program
-is linked with an explicit goal.
 \begin{verbatim}
 
-> typesPredefined :: [Decl] -> DebugTypeList
-> typesPredefined functions = nub (foldr typesBody [] functions)
-
-> typesBody :: Decl -> DebugTypeList -> DebugTypeList
-> typesBody (FunctionDecl _ _ _ e) = typesExpr e
+> debugFunction :: (QualIdent -> Bool) -> ModuleIdent
+>               -> QualIdent -> [Ident] -> Type -> Expression -> Decl
+> debugFunction trusted m f vs ty e = FunctionDecl f' vs ty' e'
+>   where f' = changeFunctionqId f
+>         ty' = transformFunType (length vs) ty
+>         e' = debugSecondPhase m f (trusted f) vs ty' (debugFirstPhase e)
 
-> typesExpr :: Expression -> DebugTypeList -> DebugTypeList
-> typesExpr (Literal _) env = env
-> typesExpr (Variable _) env = env
-> typesExpr (Function _ _) env = env
-> typesExpr (Constructor qId n) env =
->   if idModule == Nothing && n > 0 then env' else env
->   where (idModule,ident) = splitQualIdent qId
->         env' = (qId,(IsConstructor,n,debugTypePredef ident n)) : env
-> typesExpr (Apply e1 e2) env = typesExpr e1 (typesExpr e2 env)
-> typesExpr (Case _ e alts) env = typesExpr e (foldr typesAlt env alts)
->   where typesAlt (Alt _ e) = typesExpr e
-> typesExpr (Or e1 e2) env = typesExpr e1 (typesExpr e2 env)
-> typesExpr (Exist _ e) env = typesExpr e env
-> typesExpr (Let (Binding _ e1) e2) env = typesExpr e1 (typesExpr e2 env)
-> typesExpr (Letrec binds e) env = foldr typesBinding (typesExpr e env) binds
->   where typesBinding (Binding _ e) = typesExpr e
-
-> debugTypePredef :: Ident -> Int -> Type
-> debugTypePredef ident n
->   | ident == consId && n == 2 = typeCons
->   | isTupleId ident = typeTuple n
->   | otherwise = error ("debugTypePredef: " ++ show ident ++ "/" ++ show n)
+> changeFunctionqId :: QualIdent -> QualIdent
+> changeFunctionqId f = debugRenameqId f
 
 \end{verbatim}
 
+The first phase of the transformation process changes the names of all
+function applications.
 
-
-Function types appearing in data constructor declarations must be changed.
 \begin{verbatim}
 
-> debugTypes :: [Decl] -> [Decl]
-> debugTypes ds = map debugTypeDecl ds
+> debugFirstPhase :: Expression -> Expression
+> debugFirstPhase = renameFunction
 
-> debugTypeDecl :: Decl -> Decl
-> debugTypeDecl (DataDecl tc n cs) = DataDecl tc n (map debugConstrDecl cs)
-> debugTypeDecl (TypeDecl tc n ty) = TypeDecl tc n (transformType' ty)
+> class FirstPhase a where
+>   renameFunction :: a -> a
 
-> debugConstrDecl :: ConstrDecl -> ConstrDecl
-> debugConstrDecl (ConstrDecl c tys) = ConstrDecl c (map transformType' tys)
+> instance FirstPhase a => FirstPhase [a] where
+>   renameFunction = map renameFunction
 
-\end{verbatim}
-Auxiliary functions are introduced to deal with HO parameter applications
-\begin{verbatim}
+> instance FirstPhase Expression where
+>   renameFunction (Literal l) = Literal l
+>   renameFunction (Variable v) = Variable v
+>   renameFunction (Function f n) = Function (changeFunctionqId f) n
+>   renameFunction (Constructor c n) = Constructor c n
+>   renameFunction (Apply e1 e2) = Apply (renameFunction e1) (renameFunction e2)
+>   renameFunction (Case rf e as) =
+>     Case rf (renameFunction e) (renameFunction as)
+>   renameFunction (Choice es) = Choice (renameFunction es)
+>   renameFunction (Exist vs e) = Exist vs (renameFunction e)
+>   renameFunction (Let rec ds e) =
+>     Let rec (renameFunction ds) (renameFunction e)
+>   renameFunction (SrcLoc p e) = SrcLoc p (renameFunction e)
+
+> instance FirstPhase Alt where
+>   renameFunction (Alt t e) = Alt t (renameFunction e)
 
-> debugAuxiliary :: ModuleIdent -> [(QualIdent, (SymbolType,Int,Type))] -> [Decl]
-> debugAuxiliary m xs = concat (map (generateAuxFuncs m) xs)
+> instance FirstPhase Binding where
+>   renameFunction (Binding v e) = Binding v (renameFunction e)
 
 \end{verbatim}
 
-The transformed rules of the original funcions. At the partial applications
-of functions and constructos have been replaced by auxiliar functions. 
-Also, the type of the function has been transformed.
+The second phase transforms the rules of the original functions. All
+partial applications of functions and constructors have been replaced
+by auxiliary functions. Also, the type of the function has been
+transformed.
 We only need:
 \begin{itemize}
-\item Introduce local definition replacing function calls.
+\item Introduce local definitions replacing function calls.
 \item Guess if the function is a lifted function, in order to build an 
-      appropiate name and include only the function variables in the node.
+      appropriate name and include only the function variables in the node.
 \end{itemize}
 
-Two special cases handle the selector functions introduced by the
-pattern binding update strategy (see p.~\pageref{pattern-binding} in
-Sect.~\ref{pattern-binding}) and $\eta$-expanded functions with result
-type \texttt{IO}~$t$. The former are not transformed at all and the
-latter do not return a pair composed of a result and a computation
-tree, but simply the result of the monadic action called in the body
-of the function. This is a consequence of the special rule that
-applies to the \texttt{IO} type (see notes on \texttt{transformType}
-above). Ignoring the local computation trees in this case is safe
-since $\eta$ expansion across \texttt{IO} is valid only if the body of
-the function is a non-expansive expression, which means that all local
-computation trees are void (cf.\ p.~\pageref{eta-expansion} in
-Sect.~\ref{eta-expansion} for the definition of non-expansive
-expressions.)
-\begin{verbatim}
-
-> ---------------------------------------------------------------------------
-
-> debugFunction ::   (QualIdent -> Bool) -> Decl -> Decl
-> debugFunction trusted (FunctionDecl qId lVars fType expr)
->   | isQSelectorId qId = FunctionDecl qId lVars fType expr
->   | otherwise         = FunctionDecl qId' lVars fType expr'
->   where
->     isIO  = isIOType (resultType fType)
->     arity = length lVars
->     n     = typeArity fType
->     expr' = if isIO && arity > n
->             then newLocalDeclarationsEtaIO qId trust expr lVars arity
->             else newLocalDeclarations      qId trust expr lVars arity
->     qId' = changeFunctionqId qId
->     trust = trusted qId
-        
-
-> newLocalDeclarations :: QualIdent -> Bool -> Expression -> [Ident] ->
->                         Int -> Expression
-> newLocalDeclarations qId trust exp lVars arity  = 
->       exp' 
->       where   
->         (_,exp',_) = newBindings qId exp lVars' 0 [] True trust
->         lVars'        = drop ((length lVars)-arity) lVars
-
-> newLocalDeclarationsEtaIO :: QualIdent -> Bool -> Expression -> [Ident] ->
->                          Int -> Expression
-> newLocalDeclarationsEtaIO qId trust exp lVars arity  = 
->       etaExpandIO exp'' v
->       where   
->         (exp', v)   = etaReduceIO exp
->         (_,exp'',_) = newBindings qId exp' lVars' 0 [] False trust
->         lVars'        = drop ((length lVars)-arity) lVars
+A special case handles $\eta$-expanded functions with result type
+\texttt{IO}~$t$. According to the special transformation rule that
+applies to the \texttt{IO} type (see notes on \texttt{transformFunType}),
+we must not add a computation tree to the result of the transformed
+function, but rather make the transformed function return the
+computation tree together with its result in the \texttt{IO} monad.
+Thus, an $\eta$-expanded \texttt{IO} function $f \, x_1 \dots x_{n-1}
+\, x_n = e \, x_{n}$ is transformed into $f' \, x_1 \dots x_{n-1} \,
+x_n = \texttt{performIO} \, e' \, x_n$ where $e'$ is the transformed
+expression derived for $e$ and the auxiliary function
+\texttt{performIO}, which is defined in \texttt{DebugPrelude}, takes
+care of evaluating the transformed monadic action and returning a
+suitable computation tree. Its definition is
+\begin{verbatim}
+  performIO (m,t1) = m >>= \(r,t2) -> return (r, ioCTree t1 (r,t2))
+\end{verbatim}
+The auxiliary function \texttt{ioCTree}, which is also defined in
+\texttt{DebugPrelude}, simply adds the pair \texttt{(dEval r,t2)} to
+the list of subcomputations of the computation tree \texttt{t1}.
+\begin{verbatim}
+
+> debugSecondPhase :: ModuleIdent -> QualIdent -> Bool -> [Ident] -> Type
+>                  -> Expression -> Expression
+> debugSecondPhase m f trust vs ty e
+>   | isIOType (resultType ty) && length vs > typeArity ty =
+>       newLocalDeclarationsEtaIO m f trust vs e
+>   | otherwise = newLocalDeclarations m f trust vs e
+
+> newLocalDeclarations :: ModuleIdent -> QualIdent -> Bool -> [Ident]
+>                      -> Expression -> Expression
+> newLocalDeclarations m f trust vs e = snd (newBindings createNode m "" [] 0 e)
+>   where createNode = if trust then createEmptyNode else createTree f vs
+
+> newLocalDeclarationsEtaIO :: ModuleIdent -> QualIdent -> Bool -> [Ident]
+>                           -> Expression -> Expression
+> newLocalDeclarationsEtaIO m f trust vs e =
+>   etaExpandIO (newLocalDeclarations m f trust (init vs) e') v
+>   where (e',v) = etaReduceIO e
 
 > etaExpandIO :: Expression -> Expression -> Expression
-> etaExpandIO (Exist v e)   = Exist v . etaExpandIO e
-> etaExpandIO (Let d e)     = Let d . etaExpandIO e
-> etaExpandIO (Letrec ds e) = Letrec ds . etaExpandIO e
-> etaExpandIO e             = Apply e
+> etaExpandIO (Case rf e as) = Case rf e . zipWith etaExpandIOAlt as . repeat
+>   where etaExpandIOAlt (Alt t e) = Alt t . etaExpandIO e
+> etaExpandIO (Exist vs e)   = Exist vs . etaExpandIO e
+> etaExpandIO (Let rec ds e) = Let rec ds . etaExpandIO e
+> etaExpandIO (SrcLoc p e)   = SrcLoc p . etaExpandIO e
+> etaExpandIO e              = Apply (Apply debugPerformIO e)
 
 > etaReduceIO :: Expression -> (Expression,Expression)
-> etaReduceIO (Apply e1 e2) = (e1, e2)
-> etaReduceIO (Exist v e)   = (Exist v e', v')  where (e', v') = etaReduceIO e
-> etaReduceIO (Let d e)     = (Let d e', v)     where (e', v) = etaReduceIO e
-> etaReduceIO (Letrec ds e) = (Letrec ds e', v) where (e', v) = etaReduceIO e
+> etaReduceIO (Apply e1 e2)  = (e1, e2)
+> etaReduceIO (Case rf e1 [Alt t e2]) = (Case rf e1 [Alt t e2'], v)
+>                                                where (e2', v) = etaReduceIO e2
+> etaReduceIO (Exist vs e)   = (Exist vs e', v)   where (e', v) = etaReduceIO e
+> etaReduceIO (Let rec ds e) = (Let rec ds e', v) where (e', v) = etaReduceIO e
+> etaReduceIO (SrcLoc p e)   = (SrcLoc p e', v)   where (e', v) = etaReduceIO e
 > etaReduceIO e = error ("etaReduceIO " ++ showsPrec 11 e "")
 
+> debugPerformIO :: Expression
+> debugPerformIO = Function (debugQualPreludeName "performIO") 1
 
 \end{verbatim}
 
-This type represent the result of the next set of functions. The first part is a
-list with the new local definitions (bindings) introduced, 
-the second is a list with  the new computation trees
-introduced, prepared for function {\tt clean}. The last component is the
-expression after the introduction of the new local definitions.
-
-\begin{verbatim}
-
-> type SecondPhaseResult = ([Expression],Expression,Int)
-
-\end{verbatim}
-
-Next functions change a expression {\tt e} into {\tt let auxN = e in } 
-{\tt let resultN = fst e in } {\tt let treeN = snd e in} {\tt Variable resultN},
-where $N$ represents a number used to avoid repeated name of variables.
-Actually this infomation is returned in the following, more convinient format:
-{\tt (Trees++[cleanTree], Variable resultId)}, where  {\tt cleanTree} is
-{\tt (dVal resultN, treeN)}. The last value is the new value for $n$ that is used 
-to avoid repeating identifiers.
-
-\begin{verbatim}
-
-> decomposeExp :: [Expression] -> Int -> Expression ->  SecondPhaseResult
->
-> decomposeExp lTrees n exp = 
->       (lTrees++[cleanTree], letExp, n+1)
->       where 
->        treeId    = newIdName n "tree"
->        resultId  = newIdName n "result"
->        aux       = newIdName n "Aux"
->        auxResult = Apply (Function fst 1) (Variable aux)
->        auxTree   = Apply (Function snd 1) (Variable aux)
->        fst       = qualifyWith preludeMIdent (mkIdent "fst")
->        snd       = qualifyWith preludeMIdent (mkIdent "snd")
->        letExp    = Let (Binding aux exp) (Let (Binding resultId auxResult) 
->                    (Let (Binding treeId auxTree) (Variable resultId)) )
->        cleanTree = retrieveCleanTree (resultId,treeId)
-
-
-
-> newBindings :: QualIdent -> Expression -> [Ident] -> Int -> 
->                 [Expression] -> Bool -> Bool -> SecondPhaseResult
-> newBindings qId exp lVars n lTrees isMainExp trust = 
->       if  placeForCT then ([cleanTree], letExp,n2+1)
->       else extractBindings qId exp lVars n lTrees isMainExp trust
->       where 
->          freeCaseOr = noCaseOr exp
->          (lTrees2,exp2,n2) =  extractBindings qId exp lVars n 
->                                               lTrees False trust
->          placeForCT = isMainExp   && freeCaseOr
->          (lets,exp3)= extractLets exp2
->          treeId   = newIdName n2 "tree"
->          resultId = newIdName n2 "result"
->          vResult  = Variable resultId
->          vTree    = Variable treeId
->          cTree    = if trust then  createEmptyNode lTrees2
->                     else createTree qId lVars resultId lTrees2
->          cleanTree= retrieveCleanTree (resultId,treeId)
->          rhs      = debugBuildPairExp vResult vTree
->          bindingR = Binding resultId exp3
->          bindingT = Binding treeId cTree
->          letExp   = buildLetExp (lets++[Let bindingR,Let  bindingT]) rhs
-
-
-> extractBindings :: QualIdent -> Expression -> [Ident] -> Int -> 
->                [Expression] -> Bool -> Bool -> SecondPhaseResult
->
-> extractBindings qId e@(Function f a) lVars n lTrees isMainExp voidTree = 
->       if   a>0 then (lTrees,e,n)
->       else decomposeExp lTrees n e
-
-> extractBindings qId (Case eval exp lAlt) lVars n lTrees isMainExp voidTree = 
->       if isMainExp then ([], buildLetExp lets (Case eval e2 lAlt'),n2)
->       else decomposeExp [] n2 (buildLetExp lets (Case eval e2 lAlt'))
->       where
->        (lTrees1,e1,n1) = extractBindings qId exp lVars n lTrees False voidTree
->        (lets,e2) = extractLets e1
->        (lTrees2,lAlt',n2) = extractBindingsAlts qId lAlt lVars n1 lTrees1 trust
->        trust = not isMainExp || voidTree
-
-> extractBindings qId (Or e1 e2) lVars n lTrees isMainExp voidTree = 
->       if isMainExp then ([],Or e1' e2',n2)
->       else decomposeExp [] n2 (Or e1' e2')
->       where
->        (lTrees1,e1',n1) = newBindings qId e1 lVars n lTrees True trust
->        (lTrees2,e2',n2) = newBindings qId e2 lVars n1 lTrees True trust
->        trust = not isMainExp || voidTree
-
-> extractBindings qId (Exist id exp) lVars n lTrees isMainExp voidTree = 
->       (lTrees', Exist id exp',n')
->       where
->        (lTrees',exp',n') = extractBindings qId exp lVars n lTrees isMainExp voidTree
-
-> extractBindings qId (Let binding e) lVars n lTrees isMainExp voidTree = 
->       (lTrees2, buildLetExp lbinding' e',n2)
->       where
->        (lTrees1,lbinding',n1) = extractBindingsBinding qId binding  n  
->        (lTrees2, e',n2) = extractBindings qId e lVars n1 (lTrees++lTrees1) isMainExp voidTree
-
-> extractBindings qId (Letrec lbinding e) lVars n lTrees isMainExp voidTree = 
->       (lTrees2,buildLetrecExp lets lbinding' e',n2)
->       where
->        (lTrees1,lets,lbinding',n1) = extractBindingsLBindings qId lbinding  n
->        (lTrees2,e',n2) = extractBindings qId e lVars n1 (lTrees++lTrees1) isMainExp voidTree
->
-> extractBindings qId e@(Apply _ _) lVars n lTrees isMainExp voidTree = 
->       (lTrees1++lTrees2, buildLetExp 
->                            ((concat (map fst letArgs2))++letse) e2,n2)
->       where
->        (f,args) = extractApply e []
->        (lTrees1,args1,n1) = extractBindingsList qId args lVars n lTrees False voidTree
->        letArgs2 = map extractLets args1
->        (lTrees2,e1,n2) = extractBindingsApply f (map snd letArgs2) n1 
->        (letse,e2) = extractLets e1
->
-
-> extractBindings _ exp _ n lTrees _ _ = (lTrees,exp,n)
-
-
-> extractBindingsApply ::  Expression -> [Expression] -> 
->                         Int ->  SecondPhaseResult
-
-> extractBindingsApply  e@(Constructor qId arity) args  n  =
->       ([],createApply e args,n)
-
-> extractBindingsApply f@(Function qId arity) args  n  = 
->       if length args==arity-1  then ([],partialApp,n)
->       else if isQSelectorId qId then extractBindingsApply app extraArgs n
->       else (lTrees1++lTrees2,buildLetExp lets e,n2)
->       where 
+This type represents the result of the next set of functions. The
+first part is a list with the new computation trees introduced,
+prepared for function \texttt{clean}, the second is a context for the
+transformed expression with the new local definitions (bindings)
+introduced. The third component is the transformed expression itself
+(without the new local definitions).
+
+\begin{verbatim}
+
+> type SecondPhaseResult a = (Int,[Expression],Context,a)
+> type Context = Expression -> Expression
+
+\end{verbatim}
+
+The next function changes an expression \texttt{e} into \texttt{case e
+of \lb{}(result$N$, tree$N$) -> result$N$\rb{}}, when \texttt{e}
+occurs in a strict position, and into \texttt{let \lb{} aux$N$ = e
+\rb{} in let \lb{} result$N$ = fst e; tree$N$ = snd e \rb{} in
+result$N$}, when \texttt{e} occurs in a lazy position. $N$ represents
+a number used to ensure distinct names of variables. Actually this
+information is returned in the following, more convenient format: 
+\texttt{(Trees++[cleanTree], lets, Variable resultId)}, where
+\texttt{cleanTree} is \texttt{(dVal result$N$, tree$N$)} and
+\texttt{lets} is the context for the transformed expression, i.e.,
+either the case expression without its body or the local declarations
+of \texttt{aux$N$}, \texttt{result$N$}, and \texttt{tree$N$}.
+
+\begin{verbatim}
+
+> data Mode = Strict | Lazy
+
+> decomposeExp :: Mode -> Int -> Expression -> SecondPhaseResult Expression
+>
+> decomposeExp Strict n exp = (n+1,[cleanTree],match,Variable resultId)
+>   where resultId  = newIdName n "result"
+>         treeId    = newIdName n "tree"
+>         pattern   = ConstructorPattern qPairId [resultId,treeId]
+>         match     = Case Rigid exp . return . Alt pattern
+>         cleanTree = retrieveCleanTree resultId treeId
+> decomposeExp Lazy n exp = (n+1,[cleanTree],lets,Variable resultId)
+>   where auxId     = newIdName n "Aux"
+>         resultId  = newIdName n "result"
+>         treeId    = newIdName n "tree"
+>         fst       = Function (qualPreludeName "fst") 1
+>         snd       = Function (qualPreludeName "snd") 1
+>         lets      = Let NonRec [Binding auxId exp] .
+>                     Let NonRec [Binding resultId (Apply fst (Variable auxId)),
+>                                 Binding treeId (Apply snd (Variable auxId))]
+>         cleanTree = retrieveCleanTree resultId treeId
+
+
+> class SecondPhase a where
+>   newBindings :: (String -> Ident -> [Expression] -> Expression)
+>               -> ModuleIdent -> String -> [Expression] -> Int -> a -> (Int,a)
+
+> instance SecondPhase Expression where
+>   newBindings createNode _ p cts n e@(Literal _) =
+>     composeExp createNode p n cts e
+>   newBindings createNode _ p cts n e@(Variable _) =
+>     composeExp createNode p n cts e
+>   newBindings createNode m p cts n f@(Function _ a)
+>     | a > 0 = composeExp createNode p n cts (wrapPartial m (a - 1) f)
+>     | otherwise = (n2,lets1 e')
+>     where (n1,cts1,lets1,v) = decomposeExp Strict n f
+>           (n2,e') = composeExp createNode p n1 (cts++cts1) v
+>   newBindings createNode m p cts n e@(Constructor _ a) =
+>     composeExp createNode p n cts (wrapPartial m a e)
+>   newBindings createNode m p cts n e@(Apply _ _) = (n2,lets1 e'')
+>     where (n1,cts1,lets1,e') = extractBindings Strict m n e
+>           (n2,e'') = composeExp createNode p n1 (cts++cts1) e'
+>   newBindings createNode m p cts n (Case rf e as) =
+>     (n2,lets1 (Case rf e' as'))
+>     where (n1,cts1,lets1,e') = extractBindings Strict m n e
+>           (n2,as') = mapAccumL (newBindings createNode m p (cts++cts1)) n1 as
+>   newBindings createNode m p cts n (Choice es) = (n',Choice es')
+>     where (n',es') = mapAccumL (newBindings createNode m p cts) n es
+>   newBindings createNode m p cts n (Exist vs e) = (n',Exist vs e')
+>     where (n',e') = newBindings createNode m p cts n e
+>   newBindings createNode m p cts n (Let rec ds e) =
+>     (n2,letBindings rec lets1 ds' e')
+>     where (n1,cts1,lets1,ds') = extractBindings Lazy m n ds
+>           (n2,e') = newBindings createNode m p (cts++cts1) n1 e
+>   newBindings createNode m _ cts n (SrcLoc p e) = (n',SrcLoc p e')
+>     where (n',e') = newBindings createNode m p cts n e
+
+> instance SecondPhase Alt where
+>   newBindings createNode m p cts n (Alt t e) = (n',Alt t e')
+>     where (n',e') = newBindings createNode m p cts n e
+
+> composeExp :: (String -> Ident -> [Expression] -> Expression)
+>            -> String -> Int -> [Expression] -> Expression -> (Int,Expression)
+> composeExp createNode p n cts e = (n+1,e')
+>   where rid = newIdName n "result"
+>         tid = newIdName n "tree"
+>         ct  = createNode p rid cts
+>         e'  = Let NonRec [Binding rid e] $ Let NonRec [Binding tid ct] $
+>               debugBuildPairExp (Variable rid) (Variable tid)
+
+
+> class SecondPhaseArg a where
+>   extractBindings :: Mode -> ModuleIdent -> Int -> a -> SecondPhaseResult a
+
+> instance SecondPhaseArg a => SecondPhaseArg [a] where
+>   extractBindings _    _ n []     = (n,[],id,[])
+>   extractBindings mode m n (x:xs) = (n2,cts1++cts2,lets1 . lets2,x':xs')
+>     where (n1,cts1,lets1,x')  = extractBindings mode m n x
+>           (n2,cts2,lets2,xs') = extractBindings mode m n1 xs
+
+> instance SecondPhaseArg Expression where
+>   extractBindings mode m n e = (n2,cts1++cts2,lets1 . lets2,e')
+>     where (f,es) = extractApply e []
+>           (n1,cts1,lets1,es') = extractBindings Lazy m n es
+>           (n2,cts2,lets2,e') = extractBindingsApply mode m n1 f es'
+
+> instance SecondPhaseArg Binding where
+>   extractBindings _ m n (Binding v e) = (n',cts',lets',Binding v e')
+>     where (n',cts',lets',e') = extractBindings Lazy m n e
+
+
+> extractBindingsApply :: Mode -> ModuleIdent -> Int -> Expression
+>                      -> [Expression] -> SecondPhaseResult Expression
+
+> extractBindingsApply mode _ n e@(Literal _) args = applyValue mode n e args
+> extractBindingsApply mode _ n e@(Variable _) args = applyValue mode n e args
+> extractBindingsApply mode m n e@(Constructor _ arity) args =
+>   applyValue mode n (wrapPartial m d (createApply e args)) []
+>   where d = arity - length args
+> extractBindingsApply mode m n f@(Function _ arity) args
+>   | d > 0 = applyValue mode n (wrapPartial m (d - 1) (createApply f args)) []
+>   | otherwise = applyExp mode n (createApply f nArgs) extraArgs
+>   where d = arity - length args
 >         (nArgs,extraArgs) = splitAt arity args
->         app = createApply f nArgs
->         partialApp = createApply f args --05-12-2001
->         (lTrees1,v,n1) = decomposeExp [] n app
->         (lets,body) = extractLets v
->         (lTrees2,e,n2) = extractBindingsApply body extraArgs n1
-
-> extractBindingsApply f []  n  = ([],f,n)
-> 
-> extractBindingsApply f (e:es)  n  =
->       (t++t',buildLetExp lets e',n2)
->       where 
->         app = createApply f [e]
->         (t,v,n1) = decomposeExp [] n app
->         (lets,body) = extractLets v
->         (t',e',n2) = extractBindingsApply body es n1 
-
-
-> extractBindingsList::QualIdent -> [Expression] -> [Ident] -> Int -> 
->                      [Expression] -> Bool -> Bool ->
->                      ([Expression],[Expression],Int)
-> extractBindingsList _ [] _ n lTrees _ _ = (lTrees,[],n)
-> extractBindingsList qId (x:xs) lVars n lTrees isMainExp voidTree = 
->       (lTrees2, x':xs',n2)
->       where
->        (lTrees1,x',n1) = newBindings qId x lVars n lTrees isMainExp voidTree
->        (lTrees2,xs',n2) = extractBindingsList qId xs lVars n1 lTrees1 isMainExp voidTree 
-
-
-> extractBindingsBinding:: QualIdent -> Binding ->  Int -> 
->                          ([Expression],[Expression->Expression],Int)
-> extractBindingsBinding qId (Binding vId e)  n  = (lTrees,lBinding,n')
->       where
->        (lTrees,e1,n') = newBindings qId e [] n [] False False
->        (lets,e2)      = extractLets e1
->        lBinding       = lets++[Let (Binding vId e2)]
-
-
-> extractBindingsLBindings:: QualIdent -> [Binding]  -> Int -> 
->                      ([Expression],[Expression->Expression],[Binding],Int)
-> extractBindingsLBindings qId []  n  = ([],[],[],n)
-> extractBindingsLBindings qId (x:xs)  n  = 
->       (lTrees1++lTrees2,letsX++letsXs,(Binding vId e2):xs',n2)
->       where
->        (Binding vId e) = x
->        (lTrees1,e1,n1) = newBindings qId e [] n [] False False
->        (letsX,e2)       = extractLets e1
->        (lTrees2,letsXs,xs',n2) = extractBindingsLBindings qId xs n1
-
-
-> extractBindingsAlts:: QualIdent -> [Alt] -> [Ident] -> Int -> [Expression] ->
->                       Bool -> ([Expression],[Alt],Int)
-
-> extractBindingsAlts _ [] _ n  _ _    = ([],[],n)
-> extractBindingsAlts qId (x:xs) lVars n lTrees voidTree = 
->       (lTrees1++lTrees2,(Alt const e'):xs',n2)
->       where
->        (Alt const e) = x
->        (lTrees1,e',n1) = newBindings qId e lVars n lTrees True voidTree
->        (lTrees2,xs',n2) = extractBindingsAlts qId xs lVars n1 lTrees voidTree 
-
-          
-> noCaseOr :: Expression -> Bool
-> noCaseOr (Case _ _ _) = False
-> noCaseOr (Or _ _) = False
-> noCaseOr (Apply e1 _) = noCaseOr e1
-> noCaseOr (Exist _ exp) = noCaseOr exp
-> noCaseOr (Let _ exp) = noCaseOr exp
-> noCaseOr (Letrec _ exp) = noCaseOr exp
-> noCaseOr _ = True
-          
-> createTree :: QualIdent ->  [Ident] -> Ident -> [Expression] -> Expression
-> createTree qId lVars resultId trees = 
->       node fName fParams fResult debugNil clean
->       where
->       (idModule,ident) = splitQualIdent qId
->       fNameCh = maybe "" moduleName idModule ++ "." ++ name ident
->       fName   = debugBuildList (map (Literal . Char) fNameCh)
->       fParams = debugBuildList (map (dEvalApply.Variable) lVars)
->       fResult = (dEvalApply.Variable) resultId
->       clean   = Apply (Function debugClean 1) (debugBuildList trees)
-
-> buildLetExp :: [Expression->Expression] -> Expression -> Expression
-> buildLetExp bindings exp =  foldr (\x y->x y) exp bindings
-
-> buildLetrecExp :: [Expression->Expression] -> [Binding] -> Expression -> Expression
-> buildLetrecExp bindings lbindings exp =
->   fixLetrecExp lbindings (buildLetExp bindings (Letrec [] exp))
-
-> fixLetrecExp :: [Binding] -> Expression -> Expression
-> fixLetrecExp lbindings (Exist var exp) = Exist var (fixLetrecExp lbindings exp)
-> fixLetrecExp lbindings (Let binding exp) = fixLetrecExp (binding:lbindings) exp
-> fixLetrecExp lbindings (Letrec lbindings' exp)
->   | null lbindings' = Letrec lbindings exp
->   | otherwise = fixLetrecExp (lbindings' ++ lbindings) exp
+> extractBindingsApply mode m n e@(Case _ _ _) args = applyExp mode n' e' args
+>   where (n',e') = newBindings createEmptyNode m "" [] n e
+> extractBindingsApply mode m n e@(Choice _) args = applyExp mode n' e' args
+>   where (n',e') = newBindings createEmptyNode m "" [] n e
+> extractBindingsApply mode m n (Exist vs e) args =
+>   (n2,cts1++cts2,Exist vs . lets1 . lets2,e'')
+>   where (n1,cts1,lets1,e') = extractBindings mode m n e
+>         (n2,cts2,lets2,e'') = applyValue mode n1 e' args
+> extractBindingsApply mode m n (Let rec ds e) args =
+>   (n3,cts1++cts2++cts3,letBindings rec lets1 ds' . lets2 . lets3,e'')
+>   where (n1,cts1,lets1,ds') = extractBindings Lazy m n ds
+>         (n2,cts2,lets2,e') = extractBindings mode m n1 e
+>         (n3,cts3,lets3,e'') = applyValue mode n2 e' args
+> extractBindingsApply mode m n (SrcLoc p e) args =
+>   (n2,cts1++cts2,lets1 . lets2,e'')
+>   where (n1,cts1,lets1,e') = extractBindings mode m n e
+>         (n2,cts2,lets2,e'') = applyValue mode n1 (SrcLoc p e') args
+
+> applyValue :: Mode -> Int -> Expression -> [Expression]
+>            -> SecondPhaseResult Expression
+> applyValue _    n f []     = (n,[],id,f)
+> applyValue mode n f (e:es) = applyExp mode n (Apply f e) es
+
+> applyExp :: Mode -> Int -> Expression -> [Expression]
+>          -> SecondPhaseResult Expression
+> applyExp mode n e es = (n2,cts1++cts2,lets1 . lets2,e')
+>   where (n1,cts1,lets1,v) = decomposeExp mode n e
+>         (n2,cts2,lets2,e') = applyValue mode n1 v es
 
-\end{verbatim}
 
+> extractApply :: Expression -> [Expression] -> (Expression,[Expression])
+> extractApply (Apply e1 e2) l = extractApply e1 (e2:l)
+> extractApply e1 l = (e1,l)
 
-Extract lets put all the let, exist and letrec constructions in the outer part
-of the expression. Teh expression is assumed to be free of case and or expressions.
+> createApply :: Expression -> [Expression] -> Expression
+> createApply exp lExp = foldl Apply exp lExp
 
-\begin{verbatim}
 
-> outerLets :: Expression ->  Expression
-> outerLets e = foldr (\x y -> x y) e' l
->       where (l,e') = extractLets e
-
-> extractLets :: Expression ->  ([Expression->Expression],Expression)
->
-> extractLets (Apply e1 e2) = (l1++l2,Apply e1'  e2')
->       where (l1,e1') = extractLets e1
->             (l2,e2') = extractLets e2
-> extractLets (Exist ident e) = ((Exist ident):l1,e')
->       where (l1,e') = extractLets e
-> extractLets (Let binding e) = ((Let binding):l1,e')
->       where (l1,e') = extractLets e
-> extractLets (Letrec lbinding e) = ((Letrec lbinding):l1,e')
->       where (l1,e') = extractLets e
-> extractLets e = ([],e)
+> createTree :: QualIdent -> [Ident] -> String -> Ident -> [Expression]
+>            -> Expression
+> createTree qId lVars rule resultId trees =
+>   node fName fParams fResult fRule clean
+>   where (idModule,ident) = splitQualIdent qId
+>         fNameCh = maybe "" moduleName idModule ++ "." ++ name ident
+>         fName   = debugBuildList (map (Literal . Char) fNameCh)
+>         fParams = debugBuildList (map (dEvalApply.Variable) lVars)
+>         fResult = (dEvalApply.Variable) resultId
+>         fRule   = debugBuildList (map (Literal . Char) rule)
+>         clean   = if null trees then debugNil
+>                   else Apply (Function debugClean 1) (debugBuildList trees)
+
+> createEmptyNode :: String -> Ident -> [Expression] -> Expression
+> createEmptyNode _ _ trees = if null trees then void else emptyNode clean
+>   where clean = Apply (Function debugClean 1) (debugBuildList trees)
+
+> letBindings :: Rec -> Context -> [Binding] -> Context
+> letBindings NonRec lets ds = lets . Let NonRec ds
+> letBindings Rec lets ds =
+>   fixLetrecBindings (Let Rec) (lets (Let Rec ds (Variable undefined)))
+
+> fixLetrecBindings :: ([Binding]->Context) -> Expression -> Context
+> fixLetrecBindings bindings (Variable _) = bindings []
+> fixLetrecBindings bindings (Exist vs e) =
+>   Exist vs . fixLetrecBindings bindings e
+> fixLetrecBindings bindings (Let _ ds e) =
+>   fixLetrecBindings (bindings . (ds++)) e
 
 \end{verbatim}
 
-
-Function {\tt retrieveCleanTree} convert a value {\tt SecondPhaseResult} 
-of the form {(res,tree),exp)} representing
-a  new local let, into an element of the list of trees of the form
-{\tt (dEval res,tree)}.
+The function \texttt{retrieveCleanTree} computes an element of the
+list of computation trees of the form \texttt{(dEval $r$,$t$)} for a
+given pair of variables $r$ and $t$ bound to a subcomputation result
+and its associated computation tree, respectively.
 
 \begin{verbatim}
 
-> retrieveCleanTree :: (Ident,Ident) -> Expression
-> retrieveCleanTree (id1,id2) = debugBuildPairExp id1' id2'
->       where
->        id1' = dEvalApply (Variable id1 )
->        id2' = Variable id2
-
-
-\end{verbatim}
-
-\begin{verbatim}
-
-> changeFunctionqId :: QualIdent -> QualIdent
-> changeFunctionqId qId = qId'
->       where
->       (idModule,ident) = splitQualIdent qId
->       ident'    = debugRenameId "" ident
->       qId'      = maybe qId (flip qualifyWith ident') idModule
+> retrieveCleanTree :: Ident -> Ident -> Expression
+> retrieveCleanTree id1 id2 =
+>   debugBuildPairExp (dEvalApply (Variable id1)) (Variable id2)
 
 \end{verbatim}
-
diff -u curry-0.9.11/Env.lhs curry-0.9.11-classful/Env.lhs
--- curry-0.9.11/Env.lhs	2007-06-15 14:16:36.000000000 +0200
+++ curry-0.9.11-classful/Env.lhs	2007-08-27 08:51:43.000000000 +0200
@@ -1,7 +1,7 @@
 % -*- LaTeX -*-
-% $Id: Env.lhs 1744 2005-08-23 16:17:12Z wlux $
+% $Id: Env.lhs 2454 2007-08-23 23:06:53Z wlux $
 %
-% Copyright (c) 2002, Wolfgang Lux
+% Copyright (c) 2002-2007, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{Env.lhs}
@@ -20,12 +20,10 @@
     \mathop{{\mathcal C}odom}(\rho) = \left\{t_1,\dots,t_n\right\}
   \end{array}
 \end{displaymath}
-
-Unfortunately we cannot define \texttt{Env} as a \texttt{newtype}
-because of a bug in the nhc compiler.
 \begin{verbatim}
 
-> module Env where
+> module Env(Env, emptyEnv, bindEnv, unbindEnv, lookupEnv,
+>            environment, envToList, envSize) where
 > import Map
 
 > newtype Env a b = Env (FM a b) deriving Show
diff -u curry-0.9.11/Error.lhs curry-0.9.11-classful/Error.lhs
--- curry-0.9.11/Error.lhs	2007-06-15 14:16:36.000000000 +0200
+++ curry-0.9.11-classful/Error.lhs	2006-11-30 15:13:52.000000000 +0100
@@ -1,5 +1,5 @@
 % -*- LaTeX -*-
-% $Id: Error.lhs 1965 2006-08-31 08:32:33Z wlux $
+% $Id: Error.lhs 1972 2006-09-19 18:32:32Z wlux $
 %
 % Copyright (c) 2003-2006, Wolfgang Lux
 % See LICENSE for the full license.
diff -u curry-0.9.11/Exports.lhs curry-0.9.11-classful/Exports.lhs
--- curry-0.9.11/Exports.lhs	2007-06-15 14:16:34.000000000 +0200
+++ curry-0.9.11-classful/Exports.lhs	2011-10-08 12:42:57.000000000 +0200
@@ -1,108 +1,244 @@
 % -*- LaTeX -*-
-% $Id: Exports.lhs 2148 2007-04-02 13:56:20Z wlux $
+% $Id: Exports.lhs 3056 2011-10-07 16:27:03Z wlux $
 %
-% Copyright (c) 2000-2007, Wolfgang Lux
+% Copyright (c) 2000-2011, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{Exports.lhs}
-\section{Creating Interfaces}
+\section{Creating Interfaces}\label{sec:exports}
 After checking a module, the compiler generates the interface's
 declarations from the list of exported types and values. If an entity
 is imported from another module, its name is qualified with the name
-of the module containing its definition. Furthermore, newtypes whose
-constructor is not exported are transformed into (abstract) data
-types.
+of the module containing its definition. Instances are exported
+together with their classes and types as explained below.
+
+Data types and renaming types whose constructors and field labels are
+not exported are exported as abstract types, i.e., their constructors
+do not appear in the interface. If only some constructors or field
+labels of a type are not exported all constructors appear in the
+interface, but a pragma marks the constructors and field labels which
+are not exported as hidden to prevent their use in user code. A
+special case is made for the Prelude's \texttt{Success} type, whose
+only constructor is not exported from the Prelude. Since the compiler
+makes use of this constructor when flattening guard expressions (cf.\
+Sect.~\ref{sec:flatcase}), \texttt{typeDecl}'s \texttt{DataType} case
+explicitly forces the \texttt{Success} constructor to appear as hidden
+data constructor in the interface. For a similar reason, the compiler
+also forces the \verb|:%| constructor of type \texttt{Ratio.Ratio} to
+appear in interfaces.
+
+\textbf{Attention:} The compiler assumes that the environments passed
+to \texttt{exportInterface} reflect the types of the module's entities
+after type inference. However, the source code module passed to
+\texttt{exportInterface} must reflect the module's code \emph{after}
+applying all source code transformations to the program so that
+correct arity annotations are written to the interface.
 \begin{verbatim}
 
 > module Exports(exportInterface) where
 > import Base
+> import Curry
+> import CurryUtils
+> import Env
+> import InstInfo
+> import IntfQual
+> import Kinds
+> import KindTrans
+> import List
+> import Maybe
+> import PrecInfo
+> import PredefIdent
 > import Set
 > import TopEnv
+> import Types
+> import TypeInfo
 > import TypeTrans
+> import ValueInfo
 
-> exportInterface :: Module -> PEnv -> TCEnv -> ValueEnv -> Interface
-> exportInterface (Module m (Just (Exporting _ es)) _ _) pEnv tcEnv tyEnv =
->   Interface m imports (precs ++ hidden ++ ds)
->   where imports = map (IImportDecl noPos) (usedModules ds)
->         precs = foldr (infixDecl m pEnv) [] es
->         hidden = map (hiddenTypeDecl m tcEnv) (hiddenTypes ds)
->         ds =
->           foldr (typeDecl m tcEnv tyEnv)
->                 (foldr (funDecl m tcEnv tyEnv) [] es)
->                 es
-
-> infixDecl :: ModuleIdent -> PEnv -> Export -> [IDecl] -> [IDecl]
-> infixDecl m pEnv (Export f) ds = iInfixDecl m pEnv f ds
-> infixDecl m pEnv (ExportTypeWith tc cs) ds =
->   foldr (iInfixDecl m pEnv . qualifyLike tc) ds cs
+> exportInterface :: Module a -> PEnv -> TCEnv -> InstEnv -> ValueEnv
+>                 -> Interface
+> exportInterface (Module m (Just (Exporting _ es)) _ ds) pEnv tcEnv iEnv tyEnv =
+>   Interface m imports (unqualIntf m (precs ++ ds''))
+>   where aEnv = bindArities m ds
+>         tcs = foldr definedType [] ds''
+>         tcs' = [tc | Just tc <- map (localIdent m) tcs]
+>         tvs = filter (`notElem` tcs') nameSupply
+>         imports = map (IImportDecl noPos) (filter (m /=) (usedModules ds''))
+>         precs = foldr (infixDecl pEnv) [] es
+>         ds' = types ++ values ++ insts
+>         ds'' = closeInterface m tcEnv iEnv aEnv tvs zeroSet ds'
+>         types = foldr (typeDecl tcEnv aEnv tyEnv tvs) [] es
+>         values = foldr (valueDecl aEnv tyEnv tvs) [] es
+>         insts = foldr (uncurry (instDecl tcEnv aEnv tvs)) [] (envToList iEnv)
+
+> infixDecl :: PEnv -> Export -> [IDecl] -> [IDecl]
+> infixDecl pEnv (Export f) ds = iInfixDecl pEnv f ds
+> infixDecl pEnv (ExportTypeWith tc cs) ds =
+>   foldr (iInfixDecl pEnv . qualifyLike tc) ds cs
 
-> iInfixDecl :: ModuleIdent -> PEnv -> QualIdent -> [IDecl] -> [IDecl]
-> iInfixDecl m pEnv op ds =
+> iInfixDecl :: PEnv -> QualIdent -> [IDecl] -> [IDecl]
+> iInfixDecl pEnv op ds =
 >   case qualLookupTopEnv op pEnv of
 >     [] -> ds
->     [PrecInfo _ (OpPrec fix pr)] ->
->       IInfixDecl noPos fix pr (qualUnqualify m op) : ds
+>     [PrecInfo _ (OpPrec fix pr)] -> IInfixDecl noPos fix pr op : ds
 >     _ -> internalError "infixDecl"
 
-> typeDecl :: ModuleIdent -> TCEnv -> ValueEnv -> Export -> [IDecl] -> [IDecl]
-> typeDecl _ _ _ (Export _) ds = ds
-> typeDecl m tcEnv tyEnv (ExportTypeWith tc cs) ds =
+> typeDecl :: TCEnv -> ArityEnv -> ValueEnv -> [Ident] -> Export -> [IDecl]
+>          -> [IDecl]
+> typeDecl _ _ _ _ (Export _) ds = ds
+> typeDecl tcEnv aEnv tyEnv tvs (ExportTypeWith tc xs) ds =
 >   case qualLookupTopEnv tc tcEnv of
->     [DataType _ n cs'] -> iTypeDecl IDataDecl m tc n constrs : ds
->       where constrs evs
->               | null cs = []
->               | otherwise =
->                   map (>>= fmap (constrDecl tcEnv tyEnv tc n evs) . hide cs)
->                       cs'
->             hide cs c
->               | c `elem` cs = Just c
->               | otherwise = Nothing
->     [RenamingType _ n c]
->       | null cs -> iTypeDecl IDataDecl m tc n (const []) : ds
->       | otherwise -> iTypeDecl INewtypeDecl m tc n newConstr : ds
->       where newConstr _ = newConstrDecl tcEnv tyEnv tc c
->     [AliasType _ n ty] ->
->       iTypeDecl ITypeDecl m tc n (const (fromType tcEnv ty)) : ds
+>     [DataType _ k cs]
+>       | null xs && tc /= qSuccessId && tc /= qRatioId ->
+>           iTypeDecl IDataDecl [] tc tvs n k [] [] : ds
+>       | otherwise -> iTypeDecl IDataDecl cx' tc tvs n k cs' xs' : ds
+>       where n = kindArity k
+>             xs' = filter (`notElem` xs) (cs ++ ls)
+>             QualTypeExpr cx' _ = fromQualType tvs ty'
+>             ty' = canonType (qualInstType (nub (concat cxs)) tc n)
+>             (cxs,cs') = unzip (map (constrDecl tyEnv xs tc tvs) cs)
+>             ls = nub (concatMap labels cs')
+>     [RenamingType _ k c]
+>       | null xs -> iTypeDecl IDataDecl [] tc tvs n k [] [] : ds
+>       | otherwise -> iTypeDecl INewtypeDecl cx tc tvs n k nc xs' : ds
+>       where n = kindArity k
+>             (cx,nc) = newConstrDecl tyEnv xs tc tvs c
+>             xs' = [c | c `notElem` xs]
+>     [AliasType _ n k ty] ->
+>       iTypeDecl (const . ITypeDecl) [] tc tvs n k (fromType tvs ty) : ds
+>     [TypeClass _ k clss fs] ->
+>       iClassDecl IClassDecl tc tvs k clss methods fs' : ds
+>       where methods = map (methodDecl aEnv tyEnv tc tvs) fs
+>             fs' = filter (`notElem` xs) (map fst fs)
 >     _ -> internalError "typeDecl"
 
-> iTypeDecl :: (Position -> QualIdent -> [Ident] -> a -> IDecl)
->           -> ModuleIdent -> QualIdent -> Int -> ([Ident] -> a) -> IDecl
-> iTypeDecl f m tc n g = f noPos (qualUnqualify m tc) tvs (g tvs')
->   where (tvs,tvs') = splitAt n nameSupply
-
-> constrDecl :: TCEnv -> ValueEnv -> QualIdent -> Int -> [Ident] -> Ident
->            -> ConstrDecl
-> constrDecl tcEnv tyEnv tc n evs c =
->   ConstrDecl noPos (take (n' - n) evs) c (map (fromType tcEnv) (arrowArgs ty))
->   where ForAll n' ty = conType (qualifyLike tc c) tyEnv
-
-> newConstrDecl :: TCEnv -> ValueEnv -> QualIdent -> Ident -> NewConstrDecl
-> newConstrDecl tcEnv tyEnv tc c =
->   NewConstrDecl noPos c (fromType tcEnv (head (arrowArgs ty)))
->   where ForAll _ ty = conType (qualifyLike tc c) tyEnv
-
-> funDecl :: ModuleIdent -> TCEnv -> ValueEnv -> Export -> [IDecl] -> [IDecl]
-> funDecl m tcEnv tyEnv (Export f) ds =
->   IFunctionDecl noPos (qualUnqualify m f) n' (fromType tcEnv ty) : ds
->   where n = arity f tyEnv
->         n' = if arrowArity ty == n then Nothing else Just n
->         ty = rawType (funType f tyEnv)
-> funDecl _ _ _ (ExportTypeWith _ _) ds = ds
+> iTypeDecl :: (Position -> [ClassAssert] -> QualIdent -> Maybe KindExpr
+>               -> [Ident] -> a)
+>           -> [ClassAssert] -> QualIdent -> [Ident] -> Int -> Kind -> a
+> iTypeDecl f cx tc tvs n k = f noPos cx tc k' (take n tvs)
+>   where k' = if k == simpleKind n then Nothing else Just (fromKind k)
+
+> iClassDecl :: (Position -> [ClassAssert] -> QualIdent -> Maybe KindExpr
+>                -> Ident -> a)
+>            -> QualIdent -> [Ident] -> Kind -> [QualIdent] -> a
+> iClassDecl f cls tvs k clss = f noPos cx cls k' tv
+>   where k' = if k == KindStar then Nothing else Just (fromKind k)
+>         tv = head tvs
+>         cx = [ClassAssert cls (VariableType tv) | cls <- clss]
+
+> constrDecl :: ValueEnv -> [Ident] -> QualIdent -> [Ident] -> Ident
+>            -> (Context,ConstrDecl)
+> constrDecl tyEnv xs tc tvs c
+>   | any (`elem` xs) ls = (cxL,RecordDecl noPos evs cxR' c fs)
+>   | otherwise = (cxL,ConstrDecl noPos evs cxR' c tys)
+>   where evs = drop (n - n') (take n tvs)
+>         (ls,ConstrInfo n' cxR,ForAll n (QualType cx ty)) =
+>           conType (qualifyLike tc c) tyEnv
+>         cxL = filter (`notElem` cxR) cx
+>         QualTypeExpr cxR' ty' = fromQualType tvs (QualType cxR ty)
+>         tys = argTypes ty'
+>         fs = zipWith (FieldDecl noPos . return) ls tys
+
+> newConstrDecl :: ValueEnv -> [Ident] -> QualIdent -> [Ident] -> Ident
+>               -> ([ClassAssert],NewConstrDecl)
+> newConstrDecl tyEnv xs tc tvs c
+>   | l `elem` xs = (cx',NewRecordDecl noPos c l ty'')
+>   | otherwise = (cx',NewConstrDecl noPos c ty'')
+>   where (l:_,_,ForAll _ ty) = conType (qualifyLike tc c) tyEnv
+>         QualTypeExpr cx' ty' = fromQualType tvs ty
+>         ty'' = head (argTypes ty')
+
+> methodDecl :: ArityEnv -> ValueEnv -> QualIdent -> [Ident] -> (Ident,Int)
+>            -> IMethodDecl
+> methodDecl aEnv tyEnv cls tvs (f,n) =
+>   IMethodDecl noPos f n' (fromQualType tvs (contextMap tail ty))
+>   where n' = arityAnnot (qualifyLike cls (dfltMethodId f)) n 0 aEnv
+>         ForAll _ ty = funType (qualifyLike cls f) tyEnv
+
+> valueDecl :: ArityEnv -> ValueEnv -> [Ident] -> Export -> [IDecl] -> [IDecl]
+> valueDecl aEnv tyEnv tvs (Export f) ds =
+>   IFunctionDecl noPos f n (fromQualType tvs ty) : ds
+>   where n = arityAnnot f (arity f tyEnv) (arrowArity (unqualType ty)) aEnv
+>         ForAll _ ty = funType f tyEnv
+> valueDecl _ _ _ (ExportTypeWith _ _) ds = ds
+
+> instDecl :: TCEnv -> ArityEnv -> [Ident] -> CT -> InstInfo -> [IDecl]
+>          -> [IDecl]
+> instDecl tcEnv aEnv tvs (CT cls tc) (m,cx,fs) ds
+>   | fst (splitQualIdent cls) /= Just m && fst (splitQualIdent tc) /= Just m =
+>       iInstDecl tcEnv aEnv tvs (CT cls tc) (m,cx,fs) : ds
+>   | otherwise = ds
+
+> iInstDecl :: TCEnv -> ArityEnv -> [Ident] -> CT -> InstInfo -> IDecl
+> iInstDecl tcEnv aEnv tvs (CT cls tc) (m,cx,fs) =
+>   IInstanceDecl noPos cx' cls ty' (Just m) [(f,n) | (f,Just n) <- fs']
+>   where QualTypeExpr cx' ty' = fromQualType tvs (qualInstType cx tc n)
+>         n = kindArity (constrKind tc tcEnv) - kindArity (classKind cls tcEnv)
+>         fs' = [(f,arityAnnot (qInstMethodId m tc f) n 0 aEnv) | (f,n) <- fs]
+>         qInstMethodId m tc f = qualifyWith m (instMethodId tc f)
+
+> arityAnnot :: QualIdent -> Int -> Int -> ArityEnv -> Maybe Integer
+> arityAnnot f n n0 aEnv = if n' == n0 then Nothing else Just (toInteger n')
+>   where n' = fromMaybe n (lookupEnv f aEnv)
+
+\end{verbatim}
+Simplification can change the arity of an exported function defined in
+the current module via $\eta$-expansion (cf.\ 
+Sect.~\ref{eta-expansion}). In order to generate correct arity
+annotations, the compiler collects the arities of all user defined
+functions at the top-level and in the class and instance declarations
+of the transformed code in an auxiliary environment. Note that we
+ignore foreign function declarations here because their arities are
+fixed and cannot be changed by program transformations. When adding
+the arities of default type class and instance methods, we must remove
+the unique key added during renaming. Furthermore, we prefix default
+and instance method identifiers with an anonymous identifier and the
+name of the instance's type, respectively. This is necessary for
+default method implementations so that their arities are not confused
+with that of a method (stub) if a method is exported without its
+class, i.e., like a top-level function, and for instance methods to
+avoid name conflicts between methods of different instances of the
+same class.
+\begin{verbatim}
+
+> type ArityEnv = Env QualIdent Int
+
+> bindArities :: ModuleIdent -> [TopDecl a] -> ArityEnv
+> bindArities m ds = foldr bindArity emptyEnv (concatMap functions ds)
+>   where bindArity (f,eqs) = bindEnv (qualifyWith m f) (eqnArity (head eqs))
+
+> functions :: TopDecl a -> [(Ident,[Equation a])]
+> functions (DataDecl _ _ _ _ _ _) = []
+> functions (NewtypeDecl _ _ _ _ _ _) = []
+> functions (TypeDecl _ _ _ _) = []
+> functions (ClassDecl _ _ _ _ ds) =
+>   [(dfltMethodId (unRenameIdent f),eqs) | FunctionDecl _ _ f eqs <- ds]
+> functions (InstanceDecl _ _ _ ty ds) =
+>   [(instMethodId tc (unRenameIdent f),eqs) | FunctionDecl _ _ f eqs <- ds]
+>   where tc = typeConstr ty
+> functions (DefaultDecl _ _) = []
+> functions (BlockDecl d) =
+>   case d of
+>     FunctionDecl _ _ f eqs -> [(f,eqs)]
+>     _ -> []
+
+> dfltMethodId  :: Ident -> Ident
+> dfltMethodId = instMethodId (qualify anonId)
+
+> instMethodId :: QualIdent -> Ident -> Ident
+> instMethodId tc f = mkIdent (qualName tc ++ '.' : name f)
 
 \end{verbatim}
 The compiler determines the list of imported modules from the set of
-module qualifiers that are used in the interface. Careful readers
-probably will have noticed that the functions above carefully strip
-the module prefix from all entities that are defined in the current
-module. Note that the list of modules returned from
-\texttt{usedModules} is not necessarily a subset of the modules that
-were imported into the current module. This will happen when an
-imported module re-exports entities from another module. E.g., given
-the three modules
-\begin{verbatim}
-module A where { data A = A; }
-module B(A(..)) where { import A; }
-module C where { import B; x = A; }
+module qualifiers that are used in the interface. Note that the list
+of modules returned from \texttt{usedModules} is not necessarily a
+subset of the union of the current module and the modules that were
+imported into it. This will happen when an imported module reexports
+entities from another module. E.g., given the three modules
+\begin{verbatim}
+module A where { data T = T; }
+module B(T(..)) where { import A; }
+module C where { import B; x = T; }
 \end{verbatim}
 the interface for module \texttt{C} will import module \texttt{A} but
 not module \texttt{B}.
@@ -122,52 +258,196 @@
 >   modules xs ms = foldr modules ms xs
 
 > instance HasModule IDecl where
->   modules (IDataDecl _ tc _ cs) = modules tc . modules cs
->   modules (INewtypeDecl _ tc _ nc) = modules tc . modules nc
->   modules (ITypeDecl _ tc _ ty) = modules tc . modules ty
+>   modules (IInfixDecl _ _ _ op) = modules op
+>   modules (HidingDataDecl _ tc _ _) = modules tc
+>   modules (IDataDecl _ cx tc _ _ cs _) = modules cx . modules tc . modules cs
+>   modules (INewtypeDecl _ cx tc _ _ nc _) =
+>     modules cx . modules tc . modules nc
+>   modules (ITypeDecl _ tc _ _ ty) = modules tc . modules ty
+>   modules (HidingClassDecl _ cx cls _ _) = modules cx . modules cls
+>   modules (IClassDecl _ cx cls _ _ ds _) =
+>     modules cx . modules cls . modules ds
+>   modules (IInstanceDecl _ cx cls ty m _) =
+>      modules cx . modules cls . modules ty . maybe id (:) m
 >   modules (IFunctionDecl _ f _ ty) = modules f . modules ty
 
 > instance HasModule ConstrDecl where
->   modules (ConstrDecl _ _ _ tys) = modules tys
->   modules (ConOpDecl _ _ ty1 _ ty2) = modules ty1 . modules ty2
+>   modules (ConstrDecl _ _ cx _ tys) = modules cx . modules tys
+>   modules (ConOpDecl _ _ cx ty1 _ ty2) =
+>     modules cx . modules ty1 . modules ty2
+>   modules (RecordDecl _ _ cx _ fs) = modules cx . modules fs
+
+> instance HasModule FieldDecl where
+>   modules (FieldDecl _ _ ty) = modules ty
 
 > instance HasModule NewConstrDecl where
 >   modules (NewConstrDecl _ _ ty) = modules ty
+>   modules (NewRecordDecl _ _ _ ty) = modules ty
+
+> instance HasModule IMethodDecl where
+>   modules (IMethodDecl _ _ _ ty) = modules ty
+
+> instance HasModule QualTypeExpr where
+>   modules (QualTypeExpr cx ty) = modules cx . modules ty
+
+> instance HasModule ClassAssert where
+>   modules (ClassAssert cls ty) = modules cls . modules ty
 
 > instance HasModule TypeExpr where
->   modules (ConstructorType tc tys) = modules tc . modules tys
+>   modules (ConstructorType tc) = modules tc
 >   modules (VariableType _) = id
 >   modules (TupleType tys) = modules tys
 >   modules (ListType ty) = modules ty
 >   modules (ArrowType ty1 ty2) = modules ty1 . modules ty2
+>   modules (ApplyType ty1 ty2) = modules ty1 . modules ty2
 
 > instance HasModule QualIdent where
 >   modules = maybe id (:) . fst . splitQualIdent
 
 \end{verbatim}
-After the interface declarations have been computed, the compiler adds
-hidden (data) type declarations to the interface for all types which
-were used in the interface but are not exported from it. This is
-necessary in order to distinguish type constructors and type
-variables. Furthermore, by including hidden types in interfaces the
-compiler can check them without loading the imported modules.
-\begin{verbatim}
-
-> hiddenTypeDecl :: ModuleIdent -> TCEnv -> QualIdent -> IDecl
-> hiddenTypeDecl m tcEnv tc = HidingDataDecl noPos tc (take n nameSupply)
->   where n = constrKind (qualQualify m tc) tcEnv
-
-> hiddenTypes :: [IDecl] -> [QualIdent]
-> hiddenTypes ds =
->   filter (not . isPrimTypeId) (toListSet (foldr deleteFromSet used defd))
->   where used = fromListSet (usedTypes ds [])
->         defd = foldr definedType [] ds
+After an initial interface has been computed from the list of exported
+types and classes, the compiler adds hidden (data) type and class
+declarations to the interface for all types and classes which are used
+in the interface but not exported from it. For types declared in the
+current module, hidden type declarations are necessary in order to
+distinguish type constructors and type variables in the interface.
+Furthermore, by including hidden types and classes in interfaces the
+compiler can check them without loading the imported modules. Besides
+hidden type and class declarations, the compiler also adds the
+necessary instance declarations to the interface. Since class and
+instance declarations added to an interface can require the inclusion
+of further classes by their respective contexts, closing an interface
+is implemented as a fix-point computation which starts from the
+initial interface.
+
+The Haskell report requires that ``all instances in scope within a
+module are \emph{always} exported'' (\cite{PeytonJones03:Haskell},
+Sect.~5.4). Thus, it seems the compiler should dump the whole instance
+environment to the module's interface. Fortunately, it is not really
+necessary to include all instance declarations that are in scope in a
+module in its interface. Since in order to use an instance both the
+instance's class and type must be in scope (eventually implicitly due
+to declarations using the class and type, respectively), an instance
+that is defined in the same module as its class or its type is
+exported only if the class or type occurs in the interface as well.
+Only instances that are defined in a module that is different from
+both the modules defining its class and its type are always exported
+when they are in scope. This leads to smaller interfaces which can be
+loaded more quickly by the compiler and are easier to understand for
+the user.
+
+More formally, an instance $M_1.C\;(M_2.T\,u_1 \dots u_n)$ defined in
+module $M_3$ is exported from module $M_4$ if either
+\begin{enumerate}
+  \item $M_1=M_3 \land M_1.C \in \emph{intf}(M_4)$, or
+  \item $M_1\not=M_3 \land M_2=M_3 \land M_2.T \in \emph{intf}(M_4)$, or
+  \item $M_1\not=M_3 \land M_2\not=M_3$.
+\end{enumerate}
+The condition $M_1\not=M_3$ in the second alternative takes care of
+exporting an instance of a class and a type defined in the same module
+together with the class only. As a special case, if the class and the
+type are both defined in the current module, the instance is exported
+only if both appear in the interface, i.e., we impose the additional
+restriction
+\begin{displaymath}
+  M_1\not=M_4 \lor M_2\not=M_4 \lor M_3\not=M_4 \lor (M_1.C \in
+  \emph{intf}(M_4) \land M_2.T \in \emph{intf}(M_4)) .
+\end{displaymath}
+Obviously, this restriction affects only the first alternative, since
+if $M_1\not=M_3$ at least one of the conditions $M_1\not=M_4$ and
+$M_3\not=M_4$ is true. Taking the additional restriction into account,
+the first alternative becomes
+\begin{enumerate}
+  \item[1'.] $M_1=M_3 \land M_1.C \in \emph{intf}(M_4) \land
+    (M_1\not=M_4 \lor M_2\not=M_4 \lor M_2.T \in \emph{intf}(M_4))$.
+\end{enumerate}
+
+While computing the closure of an interface, the first condition is
+considered for all classes that are part of the interface, and the
+first and the second condition are considered for all types that are
+part of the interface. Instances for which the third condition holds
+are already included in the initial interface by \texttt{instDecls}
+above. If $T$ is one of the primitive type constructors \texttt{()},
+\texttt{[]}, \texttt{(->)}, or a tuple type constructor, we stipulate
+$M_2\not=M_3$.
+
+Note that we do not categorize type synonym declarations as type
+declarations in \texttt{declIs} below because instances can be
+declared only for data and renaming types and therefore there is no
+point looking for any instances of the type in the instance
+environment.
+\begin{verbatim}
+
+> data DeclIs =
+>   IsOther | IsType QualIdent | IsClass QualIdent | IsInst CT deriving (Eq,Ord)
+
+> closeInterface :: ModuleIdent -> TCEnv -> InstEnv -> ArityEnv -> [Ident]
+>                -> Set DeclIs -> [IDecl] -> [IDecl]
+> closeInterface _ _ _ _ _ _ [] = []
+> closeInterface m tcEnv iEnv aEnv tvs ds' (d:ds)
+>   | d' == IsOther =
+>       d : closeInterface m tcEnv iEnv aEnv tvs ds' (ds ++ ds'')
+>   | d' `elemSet` ds' = closeInterface m tcEnv iEnv aEnv tvs ds' ds
+>   | otherwise =
+>       d : closeInterface m tcEnv iEnv aEnv tvs (d' `addToSet` ds') (ds ++ ds'')
+>   where d' = declIs d
+>         ds'' =
+>           map (hiddenTypeDecl tcEnv tvs)
+>               (filter (not . isPrimTypeId . unqualify) (usedTypes d [])) ++
+>           instances m tcEnv iEnv aEnv tvs ds' d'
+
+> declIs :: IDecl -> DeclIs
+> declIs (IInfixDecl _ _ _ _) = IsOther
+> declIs (HidingDataDecl _ tc _ _) = IsType tc
+> declIs (IDataDecl _ _ tc _ _ _ _) = IsType tc
+> declIs (INewtypeDecl _ _ tc _ _ _ _) = IsType tc
+> declIs (ITypeDecl _ _ _ _ _) = IsOther {-sic!-}
+> declIs (HidingClassDecl _ _ cls _ _) = IsClass cls
+> declIs (IClassDecl _ _ cls _ _ _ _) = IsClass cls
+> declIs (IInstanceDecl _ _ cls ty _ _) = IsInst (CT cls (typeConstr ty))
+> declIs (IFunctionDecl _ _ _ _) = IsOther
 
 > definedType :: IDecl -> [QualIdent] -> [QualIdent]
-> definedType (IDataDecl _ tc _ _) tcs = tc : tcs
-> definedType (INewtypeDecl _ tc _ _) tcs = tc : tcs
-> definedType (ITypeDecl _ tc _ _) tcs = tc : tcs
-> definedType (IFunctionDecl _ _ _ _)  tcs = tcs
+> definedType (IInfixDecl _ _ _ _) tcs = tcs
+> definedType (HidingDataDecl _ tc _ _) tcs = tc : tcs
+> definedType (IDataDecl _ _ tc _ _ _ _) tcs = tc : tcs
+> definedType (INewtypeDecl _ _ tc _ _ _ _) tcs = tc : tcs
+> definedType (ITypeDecl _ tc _ _ _) tcs = tc : tcs
+> definedType (HidingClassDecl _ _ cls _ _) tcs = cls : tcs
+> definedType (IClassDecl _ _ cls _ _ _ _) tcs = cls : tcs
+> definedType (IInstanceDecl _ _ _ _ _ _) tcs = tcs
+> definedType (IFunctionDecl _ _ _ _) tcs = tcs
+
+> instances :: ModuleIdent -> TCEnv -> InstEnv -> ArityEnv -> [Ident]
+>           -> Set DeclIs -> DeclIs -> [IDecl]
+> instances _ _ _ _ _ _ IsOther = []
+> instances _ tcEnv iEnv aEnv tvs ds' (IsType tc) =
+>   [iInstDecl tcEnv aEnv tvs (CT cls tc) (m',cx,fs)
+>   | (CT cls tc',(m',cx,fs)) <- envToList iEnv,
+>     tc == tc',
+>     if fst (splitQualIdent cls) == Just m'
+>       then IsClass cls `elemSet` ds'
+>       else fst (splitQualIdent tc) == Just m']
+> instances m tcEnv iEnv aEnv tvs ds' (IsClass cls) =
+>   [iInstDecl tcEnv aEnv tvs (CT cls tc) (m',cx,fs)
+>   | (CT cls' tc,(m',cx,fs)) <- envToList iEnv,
+>     cls == cls',
+>     fst (splitQualIdent cls) == Just m',
+>     m /= m' || isPrimTypeId (unqualify tc)
+>             || fst (splitQualIdent tc) /= Just m
+>             || IsType tc `elemSet` ds']
+> instances _ _ _ _ _ _ (IsInst _) = []
+
+> hiddenTypeDecl :: TCEnv -> [Ident] -> QualIdent -> IDecl
+> hiddenTypeDecl tcEnv tvs tc =
+>   case qualLookupTopEnv tc tcEnv of
+>     [DataType _ k _] ->
+>       iTypeDecl hidingDataDecl [] tc tvs (kindArity k) k undefined
+>     [RenamingType _ k _] ->
+>       iTypeDecl hidingDataDecl [] tc tvs (kindArity k) k undefined
+>     [TypeClass _ k clss _] -> iClassDecl HidingClassDecl tc tvs k clss
+>     _ -> internalError "hiddenTypeDecl"
+>   where hidingDataDecl p _ tc k tvs _ = HidingDataDecl p tc k tvs
 
 > class HasType a where
 >   usedTypes :: a -> [QualIdent] -> [QualIdent]
@@ -179,24 +459,46 @@
 >   usedTypes xs tcs = foldr usedTypes tcs xs
 
 > instance HasType IDecl where
->   usedTypes (IDataDecl _ _ _ cs) = usedTypes cs
->   usedTypes (INewtypeDecl _ _ _ nc) = usedTypes nc
->   usedTypes (ITypeDecl _ _ _ ty) = usedTypes ty
+>   usedTypes (IInfixDecl _ _ _ _) = id
+>   usedTypes (HidingDataDecl _ _ _ _) = id
+>   usedTypes (IDataDecl _ cx _ _ _ cs _) = usedTypes cx . usedTypes cs
+>   usedTypes (INewtypeDecl _ cx _ _ _ nc _) = usedTypes cx . usedTypes nc
+>   usedTypes (ITypeDecl _ _ _ _ ty) = usedTypes ty
+>   usedTypes (HidingClassDecl _ cx _ _ _) = usedTypes cx
+>   usedTypes (IClassDecl _ cx _ _ _ ds _) = usedTypes cx . usedTypes ds
+>   usedTypes (IInstanceDecl _ cx cls ty _ _) =
+>     usedTypes cx . (cls :) . usedTypes ty
 >   usedTypes (IFunctionDecl _ _ _ ty) = usedTypes ty
 
 > instance HasType ConstrDecl where
->   usedTypes (ConstrDecl _ _ _ tys) = usedTypes tys
->   usedTypes (ConOpDecl _ _ ty1 _ ty2) = usedTypes ty1 . usedTypes ty2
+>   usedTypes (ConstrDecl _ _ cx _ tys) = usedTypes cx . usedTypes tys
+>   usedTypes (ConOpDecl _ _ cx ty1 _ ty2) =
+>     usedTypes cx . usedTypes ty1 . usedTypes ty2
+>   usedTypes (RecordDecl _ _ cx _ fs) = usedTypes cx . usedTypes fs
+
+> instance HasType FieldDecl where
+>   usedTypes (FieldDecl _ _ ty) = usedTypes ty
 
 > instance HasType NewConstrDecl where
 >   usedTypes (NewConstrDecl _ _ ty) = usedTypes ty
+>   usedTypes (NewRecordDecl _ _ _ ty) = usedTypes ty
+
+> instance HasType IMethodDecl where
+>   usedTypes (IMethodDecl _ _ _ ty) = usedTypes ty
+
+> instance HasType QualTypeExpr where
+>   usedTypes (QualTypeExpr cx ty) = usedTypes cx . usedTypes ty
+
+> instance HasType ClassAssert where
+>   usedTypes (ClassAssert cls ty) = (cls :) . usedTypes ty
 
 > instance HasType TypeExpr where
->   usedTypes (ConstructorType tc tys) = (tc :) . usedTypes tys
+>   usedTypes (ConstructorType tc) = (tc :)
 >   usedTypes (VariableType _) = id
 >   usedTypes (TupleType tys) = usedTypes tys
 >   usedTypes (ListType ty) = usedTypes ty
 >   usedTypes (ArrowType ty1 ty2) = usedTypes ty1 . usedTypes ty2
+>   usedTypes (ApplyType ty1 ty2) = usedTypes ty1 . usedTypes ty2
 
 \end{verbatim}
 Auxiliary definitions.
@@ -205,4 +507,12 @@
 > noPos :: Position
 > noPos = undefined
 
+> argTypes :: TypeExpr -> [TypeExpr]
+> argTypes (ArrowType ty1 ty2) = ty1 : argTypes ty2
+> argTypes _ = []
+
+> qualInstType :: Context -> QualIdent -> Int -> QualType
+> qualInstType cx tc n =
+>   QualType cx (applyType (TypeConstructor tc) (map TypeVariable [0..n-1]))
+
 \end{verbatim}
diff -u curry-0.9.11/ExportSyntaxCheck.lhs curry-0.9.11-classful/ExportSyntaxCheck.lhs
--- curry-0.9.11/ExportSyntaxCheck.lhs	2007-06-15 14:16:34.000000000 +0200
+++ curry-0.9.11-classful/ExportSyntaxCheck.lhs	2009-08-25 10:02:57.000000000 +0200
@@ -1,7 +1,7 @@
 % -*- LaTeX -*-
-% $Id: ExportSyntaxCheck.lhs 1912 2006-05-03 14:53:33Z wlux $
+% $Id: ExportSyntaxCheck.lhs 2898 2009-08-24 09:40:09Z wlux $
 %
-% Copyright (c) 2000-2006, Wolfgang Lux
+% Copyright (c) 2000-2009, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{ExportSyntaxCheck.lhs}
@@ -15,62 +15,78 @@
 
 > module ExportSyntaxCheck(checkExports) where
 > import Base
+> import Curry
 > import Error
+> import IdentInfo
 > import List
 > import Map
 > import Maybe
+> import PredefIdent
 > import Set
 > import TopEnv
 
 > checkExports :: ModuleIdent -> [ImportDecl] -> TypeEnv -> FunEnv
 >              -> Maybe ExportSpec -> Error ExportSpec
-> checkExports m is tEnv fEnv =
->   maybe (return (Exporting noPos (expandLocalModule tEnv fEnv)))
->         (\es -> do
->                   es' <- liftE nubExports (expandSpecs ms m tEnv fEnv es)
->                   checkInterface es'
->                   return es')
+> checkExports m is tEnv fEnv es =
+>   do
+>     es' <-
+>       liftE (nubExports . canonExports tEnv) (expandSpecs ms m tEnv fEnv es)
+>     checkInterface es'
+>     return es'
 >   where ms = fromListSet [fromMaybe m asM | ImportDecl _ m _ asM _ <- is]
->         noPos = undefined
 
 > checkInterface :: ExportSpec -> Error ()
 > checkInterface (Exporting p es) =
->   mapE_ (errorAt p . ambiguousExportType . fst)
+>   mapE_ (errorAt p . ambiguousExport . fst)
 >         (duplicates [unqualify tc | ExportTypeWith tc _ <- es]) &&>
->   mapE_ (errorAt p . ambiguousExportValue . fst)
->         (duplicates ([c | ExportTypeWith _ cs <- es, c <- cs] ++
+>   mapE_ (errorAt p . ambiguousExport . fst)
+>         (duplicates ([x | ExportTypeWith _ xs <- es, x <- xs] ++
 >                      [unqualify f | Export f <- es]))
 
 \end{verbatim}
 While checking all export specifications, the compiler expands
-specifications of the form \verb|T(..)| into
-\texttt{T($C_1,\dots,C_n$)}, where $C_1,\dots,C_n$ are the data
-constructors of type \texttt{T}, and replaces an export specification
-\verb|module M| by specifications for all entities which are defined
-in module \texttt{M} and imported into the current module with their
-unqualified name. In order to distinguish exported type constructors
-from exported functions, the former are translated into the equivalent
-form \verb|T()|. Note that the export specification \texttt{x} may
-export a type constructor \texttt{x} \emph{and} a global function
-\texttt{x} at the same time.
+specifications of the form \verb|T(..)| and \verb|C(..)| into
+\texttt{T($C_1,\dots,C_m,l_1,\dots,l_n$)}, where $C_1,\dots,C_m$ are
+the data constructors of type \texttt{T} and $l_1,\dots,l_n$ its field
+labels, and \texttt{C($f_1,\dots,f_n$)}, respectively, where
+$f_1,\dots,f_n$ are the methods of type class \texttt{C}. In addition,
+it replaces an export specification \verb|module M| by specifications
+for all entities which are in scope with an unqualified name $x$ and a
+qualified name \verb|M.|$x$. In order to distinguish exported type
+constructors and type classes from exported functions, the former are
+translated into the equivalent form \verb|T()| and \verb|C()|,
+respectively. Note that the export specification \texttt{x} may export
+a type constructor or type class \texttt{x} \emph{and} a global
+function \texttt{x} at the same time.
+
+The code of \texttt{expandSpecs} ensures that the unit, list, and
+tuple types are exported from the Prelude even if its exported
+entities are specified explicitly. On the other hand, the function
+\texttt{expandModule} carefully excludes the identifiers of these
+particular types in case a module's export list contains the
+specification \texttt{module Prelude} so that these types are not
+exported by any module other than the Prelude.
 \begin{verbatim}
 
 > expandSpecs :: Set ModuleIdent -> ModuleIdent -> TypeEnv -> FunEnv
->             -> ExportSpec -> Error ExportSpec
-> expandSpecs ms m tEnv fEnv (Exporting p es) =
->   liftE (Exporting p . concat) (mapE (expandExport p ms m tEnv fEnv) es)
-
-> expandExport :: Position -> Set ModuleIdent -> ModuleIdent -> TypeEnv
->              -> FunEnv -> Export -> Error [Export]
-> expandExport p _ _ tEnv fEnv (Export x) = expandThing p tEnv fEnv x
-> expandExport p _ _ tEnv _ (ExportTypeWith tc cs) = expandTypeWith p tEnv tc cs
-> expandExport p _ _ tEnv _ (ExportTypeAll tc) = expandTypeAll p tEnv tc
-> expandExport p ms m tEnv fEnv (ExportModule m')
->   | m == m' =
->       return ((if m `elemSet` ms then expandModule tEnv fEnv m else []) ++
->               expandLocalModule tEnv fEnv)
->   | m' `elemSet` ms = return (expandModule tEnv fEnv m')
->   | otherwise = errorAt p (moduleNotImported m')
+>             -> Maybe ExportSpec -> Error ExportSpec
+> expandSpecs ms m tEnv fEnv (Just (Exporting p es)) =
+>   liftE (Exporting p . (es' ++) . concat)
+>         (mapE (expandExport p (addToSet m ms) tEnv fEnv) es)
+>   where es' = [exportType t | m == preludeMIdent,
+>                               (tc,t) <- localBindings tEnv, isPrimTypeId tc]
+> expandSpecs _ _ tEnv fEnv Nothing =
+>   return (Exporting noPos (expandLocalModule tEnv fEnv))
+>   where noPos = undefined
+
+> expandExport :: Position -> Set ModuleIdent -> TypeEnv -> FunEnv -> Export
+>              -> Error [Export]
+> expandExport p _ tEnv fEnv (Export x) = expandThing p tEnv fEnv x
+> expandExport p _ tEnv _ (ExportTypeWith tc xs) = expandTypeWith p tEnv tc xs
+> expandExport p _ tEnv _ (ExportTypeAll tc) = expandTypeAll p tEnv tc
+> expandExport p ms tEnv fEnv (ExportModule m)
+>   | m `elemSet` ms = return (expandModule tEnv fEnv m)
+>   | otherwise = errorAt p (moduleNotImported m)
 
 > expandThing :: Position -> TypeEnv -> FunEnv -> QualIdent -> Error [Export]
 > expandThing p tEnv fEnv tc =
@@ -79,72 +95,126 @@
 >     [t] -> expandThing' p fEnv tc (Just [exportType (abstract t)])
 >       where abstract (Data tc _) = Data tc []
 >             abstract (Alias tc) = Alias tc
->     _ -> errorAt p (ambiguousType tc)
+>             abstract (Class cls _) = Class cls []
+>     _ -> errorAt p (ambiguousName tc)
 
 > expandThing' :: Position -> FunEnv -> QualIdent -> Maybe [Export]
 >              -> Error [Export]
 > expandThing' p fEnv f tcExport =
 >   case qualLookupTopEnv f fEnv of
 >     [] -> maybe (errorAt p (undefinedEntity f)) return tcExport
->     [Var f'] -> return (Export f' : fromMaybe [] tcExport)
+>     [Var f' _] -> return (Export f' : fromMaybe [] tcExport)
 >     [Constr _] -> maybe (errorAt p (exportDataConstr f)) return tcExport
 >     _ -> errorAt p (ambiguousName f)
 
 > expandTypeWith :: Position -> TypeEnv -> QualIdent -> [Ident]
 >                -> Error [Export]
-> expandTypeWith p tEnv tc cs =
+> expandTypeWith p tEnv tc xs =
 >   do
->     (tc',cs'') <- constrs p tEnv tc
->     mapE_ (errorAt p . undefinedDataConstr tc) (filter (`notElem` cs'') cs')
->     return [ExportTypeWith tc' cs']
->   where cs' = nub cs
+>     (isType,tc',xs'') <- elements p tEnv tc
+>     mapE_ (errorAt p . undefinedElement isType tc)
+>           (filter (`notElem` xs'') xs')
+>     return [ExportTypeWith tc' xs']
+>   where xs' = nub xs
 
 > expandTypeAll :: Position -> TypeEnv -> QualIdent -> Error [Export]
 > expandTypeAll p tEnv tc =
 >   do
->     (tc',cs) <- constrs p tEnv tc
->     return [ExportTypeWith tc' cs]
+>     (_,tc',xs) <- elements p tEnv tc
+>     return [ExportTypeWith tc' xs]
 
-> constrs :: Position -> TypeEnv -> QualIdent -> Error (QualIdent,[Ident])
-> constrs p tEnv tc =
+> elements :: Position -> TypeEnv -> QualIdent -> Error (Bool,QualIdent,[Ident])
+> elements p tEnv tc =
 >   case qualLookupTopEnv tc tEnv of
->     [] -> errorAt p (undefinedType tc)
->     [Data tc cs] -> return (tc,cs)
->     [Alias tc] -> return (tc,[])
->     _ -> errorAt p (ambiguousType tc)
+>     [] -> errorAt p (undefinedEntity tc)
+>     [Data tc xs] -> return (True,tc,xs)
+>     [Alias tc] -> return (True,tc,[])
+>     [Class cls fs] -> return (False,cls,fs)
+>     _ -> errorAt p (ambiguousName tc)
 
 > expandLocalModule :: TypeEnv -> FunEnv -> [Export]
 > expandLocalModule tEnv fEnv =
 >   [exportType t | (_,t) <- localBindings tEnv] ++
->   [Export f' | (f,Var f') <- localBindings fEnv, not (isRenamed f)]
+>   [Export f' | (_,Var f' _) <- localBindings fEnv]
 
 > expandModule :: TypeEnv -> FunEnv -> ModuleIdent -> [Export]
 > expandModule tEnv fEnv m =
->   [exportType t | (_,t) <- moduleImports m tEnv] ++
->   [Export f | (_,Var f) <- moduleImports m fEnv]
+>   [exportType (restrict xs t) | (tc,t) <- moduleBindings m tEnv,
+>                                 not (isPrimTypeId tc)] ++
+>   [Export f | Var f _ <- vs]
+>   where vs = map snd (moduleBindings m fEnv)
+>         xs = map origName vs
+>         restrict xs' (Data tc xs) =
+>           Data tc (filter ((`elem` xs') . qualifyLike tc) xs)
+>         restrict _ (Alias tc) = Alias tc
+>         restrict xs (Class cls fs) =
+>           Class cls (filter ((`elem` xs) . qualifyLike cls) fs)
 
 > exportType :: TypeKind -> Export
-> exportType (Data tc cs) = ExportTypeWith tc cs
+> exportType (Data tc xs) = ExportTypeWith tc xs
 > exportType (Alias tc) = ExportTypeWith tc []
+> exportType (Class cls fs) = ExportTypeWith cls fs
+
+\end{verbatim}
+For compatibility with Haskell, we allow exporting field labels and
+type class methods but not constructors individually as well as
+together with their types and classes, respectively. Thus, given the
+declaration
+\begin{verbatim}
+  data T a = C{ l::a }
+\end{verbatim}
+the export lists \texttt{(T(C,l))} and \texttt{(T(C),l)} are
+equivalent and both export the constructor \texttt{C} and the field
+label \texttt{l} together with the type \texttt{T}. However, it is
+also possible to export the label \texttt{l} without exporting its
+type \texttt{T}. In this case, the label is exported just like a
+top-level function (namely the implicit record selection function
+corresponding to the label). In order to avoid ambiguities in the
+interface, we convert an individual export of a label $l$ into the
+form $T(l)$ whenever its type $T$ occurs in the export list as well.
+\begin{verbatim}
+
+> canonExports :: TypeEnv -> ExportSpec -> ExportSpec
+> canonExports tEnv (Exporting p es) =
+>   Exporting p (map (canonExport (canonElements tEnv es)) es)
+
+> canonExport :: FM QualIdent Export -> Export -> Export
+> canonExport xs (Export x) = fromMaybe (Export x) (lookupFM x xs)
+> canonExport _ (ExportTypeWith tc xs) = ExportTypeWith tc xs
+
+> canonElements :: TypeEnv -> [Export] -> FM QualIdent Export
+> canonElements tEnv es = foldr bindElements zeroFM (allEntities tEnv)
+>   where tcs = [tc | ExportTypeWith tc _ <- es]
+>         bindElements (Data tc xs) ys
+>           | tc `elem` tcs = foldr (bindElement tc) ys xs
+>           | otherwise = ys
+>         bindElements (Alias _) ys = ys
+>         bindElements (Class cls fs) ys
+>           | cls `elem` tcs = foldr (bindElement cls) ys fs
+>           | otherwise = ys
+>         bindElement tc x = addToFM (qualifyLike tc x) (ExportTypeWith tc [x])
 
 \end{verbatim}
 The expanded list of exported entities may contain duplicates. These
-are removed by the function \texttt{nubExports}.
+are removed by the function \texttt{nubExports}. In particular, this
+function removes any field labels and type class methods from the list
+of exported values which are also exported along with their types and
+classes, respectively.
 \begin{verbatim}
 
 > nubExports :: ExportSpec -> ExportSpec
 > nubExports (Exporting p es) = Exporting p $
->   [ExportTypeWith tc cs | (tc,cs) <- toListFM (foldr addType zeroFM es)] ++
->   [Export f | f <- toListSet (foldr addFun zeroSet es)]
+>   [ExportTypeWith tc xs | (tc,xs) <- toListFM (foldr addType zeroFM es)] ++
+>   [Export f | f <- toListSet (foldr addValue zeroSet es)]
 
 > addType :: Export -> FM QualIdent [Ident] -> FM QualIdent [Ident]
 > addType (Export _) tcs = tcs
-> addType (ExportTypeWith tc cs) tcs =
->   addToFM tc (cs `union` fromMaybe [] (lookupFM tc tcs)) tcs
+> addType (ExportTypeWith tc xs) tcs =
+>   addToFM tc (xs `union` fromMaybe [] (lookupFM tc tcs)) tcs
 
-> addFun :: Export -> Set QualIdent -> Set QualIdent
-> addFun (Export f) fs = f `addToSet` fs
-> addFun (ExportTypeWith _ _) fs = fs
+> addValue :: Export -> Set QualIdent -> Set QualIdent
+> addValue (Export f) fs = f `addToSet` fs
+> addValue (ExportTypeWith _ _) fs = fs
 
 \end{verbatim}
 Error messages.
@@ -154,20 +224,11 @@
 > undefinedEntity x =
 >   "Entity " ++ qualName x ++ " in export list is not defined"
 
-> undefinedType :: QualIdent -> String
-> undefinedType tc = "Type " ++ qualName tc ++ " in export list is not defined"
-
 > moduleNotImported :: ModuleIdent -> String
 > moduleNotImported m = "Module " ++ moduleName m ++ " not imported"
 
-> ambiguousExportType :: Ident -> String
-> ambiguousExportType x = "Ambiguous export of type " ++ name x
-
-> ambiguousExportValue :: Ident -> String
-> ambiguousExportValue x = "Ambiguous export of " ++ name x
-
-> ambiguousType :: QualIdent -> String
-> ambiguousType tc = "Ambiguous type " ++ qualName tc
+> ambiguousExport :: Ident -> String
+> ambiguousExport x = "Ambiguous export of " ++ name x
 
 > ambiguousName :: QualIdent -> String
 > ambiguousName x = "Ambiguous name " ++ qualName x
@@ -175,8 +236,10 @@
 > exportDataConstr :: QualIdent -> String
 > exportDataConstr c = "Data constructor " ++ qualName c ++ " in export list"
 
-> undefinedDataConstr :: QualIdent -> Ident -> String
-> undefinedDataConstr tc c =
->   name c ++ " is not a data constructor of type " ++ qualName tc
+> undefinedElement :: Bool -> QualIdent -> Ident -> String
+> undefinedElement True tc c =
+>   name c ++ " is not a constructor or label of type " ++ qualName tc
+> undefinedElement False cls f =
+>   name f ++ " is not a method of type class " ++ qualName cls
 
 \end{verbatim}
Sottodirectory in comune: curry-0.9.11/ghc e curry-0.9.11-classful/ghc
Solo in curry-0.9.11-classful/: ghc.htm
diff -u curry-0.9.11/ghc-make.mk curry-0.9.11-classful/ghc-make.mk
--- curry-0.9.11/ghc-make.mk	2007-06-15 14:16:33.000000000 +0200
+++ curry-0.9.11-classful/ghc-make.mk	2008-03-13 09:20:32.000000000 +0100
@@ -1,29 +1,45 @@
 # Specific rules for building with ghc --make
-# $Id: ghc-make.mk 2239 2007-06-10 00:46:39Z wlux $
+# $Id: ghc-make.mk 2638 2008-03-13 08:07:44Z wlux $
 #
-# Copyright (c) 2002-2007, Wolfgang Lux
+# Copyright (c) 2002-2008, Wolfgang Lux
 # See LICENSE for the full license.
 #
 
 # specific definitions for ghc
-GHC_HCFLAGS = -H12m -i$(HC_PATH_STYLE)
+GHC_HFLAGS = -H12m -i$(HC_PATH_STYLE)
 
 # programs
+# NB The seemingly contrived $(MAKEFLAGS:M-s:S/=/=/) substitution is used in
+#    order to check for the presence of -s among the command line flags in
+#    a portable way. GNU make and other POSIX compatible make commands
+#    collect all single letter options -- if any -- in the first word of
+#    $(MAKEFLAGS). BSD make commands, on the other hand, use a separate word
+#    for each single letter option. In order to make the -s option the first
+#    word if present, we use BSD make's :M variable modifier, which filters
+#    $(MAKEFLAGS) keeping only those words which match the pattern following
+#    :M. Since other make commands do not understand this modifier, we also
+#    add the identity substitution :S/=/=/, which yields a System V compatible
+#    variable substitution of the form :SUFFIX=REPL.
 cycc: $(cycc_SRCS)
-	@case "$(MFLAGS)" in -*s*) s=-v0;; *) s=;; esac; \
-	$(HC) --make $(HCFLAGS) $(GHC_HCFLAGS) $$s -o $@ $@
+	@set dummy $(MAKEFLAGS:M-s:S/=/=/); \
+	case $$2 in *=*) s=;; *s*) s=-v0;; *) s=;; esac; \
+	$(HC) --make $(HFLAGS) $(GHC_HFLAGS) $$s -o $@ $@
 cymk: $(cymk_SRCS)
-	@case "$(MFLAGS)" in -*s*) s=-v0;; *) s=;; esac; \
-	$(HC) --make $(HCFLAGS) $(GHC_HCFLAGS) $$s -o $@ $@
+	@set dummy $(MAKEFLAGS:M-s:S/=/=/); \
+	case $$2 in *=*) s=;; *s*) s=-v0;; *) s=;; esac; \
+	$(HC) --make $(HFLAGS) $(GHC_HFLAGS) $$s -o $@ $@
 newer: $(newer_SRCS)
-	@case "$(MFLAGS)" in -*s*) s=-v0;; *) s=;; esac; \
-	$(HC) --make $(HCFLAGS) $(GHC_HCFLAGS) $$s -o $@ $@
+	@set dummy $(MAKEFLAGS:M-s:S/=/=/); \
+	case $$2 in *=*) s=;; *s*) s=-v0;; *) s=;; esac; \
+	$(HC) --make $(HFLAGS) $(GHC_HFLAGS) $$s -o $@ $@
 cam2c: $(cam2c_SRCS)
-	@case "$(MFLAGS)" in -*s*) s=-v0;; *) s=;; esac; \
-	$(HC) --make $(HCFLAGS) $(GHC_HCFLAGS) $$s -o $@ $@
+	@set dummy $(MAKEFLAGS:M-s:S/=/=/); \
+	case $$2 in *=*) s=;; *s*) s=-v0;; *) s=;; esac; \
+	$(HC) --make $(HFLAGS) $(GHC_HFLAGS) $$s -o $@ $@
 mach: $(mach_SRCS)
-	@case "$(MFLAGS)" in -*s*) s=-v0;; *) s=;; esac; \
-	$(HC) --make $(HCFLAGS) $(GHC_HCFLAGS) $$s -o $@ $@
+	@set dummy $(MAKEFLAGS:M-s:S/=/=/); \
+	case $$2 in *=*) s=;; *s*) s=-v0;; *) s=;; esac; \
+	$(HC) --make $(HFLAGS) $(GHC_HFLAGS) $$s -o $@ $@
 
 # compute the dependencies
 depend-dir:
diff -u curry-0.9.11/ghc.mk curry-0.9.11-classful/ghc.mk
--- curry-0.9.11/ghc.mk	2007-06-15 14:16:33.000000000 +0200
+++ curry-0.9.11-classful/ghc.mk	2008-02-06 08:39:37.000000000 +0100
@@ -1,19 +1,19 @@
 # Specific rules for building with ghc
-# $Id: ghc.mk 2239 2007-06-10 00:46:39Z wlux $
+# $Id: ghc.mk 2611 2008-02-03 23:35:16Z wlux $
 #
-# Copyright (c) 2002-2007, Wolfgang Lux
+# Copyright (c) 2002-2008, Wolfgang Lux
 # See LICENSE for the full license.
 #
 
 # specific definitions for ghc
-GHC_HCFLAGS = -H12m -i$(HC_PATH_STYLE)
+GHC_HFLAGS = -H12m -i$(HC_PATH_STYLE)
 
 # additional suffix rules
 .SUFFIXES: .hs .lhs .hi .o
 .hs.o:
-	$(HC) $(HCFLAGS) $(GHC_HCFLAGS) $($*_HCFLAGS) -c $< -o $@
+	$(HC) $(HFLAGS) $(GHC_HFLAGS) $($*_HFLAGS) -c $< -o $@
 .lhs.o:
-	$(HC) $(HCFLAGS) $(GHC_HCFLAGS) $($*_HCFLAGS) -c $< -o $@
+	$(HC) $(HFLAGS) $(GHC_HFLAGS) $($*_HFLAGS) -c $< -o $@
 .o.hi:
 	@test -f $@ || \
 	(echo "$@ does not exist!"; \
@@ -21,15 +21,15 @@
 
 # programs
 cycc: $(cycc_OBJS)
-	$(HC) $(HCFLAGS) $(GHC_HCFLAGS) -o $@ $(cycc_OBJS)
+	$(HC) $(HFLAGS) $(GHC_HFLAGS) -o $@ $(cycc_OBJS)
 cymk: $(cymk_OBJS)
-	$(HC) $(HCFLAGS) $(GHC_HCFLAGS) -o $@ $(cymk_OBJS)
+	$(HC) $(HFLAGS) $(GHC_HFLAGS) -o $@ $(cymk_OBJS)
 newer: $(newer_OBJS)
-	$(HC) $(HCFLAGS) $(GHC_HCFLAGS) -o $@ $(newer_OBJS)
+	$(HC) $(HFLAGS) $(GHC_HFLAGS) -o $@ $(newer_OBJS)
 cam2c: $(cam2c_OBJS)
-	$(HC) $(HCFLAGS) $(GHC_HCFLAGS) -o $@ $(cam2c_OBJS)
+	$(HC) $(HFLAGS) $(GHC_HFLAGS) -o $@ $(cam2c_OBJS)
 mach: $(mach_OBJS)
-	$(HC) $(HCFLAGS) $(GHC_HCFLAGS) -o $@ $(mach_OBJS)
+	$(HC) $(HFLAGS) $(GHC_HFLAGS) -o $@ $(mach_OBJS)
 
 # additional cleanup rules
 mostlyclean-dir::
@@ -38,11 +38,11 @@
 # compute the dependencies
 # NB: ./ prefixes stripped from dependencies for proper operation with BSD make
 depend-dir: $(SRCS)
-	$(HC) $(HCFLAGS) $(GHC_HCFLAGS) -M -optdep-f -optdep.depend.cycc $(cycc_SRCS)
-	$(HC) $(HCFLAGS) $(GHC_HCFLAGS) -M -optdep-f -optdep.depend.cymk $(cymk_SRCS)
-	$(HC) $(HCFLAGS) $(GHC_HCFLAGS) -M -optdep-f -optdep.depend.newer $(newer_SRCS)
-	$(HC) $(HCFLAGS) $(GHC_HCFLAGS) -M -optdep-f -optdep.depend.cam2c $(cam2c_SRCS)
-	$(HC) $(HCFLAGS) $(GHC_HCFLAGS) -M -optdep-f -optdep.depend.mach $(mach_SRCS)
+	$(HC) $(HFLAGS) $(GHC_HFLAGS) -M -optdep-f -optdep.depend.cycc $(cycc_SRCS)
+	$(HC) $(HFLAGS) $(GHC_HFLAGS) -M -optdep-f -optdep.depend.cymk $(cymk_SRCS)
+	$(HC) $(HFLAGS) $(GHC_HFLAGS) -M -optdep-f -optdep.depend.newer $(newer_SRCS)
+	$(HC) $(HFLAGS) $(GHC_HFLAGS) -M -optdep-f -optdep.depend.cam2c $(cam2c_SRCS)
+	$(HC) $(HFLAGS) $(GHC_HFLAGS) -M -optdep-f -optdep.depend.mach $(mach_SRCS)
 	sed 's,\./,,' .depend.cycc .depend.cymk .depend.newer .depend.mach .depend.cam2c > .depend
 	@rm -f -- .depend.cycc .depend.cymk .depend.newer .depend.cam2c .depend.mach
 	@rm -f -- .depend.cycc.bak .depend.cymk.bak .depend.newer.bak .depend.cam2c.bak .depend.mach.bak
Solo in curry-0.9.11-classful/: Goals.lhs
Sottodirectory in comune: curry-0.9.11/hbc e curry-0.9.11-classful/hbc
Solo in curry-0.9.11-classful/: hbc.htm
diff -u curry-0.9.11/hbc.mk curry-0.9.11-classful/hbc.mk
--- curry-0.9.11/hbc.mk	2007-06-15 14:16:33.000000000 +0200
+++ curry-0.9.11-classful/hbc.mk	2008-03-13 09:20:32.000000000 +0100
@@ -1,31 +1,47 @@
 # Specific rules for building with hbc
-# $Id: hbc.mk 2239 2007-06-10 00:46:39Z wlux $
+# $Id: hbc.mk 2638 2008-03-13 08:07:44Z wlux $
 #
-# Copyright (c) 2002-2007, Wolfgang Lux
+# Copyright (c) 2002-2008, Wolfgang Lux
 # See LICENSE for the full license.
 #
 
 # specific definitions for hbc
-HBCMAKE = hbcmake -f $(srcdir)/hbc.mk
-HBC_HCFLAGS = -I hbc -I $(HC_PATH_STYLE)
-HBCFLAGS = -H20m -noflags -s
+HBCMAKE = hbcmake
+HBC_HFLAGS = -f $(srcdir)/hbc.mk -I hbc -I $(HC_PATH_STYLE)
+HBCFLAGS = -H24m -noflags
 
 # programs
+# NB The seemingly contrived $(MAKEFLAGS:M-s:S/=/=/) substitution is used in
+#    order to check for the presence of -s among the command line flags in
+#    a portable way. GNU make and other POSIX compatible make commands
+#    collect all single letter options -- if any -- in the first word of
+#    $(MAKEFLAGS). BSD make commands, on the other hand, use a separate word
+#    for each single letter option. In order to make the -s option the first
+#    word if present, we use BSD make's :M variable modifier, which filters
+#    $(MAKEFLAGS) keeping only those words which match the pattern following
+#    :M. Since other make commands do not understand this modifier, we also
+#    add the identity substitution :S/=/=/, which yields a System V compatible
+#    variable substitution of the form :SUFFIX=REPL.
 cycc: $(cycc_SRCS)
-	@case "$(MFLAGS)" in -*s*) s=-s;; *) s=;; esac; \
-	HBC=$(HC) $(HBCMAKE) $$s $(HCFLAGS) $(HBC_HCFLAGS) $@
+	@set dummy $(MAKEFLAGS:M-s:S/=/=/); \
+	case $$2 in *=*) s=;; *s*) s=-s;; *) s=;; esac; \
+	HBC=$(HC) $(HBCMAKE) $$s $(HFLAGS) $(HBC_HFLAGS) $@
 cymk: $(cymk_SRCS)
-	@case "$(MFLAGS)" in -*s*) s=-s;; *) s=;; esac; \
-	HBC=$(HC) $(HBCMAKE) $$s $(HCFLAGS) $(HBC_HCFLAGS) $@
+	@set dummy $(MAKEFLAGS:M-s:S/=/=/); \
+	case $$2 in *=*) s=;; *s*) s=-s;; *) s=;; esac; \
+	HBC=$(HC) $(HBCMAKE) $$s $(HFLAGS) $(HBC_HFLAGS) $@
 newer: $(newer_SRCS)
-	@case "$(MFLAGS)" in -*s*) s=-s;; *) s=;; esac; \
-	HBC=$(HC) $(HBCMAKE) $$s $(HCFLAGS) $(HBC_HCFLAGS) $@
+	@set dummy $(MAKEFLAGS:M-s:S/=/=/); \
+	case $$2 in *=*) s=;; *s*) s=-s;; *) s=;; esac; \
+	HBC=$(HC) $(HBCMAKE) $$s $(HFLAGS) $(HBC_HFLAGS) $@
 cam2c: $(cam2c_SRCS)
-	@case "$(MFLAGS)" in -*s*) s=-s;; *) s=;; esac; \
-	HBC=$(HC) $(HBCMAKE) $$s $(HCFLAGS) $(HBC_HCFLAGS) $@
+	@set dummy $(MAKEFLAGS:M-s:S/=/=/); \
+	case $$2 in *=*) s=;; *s*) s=-s;; *) s=;; esac; \
+	HBC=$(HC) $(HBCMAKE) $$s $(HFLAGS) $(HBC_HFLAGS) $@
 mach: $(mach_SRCS)
-	@case "$(MFLAGS)" in -*s*) s=-s;; *) s=;; esac; \
-	HBC=$(HC) $(HBCMAKE) $$s $(HCFLAGS) $(HBC_HCFLAGS) $@
+	@set dummy $(MAKEFLAGS:M-s:S/=/=/); \
+	case $$2 in *=*) s=;; *s*) s=-s;; *) s=;; esac; \
+	HBC=$(HC) $(HBCMAKE) $$s $(HFLAGS) $(HBC_HFLAGS) $@
 
 # compute the dependencies
 depend-dir:
Solo in curry-0.9.11-classful/: hs2010
Solo in curry-0.9.11-classful/: hs2010.htm
Solo in curry-0.9.11-classful/: IdentInfo.lhs
diff -u curry-0.9.11/Ident.lhs curry-0.9.11-classful/Ident.lhs
--- curry-0.9.11/Ident.lhs	2007-06-15 14:16:35.000000000 +0200
+++ curry-0.9.11-classful/Ident.lhs	2009-08-25 10:02:57.000000000 +0200
@@ -1,7 +1,7 @@
 % -*- LaTeX -*-
-% $Id: Ident.lhs 1947 2006-07-08 09:14:19Z wlux $
+% $Id: Ident.lhs 2898 2009-08-24 09:40:09Z wlux $
 %
-% Copyright (c) 1999-2005, Wolfgang Lux
+% Copyright (c) 1999-2009, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{Ident.lhs}
@@ -18,11 +18,10 @@
 
 \ToDo{Probably we should use \texttt{Integer} for the \emph{id}s.}
 
-Qualified identifiers may optionally be prefixed by a module
-name. \textbf{The order of the cases \texttt{UnqualIdent} and
-\texttt{QualIdent} is important. Some parts of the compiler rely on
-the fact that all qualified identifiers are greater than any
-unqualified identifier.}
+Qualified identifiers may optionally be prefixed by a module name.
+\textbf{Note that some parts of the compiler rely on the fact that
+qualified identifiers are ordered first by their module qualifiers,
+i.e., $M.x < M'.x'$ iff $M < M' \vee (M == M' \wedge x < x')$.}
 \begin{verbatim}
 
 > module Ident(Ident,QualIdent,ModuleIdent,
@@ -31,16 +30,7 @@
 >              mkMIdent,moduleName,moduleQualifiers,isInfixOp,isQInfixOp,
 >              qualify,qualifyWith,qualifyLike,qualQualify,isQualified,
 >              unqualify,qualUnqualify,localIdent,splitQualIdent,
->              preludeMIdent,debugPreludeMIdent,ptrMIdent,stablePtrMIdent,
->              anonId,unitId,boolId,charId,intId,floatId,listId,ioId,
->              ptrId,funPtrId,stablePtrId,
->              successId,trueId,falseId,nilId,consId,mainId,
->              tupleId,isTupleId,tupleArity,selectorId,isSelectorId,
->              minusId,fminusId,
->              qUnitId,qBoolId,qCharId,qIntId,qFloatId,qListId,qIOId,
->              qSuccessId,qPtrId,qFunPtrId,qStablePtrId,
->              qTrueId,qFalseId,qNilId,qConsId,
->              qTupleId,isQTupleId,qTupleArity,isQSelectorId) where
+>              anonId) where
 > import Char
 > import List
 
@@ -91,7 +81,7 @@
 > moduleQualifiers (ModuleIdent xs) = xs
 
 > isInfixOp :: Ident -> Bool
-> isInfixOp (Ident ('<':c:cs) _)=
+> isInfixOp (Ident ('<':c:cs) _) =
 >   last (c:cs) /= '>' || not (isAlphaNum c) && c `notElem` "_(["
 > isInfixOp (Ident (c:_) _) = not (isAlphaNum c) && c `notElem` "_(["
 > isInfixOp (Ident _ _) = False -- error "Zero-length identifier"
@@ -145,98 +135,10 @@
 > splitQualIdent (QualIdent m x) = (Just m,x)
 
 \end{verbatim}
-A few identifiers a predefined here.
+The ubiquitous anonymous identifier is defined here, too.
 \begin{verbatim}
 
-> preludeMIdent, debugPreludeMIdent, ptrMIdent, stablePtrMIdent :: ModuleIdent
-> preludeMIdent      = ModuleIdent ["Prelude"]
-> debugPreludeMIdent = ModuleIdent ["DebugPrelude"]
-> ptrMIdent          = ModuleIdent ["Ptr"]
-> stablePtrMIdent    = ModuleIdent ["StablePtr"]
-
 > anonId :: Ident
 > anonId = Ident "_" 0
 
-> unitId, boolId, charId, intId, floatId, listId, ioId, successId :: Ident
-> unitId    = Ident "()" 0
-> boolId    = Ident "Bool" 0
-> charId    = Ident "Char" 0
-> intId     = Ident "Int" 0
-> floatId   = Ident "Float" 0
-> listId    = Ident "[]" 0
-> ioId      = Ident "IO" 0
-> successId = Ident "Success" 0
-
-> ptrId, funPtrId, stablePtrId :: Ident
-> ptrId       = Ident "Ptr" 0
-> funPtrId    = Ident "FunPtr" 0
-> stablePtrId = Ident "StablePtr" 0
-
-> trueId, falseId, nilId, consId :: Ident
-> trueId  = Ident "True" 0
-> falseId = Ident "False" 0
-> nilId   = Ident "[]" 0
-> consId  = Ident ":" 0
-
-> tupleId :: Int -> Ident
-> tupleId n
->   | n >= 2 = Ident ("(" ++ replicate (n - 1) ',' ++ ")") 0
->   | otherwise = error "internal error: tupleId"
-
-> isTupleId :: Ident -> Bool
-> isTupleId x = n > 1 && x == tupleId n
->   where n = length (name x) - 1
-
-> tupleArity :: Ident -> Int
-> tupleArity x
->   | n > 1 && x == tupleId n = n
->   | otherwise = error "internal error: tupleArity"
->   where n = length (name x) - 1
-
-> selectorId :: Int -> Ident
-> selectorId n = Ident ("_#sel" ++ show n) 0
-
-> isSelectorId :: Ident -> Bool
-> isSelectorId x = any ("_#sel" `isPrefixOf`) (tails (name x))
-
-> mainId, minusId, fminusId :: Ident
-> mainId = Ident "main" 0
-> minusId = Ident "-" 0
-> fminusId = Ident "-." 0
-
-> qUnitId, qNilId, qConsId, qListId :: QualIdent
-> qUnitId = UnqualIdent unitId
-> qListId = UnqualIdent listId
-> qNilId  = UnqualIdent nilId
-> qConsId = UnqualIdent consId
-
-> qBoolId, qCharId, qIntId, qFloatId, qSuccessId, qIOId :: QualIdent
-> qBoolId = QualIdent preludeMIdent boolId
-> qCharId = QualIdent preludeMIdent charId
-> qIntId = QualIdent preludeMIdent intId
-> qFloatId = QualIdent preludeMIdent floatId
-> qSuccessId = QualIdent preludeMIdent successId
-> qIOId = QualIdent preludeMIdent ioId
-
-> qPtrId, qFunPtrId, qStablePtrId :: QualIdent
-> qPtrId = QualIdent ptrMIdent ptrId
-> qFunPtrId = QualIdent ptrMIdent funPtrId
-> qStablePtrId = QualIdent stablePtrMIdent stablePtrId
-
-> qTrueId, qFalseId :: QualIdent
-> qTrueId = QualIdent preludeMIdent trueId
-> qFalseId = QualIdent preludeMIdent falseId
-
-> qTupleId :: Int -> QualIdent
-> qTupleId = UnqualIdent . tupleId
-
-> isQTupleId :: QualIdent -> Bool
-> isQTupleId = isTupleId . unqualify
-
-> qTupleArity :: QualIdent -> Int
-> qTupleArity = tupleArity . unqualify
-
-> isQSelectorId :: QualIdent -> Bool
-> isQSelectorId = isSelectorId . unqualify
-
 \end{verbatim}
diff -u curry-0.9.11/ILCompile.lhs curry-0.9.11-classful/ILCompile.lhs
--- curry-0.9.11/ILCompile.lhs	2007-06-15 14:16:34.000000000 +0200
+++ curry-0.9.11-classful/ILCompile.lhs	2012-08-14 13:14:38.000000000 +0200
@@ -1,7 +1,7 @@
 % -*- LaTeX -*-
-% $Id: ILCompile.lhs 2190 2007-05-06 09:49:45Z wlux $
+% $Id: ILCompile.lhs 3097 2012-08-13 09:54:38Z wlux $
 %
-% Copyright (c) 1999-2007, Wolfgang Lux
+% Copyright (c) 1999-2011, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{ILCompile.lhs}
@@ -10,55 +10,49 @@
 language into abstract machine code.
 \begin{verbatim}
 
-> module ILCompile where
-> import Ident
-> import IL
+> module ILCompile(camCompile, var, fun, apFun, con) where
 > import qualified Cam
-> import Env
+> import Combined
+> import IL
 > import List
 > import Map
 > import Maybe
 > import Monad
+> import PredefIdent
 > import SCC
-> import Combined
 > import Utils
 
 > type CompState a = StateT [Cam.Name] Id a
 
 > camCompile :: Module -> Cam.Module
-> camCompile (Module m is ds) =
->   map compileImport is ++ concat (map compileDecl ds)
+> camCompile (Module _ es is ds) =
+>   map compileImport is ++ concat (map (compileDecl es) ds)
 >   where compileImport = Cam.ImportDecl . Cam.mangle . moduleName
 
-> camCompileData :: [Decl] -> [Cam.Decl]
-> camCompileData ds = [compileData tc n cs | DataDecl tc n cs <- ds]
-
-> compileDecl :: Decl -> [Cam.Decl]
-> compileDecl (DataDecl tc n cs) = [compileData tc n cs]
-> compileDecl (TypeDecl _ _ _) = []
-> compileDecl (FunctionDecl f vs _ e) = [compileFun f vs e]
-> compileDecl (ForeignDecl f cc ie ty) = [compileForeign f cc ie ty]
-
-> compileData :: QualIdent -> Int -> [ConstrDecl] -> Cam.Decl
-> compileData tc n cs =
->   Cam.DataDecl (con tc) (take n vs) (map (compileConstr vs) cs)
+> compileDecl :: [QualIdent] -> Decl -> [Cam.Decl]
+> compileDecl es (DataDecl tc n cs) = [compileData es tc n cs]
+> compileDecl _ (TypeDecl _ _ _) = []
+> compileDecl es (FunctionDecl f vs _ e) = [compileFun es f vs e]
+> compileDecl es (ForeignDecl f cc ie ty) = [compileForeign es f cc ie ty]
+
+> compileData :: [QualIdent] -> QualIdent -> Int -> [ConstrDecl] -> Cam.Decl
+> compileData es tc n cs =
+>   Cam.DataDecl (con tc) (take n vs) (map (compileConstr es vs) cs)
 >   where vs = nameSupply "_"
 
-> compileConstr :: [Cam.Name] -> ConstrDecl -> Cam.ConstrDecl
-> compileConstr vs (ConstrDecl c tys) = Cam.ConstrDecl c' (map compileType tys)
->   where c' = if c == hidden then hiddenCon else con c
->         compileType (TypeConstructor tc tys) =
+> compileConstr :: [QualIdent] -> [Cam.Name] -> ConstrDecl -> Cam.ConstrDecl
+> compileConstr es vs (ConstrDecl c tys) =
+>   Cam.ConstrDecl (vis es c) (con c) (map compileType tys)
+>   where compileType (TypeConstructor tc tys) =
 >           Cam.TypeApp (con tc) (map compileType tys)
 >         compileType (TypeVariable n) = Cam.TypeVar (vs !! n)
 >         compileType (TypeArrow ty1 ty2) =
 >           Cam.TypeArr (compileType ty1) (compileType ty2)
 
-> compileFun :: QualIdent -> [Ident] -> Expression -> Cam.Decl
-> compileFun f vs e =
->   runSt (compile (Cam.FunctionDecl (fun f)) vs e) (nameSupply "_")
->   where compile = if isQSelectorId f then compileSelector else compileFunction
->         compileFunction f vs e =
->           liftM (f (map var vs) . unalias) (compileStrict [] e [])
+> compileFun :: [QualIdent] -> QualIdent -> [Ident] -> Expression -> Cam.Decl
+> compileFun es f vs e =
+>   Cam.FunctionDecl (vis es f) (fun f) (map var vs) (unalias st)
+>   where st = runSt (compileStrict [] e []) (nameSupply "_")
 
 \end{verbatim}
 The code of a few known foreign functions using the \texttt{primitive}
@@ -92,9 +86,10 @@
 world.
 \begin{verbatim}
 
-> compileForeign :: QualIdent -> CallConv -> String -> Type -> Cam.Decl
-> compileForeign f cc fExt ty =
->   Cam.FunctionDecl (fun f) vs (foreignCall cc fExt vs tys ty' vs')
+> compileForeign :: [QualIdent] -> QualIdent -> CallConv -> String -> Type
+>                -> Cam.Decl
+> compileForeign es f cc fExt ty =
+>   Cam.FunctionDecl (vis es f) (fun f) vs (foreignCall cc fExt vs tys ty' vs')
 >   where (tys,ty') = arrowUnapply ty
 >         (vs,vs') = splitAt n (nameSupply "_")
 >         n = if isIO ty' then length tys + 1 else length tys
@@ -118,7 +113,6 @@
 > foreignPrimitive f =
 >   case f of
 >     "failed" -> failed
->     "success" -> success
 >     "seq" -> seq
 >     "ensureNotFree" -> ensureNotFree
 >     "return" -> return
@@ -127,13 +121,11 @@
 >     "unsafePerformIO" -> unsafePerformIO
 >     "fixIO" -> fixIO
 >     _ -> const . (Cam.Exec (Cam.mangle f))
->   where failed _ _ = Cam.Choices []
->         success _ _ = Cam.Return (Cam.Constr (Cam.mangle "Success") [])
->         seq (v1:v2:_) (w1:_) =
->           Cam.Seq (w1 Cam.:<- Cam.Enter v1) (Cam.Enter v2)
+>   where failed _ _ = Cam.Choice []
+>         seq (v1:v2:_) (w1:_) = Cam.Seq (w1 Cam.:<- Cam.Eval v1) (Cam.Eval v2)
 >         ensureNotFree (v1:_) (w1:_) = rigidArg v1 w1 (Cam.Return (Cam.Var w1))
 >         return (v1:_) _ = Cam.Return (Cam.Var v1)
->         (>>) (v1:v2:v3:_) (w1:_) = 
+>         (>>) (v1:v2:v3:_) (w1:_) =
 >           Cam.Seq (w1 Cam.:<- Cam.Exec (apFun 1) [v1,v3])
 >                   (Cam.Exec (apFun 1) [v2,v3])
 >         (>>=) (v1:v2:v3:_) (w1:_) =
@@ -142,14 +134,13 @@
 >         unsafePerformIO (v1:_) (w1:w2:_) =
 >           Cam.Seq (w1 Cam.:<- Cam.Return (Cam.Constr (con qUnitId) [])) $
 >           Cam.Seq (w2 Cam.:<- Cam.Exec (apFun 1) [v1,w1]) $
->           Cam.Enter w2
+>           Cam.Eval w2
 >         fixIO (v1:v2:_) (w1:_) =
->           Cam.Seq (Cam.Let [Cam.Bind w1 (Cam.Lazy (apFun 2) [v1,w1,v2])])
->                   (Cam.Enter w1)
+>           Cam.Let [Cam.Bind w1 (Cam.Lazy (apFun 2) [v1,w1,v2])] (Cam.Eval w1)
 
 > rigidArg :: Cam.Name -> Cam.Name -> Cam.Stmt -> Cam.Stmt
 > rigidArg v1 v2 st =
->   Cam.Seq (v2 Cam.:<- Cam.Enter v1)
+>   Cam.Seq (v2 Cam.:<- Cam.Eval v1)
 >           (Cam.Switch Cam.Rigid v2 [Cam.Case Cam.DefaultCase st])
 
 > foreignCCall :: CallConv -> Type -> String -> [Type] -> [Cam.Name] -> Cam.Stmt
@@ -194,51 +185,7 @@
 > cRetType RawCall _ = Just Cam.TypeNodePtr
 
 \end{verbatim}
-The selector functions, which are introduced by the compiler in order
-to avoid a space leak with lazy pattern bindings (see
-p.~\pageref{pattern-binding} in Sect.~\ref{sec:simplify}), have to be
-treated specially. The first argument of a selector function is the
-pattern to be matched and the remaining arguments are references to
-the free variables of the pattern excluding the variable that is
-returned by the selector. When a selector is evaluated, it updates the
-additional arguments with queue-me nodes first so as to prevent
-concurrent computations from evaluating the corresponding selectors.
-After matching is complete, these queue-me nodes are updated with
-pointers to the matched arguments from the pattern.
-
-The compiler uses the convention that the additional arguments use the
-same names as the corresponding variables in the pattern. However, in
-the abstract machine code these variables have to use different names.
-The function \texttt{compileSelector} takes care of this renaming and
-inserts the necessary \texttt{Lock} and \texttt{Update} statements. It
-makes use of the fact that the body of a selector is a nested case
-expression whose innermost expression is the matched variable.
-\begin{verbatim}
-
-> compileSelector :: ([Cam.Name] -> Cam.Stmt -> Cam.Decl)
->                 -> [Ident] -> Expression -> CompState Cam.Decl
-> compileSelector f (v:vs) e =
->   do
->     vs' <- mapM (const freshName) vs
->     st <- compileSelectorExpr (zip vs vs') e
->     return (f (var v : vs') (foldr lock st vs'))
->   where lock v = Cam.Seq (Cam.Lock v)
-
-> compileSelectorExpr :: [(Ident,Cam.Name)] -> Expression -> CompState Cam.Stmt
-> compileSelectorExpr vs (Case ev (Variable v) [Alt t e]) =
->   do
->     v' <- freshName
->     st <- compileSelectorExpr vs e
->     return (Cam.Seq (v' Cam.:<- Cam.Enter (var v))
->                     (Cam.Switch (rf ev) v' [caseTag noVar t st]))
->   where noVar = internalError "invalid selector pattern"
-> compileSelectorExpr vs (Variable v) =
->   return (foldr update (Cam.Enter (var v)) vs)
->   where update (v,v') = Cam.Seq (Cam.Update v' (var v))
-> compileSelectorExpr _ _ = internalError "invalid selector function"
-
-\end{verbatim}
-The compilation of expressions is straight forward. The compiler
+The compilation of expressions is straightforward. The compiler
 attempts to avoid redundant evaluations of nodes. To this end, a list
 of the names of those variables whose bindings are known to be in head
 normal form, is passed as an additional argument to
@@ -249,7 +196,7 @@
 > compileStrict _ (Literal l) vs = compileLazy (Literal l) vs
 > compileStrict hnfs (Variable v) vs
 >   | null vs =
->       return ((if v `elem` hnfs then Cam.Return . Cam.Var else Cam.Enter)
+>       return ((if v `elem` hnfs then Cam.Return . Cam.Var else Cam.Eval)
 >               (var v))
 >   | otherwise = return (Cam.Exec (apFun (length vs)) (var v:vs))
 > compileStrict _ (Function f arity) vs
@@ -280,33 +227,27 @@
 >       _ ->
 >         do
 >           v <- freshName
->           as' <- mapM (flip (compileCase hnfs' v) vs) as
+>           as' <- sequence [compileCase hnfs' v a vs | a <- as]
 >           return (Cam.Seq (v Cam.:<- st) (Cam.Switch (rf ev) v as'))
 >   where hnfs' = noteHnf e hnfs
-> compileStrict hnfs (Or e1 e2) vs =
->   do
->     sts <- mapM (flip (compileStrict hnfs) vs) (branches e1 ++ branches e2)
->     return (Cam.Choices sts)
->   where branches (Or e1 e2) = branches e1 ++ branches e2
->         branches e = [e]
-> compileStrict hnfs (Exist v e) vs =
+> compileStrict hnfs (Choice es) vs =
 >   do
->     st <- compileStrict (v:hnfs) e vs
->     return (Cam.Seq (var v Cam.:<- Cam.Return Cam.Free) st)
-> compileStrict hnfs (Let bd e) vs =
->   do
->     st1 <- compileBinding bd
->     st2 <- compileStrict (addHnfs [bd] hnfs) e vs
->     return (Cam.Seq st1 st2)
-> compileStrict hnfs (Letrec bds e) vs =
->   do
->     bdss' <- compileRecBindings bds
->     st <- compileStrict (addHnfs bds hnfs) e vs
->     return (foldr (Cam.Seq . Cam.Let) st bdss')
+>     sts <- sequence [compileStrict hnfs e vs | e <- es]
+>     return (Cam.Choice sts)
+> compileStrict hnfs (Exist us e) vs =
+>   do
+>     st <- compileStrict (us ++ hnfs) e vs
+>     return (foldr Cam.Seq st [var u Cam.:<- Cam.Return Cam.Free | u <- us])
+> compileStrict hnfs (Let rec ds e) vs =
+>   liftM2 (letBindings rec)
+>          (mapM compileBinding ds)
+>          (compileStrict (addHnfs ds hnfs) e vs)
+> compileStrict hnfs (SrcLoc _ e) vs = compileStrict hnfs e vs
 
 > literal :: Literal -> Cam.Literal
 > literal (Char c) = Cam.Char c
 > literal (Int i) = Cam.Int i
+> literal (Integer i) = Cam.Integer i
 > literal (Float f) = Cam.Float f
 
 > noteHnf :: Expression -> [Ident] -> [Ident]
@@ -316,13 +257,13 @@
 > noteHnf (Constructor _ _) hnfs = hnfs
 > noteHnf (Apply f _) hnfs = noteHnf f hnfs
 > noteHnf (Case _ e _) hnfs = noteHnf e hnfs
-> noteHnf (Or e1 e2) hnfs = intersect (noteHnf e1 hnfs) (noteHnf e2 hnfs)
+> noteHnf (Choice es) hnfs = foldl1 intersect [noteHnf e hnfs | e <- es]
 > noteHnf (Exist _ e) hnfs = noteHnf e hnfs
-> noteHnf (Let _ e) hnfs = noteHnf e hnfs
-> noteHnf (Letrec _ e) hnfs = noteHnf e hnfs
+> noteHnf (Let _ _ e) hnfs = noteHnf e hnfs
+> noteHnf (SrcLoc _ e) hnfs = noteHnf e hnfs
 
 > addHnfs :: [Binding] -> [Ident] -> [Ident]
-> addHnfs bds hnfs = [v | Binding v e <- bds, isHnf hnfs e] ++ hnfs
+> addHnfs ds hnfs = [v | Binding v e <- ds, isHnf hnfs e] ++ hnfs
 
 > isHnf :: [Ident] -> Expression -> Bool
 > isHnf _ (Literal _) = True
@@ -330,9 +271,9 @@
 > isHnf _ (Function _ n) = n > 0
 > isHnf _ (Constructor _ _) = True
 > isHnf _ (Apply e1 e2) = isHnfApp e1 [e2]
-> isHnf hnfs (Exist v e) = isHnf (v:hnfs) e
-> isHnf hnfs (Let bd e) = isHnf (addHnfs [bd] hnfs) e
-> isHnf hnfs (Letrec bds e) = isHnf (addHnfs bds hnfs) e
+> isHnf hnfs (Exist vs e) = isHnf (vs ++ hnfs) e
+> isHnf hnfs (Let _ ds e) = isHnf (addHnfs ds hnfs) e
+> isHnf hnfs (SrcLoc _ e) = isHnf hnfs e
 > isHnf _ _ = internalError "isHnf"
 
 > isHnfApp :: Expression -> [Expression] -> Bool
@@ -341,8 +282,8 @@
 > isHnfApp (Constructor _ _) _ = True
 > isHnfApp (Apply e1 e2) es = isHnfApp e1 (e2:es)
 > isHnfApp (Exist _ e) es = isHnfApp e es
-> isHnfApp (Let _ e) es = isHnfApp e es
-> isHnfApp (Letrec _ e) es = isHnfApp e es
+> isHnfApp (Let _ _ e) es = isHnfApp e es
+> isHnfApp (SrcLoc _ e) es = isHnfApp e es
 > isHnfApp _ _ = internalError "isHnfApp"
 
 > rf :: Eval -> Cam.RF
@@ -364,11 +305,11 @@
 >   Cam.Case Cam.DefaultCase . Cam.Seq (var v' Cam.:<- Cam.Return (Cam.Var v))
 
 \end{verbatim}
-When compiling expressions in lazy -- i.e., argument -- positions,
-the compiler generates minimal binding groups in order to improve the
+When compiling expressions in lazy -- i.e., argument -- positions, the
+compiler generates minimal binding groups in order to improve the
 efficiency of the compiler. Note that the compiler can only handle
-constants, applications, and let bindings in lazy positions. Case and
-non-deterministic or expressions have to be lifted into global
+constants, applications, and let bindings in lazy positions. (F)case
+and non-deterministic choice expressions must be lifted into global
 functions before compiling into abstract machine code.
 \begin{verbatim}
 
@@ -378,15 +319,14 @@
 >     st <- compileLazy e []
 >     return (var v Cam.:<- st)
 
-> compileRecBindings :: [Binding] -> CompState [[Cam.Bind]]
-> compileRecBindings bds =
->   do
->     bds' <- mapM compileBinding bds
->     return (scc bound free (concatMap binds bds'))
+> letBindings :: Rec -> [Cam.Stmt0] -> Cam.Stmt -> Cam.Stmt
+> letBindings NonRec sts st = foldr Cam.Seq st sts
+> letBindings Rec sts st =
+>   foldr Cam.Let st (scc bound free (concatMap binds sts))
 >   where binds (v Cam.:<- Cam.Return e) = [Cam.Bind v e]
 >         binds (v Cam.:<- Cam.Seq st1 st2) = binds st1 ++ binds (v Cam.:<- st2)
->         binds (Cam.Let bds) = bds
->         binds st = internalError ("compileRecBindings " ++ show st)
+>         binds (v Cam.:<- Cam.Let ds st) = ds ++ binds (v Cam.:<- st)
+>         binds st = internalError ("letBindings " ++ show st)
 >         bound (Cam.Bind v _) = [v]
 >         free (Cam.Bind _ e) = vars e
 
@@ -421,44 +361,47 @@
 >     st1 <- compileLazy e2 []
 >     st2 <- compileLazy e1 (v:vs)
 >     return (Cam.Seq (v Cam.:<- st1) st2)
-> compileLazy (Exist v e) vs =
->   do
->     st <- compileLazy e vs
->     return (Cam.Seq (var v Cam.:<- Cam.Return Cam.Free) st)
-> compileLazy (Let bd e) vs =
->   do
->     st1 <- compileBinding bd
->     st2 <- compileLazy e vs
->     return (Cam.Seq st1 st2)
-> compileLazy (Letrec bds e) vs =
+> compileLazy (Exist us e) vs =
 >   do
->     bdss' <- compileRecBindings bds
 >     st <- compileLazy e vs
->     return (foldr (Cam.Seq . Cam.Let) st bdss')
+>     return (foldr Cam.Seq st [var u Cam.:<- Cam.Return Cam.Free | u <- us])
+> compileLazy (Let rec ds e) vs =
+>   liftM2 (letBindings rec) (mapM compileBinding ds) (compileLazy e vs)
+> compileLazy (SrcLoc _ e) vs = compileLazy e vs
 > compileLazy e _ = internalError ("compileLazy: " ++ show e)
 
 \end{verbatim}
 In a post-processing step, the generated code is simplified by
-removing alias bindings and nested statement sequences. In addition,
-the code is transformed such that \texttt{let} statements are used
-only to create recursive bindings. All other nodes are allocated with
-statements of the form $x$ \texttt{<-} \texttt{return} $e$. Note that
-non-recursive \texttt{let} bindings can be introduced in
-\texttt{compileRecBindings} when the bindings of an intermediate
-language \texttt{letrec} expression are split into minimal recursive
-groups.
+removing alias bindings and nested statement sequences. Note that $y$
+becomes an alias for $x$ after evaluating the statement $y$
+\texttt{<-} \texttt{eval} $x$ and is used to replace all further
+occurrences of $x$. This is necessary to ensure the validity of the
+optimization to just return variables after they have been evaluated
+once. Otherwise, the code might unexpectedly return an indirection
+node, e.g., for a function like \verb|f xs = case xs of { _:_ -> xs }|.
+
+In addition, the code is transformed such that \texttt{let} statements
+are used only to create recursive bindings. All other nodes are
+allocated with statements of the form $x$ \texttt{<-} \texttt{return}
+$e$. Note that non-recursive \texttt{let} bindings can be introduced
+in \texttt{letBindings} when the bindings of an intermediate language
+\texttt{letrec} expression are split into minimal recursive groups.
 
-In order to simplify the generated code, we make use of the following
-equivalences.
+Here is a summary of the equivalences used to simplify the generated
+code.
 \begin{quote}\def\lb{\char`\{}\def\rb{\char`\}}
   \begin{tabular}{r@{$\null\equiv\null$}ll}
-    \texttt{let} \texttt{\lb} $x$ \texttt{=} $e$ \texttt{\rb;} \emph{st} &
-      $x$ \texttt{<-} \texttt{return} $e$ & $(x \not\in \textrm{vars}(e))$ \\
+    \texttt{let} \texttt{\lb} $x$ \texttt{=} $e$ \texttt{\rb} \texttt{in} \emph{st} &
+      $x$ \texttt{<-} \texttt{return} $e$\texttt{;} \emph{st} & $(x \not\in \textrm{vars}(e))$ \\
     $x$ \texttt{<-} \emph{st}\texttt{;} \texttt{return} $x$ & \emph{st} \\
     $x$ \texttt{<-} \texttt{return} $y$\texttt{;} \emph{st} &
-      $\emph{st}[y/x]$ \\
-    $x$ \texttt{<-} \texttt{\lb} \emph{st$_1$}\texttt{;} \emph{st$_2$} \texttt{\rb} &
-    \emph{st$_1$}; $x$ \texttt{<-} \emph{st$_2$}
+      $\emph{st}[x/y]$ \\
+    $x$ \texttt{<-} \texttt{eval} $y$\texttt{;} \emph{st} &
+      $x$ \texttt{<-} \texttt{eval} $y$\texttt{;} $\emph{st}[y/x]$ \\
+    $y$ \texttt{<-} \texttt{\lb} $x$ \texttt{<-} \emph{st$_1$}\texttt{;} \emph{st$_2$} \texttt{\rb}\texttt{;} \emph{st$_3$} &
+      $x$ \texttt{<-} \emph{st$_1$}\texttt{;} $y$ \texttt{<-} \emph{st$_2$}\texttt{;} \emph{st$_3$} \\
+    $x$ \texttt{<-} \texttt{\lb} \texttt{let} \texttt{\lb} \emph{ds} \texttt{\rb} \texttt{in} \emph{st$_1$} \texttt{\rb}\texttt{;} \emph{st$_2$} &
+      \texttt{let} \texttt{\lb} \emph{ds} \texttt{\rb} \texttt{in} $x$ \texttt{<-} \emph{st$_1$}\texttt{;} \emph{st$_2$}
   \end{tabular}
 \end{quote}
 \begin{verbatim}
@@ -469,53 +412,48 @@
 
 > unaliasStmt :: AliasMap -> Cam.Stmt -> Cam.Stmt
 > unaliasStmt aliases (Cam.Return e) = Cam.Return (unaliasExpr aliases e)
-> unaliasStmt aliases (Cam.Enter v) = Cam.Enter (unaliasVar aliases v)
-> unaliasStmt aliases (Cam.Exec f vs) =
->   Cam.Exec f (map (unaliasVar aliases) vs)
+> unaliasStmt aliases (Cam.Eval v) = Cam.Eval (unaliasVar aliases v)
+> unaliasStmt aliases (Cam.Exec f vs) = Cam.Exec f (map (unaliasVar aliases) vs)
 > unaliasStmt aliases (Cam.CCall h ty cc) =
 >   Cam.CCall h ty (unaliasCCall aliases cc)
 > unaliasStmt aliases (Cam.Seq (v Cam.:<- Cam.Seq st1 st2) st3) =
 >   unaliasStmt aliases (Cam.Seq st1 (Cam.Seq (v Cam.:<- st2) st3))
-> unaliasStmt aliases (Cam.Seq (Cam.Let [Cam.Bind v e]) st)
->   | v `notElem` vars e = 
+> unaliasStmt aliases (Cam.Seq (v Cam.:<- Cam.Let ds st1) st2) =
+>   unaliasStmt aliases (Cam.Let ds (Cam.Seq (v Cam.:<- st1) st2))
+> unaliasStmt aliases (Cam.Seq (v Cam.:<- st1) st2) =
+>   case unaliasStmt aliases st1 of
+>     Cam.Return (Cam.Var v') -> unaliasStmt (addToFM v v' aliases) st2
+>     Cam.Eval v' ->
+>       Cam.Seq (v Cam.:<- Cam.Eval v') (unaliasStmt (addToFM v' v aliases) st2)
+>     st1' ->
+>       case unaliasStmt aliases st2 of
+>         Cam.Return (Cam.Var v') | v == v' -> st1'
+>         st2' -> Cam.Seq (v Cam.:<- st1') st2'
+> unaliasStmt aliases (Cam.Let [Cam.Bind v e] st)
+>   | v `notElem` vars e =
 >       unaliasStmt aliases (Cam.Seq (v Cam.:<- Cam.Return e) st)
-> unaliasStmt aliases (Cam.Seq st1 st2) =
->   case f (unaliasStmt aliases' st2) of
->     Cam.Seq (v1' Cam.:<- st') (Cam.Return (Cam.Var v2')) | v1' == v2' -> st'
->     st' -> st'
->   where (aliases',f) = unaliasStmt0 aliases st1
-> unaliasStmt aliases (Cam.Switch rf v cases) =
->   Cam.Switch rf (unaliasVar aliases v) (map (unaliasCase aliases) cases)
-> unaliasStmt aliases (Cam.Choices alts) =
->   Cam.Choices (map (unaliasStmt aliases) alts)
-
-> unaliasStmt0 :: AliasMap -> Cam.Stmt0 -> (AliasMap,Cam.Stmt -> Cam.Stmt)
-> unaliasStmt0 aliases (Cam.Lock v) =
->   (aliases,Cam.Seq (Cam.Lock (unaliasVar aliases v)))
-> unaliasStmt0 aliases (Cam.Update v1 v2) =
->   (aliases,
->    Cam.Seq (Cam.Update (unaliasVar aliases v1) (unaliasVar aliases v2)))
-> unaliasStmt0 aliases (v Cam.:<- st) =
->   case unaliasStmt aliases st of
->     Cam.Return (Cam.Var v') -> (addToFM v v' aliases,id)
->     st'                     -> (aliases,Cam.Seq (v Cam.:<- st'))
-> unaliasStmt0 aliases (Cam.Let bds) =
->   (aliases',
->    mkLet [Cam.Bind v (unaliasExpr aliases' e) | Cam.Bind v e <- bds''])
->   where (bds',bds'') = partition isAlias bds
+> unaliasStmt aliases (Cam.Let ds st) = Cam.Let ds''' (unaliasStmt aliases' st)
+>   where (ds',ds'') =
+>           case partition isAlias ds of
+>             (d':ds',[]) -> (ds',[d'])        -- cyclic chain of variable defs
+>             (ds',ds'') -> (ds',ds'')
+>         ds''' = [Cam.Bind v (unaliasExpr aliases' e) | Cam.Bind v e <- ds'']
 >         aliases' = foldr (uncurry addToFM) aliases
 >                          [(v,unaliasVar aliases' v')
->                          | Cam.Bind v (Cam.Var v') <- bds']
->         mkLet bds = if null bds then id else Cam.Seq (Cam.Let bds)
+>                          | Cam.Bind v (Cam.Var v') <- ds']
 >         isAlias (Cam.Bind _ (Cam.Var _)) = True
 >         isAlias (Cam.Bind _ _) = False
+> unaliasStmt aliases (Cam.Switch rf v cases) =
+>   Cam.Switch rf (unaliasVar aliases v) (map (unaliasCase aliases) cases)
+> unaliasStmt aliases (Cam.Choice alts) =
+>   Cam.Choice (map (unaliasStmt aliases) alts)
 
 > unaliasCCall :: AliasMap -> Cam.CCall -> Cam.CCall
 > unaliasCCall aliases (Cam.StaticCall f xs) =
 >   Cam.StaticCall f [(ty,unaliasVar aliases x) | (ty,x) <- xs]
 > unaliasCCall aliases (Cam.DynamicCall f xs) =
 >   Cam.DynamicCall f [(ty,unaliasVar aliases x) | (ty,x) <- xs]
-> unaliasCCall _liases (Cam.StaticAddr x) = Cam.StaticAddr x
+> unaliasCCall _ (Cam.StaticAddr x) = Cam.StaticAddr x
 
 > unaliasExpr :: AliasMap -> Cam.Expr -> Cam.Expr
 > unaliasExpr _ (Cam.Lit l) = Cam.Lit l
@@ -553,16 +491,13 @@
 > con :: QualIdent -> Cam.Name
 > con c = Cam.mangleQualified (show c)
 
-> hiddenCon :: Cam.Name
-> hiddenCon = Cam.Name "_"
+> vis :: [QualIdent] -> QualIdent -> Cam.Visibility
+> vis es x = if x `elem` es then Cam.Exported else Cam.Private
 
 \end{verbatim}
 Auxiliary functions.
 \begin{verbatim}
 
-> hidden :: QualIdent
-> hidden = qualify anonId
-
 > nameSupply :: String -> [Cam.Name]
 > nameSupply v = [Cam.Name (v ++ show i) | i <- [0..]]
 
diff -u curry-0.9.11/IL.lhs curry-0.9.11-classful/IL.lhs
--- curry-0.9.11/IL.lhs	2007-06-15 14:16:34.000000000 +0200
+++ curry-0.9.11-classful/IL.lhs	2011-10-08 12:42:57.000000000 +0200
@@ -1,50 +1,55 @@
 % -*- LaTeX -*-
-% $Id: IL.lhs 2118 2007-03-15 08:49:21Z wlux $
+% $Id: IL.lhs 3056 2011-10-07 16:27:03Z wlux $
 %
-% Copyright (c) 1999-2007 Wolfgang Lux
+% Copyright (c) 1999-2011 Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{IL.lhs}
 \section{The Intermediate Language}\label{sec:IL}
-The module \texttt{IL} defines the intermediate language, which will be
-compiled into abstract machine code. The intermediate language removes
-a lot of syntactic sugar from the Curry source language. Top-level
-declarations are restricted to data type, type synonym, and function
-definitions. Type synonyms are remnants of newtype declarations in the
-source code. Their sole purpose is to allow type reconstruction while
-preserving the invariant that the arity of every function matches its
-apparent type. Note that the debugging transformation, which is
-described in Sect.~\ref{sec:dtrans}, currently relies on this
-invariant.
+The module \texttt{IL} defines the intermediate language, which will
+be compiled into abstract machine code. The intermediate language
+removes a lot of syntactic sugar from the Curry source
+language. Top-level declarations are restricted to data type, type
+synonym, and function definitions. Type synonyms are remnants of
+newtype declarations in the source code. Their sole purpose is to
+allow type reconstruction while preserving the invariant that the
+arity of every function matches its apparent type. Note that the
+debugging transformation, which is described in
+Sect.~\ref{sec:dtrans}, currently relies on this invariant. Each
+intermediate language module has an export list that names the
+exported data constructors and functions defined by that module.
 
 Type declarations use a de-Bruijn indexing scheme (starting at 0) for
 type variables. In the type of a function, all type variables are
-numbered in the order of their occurence from left to right, i.e., a
+numbered in the order of their occurrence from left to right, i.e., a
 type \texttt{(Int -> b) -> (a,b) -> c -> (a,c)} is translated into the
 type (using integer numbers to denote type variables)
 \texttt{(Int -> 0) -> (1,0) -> 2 -> (1,2)}.
 
-Pattern matching in equations is handled via flexible and rigid
-\texttt{case} expressions. \texttt{Case} expressions always evaluate
-the scrutinized expression to head normal form. Note that their
-semantics thus differs from Curry source code where the expression
-\texttt{case e1 of \char`\{\ x -> e2 \char`\}} is equivalent to
-\texttt{let \char`\{\ x = e1 \char`\}\ in e2}. Overlapping rules are
-translated with the help of \texttt{or} expressions. The intermediate
-language has three kinds of binding expressions: \texttt{Exist}
-expressions introduce a new logical variable, \texttt{let} expressions
-support a single non-recursive variable binding, and \texttt{letrec}
-expressions introduce multiple variables with mutually recursive
-initializer expressions. The intermediate language explicitly
-distinguishes (local) variables and (global) functions in expressions.
+Pattern matching in equations is handled by rigid \texttt{case} and
+flexible \texttt{fcase} expressions. \texttt{(F)case} expressions
+always evaluate the scrutinized expression to head normal form. Note
+that their semantics thus differs from Curry source code where the
+expression \texttt{case e1 of \char`\{\ x -> e2 \char`\}} is
+equivalent to \texttt{let \char`\{\ x = e1 \char`\}\ in e2}.
+Overlapping rules are translated with the help of \texttt{choice}
+expressions. The intermediate language has three kinds of binding
+expressions: \texttt{Exist} expressions introduce new logical
+variables, \texttt{let} expressions introduce multiple, non-recursive
+variable bindings, and \texttt{letrec} expressions introduce multiple
+possibly mutually recursive variable bindings. The intermediate
+language explicitly distinguishes (local) variables and (global)
+functions in expressions.
 \begin{verbatim}
 
-> module IL where
+> module IL(module IL,module Ident) where
 > import Ident
 
-> data Module = Module ModuleIdent [ModuleIdent] [Decl] deriving (Eq,Show)
+> data Module =
+>   Module ModuleIdent [QualIdent] [ModuleIdent] [Decl]
+>   deriving (Eq,Show)
 
-> data Decl = 
+> data Decl =
 >     DataDecl QualIdent Int [ConstrDecl]
 >   | TypeDecl QualIdent Int Type
 >   | FunctionDecl QualIdent [Ident] Type Expression
@@ -60,7 +65,12 @@
 >   | TypeArrow Type Type
 >   deriving (Eq,Show)
 
-> data Literal = Char Char | Int Int | Float Double deriving (Eq,Show)
+> data Literal =
+>     Char Char
+>   | Int Integer
+>   | Integer Integer
+>   | Float Double
+>   deriving (Eq,Show)
 
 > data ConstrTerm =
 >   -- literal patterns
@@ -80,15 +90,17 @@
 >   | Apply Expression Expression
 >   -- case expressions
 >   | Case Eval Expression [Alt]
->   -- non-determinisismic or
->   | Or Expression Expression
+>   -- non-determinisismic choice
+>   | Choice [Expression]
 >   -- binding forms
->   | Exist Ident Expression
->   | Let Binding Expression
->   | Letrec [Binding] Expression
+>   | Exist [Ident] Expression
+>   | Let Rec [Binding] Expression
+>   -- source code location annotations
+>   | SrcLoc String Expression
 >   deriving (Eq,Show)
 
 > data Eval = Rigid | Flex deriving (Eq,Show)
+> data Rec = NonRec | Rec deriving (Eq,Show)
 > data Alt = Alt ConstrTerm Expression deriving (Eq,Show)
 > data Binding = Binding Ident Expression deriving (Eq,Show)
 
diff -u curry-0.9.11/ILLift.lhs curry-0.9.11-classful/ILLift.lhs
--- curry-0.9.11/ILLift.lhs	2007-06-15 14:16:34.000000000 +0200
+++ curry-0.9.11-classful/ILLift.lhs	2011-10-08 12:42:57.000000000 +0200
@@ -1,20 +1,19 @@
 % -*- LaTeX -*-
-% $Id: ILLift.lhs 2179 2007-04-28 14:06:25Z wlux $
+% $Id: ILLift.lhs 3056 2011-10-07 16:27:03Z wlux $
 %
-% Copyright (c) 2000-2007, Wolfgang Lux
+% Copyright (c) 2000-2011, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{ILLift.lhs}
 \section{Normalization}
 Before the intermediate language code is translated into abstract
-machine code, all case and or expressions occurring in argument
+machine code, all (f)case and choice expressions occurring in argument
 positions are lifted into global functions.
 \begin{verbatim}
 
 > module ILLift(liftProg) where
-> import IL
-> import Ident
 > import Combined
+> import IL
 > import List
 > import Monad
 > import Utils
@@ -22,84 +21,61 @@
 > type LiftState a = St [QualIdent] a
 
 > liftProg :: Module -> Module
-> liftProg (Module m is ds) = Module m is (concatMap liftDecl ds)
+> liftProg (Module m es is ds) = Module m es is (concatMap liftDecl ds)
 
 > liftDecl :: Decl -> [Decl]
 > liftDecl (DataDecl tc n cs) = [DataDecl tc n cs]
 > liftDecl (TypeDecl tc n ty) = [TypeDecl tc n ty]
 > liftDecl (FunctionDecl f vs ty e) = FunctionDecl f vs ty e' : ds'
->   where (e',ds') = runSt (liftExpr e) nameSupply
->         nameSupply = map (qualifyLike f . appIdent (name (unqualify f))) [1..]
->         appIdent f i = mkIdent (f ++ "._#app" ++ show i)
+>   where (e',ds') = runSt (liftExpr True e) nameSupply
+>         nameSupply = map (qual m . appIdent (name f') (uniqueId f')) [1..]
+>           where (m,f') = splitQualIdent f
+>         qual m = maybe qualify qualifyWith m
+>         appIdent f n i = renameIdent (mkIdent (f ++ "._#app" ++ show i)) n
 > liftDecl (ForeignDecl f cc ie ty) = [ForeignDecl f cc ie ty]
 
-> liftExpr :: Expression -> LiftState (Expression,[Decl])
-> liftExpr (Literal l) = return (Literal l,[])
-> liftExpr (Variable v) = return (Variable v,[])
-> liftExpr (Function f n) = return (Function f n,[])
-> liftExpr (Constructor c n) = return (Constructor c n,[])
-> liftExpr (Apply f e) =
+> liftExpr :: Bool -> Expression -> LiftState (Expression,[Decl])
+> liftExpr _ (Literal l) = return (Literal l,[])
+> liftExpr _ (Variable v) = return (Variable v,[])
+> liftExpr _ (Function f n) = return (Function f n,[])
+> liftExpr _ (Constructor c n) = return (Constructor c n,[])
+> liftExpr root (Apply f e) =
 >   do
->     (f',ds) <- liftExpr f
->     (e',ds') <- liftArg e
+>     (f',ds) <- liftExpr root f
+>     (e',ds') <- liftExpr False e
 >     return (Apply f' e',ds ++ ds')
-> liftExpr (Case ev e as) =
->   do
->     (e',ds) <- liftExpr e
->     (as',ds') <- mapLift liftAlt as
->     return (Case ev e' as',ds ++ ds')
-> liftExpr (Or e1 e2) =
->   do
->     (e1',ds) <- liftExpr e1
->     (e2',ds') <- liftExpr e2
->     return (Or e1' e2',ds ++ ds')
-> liftExpr (Exist v e) =
->   do
->     (e',ds) <- liftExpr e
->     return (Exist v e',ds)
-> liftExpr (Let b e) =
->   do
->     (b',ds) <- liftBinding b
->     (e',ds') <- liftExpr e
->     return (Let b' e',ds ++ ds')
-> liftExpr (Letrec bs e) =
+> liftExpr root (Case ev e as)
+>   | root =
+>       do
+>         (e',ds) <- liftExpr root e
+>         (as',ds') <- mapLift (liftAlt root) as
+>         return (Case ev e' as',ds ++ ds')
+>   | otherwise = lift (Case ev e as)
+> liftExpr root (Choice es)
+>   | root =
+>       do
+>         (es',ds) <- mapLift (liftExpr root) es
+>         return (Choice es',ds)
+>   | otherwise = lift (Choice es)
+> liftExpr root (Exist vs e) =
+>   do
+>     (e',ds) <- liftExpr root e
+>     return (Exist vs e',ds)
+> liftExpr root (Let rec bs e) =
 >   do
 >     (bs',ds) <- mapLift liftBinding bs
->     (e',ds') <- liftExpr e
->     return (Letrec bs' e',ds ++ ds')
-
-> liftArg :: Expression -> LiftState (Expression,[Decl])
-> liftArg (Literal l) = return (Literal l,[])
-> liftArg (Variable v) = return (Variable v,[])
-> liftArg (Function f n) = return (Function f n,[])
-> liftArg (Constructor c n) = return (Constructor c n,[])
-> liftArg (Apply f e) =
+>     (e',ds') <- liftExpr root e
+>     return (Let rec bs' e',ds ++ ds')
+> liftExpr root (SrcLoc p e) =
 >   do
->     (f',ds) <- liftArg f
->     (e',ds') <- liftArg e
->     return (Apply f' e',ds ++ ds')
-> liftArg (Case ev e as) = lift (Case ev e as)
-> liftArg (Or e1 e2) = lift (Or e1 e2)
-> liftArg (Exist v e) =
->   do
->     (e',ds) <- liftArg e
->     return (Exist v e',ds)
-> liftArg (Let b e) =
->   do
->     (b',ds) <- liftBinding b
->     (e',ds') <- liftArg e
->     return (Let b' e',ds ++ ds')
-> liftArg (Letrec bs e) =
->   do
->     (bs',ds) <- mapLift liftBinding bs
->     (e',ds') <- liftArg e
->     return (Letrec bs' e',ds ++ ds')
+>     (e',ds) <- liftExpr root e
+>     return (SrcLoc p e',ds)
 
 > lift :: Expression -> LiftState (Expression,[Decl])
 > lift e =
 >   do
 >     f <- uniqueName
->     (e',ds') <- liftExpr e
+>     (e',ds') <- liftExpr True e
 >     return (foldl Apply (Function f n) (map Variable fvs),
 >             FunctionDecl f fvs ty e' : ds')
 >   where fvs = nub (fv e)
@@ -115,16 +91,16 @@
   expression in the module.}
 \begin{verbatim}
 
-> liftAlt :: Alt -> LiftState (Alt,[Decl])
-> liftAlt (Alt t e) =
+> liftAlt :: Bool -> Alt -> LiftState (Alt,[Decl])
+> liftAlt root (Alt t e) =
 >   do
->     (e',ds) <- liftExpr e
+>     (e',ds) <- liftExpr root e
 >     return (Alt t e',ds)
 
 > liftBinding :: Binding -> LiftState (Binding,[Decl])
 > liftBinding (Binding v e) =
 >   do
->     (e',ds) <- liftArg e
+>     (e',ds) <- liftExpr False e
 >     return (Binding v e',ds)
 
 > mapLift :: (a -> LiftState (a,[Decl])) -> [a] -> LiftState ([a],[Decl])
@@ -140,12 +116,14 @@
 > fv (Constructor _ _) = []
 > fv (Apply f e) = fv f ++ fv e
 > fv (Case _ e as) = fv e ++ concatMap fvAlt as
-> fv (Or e1 e2) = fv e1 ++ fv e2
-> fv (Exist v e) = filter (v /=) (fv e)
-> fv (Let (Binding v e1) e2) = fv e1 ++ filter (v /=) (fv e2)
-> fv (Letrec bs e) =
->   filter (`notElem` bvs) ([v | Binding _ e <- bs, v <- fv e] ++ fv e)
->   where bvs = [v | Binding v _ <- bs]
+> fv (Choice es) = concatMap fv es
+> fv (Exist vs e) = filter (`notElem` vs) (fv e)
+> fv (Let rec bs e) =
+>   fvBinds rec vs (concatMap fv es) ++ filter (`notElem` vs) (fv e)
+>   where (vs,es) = unzip [(v,e) | Binding v e <- bs]
+>         fvBinds NonRec _ = id
+>         fvBinds Rec vs = filter (`notElem` vs)
+> fv (SrcLoc _ e) = fv e
 
 > fvAlt :: Alt -> [Ident]
 > fvAlt (Alt t e) = filter (`notElem` bv t) (fv e)
diff -u curry-0.9.11/ILPP.lhs curry-0.9.11-classful/ILPP.lhs
--- curry-0.9.11/ILPP.lhs	2007-06-15 14:16:34.000000000 +0200
+++ curry-0.9.11-classful/ILPP.lhs	2011-10-08 12:42:57.000000000 +0200
@@ -1,7 +1,7 @@
 % -*- LaTeX -*-
-% $Id: ILPP.lhs 2118 2007-03-15 08:49:21Z wlux $
+% $Id: ILPP.lhs 3056 2011-10-07 16:27:03Z wlux $
 %
-% Copyright (c) 1999-2007 Wolfgang Lux
+% Copyright (c) 1999-2011 Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{ILPP.lhs}
@@ -13,8 +13,8 @@
 \begin{verbatim}
 
 > module ILPP(module ILPP, Doc) where
-> import Ident
 > import IL
+> import PredefIdent
 > import Pretty
 
 > default(Int,Double)
@@ -26,9 +26,12 @@
 > altIndent = 2
 
 > ppModule :: Module -> Doc
-> ppModule (Module m is ds) =
->   vcat (text "module" <+> text (show m) <+> text "where" :
->         map ppImport is ++ map ppDecl ds)
+> ppModule (Module m es is ds) =
+>   vcat (ppHeader m es : map ppImport is ++ map ppDecl ds)
+
+> ppHeader :: ModuleIdent -> [QualIdent] -> Doc
+> ppHeader m es =
+>   text "module" <+> text (show m) <+> ppTuple ppQIdent es <+> text "where"
 
 > ppImport :: ModuleIdent -> Doc
 > ppImport m = text "import" <+> text (show m)
@@ -63,8 +66,8 @@
 
 > ppType :: Int -> Type -> Doc
 > ppType p (TypeConstructor tc tys)
->   | isQTupleId tc = parens (fsep (punctuate comma (map (ppType 0) tys)))
->   | tc == qListId = brackets (ppType 0 (head tys))
+>   | isQTupleId tc && length tys == qTupleArity tc = ppTuple (ppType 0) tys
+>   | tc == qListId && length tys == 1 = brackets (ppType 0 (head tys))
 >   | otherwise =
 >       ppParen (p > 1 && not (null tys))
 >               (ppQIdent tc <+> fsep (map (ppType 2) tys))
@@ -87,7 +90,8 @@
 
 > ppLiteral :: Literal -> Doc
 > ppLiteral (Char c) = text (show c)
-> ppLiteral (Int i) = int i
+> ppLiteral (Int i) = integer i
+> ppLiteral (Integer i) = integer i
 > ppLiteral (Float f) = double f
 
 > ppConstrTerm :: ConstrTerm -> Doc
@@ -95,7 +99,7 @@
 > ppConstrTerm (ConstructorPattern c [v1,v2])
 >   | isQInfixOp c = ppIdent v1 <+> ppQInfixOp c <+> ppIdent v2
 > ppConstrTerm (ConstructorPattern c vs)
->   | isQTupleId c = parens (fsep (punctuate comma (map ppIdent vs)))
+>   | isQTupleId c = ppTuple ppIdent vs
 >   | otherwise = ppQIdent c <+> fsep (map ppIdent vs)
 > ppConstrTerm (VariablePattern v) = ppIdent v
 
@@ -109,24 +113,29 @@
 >     Apply (Function f _) e | isQInfixOp f -> ppInfixApp p e f e2
 >     Apply (Constructor c _) e | isQInfixOp c -> ppInfixApp p e c e2
 >     _ -> ppParen (p > 2) (sep [ppExpr 2 e1,nest exprIndent (ppExpr 3 e2)])
-> ppExpr p (Case ev e alts) =
+> ppExpr p (Case ev e as) =
 >   ppParen (p > 0)
->           (text "case" <+> ppEval ev <+> ppExpr 0 e <+> text "of" $$
->            nest caseIndent (vcat (map ppAlt alts)))
->   where ppEval Rigid = text "rigid"
->         ppEval Flex = text "flex"
-> ppExpr p (Or e1 e2) =
->   ppParen (p > 0) (sep [ppExpr 1 e1,char '|' <+> ppExpr 0 e2])
-> ppExpr p (Exist v e) =
->   ppParen (p > 1)
->           (sep [text "let" <+> ppIdent v <+> text "free" <+> text "in",
->                 ppExpr 1 e])
-> ppExpr p (Let b e) =
->   ppParen (p > 1) (sep [text "let" <+> ppBinding b <+> text "in",ppExpr 1 e])
-> ppExpr p (Letrec bs e) =
->   ppParen (p > 1)
->           (sep [text "letrec" <+> vcat (map ppBinding bs) <+> text "in",
->                 ppExpr 1 e])
+>           (ppCase ev <+> ppExpr 0 e <+> text "of" $$
+>            nest caseIndent (vcat (map ppAlt as)))
+>   where ppCase Rigid = text "case"
+>         ppCase Flex = text "fcase"
+> ppExpr p (Choice es) =
+>   ppParen (p > 0)
+>           (sep (zipWith (<+>)
+>                         (empty : repeat (char '|'))
+>                         (map (ppExpr 1) es)))
+> ppExpr p (Exist vs e) =
+>   ppParen (p > 0)
+>           (sep [text "let" <+> ppIdentList vs <+> text "free" <+> text "in",
+>                 ppExpr 0 e])
+>   where ppIdentList = fsep . punctuate comma . map ppIdent
+> ppExpr p (Let rec bs e) =
+>   ppParen (p > 0)
+>           (sep [ppLet rec <+> vcat (map ppBinding bs) <+> text "in",
+>                 ppExpr 0 e])
+>   where ppLet NonRec = text "let"
+>         ppLet Rec = text "letrec"
+> ppExpr p (SrcLoc _ e) = ppExpr p e
 
 > ppInfixApp :: Int -> Expression -> QualIdent -> Expression -> Doc
 > ppInfixApp p e1 op e2 =
@@ -161,4 +170,7 @@
 > ppParen :: Bool -> Doc -> Doc
 > ppParen p = if p then parens else id
 
+> ppTuple :: (a -> Doc) -> [a] -> Doc
+> ppTuple f = parens . fsep . punctuate comma . map f
+
 \end{verbatim}
diff -u curry-0.9.11/ILTrans.lhs curry-0.9.11-classful/ILTrans.lhs
--- curry-0.9.11/ILTrans.lhs	2007-06-15 14:16:34.000000000 +0200
+++ curry-0.9.11-classful/ILTrans.lhs	2011-10-08 12:42:59.000000000 +0200
@@ -1,58 +1,64 @@
 % -*- LaTeX -*-
-% $Id: ILTrans.lhs 2146 2007-04-02 08:01:20Z wlux $
+% $Id: ILTrans.lhs 3057 2011-10-07 16:37:43Z wlux $
 %
-% Copyright (c) 1999-2007, Wolfgang Lux
+% Copyright (c) 1999-2011, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{ILTrans.lhs}
 \section{Translating Curry into the Intermediate Language}\label{sec:il-trans}
 After desugaring and lifting have been performed, the source code is
-translated into the intermediate language. Besides translating from
-source terms and expressions into intermediate language terms and
-expressions, this phase in particular implements the pattern matching
-algorithm for equations.
+translated into the intermediate language.
 
 Because of name conflicts between the source and intermediate language
 representations, we can only use a qualified import of the \texttt{IL}
 module.
 \begin{verbatim}
 
-> module ILTrans(ilTrans,ilTransIntf) where
+> module ILTrans(ilTrans) where
 > import Base
-> import qualified IL
+> import Curry
+> import CurryUtils
 > import Env
-> import Maybe
+> import qualified IL
 > import List
+> import Maybe
+> import PredefTypes
 > import Set
-> import TypeTrans
+> import TopEnv
+> import Types
+> import TypeInfo
 > import Utils
+> import ValueInfo
 
 \end{verbatim}
 \paragraph{Modules}
-At the top-level, the compiler has to translate data type, newtype,
-function, and foreign declarations. When translating data type and
-newtype declarations, we ignore the types in the declarations and
-lookup the types of the constructors in the type environment instead
-because these types are already fully expanded, i.e., they do not
-include any alias types. On the other hand, we introduce new type
-synonyms in place of newtype declarations (see Sect.~\ref{sec:IL}).
+At the top-level, the compiler has to translate data, type, function,
+and foreign declarations. When translating data type and type synonym
+declarations, we ignore the types in the declarations and look up the
+types of the constructors in the type (constructor) environment
+instead because these types are already fully expanded, i.e., they do
+not include any alias types.
 \begin{verbatim}
 
-> ilTrans :: ValueEnv -> Module -> IL.Module
-> ilTrans tyEnv (Module m _ _ ds) = IL.Module m (imports m ds') ds'
->   where ds' = concatMap (translTopDecl m tyEnv) ds
-
-> translTopDecl :: ModuleIdent -> ValueEnv -> TopDecl -> [IL.Decl]
-> translTopDecl m tyEnv (DataDecl _ tc tvs cs) = [translData m tyEnv tc tvs cs]
-> translTopDecl m tyEnv (NewtypeDecl _ tc tvs nc) =
->   translNewtype m tyEnv tc tvs nc
-> translTopDecl _ _ (TypeDecl _ _ _ _) = []
-> translTopDecl m tyEnv (BlockDecl d) = translDecl m tyEnv d
-
-> translDecl :: ModuleIdent -> ValueEnv -> Decl -> [IL.Decl]
-> translDecl m tyEnv (FunctionDecl _ f eqs) = [translFunction m tyEnv f eqs]
-> translDecl m tyEnv (ForeignDecl _ cc _ ie f _) =
->   [translForeign m tyEnv f cc (fromJust ie)]
+> ilTrans :: TCEnv -> ValueEnv -> Module Type -> IL.Module
+> ilTrans tcEnv tyEnv (Module m es _ ds) =
+>   IL.Module m (exports es) (imports m ds') ds'
+>   where ds' = concatMap (translTopDecl m tcEnv tyEnv) ds
+>         exports (Just (Exporting _ es)) =
+>           filter (isJust . localIdent m) (concatMap values es)
+>         values (Export x) = [x]
+>         values (ExportTypeWith tc cs) = map (qualifyLike tc) cs
+
+> translTopDecl :: ModuleIdent -> TCEnv -> ValueEnv -> TopDecl Type -> [IL.Decl]
+> translTopDecl m _ tyEnv (DataDecl _ _ tc tvs cs _) =
+>   [translData m tyEnv tc tvs cs]
+> translTopDecl m tcEnv _ (TypeDecl _ tc _ _) = [translAlias m tcEnv tc]
+> translTopDecl m _ tyEnv (BlockDecl d) = translDecl m tyEnv d
+
+> translDecl :: ModuleIdent -> ValueEnv -> Decl Type -> [IL.Decl]
+> translDecl m tyEnv (FunctionDecl _ ty _ eqs) =
+>   map (translFunction m tyEnv ty) eqs
+> translDecl m _ (ForeignDecl _ fi ty f _) = [translForeign m f fi ty]
 > translDecl _ _ _ = []
 
 > translData :: ModuleIdent -> ValueEnv -> Ident -> [Ident] -> [ConstrDecl]
@@ -61,308 +67,159 @@
 >   IL.DataDecl (qualifyWith m tc) (length tvs)
 >               (map (translConstrDecl m tyEnv) cs)
 
-> translNewtype :: ModuleIdent -> ValueEnv -> Ident -> [Ident] -> NewConstrDecl
->               -> [IL.Decl]
-> translNewtype m tyEnv tc tvs nc =
->   [IL.TypeDecl (qualifyWith m tc) (length tvs) (translType (argType ty)),
->    IL.FunctionDecl f [v] (translType ty) (IL.Variable v)]
->   where f = qualifyWith m (nconstr nc)
->         v = head (argNames (mkIdent ""))
->         ty = rawType (conType f tyEnv)
->         argType (TypeArrow ty _) = ty
+> translAlias :: ModuleIdent -> TCEnv -> Ident -> IL.Decl
+> translAlias m tcEnv tc = IL.TypeDecl tc' n (translType ty)
+>   where [AliasType tc' n _ ty] = qualLookupTopEnv (qualifyWith m tc) tcEnv
 
 > translConstrDecl :: ModuleIdent -> ValueEnv -> ConstrDecl -> IL.ConstrDecl
-> translConstrDecl m tyEnv d =
->   IL.ConstrDecl c (map translType (arrowArgs (rawType (conType c tyEnv))))
+> translConstrDecl m tyEnv d = IL.ConstrDecl c (map translType (arrowArgs ty))
 >   where c = qualifyWith m (constr d)
+>         ty = rawType (thd3 (conType c tyEnv))
 
-> translForeign :: ModuleIdent -> ValueEnv -> Ident -> CallConv -> String
->               -> IL.Decl
-> translForeign m tyEnv f cc ie =
->   IL.ForeignDecl (qualifyWith m f) (callConv cc) ie
->                  (translType (rawType (varType f tyEnv)))
+> translForeign :: ModuleIdent -> Ident -> ForeignImport -> Type -> IL.Decl
+> translForeign m f (cc,_,ie) ty =
+>   IL.ForeignDecl (qualifyWith m f) (callConv cc) (fromJust ie) (translType ty)
 >   where callConv CallConvPrimitive = IL.Primitive
 >         callConv CallConvCCall = IL.CCall
 >         callConv CallConvRawCall = IL.RawCall
 
 \end{verbatim}
-\paragraph{Interfaces}
-In order to generate code, the compiler also needs to know the tags
-and arities of all imported data constructors. For that reason, we
-compile the data type declarations of all interfaces into the
-intermediate language, too. In this case we do not lookup the
-types in the environment because the types in the interfaces are
-already fully expanded. Note that we do not translate data types
-which are imported into the interface from another module.
-\begin{verbatim}
-
-> ilTransIntf :: Interface -> [IL.Decl]
-> ilTransIntf (Interface m _ ds) = foldr (translIntfDecl m) [] ds
-
-> translIntfDecl :: ModuleIdent -> IDecl -> [IL.Decl] -> [IL.Decl]
-> translIntfDecl m (IDataDecl _ tc tvs cs) ds
->   | not (isQualified tc) = translIntfData m (unqualify tc) tvs cs : ds
-> translIntfDecl _ _ ds = ds
-
-> translIntfData :: ModuleIdent -> Ident -> [Ident] -> [Maybe ConstrDecl]
->                -> IL.Decl
-> translIntfData m tc tvs cs =
->   IL.DataDecl (qualifyWith m tc) (length tvs)
->               (map (maybe hiddenConstr (translIntfConstrDecl m tvs)) cs)
->   where hiddenConstr = IL.ConstrDecl qAnonId []
->         qAnonId = qualify anonId
-
-> translIntfConstrDecl :: ModuleIdent -> [Ident] -> ConstrDecl -> IL.ConstrDecl
-> translIntfConstrDecl m tvs (ConstrDecl _ _ c tys) =
->   IL.ConstrDecl (qualifyWith m c) (map translType (toTypes m tvs tys))
-> translIntfConstrDecl m tvs (ConOpDecl _ _ ty1 op ty2) =
->   IL.ConstrDecl (qualifyWith m op) (map translType (toTypes m tvs [ty1,ty2]))
-
-\end{verbatim}
 \paragraph{Types}
-The type representation in the intermediate language is the same as
-the internal representation except that it does not support
-constrained type variables and skolem types. The former are fixed and
-the latter are replaced by fresh type constructors.
+In contrast to the internal type representation, the intermediate
+language does not support types with higher order kinds. The type
+transformation therefore has to transform all types to first order
+terms. To that end, we assume the existence of a type synonym
+\texttt{type @ f a = f a}. In addition, the type representation of the
+intermediate language does not support constrained type variables and
+skolem types. The former are fixed and the latter are replaced by
+fresh type constructors.
 \begin{verbatim}
 
 > translType :: Type -> IL.Type
-> translType (TypeConstructor tc tys) =
->   IL.TypeConstructor tc (map translType tys)
-> translType (TypeVariable tv) = IL.TypeVariable tv
-> translType (TypeConstrained tys _) = translType (head tys)
-> translType (TypeArrow ty1 ty2) =
->   IL.TypeArrow (translType ty1) (translType ty2)
-> translType (TypeSkolem k) =
->   IL.TypeConstructor (qualify (mkIdent ("_" ++ show k))) []
+> translType ty = fromType ty []
+>   where fromType (TypeConstructor tc) = IL.TypeConstructor tc
+>         fromType (TypeVariable tv) = foldl appType (IL.TypeVariable tv)
+>         fromType (TypeConstrained tys _) = fromType (head tys)
+>         fromType (TypeSkolem k) =
+>           foldl appType
+>                 (IL.TypeConstructor (qualify (mkIdent ("_" ++ show k))) [])
+>         fromType (TypeApply ty1 ty2) = fromType ty1 . (translType ty2 :)
+>         fromType (TypeArrow ty1 ty2) =
+>           foldl appType (IL.TypeArrow (translType ty1) (translType ty2))
+>         appType ty1 ty2 = IL.TypeConstructor (qualify (mkIdent "@")) [ty1,ty2]
 
 \end{verbatim}
 \paragraph{Functions}
 Every function in the program is translated into a function of the
-intermediate language. The arguments of the function are renamed such
-that all variables occurring in the same position (in different
-equations) have the same name. This is necessary in order to
-facilitate the translation of pattern matching into \texttt{case}
-expressions. We use the following simple convention here: The
-outermost arguments of the function are named \texttt{\_1},
-\texttt{\_2}, and so on from left to right. The names of inner
-arguments are constructed by appending \texttt{\_1}, \texttt{\_2},
-etc. from left to right to the name that would be assigned to a
-variable occurring at the position of the constructor term.
-
-Some special care is needed for the selector functions introduced by
-the compiler in place of pattern bindings. In order to generate the
-code for updating all pattern variables, the equality of names between
-the pattern variables in the first argument of the selector function
-and their repeated occurrences in the remaining arguments must be
-preserved. This means that the second and following arguments of a
-selector function have to be renamed according to the name mapping
-computed for its first argument.
+intermediate language. Recall that every function has only a single
+equation and all arguments are variables at this point.
 \begin{verbatim}
 
-> type RenameEnv = Env Ident Ident
-
-> translFunction :: ModuleIdent -> ValueEnv -> Ident -> [Equation] -> IL.Decl
-> translFunction m tyEnv f eqs =
+> translFunction :: ModuleIdent -> ValueEnv -> Type -> Equation Type -> IL.Decl
+> translFunction m tyEnv ty (Equation _ (FunLhs f ts) rhs) =
 >   IL.FunctionDecl (qualifyWith m f) vs (translType ty)
->                   (match IL.Flex vs (map (translEquation tyEnv vs vs'') eqs))
->   where ty = rawType (varType f tyEnv)
->         vs = if isSelectorId f then translArgs eqs vs' else vs'
->         (vs',vs'') = splitAt (arity eqs) (argNames (mkIdent ""))
->         arity (Equation _ (FunLhs _ ts) _ : _) = length ts
-
-> translArgs :: [Equation] -> [Ident] -> [Ident]
-> translArgs [Equation _ (FunLhs _ (t:ts)) _] (v:_) =
->   v : map (translArg (bindRenameEnv v t emptyEnv)) ts
->   where translArg env (VariablePattern v) = fromJust (lookupEnv v env)
-
-> translEquation :: ValueEnv -> [Ident] -> [Ident] -> Equation
->                -> ([NestedTerm],IL.Expression)
-> translEquation tyEnv vs vs' (Equation _ (FunLhs _ ts) rhs) =
->   (zipWith translTerm vs ts,
->    translRhs tyEnv vs' (foldr2 bindRenameEnv emptyEnv vs ts) rhs)
+>                   (translRhs tyEnv vs rhs)
+>   where vs = [v | VariablePattern _ v <- ts]
 
-> translRhs :: ValueEnv -> [Ident] -> RenameEnv -> Rhs -> IL.Expression
-> translRhs tyEnv vs env (SimpleRhs _ e _) = translExpr tyEnv vs env e
+> translRhs :: ValueEnv -> [Ident] -> Rhs Type -> IL.Expression
+> translRhs tyEnv vs (SimpleRhs p e _) =
+>   IL.SrcLoc (show p) (translExpr tyEnv vs e)
 
 \end{verbatim}
-\paragraph{Pattern Matching}
-The pattern matching code searches for the left-most inductive
-argument position in the left hand sides of all rules defining an
-equation. An inductive position is a position where all rules have a
-constructor rooted term. If such a position is found, a \texttt{case}
-expression is generated for the argument at that position. The
-matching code is then computed recursively for all of the alternatives
-independently. If no inductive position is found, the algorithm looks
-for the left-most demanded argument position, i.e., a position where
-at least one of the rules has a constructor rooted term. If such a
-position is found, an \texttt{or} expression is generated with those
-cases that have a variable at the argument position in one branch and
-all other rules in the other branch. If there is no demanded position,
-the pattern matching is finished and the compiler translates the right
-hand sides of the remaining rules, eventually combining them using
-\texttt{or} expressions.
-
-Actually, the algorithm below combines the search for inductive and
-demanded positions. The function \texttt{match} scans the argument
-lists for the left-most demanded position. If this turns out to be
-also an inductive position, the function \texttt{matchInductive} is
-called in order to generate a \texttt{case} expression. Otherwise, the
-function \texttt{optMatch} is called that tries to find an inductive
-position in the remaining arguments. If one is found,
-\texttt{matchInductive} is called, otherwise the function
-\texttt{optMatch} uses the demanded argument position found by
-\texttt{match}.
+\paragraph{Patterns}
+Since pattern matching has been transformed already, patterns can be
+translated almost directly into the intermediate language. The only
+complication arises from as-patterns, which are not supported in the
+intermediate language. Therefore, we return the respective variables
+along with the transformed patterns.
 \begin{verbatim}
 
-> data NestedTerm = NestedTerm IL.ConstrTerm [NestedTerm] deriving Show
-
-> pattern (NestedTerm t _) = t
-> arguments (NestedTerm _ ts) = ts
-
-> translLiteral :: Literal -> IL.Literal
-> translLiteral (Char c) = IL.Char c
-> translLiteral (Int _ i) = IL.Int i
-> translLiteral (Float f) = IL.Float f
-> translLiteral _ = internalError "translLiteral"
-
-> translTerm :: Ident -> ConstrTerm -> NestedTerm
-> translTerm _ (LiteralPattern l) =
->   NestedTerm (IL.LiteralPattern (translLiteral l)) []
-> translTerm v (VariablePattern _) = NestedTerm (IL.VariablePattern v) []
-> translTerm v (ConstructorPattern c ts) =
->   NestedTerm (IL.ConstructorPattern c (zipWith const vs ts))
->              (zipWith translTerm vs ts)
->   where vs = argNames v
-> translTerm v (AsPattern _ t) = translTerm v t
-> translTerm _ _ = internalError "translTerm"
-
-> bindRenameEnv :: Ident -> ConstrTerm -> RenameEnv -> RenameEnv
-> bindRenameEnv _ (LiteralPattern _) env = env
-> bindRenameEnv v (VariablePattern v') env = bindEnv v' v env
-> bindRenameEnv v (ConstructorPattern _ ts) env =
->   foldr2 bindRenameEnv env (argNames v) ts
-> bindRenameEnv v (AsPattern v' t) env = bindEnv v' v (bindRenameEnv v t env)
-> bindRenameEnv _ _ env = internalError "bindRenameEnv"
-
-> argNames :: Ident -> [Ident]
-> argNames v = [mkIdent (prefix ++ show i) | i <- [1..]]
->   where prefix = name v ++ "_"
-
-> type Match = ([NestedTerm],IL.Expression)
-> type Match' = ([NestedTerm] -> [NestedTerm],[NestedTerm],IL.Expression)
-
-> isDefaultPattern :: IL.ConstrTerm -> Bool
-> isDefaultPattern (IL.VariablePattern _) = True
-> isDefaultPattern _ = False
-
-> isDefaultMatch :: (IL.ConstrTerm,a) -> Bool
-> isDefaultMatch = isDefaultPattern . fst
-
-> match :: IL.Eval -> [Ident] -> [Match] -> IL.Expression
-> match _  []     alts = foldl1 IL.Or (map snd alts)
-> match ev (v:vs) alts
->   | null vars = e1
->   | null nonVars = e2
->   | otherwise = optMatch ev (IL.Or e1 e2) (v:) vs (map skipArg alts)
->   where (vars,nonVars) = partition isDefaultMatch (map tagAlt alts)
->         e1 = matchInductive ev id v vs nonVars
->         e2 = match ev vs (map snd vars)
->         tagAlt (t:ts,e) = (pattern t,(arguments t ++ ts,e))
->         skipArg (t:ts,e) = ((t:),ts,e)
-
-> optMatch :: IL.Eval -> IL.Expression -> ([Ident] -> [Ident]) -> [Ident]
->          -> [Match'] -> IL.Expression
-> optMatch _  e _      []     _ = e
-> optMatch ev e prefix (v:vs) alts
->   | null vars = matchInductive ev prefix v vs nonVars
->   | otherwise = optMatch ev e (prefix . (v:)) vs (map skipArg alts)
->   where (vars,nonVars) = partition isDefaultMatch (map tagAlt alts)
->         tagAlt (prefix,t:ts,e) = (pattern t,(prefix (arguments t ++ ts),e))
->         skipArg (prefix,t:ts,e) = (prefix . (t:),ts,e)
-
-> matchInductive :: IL.Eval -> ([Ident] -> [Ident]) -> Ident -> [Ident]
->                -> [(IL.ConstrTerm,Match)] -> IL.Expression
-> matchInductive ev prefix v vs alts =
->   IL.Case ev (IL.Variable v) (matchAlts ev prefix vs alts)
-
-> matchAlts :: IL.Eval -> ([Ident] -> [Ident]) -> [Ident]
->           -> [(IL.ConstrTerm,Match)] -> [IL.Alt]
-> matchAlts _  _      _  [] = []
-> matchAlts ev prefix vs ((t,alt):alts) =
->   IL.Alt t (match ev (prefix (vars t ++ vs)) (alt : map snd same)) :
->   matchAlts ev prefix vs others
->   where (same,others) = partition ((t ==) . fst) alts 
->         vars (IL.ConstructorPattern _ vs) = vs
->         vars _ = []
+> translLiteral :: Type -> Literal -> IL.Literal
+> translLiteral _ (Char c) = IL.Char c
+> translLiteral ty (Integer i) = translInt ty i
+>   where translInt (TypeConstrained tys _) = translInt (head tys)
+>         translInt ty
+>           | ty == intType = IL.Int
+>           | ty == integerType = IL.Integer
+>           | otherwise = internalError ("translLiteral(Integer): " ++ show ty)
+> translLiteral ty (Rational r) = translRat ty r
+>   where translRat (TypeConstrained tys _) = translRat (head tys)
+>         translRat ty
+>           | ty == floatType = IL.Float . fromRational
+>           | otherwise = internalError ("translLiteral(Rational): " ++ show ty)
+
+> translTerm :: ConstrTerm Type -> ([Ident],IL.ConstrTerm)
+> translTerm (LiteralPattern ty l) = ([],IL.LiteralPattern (translLiteral ty l))
+> translTerm (VariablePattern _ v) = ([],IL.VariablePattern v)
+> translTerm (ConstructorPattern _ c ts) =
+>   ([],IL.ConstructorPattern c [v | VariablePattern _ v <- ts])
+> translTerm (AsPattern v t) = (v:vs,t')
+>   where (vs,t') = translTerm t
 
 \end{verbatim}
-Note that pattern matching in case expressions has been performed in
-the \texttt{Desugar} module already, where case expressions with
-nested patterns were transformed into nested case expressions with
-flat patterns.
-
 \paragraph{Expressions}
-The translation of expressions from desugared Curry source code into
-the intermediate language is very straight forward. A minor
-complication arises for the translation of as-patterns, which are not
-supported in the intermediate language. They are transformed into an
-outer, flexible case expression that evaluates the scrutinized
-expression and binds the as-pattern variable,\footnote{Recall that
-  case expressions in the intermediate language always evaluate the
-  scrutinized expression.} and an inner case expression that matches
-this variable against the actual pattern. We always use a flexible
-match for the outer case expression because the compiler would
-generate a redundant switch statement during the translation of the
-intermediate language into abstract machine code otherwise.
-
-We also replace applications of newtype constructors by their
-arguments. This transformation was performed already during
-desugaring, but $\eta$-expansion and optimization may introduce
-further possibilities to apply this transformation.
+The translation of expressions from lifted Curry source code into the
+intermediate language is also almost straightforward. The only
+exception are case expressions with alternatives using as-patterns.
+Such expressions are transformed into an outer, flexible case
+expression that evaluates the scrutinized expression and binds the
+as-pattern variable,\footnote{Recall that case expressions in the
+intermediate language always evaluate the scrutinized expression.}
+and an inner case expression that matches this variable against the
+actual pattern. We always use a flexible match for the outer case
+expression because the compiler would generate a redundant switch
+statement during the translation of the intermediate language into
+abstract machine code otherwise.
 \begin{verbatim}
 
-> translExpr :: ValueEnv -> [Ident] -> RenameEnv -> Expression -> IL.Expression
-> translExpr _ _ _ (Literal l) = IL.Literal (translLiteral l)
-> translExpr tyEnv _ env (Variable v) =
->   case lookupVar v env of
->     Just v' -> IL.Variable v'
->     Nothing -> IL.Function v (arity v tyEnv)
->   where lookupVar v env
->           | isQualified v = Nothing
->           | otherwise = lookupEnv (unqualify v) env
-> translExpr tyEnv _ _ (Constructor c)
->   | isNewtypeConstr tyEnv c = IL.Function c 1
->   | otherwise = IL.Constructor c (arity c tyEnv)
-> translExpr tyEnv vs env (Apply e1 e2) =
->   case e1 of
->     Constructor c | isNewtypeConstr tyEnv c -> translExpr tyEnv vs env e2
->     _ -> IL.Apply (translExpr tyEnv vs env e1) (translExpr tyEnv vs env e2)
-> translExpr tyEnv vs env (Let ds e) =
+> translExpr :: ValueEnv -> [Ident] -> Expression Type -> IL.Expression
+> translExpr _ _ (Literal ty l) = IL.Literal (translLiteral ty l)
+> translExpr tyEnv vs (Variable _ v)
+>   | not (isQualified v) && v' `elem` vs = IL.Variable v'
+>   | otherwise = IL.Function v (arity v tyEnv)
+>   where v' = unqualify v
+> translExpr tyEnv _ (Constructor _ c) = IL.Constructor c (arity c tyEnv)
+> translExpr tyEnv vs (Apply e1 e2) =
+>   IL.Apply (translExpr tyEnv vs e1) (translExpr tyEnv vs e2)
+> translExpr tyEnv vs (Let ds e) =
 >   case ds of
->     [FreeDecl _ vs] -> foldr IL.Exist e' vs
->     [d] | all (`notElem` bv d) (qfv (mkMIdent []) d) ->
->       IL.Let (translBinding env' d) e'
->     _ -> IL.Letrec (map (translBinding env') ds) e'
->   where e' = translExpr tyEnv vs env' e
->         env' = foldr2 bindEnv env bvs bvs
->         bvs = bv ds
->         translBinding env (PatternDecl _ (VariablePattern v) rhs) =
->           IL.Binding v (translRhs tyEnv vs env rhs)
-> translExpr tyEnv (v:vs) env (Case e alts) =
->   caseExpr (translExpr tyEnv vs env e) (map (translAlt tyEnv vs env v) alts)
->   where caseExpr e alts
->           | v `elem` fv alts =
->               IL.Case IL.Flex e
->                       [IL.Alt (IL.VariablePattern v)
->                               (IL.Case IL.Rigid (IL.Variable v) alts)]
->           | otherwise = IL.Case IL.Rigid e alts
-> translExpr _ _ _ _ = internalError "translExpr"
-
-> translAlt :: ValueEnv -> [Ident] -> RenameEnv -> Ident -> Alt -> IL.Alt
-> translAlt tyEnv vs env v (Alt _ t rhs) =
->   IL.Alt (pattern (translTerm v t))
->          (translRhs tyEnv vs (bindRenameEnv v t env) rhs)
+>     [FreeDecl _ vs'] -> IL.Exist (bv vs') e'
+>     [d] -> IL.Let (rec d) [translBinding vs' d] e'
+>     _ -> IL.Let IL.Rec (map (translBinding vs') ds) e'
+>   where e' = translExpr tyEnv vs' e
+>         vs' = vs ++ bv ds
+>         translBinding vs (PatternDecl _ (VariablePattern _ v) rhs) =
+>           IL.Binding v (translRhs tyEnv vs rhs)
+>         rec d
+>           | any (`elem` bv d) (qfv (mkMIdent []) d) = IL.Rec
+>           | otherwise = IL.NonRec
+> translExpr tyEnv vs (Case e as) =
+>   caseExpr IL.Rigid (translExpr tyEnv vs e) (nub (concat vss')) as'
+>   where (vss',as') = unzip (map (translAlt tyEnv vs) as)
+> translExpr tyEnv vs (Fcase e as) =
+>   case e of
+>     Let [FreeDecl _ [FreeVar _ v]] (Variable _ v')
+>       | qualify v == v' && all isChoice as ->
+>           IL.Choice [translRhs tyEnv vs rhs | Alt _ _ rhs <- as]
+>     _ -> caseExpr IL.Flex (translExpr tyEnv vs e) (nub (concat vss')) as'
+>   where (vss',as') = unzip (map (translAlt tyEnv vs) as)
+>         isChoice (Alt _ t rhs) = all (`notElem` qfv (mkMIdent []) rhs) (bv t)
+
+> translAlt :: ValueEnv -> [Ident] -> Alt Type -> ([Ident],IL.Alt)
+> translAlt tyEnv vs (Alt _ t rhs) = (filter (`elem` fv e') vs',IL.Alt t' e')
+>   where (vs',t') = translTerm t
+>         e' = translRhs tyEnv (vs ++ bv t) rhs
+
+> caseExpr :: IL.Eval -> IL.Expression -> [Ident] -> [IL.Alt] -> IL.Expression
+> caseExpr ev e vs as =
+>   case (e,vs) of
+>     (IL.Variable v,_) -> match ev v (filter (v /=) vs) as
+>     (_,[]) -> IL.Case ev e as
+>     (_,v:vs) ->
+>       IL.Case IL.Flex e [IL.Alt (IL.VariablePattern v) (match ev v vs as)]
+>   where match ev v vs as =
+>           IL.Let IL.NonRec [IL.Binding v' e | v' <- vs] (IL.Case ev e as)
+>           where e = IL.Variable v
 
 > instance QuantExpr IL.ConstrTerm where
 >   bv (IL.LiteralPattern _) = []
@@ -375,12 +232,15 @@
 >   fv (IL.Function _ _) = []
 >   fv (IL.Constructor _ _) = []
 >   fv (IL.Apply e1 e2) = fv e1 ++ fv e2
->   fv (IL.Case _ e alts) = fv e ++ fv alts
->   fv (IL.Or e1 e2) = fv e1 ++ fv e2
->   fv (IL.Exist v e) = filter (/= v) (fv e)
->   fv (IL.Let (IL.Binding v e1) e2) = fv e1 ++ filter (/= v) (fv e2)
->   fv (IL.Letrec bds e) = filter (`notElem` vs) (fv es ++ fv e)
->     where (vs,es) = unzip [(v,e) | IL.Binding v e <- bds]
+>   fv (IL.Case _ e as) = fv e ++ fv as
+>   fv (IL.Choice es) = fv es
+>   fv (IL.Exist vs e) = filter (`notElem` vs) (fv e)
+>   fv (IL.Let rec bs e) =
+>     fvBinds rec vs (fv es) ++ filter (`notElem` vs) (fv e)
+>     where (vs,es) = unzip [(v,e) | IL.Binding v e <- bs]
+>           fvBinds IL.NonRec _ = id
+>           fvBinds IL.Rec vs = filter (`notElem` vs)
+>   fv (IL.SrcLoc _ e) = fv e
 
 > instance Expr IL.Alt where
 >   fv (IL.Alt t e) = filterBv t (fv e)
@@ -427,10 +287,10 @@
 >   modules (IL.Constructor c _) = modules c
 >   modules (IL.Apply e1 e2) = modules e1 . modules e2
 >   modules (IL.Case _ e as) = modules e . modules as
->   modules (IL.Or e1 e2) = modules e1 . modules e2
+>   modules (IL.Choice es) = modules es
 >   modules (IL.Exist _ e) = modules e
->   modules (IL.Let b e) = modules b . modules e
->   modules (IL.Letrec bs e) = modules bs . modules e
+>   modules (IL.Let _ bs e) = modules bs . modules e
+>   modules (IL.SrcLoc _ e) = modules e
 
 > instance HasModule IL.Alt where
 >   modules (IL.Alt t e) = modules t . modules e
diff -u curry-0.9.11/Imports.lhs curry-0.9.11-classful/Imports.lhs
--- curry-0.9.11/Imports.lhs	2007-06-15 14:16:34.000000000 +0200
+++ curry-0.9.11-classful/Imports.lhs	2009-08-25 10:02:57.000000000 +0200
@@ -1,7 +1,7 @@
 % -*- LaTeX -*-
-% $Id: Imports.lhs 2148 2007-04-02 13:56:20Z wlux $
+% $Id: Imports.lhs 2899 2009-08-24 09:52:45Z wlux $
 %
-% Copyright (c) 2000-2007, Wolfgang Lux
+% Copyright (c) 2000-2009, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{Imports.lhs}
@@ -10,15 +10,27 @@
 interfaces into the current module.
 \begin{verbatim}
 
-> module Imports(importInterface,importInterfaceIntf,importUnifyData) where
+> module Imports(importIdents,importInterface,importInterfaceIntf,
+>                importUnifyData) where
 > import Base
-> import Maybe
+> import Curry
+> import CurryUtils
+> import Env
+> import IdentInfo
+> import InstInfo
+> import Kinds
+> import KindTrans
+> import List
 > import Map
+> import Maybe
+> import PrecInfo
+> import PredefIdent
 > import Set
 > import TopEnv
+> import Types
+> import TypeInfo
 > import TypeTrans
-
-> type I a = (Ident,a)
+> import ValueInfo
 
 \end{verbatim}
 When an interface is imported into a module, the compiler must respect
@@ -27,27 +39,30 @@
 the specification or not hidden by it, respectively, are added to the
 global environments. If the qualified flag is present, only a
 qualified import is performed. Otherwise, both a qualified and an
-unqualified import are performed.
+unqualified import are performed. Regardless of the type of import,
+all instance declarations are always imported into the current module.
 \begin{verbatim}
 
-> importInterface :: ModuleIdent -> Bool -> Maybe ImportSpec
->                 -> (PEnv,TCEnv,ValueEnv) -> Interface
->                 -> (PEnv,TCEnv,ValueEnv)
-> importInterface m q is (pEnv,tcEnv,tyEnv) (Interface m' _ ds) =
->   (importEntities precs m q vs id m' ds' pEnv,
->    importEntities types m q ts (importData vs) m' ds' tcEnv,
->    importEntities values m q vs id m' ds' tyEnv)
->   where ds' = filter (not . isHiddenData) ds
->         ts = isVisible addType is
+> importIdents :: ModuleIdent -> Bool -> Maybe ImportSpec
+>              -> (TypeEnv,InstSet,FunEnv) -> Interface
+>              -> (TypeEnv,InstSet,FunEnv)
+> importIdents m q is (tEnv,iSet,vEnv) (Interface _ _ ds) =
+>   (importEntities tidents m q ts (importMembers vs) ds tEnv,
+>    importCTs ds iSet,
+>    importEntities vidents m q vs id ds vEnv)
+>   where ts = isVisible addType is
 >         vs = isVisible addValue is
 
-> isHiddenData :: IDecl -> Bool
-> isHiddenData (IInfixDecl _ _ _ _) = False
-> isHiddenData (HidingDataDecl _ _ _) = True 
-> isHiddenData (IDataDecl _ _ _ _) = False
-> isHiddenData (INewtypeDecl _ _ _ _) = False
-> isHiddenData (ITypeDecl _ _ _ _) = False
-> isHiddenData (IFunctionDecl _ _ _ _) = False
+> importInterface :: ModuleIdent -> Bool -> Maybe ImportSpec
+>                 -> (PEnv,TCEnv,InstEnv,ValueEnv) -> Interface
+>                 -> (PEnv,TCEnv,InstEnv,ValueEnv)
+> importInterface m q is (pEnv,tcEnv,iEnv,tyEnv) (Interface _ _ ds) =
+>   (importEntities precs m q vs id ds pEnv,
+>    importEntities types m q ts id ds tcEnv,
+>    importInstances ds iEnv,
+>    importEntities values m q vs id ds tyEnv)
+>   where ts = isVisible addType is
+>         vs = isVisible addValue is
 
 > isVisible :: (Import -> Set Ident -> Set Ident) -> Maybe ImportSpec
 >           -> Ident -> Bool
@@ -55,124 +70,165 @@
 > isVisible add (Just (Hiding _ xs)) = (`notElemSet` foldr add zeroSet xs)
 > isVisible _ Nothing = const True
 
-> importEntities :: Entity a
->                => (ModuleIdent -> IDecl -> [I a] -> [I a])
->                -> ModuleIdent -> Bool -> (Ident -> Bool) -> (a -> a)
->                -> ModuleIdent -> [IDecl] -> TopEnv a -> TopEnv a
-> importEntities bind m q isVisible f m' ds env =
+> importEntities :: Entity a => (IDecl -> [a]) -> ModuleIdent -> Bool
+>                -> (Ident -> Bool) -> (a -> a) -> [IDecl]
+>                -> TopEnv a -> TopEnv a
+> importEntities ents m q isVisible f ds env =
 >   foldr (uncurry (importTopEnv q m)) env
->         [(x,f y) | (x,y) <- foldr (bind m') [] ds, isVisible x]
+>         [(x,f y) | y <- concatMap ents ds,
+>                    let x = unqualify (origName y), isVisible x]
 
-> importData :: (Ident -> Bool) -> TypeInfo -> TypeInfo
-> importData isVisible (DataType tc n cs) =
->   DataType tc n (map (>>= importConstr isVisible) cs)
-> importData isVisible (RenamingType tc n nc) =
->   maybe (DataType tc n []) (RenamingType tc n) (importConstr isVisible nc)
-> importData isVisible (AliasType tc n ty) = AliasType tc n ty
+> importMembers :: (Ident -> Bool) -> TypeKind -> TypeKind
+> importMembers isVisible (Data tc xs) = Data tc (filter isVisible xs)
+> importMembers _ (Alias tc) = Alias tc
+> importMembers isVisible (Class cls fs) = Class cls (filter isVisible fs)
 
-> importConstr :: (Ident -> Bool) -> Ident -> Maybe Ident
-> importConstr isVisible c
+> importMember :: (Ident -> Bool) -> Ident -> Maybe Ident
+> importMember isVisible c
 >   | isVisible c = Just c
 >   | otherwise = Nothing
 
+> importCTs :: [IDecl] -> InstSet -> InstSet
+> importCTs ds iEnv = foldr addCT iEnv ds
+
+> addCT :: IDecl -> InstSet -> InstSet
+> addCT (IInstanceDecl _ _ cls ty _ _) = addToSet (CT cls (typeConstr ty))
+> addCT _ = id
+
+> importInstances :: [IDecl] -> InstEnv -> InstEnv
+> importInstances ds iEnv = foldr bindInstance iEnv ds
+
+> bindInstance :: IDecl -> InstEnv -> InstEnv
+> bindInstance (IInstanceDecl _ cx cls ty (Just m) fs) =
+>   bindEnv (CT cls (rootOfType ty')) (m,cx',fs')
+>   where QualType cx' ty' = toQualType (QualTypeExpr cx ty)
+>         fs' = [(f,fromInteger n) | (f,n) <- fs]
+> bindInstance _ = id
+
 \end{verbatim}
 Importing an interface into another interface is somewhat simpler
-because all entities are imported into the environments. In addition,
-only a qualified import is necessary. Only those entities that are
-actually defined in the module are imported. Since the compiler
-imports all used interfaces into other interfaces, entities defined in
-one module and re-exported by another module are made available by
-their defining modules. Furthermore, ignoring re-exported entities
-avoids a problem with the fact that the unqualified names of entities
-defined in an interface may be ambiguous if hidden data type
-declarations are taken into account. For instance, in the interface
-\begin{verbatim}
-  module M where {
-    import N;
-    hiding data N.T;
-    type T a = (a,N.T)
-  }
-\end{verbatim}
-the unqualified type identifier \verb|T| would be ambiguous if
-\verb|N.T| were not ignored.
-\begin{verbatim}
-
-> importInterfaceIntf :: (PEnv,TCEnv,ValueEnv) -> Interface
->                     -> (PEnv,TCEnv,ValueEnv)
-> importInterfaceIntf (pEnv,tcEnv,tyEnv) (Interface m _ ds) =
->   (importEntitiesIntf precs m ds' pEnv,
->    importEntitiesIntf types m ds' tcEnv,
->    importEntitiesIntf values m ds' tyEnv)
->   where ds' = filter (isJust . localIdent m . entity) ds
-
-> entity :: IDecl -> QualIdent
-> entity (IInfixDecl _ _ _ op) = op
-> entity (HidingDataDecl _ tc _) = tc
-> entity (IDataDecl _ tc _ _) = tc
-> entity (INewtypeDecl _ tc _ _) = tc
-> entity (ITypeDecl _ tc _ _) = tc
-> entity (IFunctionDecl _ f _ _) = f
-
-> importEntitiesIntf :: Entity a
->                    => (ModuleIdent -> IDecl -> [I a] -> [I a])
->                    -> ModuleIdent -> [IDecl] -> TopEnv a -> TopEnv a
-> importEntitiesIntf bind m ds env =
->   foldr (uncurry (qualImportTopEnv m)) env (foldr (bind m) [] ds)
+because only a qualified import is necessary and there are no import
+restrictions. Besides entities defined in the interface's module, we
+must also import entities that are reexported from other modules
+provided that the compiler did not load the respective interfaces.
+
+Note that the first argument of \texttt{importInterfaceIntf} is the
+list of names of the modules whose interfaces have been read by the
+compiler. Obviously, this must include the current interface's module
+name.
+\begin{verbatim}
+
+> importInterfaceIntf :: [ModuleIdent] -> (PEnv,TCEnv,InstEnv,ValueEnv)
+>                     -> Interface -> (PEnv,TCEnv,InstEnv,ValueEnv)
+> importInterfaceIntf ms (pEnv,tcEnv,iEnv,tyEnv) (Interface m is ds) =
+>   (importEntitiesIntf precs ds' pEnv,
+>    importEntitiesIntf types ds' tcEnv,
+>    importInstances ds' iEnv,
+>    importEntitiesIntf values ds' tyEnv)
+>   where ms' = m : [m | IImportDecl _ m <- is, m `notElem` ms]
+>         ds' = map unhide (filter (importEntity . entity) ds)
+>         importEntity = maybe True (`elem` ms') . fst . splitQualIdent
+
+> importEntitiesIntf :: Entity a => (IDecl -> [a]) -> [IDecl]
+>                    -> TopEnv a -> TopEnv a
+> importEntitiesIntf ents ds env = foldr importEntity env (concatMap ents ds)
+>   where importEntity x = qualImportTopEnv (origName x) x
 
 \end{verbatim}
 The list of entities exported from a module is computed with the
 following functions.
 \begin{verbatim}
 
-> precs :: ModuleIdent -> IDecl -> [I PrecInfo] -> [I PrecInfo]
-> precs m (IInfixDecl _ fix p op) =
->   qual op (PrecInfo (qualQualify m op) (OpPrec fix p))
-> precs _ _ = id
-
-> types :: ModuleIdent -> IDecl -> [I TypeInfo] -> [I TypeInfo]
-> types m (HidingDataDecl _ tc tvs) = qual tc (typeCon DataType m tc tvs [])
-> types m (IDataDecl _ tc tvs cs) =
->   qual tc (typeCon DataType m tc tvs (map (fmap constr) cs))
-> types m (INewtypeDecl _ tc tvs nc) =
->   qual tc (typeCon RenamingType m tc tvs (nconstr nc))
-> types m (ITypeDecl _ tc tvs ty) =
->   qual tc (typeCon AliasType m tc tvs (toType m tvs ty))
-> types _ _ = id
-
-> values :: ModuleIdent -> IDecl -> [I ValueInfo] -> [I ValueInfo]
-> values m (IDataDecl _ tc tvs cs) =
->   (map (dataConstr m tc' tvs (constrType tc' tvs)) (catMaybes cs) ++)
->   where tc' = qualQualify m tc
-> values m (INewtypeDecl _ tc tvs nc) =
->   (newConstr m tc' tvs (constrType tc' tvs) nc :)
->   where tc' = qualQualify m tc
-> values m (IFunctionDecl _ f n ty) =
->   qual f (Value (qualQualify m f) n' (polyType ty'))
->   where n' = fromMaybe (arrowArity ty') n
->         ty' = toType m [] ty
-> values _ _ = id
-
-> dataConstr :: ModuleIdent -> QualIdent -> [Ident] -> TypeExpr -> ConstrDecl
->            -> I ValueInfo
-> dataConstr m tc tvs ty0 (ConstrDecl _ _ c tys) =
->   (c,con DataConstructor m tc tvs c (length tys) (foldr ArrowType ty0 tys))
-> dataConstr m tc tvs ty0 (ConOpDecl _ _ ty1 op ty2) =
->   (op,con DataConstructor m tc tvs op 2 (ArrowType ty1 (ArrowType ty2 ty0)))
-
-> newConstr :: ModuleIdent -> QualIdent -> [Ident] -> TypeExpr -> NewConstrDecl
->           -> I ValueInfo
-> newConstr m tc tvs ty0 (NewConstrDecl _ c ty1) =
->   (c,con (const . NewtypeConstructor) m tc tvs c 1 (ArrowType ty1 ty0))
-
-> qual :: QualIdent -> a -> [I a] -> [I a]
-> qual x y = ((unqualify x,y) :)
+> precs :: IDecl -> [PrecInfo]
+> precs (IInfixDecl _ fix p op) = [PrecInfo op (OpPrec fix p)]
+> precs _ = []
+
+> types :: IDecl -> [TypeInfo]
+> types (IDataDecl _ _ tc k tvs cs _) =
+>   [typeCon DataType tc k tvs (map constr cs)]
+> types (INewtypeDecl _ _ tc k tvs nc _) =
+>   [typeCon RenamingType tc k tvs (nconstr nc)]
+> types (ITypeDecl _ tc k tvs ty) =
+>   [typeCon (flip AliasType (length tvs)) tc k tvs (toType tvs ty)]
+> types (IClassDecl _ cx cls k tv ds _) = [typeCls cx cls k tv (map clsMthd ds)]
+> types _ = []
+
+> typeCon :: (QualIdent -> Kind -> a) -> QualIdent -> Maybe KindExpr -> [Ident]
+>         -> a
+> typeCon f tc k tvs = f tc (maybe (simpleKind (length tvs)) toKind k)
+
+> typeCls :: [ClassAssert] -> QualIdent -> Maybe KindExpr -> Ident -> MethodList
+>         -> TypeInfo
+> typeCls cx cls k tv fs =
+>   TypeClass cls (maybe KindStar toKind k) [cls | TypePred cls _ <- cx'] fs
+>   where QualType cx' _ = toQualType (QualTypeExpr cx (VariableType tv))
+
+> clsMthd :: IMethodDecl -> (Ident,Int)
+> clsMthd (IMethodDecl _ f n _) = (f,maybe 0 fromInteger n)
+
+> values :: IDecl -> [ValueInfo]
+> values (IDataDecl _ cx tc _ tvs cs xs) =
+>   map (dataConstr cx tc tvs) (filter ((`notElem` xs) . constr) cs) ++
+>   map (uncurry (fieldLabel cx tc tvs)) (nubBy sameLabel ls)
+>   where ls = [(l,ty) | RecordDecl _ _ _ _ fs <- cs,
+>                        FieldDecl _ ls ty <- fs, l <- ls, l `notElem` xs]
+>         sameLabel (l1,_) (l2,_) = l1 == l2
+> values (INewtypeDecl _ cx tc _ tvs nc xs) =
+>   map (newConstr cx tc tvs) [nc | nconstr nc `notElem` xs] ++
+>   case nc of
+>     NewConstrDecl _ _ _ -> []
+>     NewRecordDecl _ c l ty -> [fieldLabel cx tc tvs l ty | l `notElem` xs]
+> values (IClassDecl _ _ cls _ tv ds fs') =
+>   map (classMethod cls tv) (filter ((`notElem` fs') . imethod) ds)
+> values (IFunctionDecl _ f n ty) = [Value f n' (typeScheme ty')]
+>   where n' = maybe (arrowArity (unqualType ty')) fromInteger n
+>         ty' = toQualType ty
+> values _ = []
+
+> dataConstr :: [ClassAssert] -> QualIdent -> [Ident] -> ConstrDecl -> ValueInfo
+> dataConstr cxL tc tvs (ConstrDecl _ _ cxR c tys) =
+>   con cxL tc tvs cxR c (zip (repeat anonId) tys)
+> dataConstr cxL tc tvs (ConOpDecl _ _ cxR ty1 op ty2) =
+>   con cxL tc tvs cxR op [(anonId,ty1),(anonId,ty2)]
+> dataConstr cxL tc tvs (RecordDecl _ _ cxR c fs) =
+>   con cxL tc tvs cxR c [(l,ty) | FieldDecl _ ls ty <- fs, l <- ls]
+
+> con :: [ClassAssert] -> QualIdent -> [Ident] -> [ClassAssert] -> Ident
+>     -> [(Ident,TypeExpr)] -> ValueInfo
+> con cxL tc tvs cxR c tys =
+>   DataConstructor (qualifyLike tc c) ls ci (typeScheme ty)
+>   where (ci,ty) = toConstrType cxL tc tvs cxR tys'
+>         (ls,tys') = unzip tys
+
+> newConstr :: [ClassAssert] -> QualIdent -> [Ident] -> NewConstrDecl
+>           -> ValueInfo
+> newConstr cx tc tvs (NewConstrDecl _ c ty) = ncon cx tc tvs c anonId ty
+> newConstr cx tc tvs (NewRecordDecl _ c l ty) = ncon cx tc tvs c l ty
+
+> ncon :: [ClassAssert] -> QualIdent -> [Ident] -> Ident -> Ident -> TypeExpr
+>      -> ValueInfo
+> ncon cx tc tvs c l ty =
+>   NewtypeConstructor (qualifyLike tc c) l (typeScheme ty')
+>   where ty' = snd (toConstrType cx tc tvs [] [ty])
+
+> fieldLabel :: [ClassAssert] -> QualIdent -> [Ident] -> Ident -> TypeExpr
+>            -> ValueInfo
+> fieldLabel cx tc tvs l ty =
+>   Value (qualifyLike tc l) 1 (typeScheme (toQualType ty'))
+>   where ty' = QualTypeExpr cx (ArrowType (constrType tc tvs) ty)
+
+> classMethod :: QualIdent -> Ident -> IMethodDecl -> ValueInfo
+> classMethod cls tv (IMethodDecl _ f _ ty) =
+>   Value (qualifyLike cls f) 0 (typeScheme (toMethodType cls tv ty))
 
 \end{verbatim}
 After all modules have been imported, the compiler has to ensure that
-all references to a data type use the same list of constructors.
+all references to a data type use the same list of constructors and
+all references to a type class use the same list of methods. Ditto for
+all references to a field label.
 \begin{verbatim}
 
-> importUnifyData :: TCEnv -> TCEnv
+> importUnifyData :: Entity a => TopEnv a -> TopEnv a
 > importUnifyData tcEnv =
 >   fmap (updWith (foldr (mergeData . snd) zeroFM (allImports tcEnv))) tcEnv
 >   where updWith tcs t = fromMaybe t (lookupFM (origName t) tcs)
@@ -191,17 +247,11 @@
 
 > addValue :: Import -> Set Ident -> Set Ident
 > addValue (Import f) fs = addToSet f fs
-> addValue (ImportTypeWith _ cs) fs = foldr addToSet fs cs
+> addValue (ImportTypeWith _ xs) fs = foldr addToSet fs xs
 > addValue (ImportTypeAll _) _ = internalError "addValue"
 
-> typeCon :: (QualIdent -> Int -> a) -> ModuleIdent -> QualIdent -> [Ident] -> a
-> typeCon f m tc tvs = f (qualQualify m tc) (length tvs)
-
-> con :: (QualIdent -> Int -> TypeScheme -> a) -> ModuleIdent -> QualIdent
->     -> [Ident] -> Ident -> Int -> TypeExpr -> a
-> con f m tc tvs c n ty = f (qualifyLike tc c) n (polyType (toType m tvs ty))
-
 > constrType :: QualIdent -> [Ident] -> TypeExpr
-> constrType tc tvs = ConstructorType tc (map VariableType tvs)
+> constrType tc tvs =
+>   foldl ApplyType (ConstructorType tc) (map VariableType tvs)
 
 \end{verbatim}
diff -u curry-0.9.11/ImportSyntaxCheck.lhs curry-0.9.11-classful/ImportSyntaxCheck.lhs
--- curry-0.9.11/ImportSyntaxCheck.lhs	2007-06-15 14:16:34.000000000 +0200
+++ curry-0.9.11-classful/ImportSyntaxCheck.lhs	2008-06-16 09:45:46.000000000 +0200
@@ -1,7 +1,7 @@
 % -*- LaTeX -*-
-% $Id: ImportSyntaxCheck.lhs 2148 2007-04-02 13:56:20Z wlux $
+% $Id: ImportSyntaxCheck.lhs 2724 2008-06-14 16:42:57Z wlux $
 %
-% Copyright (c) 2000-2007, Wolfgang Lux
+% Copyright (c) 2000-2008, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{ImportSyntaxCheck.lhs}
@@ -13,16 +13,21 @@
 
 > module ImportSyntaxCheck(checkImports) where
 > import Base
+> import Curry
+> import CurryUtils
 > import Error
 > import Env
+> import IdentInfo
 > import List
 > import Maybe
+> import PredefIdent
+> import TopEnv
 
 > checkImports :: Interface -> Maybe ImportSpec -> Error (Maybe ImportSpec)
 > checkImports (Interface m _ ds) =
 >   maybe (return Nothing) (liftE Just . expandSpecs m tEnv vEnv)
->   where tEnv = foldr (bindType m) emptyEnv ds
->         vEnv = foldr (bindValue m) emptyEnv ds
+>   where tEnv = bindIdents tidents ds
+>         vEnv = bindIdents vidents ds
 
 \end{verbatim}
 The compiler uses two environments collecting the type and value
@@ -34,30 +39,9 @@
 > type ExpTypeEnv = Env Ident TypeKind
 > type ExpFunEnv = Env Ident ValueKind
 
-> bindType :: ModuleIdent -> IDecl -> ExpTypeEnv -> ExpTypeEnv
-> bindType m (IDataDecl _ tc _ cs) =
->   bindUnqual tc (Data (qualQualify m tc) (map constr (catMaybes cs)))
-> bindType m (INewtypeDecl _ tc _ nc) =
->   bindUnqual tc (Data (qualQualify m tc) [nconstr nc])
-> bindType m (ITypeDecl _ tc _ _) = bindUnqual tc (Alias (qualQualify m tc))
-> bindType _ _ = id
-
-> bindValue :: ModuleIdent -> IDecl -> ExpFunEnv -> ExpFunEnv
-> bindValue m (IDataDecl _ tc _ cs) =
->   flip (foldr (bindConstr (qualQualify m tc))) (catMaybes cs)
-> bindValue m (INewtypeDecl _ tc _ nc) = bindNewConstr (qualQualify m tc) nc
-> bindValue m (IFunctionDecl _ f _ _) = bindUnqual f (Var (qualQualify m f))
-> bindValue _ _ = id
-
-> bindConstr :: QualIdent -> ConstrDecl -> ExpFunEnv -> ExpFunEnv
-> bindConstr tc (ConstrDecl _ _ c _) = bindEnv c (Constr (qualifyLike tc c))
-> bindConstr tc (ConOpDecl _ _ _ op _) = bindEnv op (Constr (qualifyLike tc op))
-
-> bindNewConstr :: QualIdent -> NewConstrDecl -> ExpFunEnv -> ExpFunEnv
-> bindNewConstr tc (NewConstrDecl _ c _) = bindEnv c (Constr (qualifyLike tc c))
-
-> bindUnqual :: QualIdent -> a -> Env Ident a -> Env Ident a
-> bindUnqual x = bindEnv (unqualify x)
+> bindIdents :: Entity a => (IDecl -> [a]) -> [IDecl] -> Env Ident a
+> bindIdents idents ds = foldr bindIdent emptyEnv (concatMap idents ds)
+>   where bindIdent x = bindEnv (unqualify (origName x)) x
 
 \end{verbatim}
 After the environments have been initialized, the optional import
@@ -87,28 +71,33 @@
 that all entities in an import specification are actually exported
 from the module. In addition, all imports of type constructors are
 changed into a \texttt{T()} specification and explicit imports for the
-data constructors are added.
+data constructors are added. The code of \texttt{expandSpecs} ensures
+that the unit, list, and tuple types are always imported from the
+Prelude even if its imported entities are specified explicitly.
 \begin{verbatim}
 
 > expandSpecs :: ModuleIdent -> ExpTypeEnv -> ExpFunEnv -> ImportSpec
 >             -> Error ImportSpec
 > expandSpecs m tEnv vEnv (Importing p is) =
->   liftE (Importing p . concat) (mapE (expandImport p m tEnv vEnv) is)
+>   liftE (Importing p . (is' ++) . concat)
+>         (mapE (expandImport p m tEnv vEnv) is)
+>   where is' = [importType t | m == preludeMIdent,
+>                               (tc,t) <- envToList tEnv, isPrimTypeId tc]
 > expandSpecs m tEnv vEnv (Hiding p is) =
 >   liftE (Hiding p . concat) (mapE (expandHiding p m tEnv vEnv) is)
 
 > expandImport :: Position -> ModuleIdent -> ExpTypeEnv -> ExpFunEnv -> Import
 >              -> Error [Import]
 > expandImport p m tEnv vEnv (Import x) = expandThing p m tEnv vEnv x
-> expandImport p m tEnv vEnv (ImportTypeWith tc cs) =
->   expandTypeWith p m tEnv tc cs
+> expandImport p m tEnv vEnv (ImportTypeWith tc xs) =
+>   expandTypeWith p m tEnv tc xs
 > expandImport p m tEnv vEnv (ImportTypeAll tc) = expandTypeAll p m tEnv tc
 
 > expandHiding :: Position -> ModuleIdent -> ExpTypeEnv -> ExpFunEnv -> Import
 >              -> Error [Import]
 > expandHiding p m tEnv vEnv (Import x) = expandHide p m tEnv vEnv x
-> expandHiding p m tEnv vEnv (ImportTypeWith tc cs) =
->   expandTypeWith p m tEnv tc cs
+> expandHiding p m tEnv vEnv (ImportTypeWith tc xs) =
+>   expandTypeWith p m tEnv tc xs
 > expandHiding p m tEnv vEnv (ImportTypeAll tc) = expandTypeAll p m tEnv tc
 
 > expandThing :: Position -> ModuleIdent -> ExpTypeEnv -> ExpFunEnv -> Ident
@@ -122,9 +111,8 @@
 >              -> Maybe [Import] -> Error [Import]
 > expandThing' p m vEnv f tcImport =
 >   case lookupEnv f vEnv of
->     Just (Constr _) ->
->       maybe (errorAt p (importDataConstr m f)) return tcImport
->     Just (Var _) -> return (Import f : fromMaybe [] tcImport)
+>     Just (Constr _) -> maybe (errorAt p (importDataConstr f)) return tcImport
+>     Just (Var _ _) -> return (Import f : fromMaybe [] tcImport)
 >     Nothing -> maybe (errorAt p (undefinedEntity m f)) return tcImport
 
 > expandHide :: Position -> ModuleIdent -> ExpTypeEnv -> ExpFunEnv -> Ident
@@ -143,26 +131,33 @@
 
 > expandTypeWith :: Position -> ModuleIdent -> ExpTypeEnv -> Ident -> [Ident]
 >                -> Error [Import]
-> expandTypeWith p m tEnv tc cs =
+> expandTypeWith p m tEnv tc xs =
 >   do
->     cs'' <- constrs p m tEnv tc
->     mapE_ (errorAt p . undefinedDataConstr m tc) (filter (`notElem` cs'') cs')
->     return [ImportTypeWith tc cs']
->   where cs' = nub cs
+>     (isType,xs'') <- elements p m tEnv tc
+>     mapE_ (errorAt p . undefinedElement isType tc)
+>           (filter (`notElem` xs'') xs')
+>     return [ImportTypeWith tc xs']
+>   where xs' = nub xs
 
 > expandTypeAll :: Position -> ModuleIdent -> ExpTypeEnv -> Ident
 >               -> Error [Import]
 > expandTypeAll p m tEnv tc =
 >   do
->     cs <- constrs p m tEnv tc
->     return [ImportTypeWith tc cs]
+>     (_,xs) <- elements p m tEnv tc
+>     return [ImportTypeWith tc xs]
 
-> constrs :: Position -> ModuleIdent -> ExpTypeEnv -> Ident -> Error [Ident]
-> constrs p m tEnv tc =
+> elements :: Position -> ModuleIdent -> ExpTypeEnv -> Ident
+>          -> Error (Bool,[Ident])
+> elements p m tEnv tc =
 >   case lookupEnv tc tEnv of
->     Just (Data _ cs) -> return cs
->     Just (Alias _) -> return []
->     Nothing -> errorAt p (undefinedType m tc)
+>     Just (Data _ xs) -> return (True,xs)
+>     Just (Alias _) -> return (True,[])
+>     Just (Class _ fs) -> return (False,fs)
+>     Nothing -> errorAt p (undefinedEntity m tc)
+
+> importType :: TypeKind -> Import
+> importType (Data tc xs) = ImportTypeWith (unqualify tc) xs
+> importType (Alias tc) = ImportTypeWith (unqualify tc) []
 
 \end{verbatim}
 Error messages.
@@ -172,15 +167,13 @@
 > undefinedEntity m x =
 >   "Module " ++ moduleName m ++ " does not export " ++ name x
 
-> undefinedType :: ModuleIdent -> Ident -> String
-> undefinedType m tc =
->   "Module " ++ moduleName m ++ " does not export type " ++ name tc
-
-> undefinedDataConstr :: ModuleIdent -> Ident -> Ident -> String
-> undefinedDataConstr m tc c =
->   name c ++ " is not a data constructor of type " ++ name tc
+> undefinedElement :: Bool -> Ident -> Ident -> String
+> undefinedElement True tc c =
+>   name c ++ " is not a constructor or label of type " ++ name tc
+> undefinedElement False cls f =
+>   name f ++ " is not a method of type class " ++ name cls
 
-> importDataConstr :: ModuleIdent -> Ident -> String
-> importDataConstr m c = "Explicit import of data constructor " ++ name c
+> importDataConstr :: Ident -> String
+> importDataConstr c = "Explicit import of data constructor " ++ name c
 
 \end{verbatim}
Solo in curry-0.9.11: in-place-config
Solo in curry-0.9.11-classful/: in-place-config.asc
Solo in curry-0.9.11: in-place-config-bin
Solo in curry-0.9.11-classful/: in-place-config-bin.asc
Solo in curry-0.9.11: install-sh
Solo in curry-0.9.11-classful/: install-sh.asc
Solo in curry-0.9.11-classful/: InstCheck.lhs
Solo in curry-0.9.11-classful/: InstInfo.lhs
Solo in curry-0.9.11-classful/: Interfaces.lhs
diff -u curry-0.9.11/IntfCheck.lhs curry-0.9.11-classful/IntfCheck.lhs
--- curry-0.9.11/IntfCheck.lhs	2007-06-15 14:16:34.000000000 +0200
+++ curry-0.9.11-classful/IntfCheck.lhs	2010-10-04 14:54:51.000000000 +0200
@@ -1,28 +1,32 @@
 % -*- LaTeX -*-
-% $Id: IntfCheck.lhs 2148 2007-04-02 13:56:20Z wlux $
+% $Id: IntfCheck.lhs 3012 2010-10-04 11:29:23Z wlux $
 %
-% Copyright (c) 2000-2007, Wolfgang Lux
+% Copyright (c) 2000-2010, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{IntfCheck.lhs}
 \section{Interface Consistency Checks}
 Interface files include declarations of all entities that are exported
-by the module, but defined in another module. Since these declarations
+by the module but defined in another module. Since these declarations
 can become inconsistent if client modules are not recompiled properly,
-the compiler checks that all imported declarations in an interface
-agree with their original definitions.
-
-One may ask why we include imported declarations at all, if the
-compiler always has to compare those declarations with the original
-definitions. The main reason for this is that it helps to avoid
-unnecessary recompilations of client modules. As an example, consider
-the three modules
+the compiler checks that all imported declarations in interfaces are
+consistent and agree with their original definitions where they are
+available.
+
+The main rationale for this design decision is that it is sufficient
+to read only the interfaces of the Prelude and those modules that are
+imported explicitly by the compiled module if the definitions of all
+exported entities are present in an interface. This makes
+bootstrapping simpler for mutually recursive modules, in particular if
+the mutual recursion also shows up in the interfaces. Furthermore, it
+helps avoiding unnecessary recompilation of client modules. As an
+example, consider the three modules
 \begin{verbatim}
   module A where { data T = C }
   module B(T(..)) where { import A }
   module C where { import B; f = C }
 \end{verbatim}
-where module \texttt{B} could be considered as a public interface of
+where module \texttt{B} could be considered the public interface of
 module \texttt{A}, which restricts access to type \texttt{A.T} and its
 constructor \texttt{C}. The client module \texttt{C} imports this type
 via the public interface \texttt{B}. If now module \texttt{A} is
@@ -38,104 +42,168 @@
 \texttt{B}'s interface remains unchanged and therefore the client
 module \texttt{C} is not recompiled.
 
-Another reason for including imported declarations in interfaces is
-that the compiler in principle could avoid loading interfaces of
-modules that are imported only indirectly, which would save processing
-time and allow distributing binary packages of a library with a public
-interface module only. However, this has not been implemented yet.
+When detecting a conflict between the definition of an imported
+entity, say \texttt{A.x}, in the interfaces of modules \texttt{B} and
+\texttt{C}, respectively, we have to distinguish whether the interface
+of module \texttt{A} has been loaded as well or not. In the former
+case, we can give an authoritative answer whether \texttt{A.x}'s
+definition in \texttt{B} is wrong or whether the definition in
+\texttt{C} is wrong. We can even detect if \texttt{A} does not export
+\texttt{x} at all. In the latter case, we can not give an
+authoritative answer which definition is wrong and therefore report an
+error for both.
 \begin{verbatim}
 
 > module IntfCheck(intfCheck) where
 > import Base
+> import Curry
+> import CurryUtils
+> import Env
 > import Error
+> import InstInfo
+> import Kinds
+> import KindTrans
+> import List
 > import Maybe
 > import Monad
+> import PrecInfo
 > import TopEnv
+> import Types
+> import TypeInfo
 > import TypeTrans
+> import ValueInfo
 
-> intfCheck :: ModuleIdent -> PEnv -> TCEnv -> ValueEnv -> [IDecl] -> Error ()
-> intfCheck m pEnv tcEnv tyEnv = mapE_ (checkImport m pEnv tcEnv tyEnv)
+> intfCheck :: ModuleIdent -> PEnv -> TCEnv -> InstEnv -> ValueEnv -> [IDecl]
+>           -> Error ()
+> intfCheck m pEnv tcEnv iEnv tyEnv ds =
+>   mapE_ (checkImport pEnv tcEnv iEnv tyEnv)
+>         (filter (isNothing . localIdent m . entity) ds)
 
-> checkImport :: ModuleIdent -> PEnv -> TCEnv -> ValueEnv -> IDecl -> Error ()
-> checkImport _ pEnv _ _ (IInfixDecl p fix pr op) =
+> checkImport :: PEnv -> TCEnv -> InstEnv -> ValueEnv -> IDecl -> Error ()
+> checkImport pEnv _ _ _ (IInfixDecl p fix pr op) =
 >   checkPrecInfo checkPrec pEnv p op
 >   where checkPrec (PrecInfo op' (OpPrec fix' pr')) =
 >           op == op' && fix == fix' && pr == pr'
-> checkImport _ _ tcEnv _ (HidingDataDecl p tc tvs) =
+> checkImport _ tcEnv _ _ (HidingDataDecl p tc k tvs) =
 >   checkTypeInfo "hidden data type" checkData tcEnv p tc
->   where checkData (DataType tc' n' _)
->           | tc == tc' && length tvs == n' = Just (return ())
->         checkData (RenamingType tc' n' _)
->           | tc == tc' && length tvs == n' = Just (return ())
+>   where checkData (DataType tc' k' _)
+>           | tc == tc' && maybe (simpleKind (length tvs)) toKind k == k' =
+>               Just (return ())
+>         checkData (RenamingType tc' k' _)
+>           | tc == tc' && maybe (simpleKind (length tvs)) toKind k == k' =
+>               Just (return ())
 >         checkData _ = Nothing
-> checkImport m _ tcEnv tyEnv (IDataDecl p tc tvs cs) =
+> checkImport _ tcEnv _ tyEnv (IDataDecl p cx tc k tvs cs _) =
 >   checkTypeInfo "data type" checkData tcEnv p tc
->   where checkData (DataType tc' n' cs')
->           | tc == tc' && length tvs == n' &&
->             (null cs || length cs == length cs') &&
->             and (zipWith isVisible cs cs') =
->               Just (mapM_ (checkConstrImport m tyEnv tc tvs) (catMaybes cs))
->         checkData (RenamingType tc' n' _)
->           | tc == tc' && length tvs == n' && null cs = Just (return ())
+>   where checkData (DataType tc' k' cs')
+>           | tc == tc' && maybe (simpleKind (length tvs)) toKind k == k' &&
+>             (null cs || map constr cs == cs') =
+>               Just (mapM_ (checkConstrImport tyEnv cx tc tvs) cs)
+>         checkData (RenamingType tc' k' _)
+>           | tc == tc' && maybe (simpleKind (length tvs)) toKind k == k' &&
+>             null cs =
+>               Just (return ())
 >         checkData _ = Nothing
->         isVisible (Just c) (Just c') = constr c == c'
->         isVisible (Just _) Nothing = False
->         isVisible Nothing _ = True
-> checkImport m _ tcEnv tyEnv (INewtypeDecl p tc tvs nc) =
+> checkImport _ tcEnv _ tyEnv (INewtypeDecl p cx tc k tvs nc _) =
 >   checkTypeInfo "newtype" checkNewtype tcEnv p tc
->   where checkNewtype (RenamingType tc' n' nc')
->           | tc == tc' && length tvs == n' && nconstr nc == nc' =
->               Just (checkNewConstrImport m tyEnv tc tvs nc)
+>   where checkNewtype (RenamingType tc' k' nc')
+>           | tc == tc' && maybe (simpleKind (length tvs)) toKind k == k' &&
+>             nconstr nc == nc' =
+>               Just (checkNewConstrImport tyEnv cx tc tvs nc)
 >         checkNewtype _ = Nothing
-> checkImport m _ tcEnv _ (ITypeDecl p tc tvs ty) =
+> checkImport _ tcEnv _ _ (ITypeDecl p tc k tvs ty) =
 >   checkTypeInfo "synonym type" checkType tcEnv p tc
->   where checkType (AliasType tc' n' ty')
->           | tc == tc' && length tvs == n' && toType m tvs ty == ty' =
+>   where checkType (AliasType tc' n' k' ty')
+>           | tc == tc' && maybe (simpleKind (length tvs)) toKind k == k' &&
+>             length tvs == n' && toType tvs ty == ty' =
 >               Just (return ())
 >         checkType _ = Nothing
-> checkImport m _ _ tyEnv (IFunctionDecl p f n ty) =
+> checkImport _ tcEnv _ _ (HidingClassDecl p cx cls k tv) =
+>   checkTypeInfo "hidden type class" checkClass tcEnv p cls
+>   where checkClass (TypeClass cls' k' clss' _)
+>           | cls == cls' && maybe KindStar toKind k == k' &&
+>             [cls | ClassAssert cls _ <- cx] == clss' =
+>               Just (return ())
+>         checkClass _ = Nothing
+> checkImport _ tcEnv _ tyEnv (IClassDecl p cx cls k tv ds _) =
+>   checkTypeInfo "type class" checkClass tcEnv p cls
+>   where checkClass (TypeClass cls' k' clss' fs')
+>           | cls == cls' && maybe KindStar toKind k == k' &&
+>             [cls | ClassAssert cls _ <- cx] == clss' &&
+>             [(f,maybe 0 fromInteger n) | IMethodDecl _ f n _ <- ds] == fs' =
+>               Just (mapM_ (checkMethodImport tyEnv cls tv) ds)
+>         checkClass _ = Nothing
+> checkImport _ _ iEnv _ (IInstanceDecl p cx cls ty m fs) =
+>   checkInstInfo checkInst iEnv p cls tc m
+>   where QualType cx' ty' = toQualType (QualTypeExpr cx ty)
+>         tc = rootOfType ty'
+>         checkInst cx'' fs' =
+>           cx' == cx'' && sort fs == sort [(f,toInteger n) | (f,n) <- fs']
+> checkImport _ _ _ tyEnv (IFunctionDecl p f n ty) =
 >   checkValueInfo "function" checkFun tyEnv p f
 >   where checkFun (Value f' n' (ForAll _ ty')) =
->           f == f' && maybe True (n' ==) n && toType m [] ty == ty'
+>           f == f' && maybe True (toInteger n' ==) n && toQualType ty == ty'
 >         checkFun _ = False
 
-> checkConstrImport :: ModuleIdent -> ValueEnv -> QualIdent -> [Ident]
+> checkConstrImport :: ValueEnv -> [ClassAssert] -> QualIdent -> [Ident]
 >                   -> ConstrDecl -> Error ()
-> checkConstrImport m tyEnv tc tvs (ConstrDecl p evs c tys) =
+> checkConstrImport tyEnv cxL tc tvs (ConstrDecl p evs cxR c tys) =
 >   checkValueInfo "data constructor" checkConstr tyEnv p qc
 >   where qc = qualifyLike tc c
->         checkConstr (DataConstructor c' _ (ForAll n' ty')) =
+>         checkConstr (DataConstructor c' _ ci' (ForAll n' ty')) =
 >           qc == c' && length (tvs ++ evs) == n' &&
->           toTypes m tvs tys == arrowArgs ty'
+>           toConstrType cxL tc tvs cxR tys == (ci',ty')
 >         checkConstr _ = False
-> checkConstrImport m tyEnv tc tvs (ConOpDecl p evs ty1 op ty2) =
+> checkConstrImport tyEnv cxL tc tvs (ConOpDecl p evs cxR ty1 op ty2) =
 >   checkValueInfo "data constructor" checkConstr tyEnv p qc
 >   where qc = qualifyLike tc op
->         checkConstr (DataConstructor c' _ (ForAll n' ty')) =
+>         checkConstr (DataConstructor c' _ ci' (ForAll n' ty')) =
 >           qc == c' && length (tvs ++ evs) == n' &&
->           toTypes m tvs [ty1,ty2] == arrowArgs ty'
+>           toConstrType cxL tc tvs cxR [ty1,ty2] == (ci',ty')
+>         checkConstr _ = False
+> checkConstrImport tyEnv cxL tc tvs (RecordDecl p evs cxR c fs) =
+>   checkValueInfo "data constructor" checkConstr tyEnv p qc
+>   where qc = qualifyLike tc c
+>         (ls,tys) = unzip [(l,ty) | FieldDecl _ ls ty <- fs, l <- ls]
+>         checkConstr (DataConstructor c' ls' ci' (ForAll n' ty')) =
+>           qc == c' && length (tvs ++ evs) == n' && ls == ls' &&
+>           toConstrType cxL tc tvs cxR tys == (ci',ty')
 >         checkConstr _ = False
 
-> checkNewConstrImport :: ModuleIdent -> ValueEnv -> QualIdent -> [Ident]
+> checkNewConstrImport :: ValueEnv -> [ClassAssert] -> QualIdent -> [Ident]
 >                      -> NewConstrDecl -> Error ()
-> checkNewConstrImport m tyEnv tc tvs (NewConstrDecl p c ty) =
+> checkNewConstrImport tyEnv cx tc tvs (NewConstrDecl p c ty) =
 >   checkValueInfo "newtype constructor" checkNewConstr tyEnv p qc
 >   where qc = qualifyLike tc c
->         checkNewConstr (NewtypeConstructor c' (ForAll n' ty')) =
+>         checkNewConstr (NewtypeConstructor c' _ (ForAll n' ty')) =
 >           qc == c' && length tvs == n' &&
->           toType m tvs ty == head (arrowArgs ty')
+>           snd (toConstrType cx tc tvs [] [ty]) == ty'
+>         checkNewConstr _ = False
+> checkNewConstrImport tyEnv cx tc tvs (NewRecordDecl p c l ty) =
+>   checkValueInfo "newtype constructor" checkNewConstr tyEnv p qc
+>   where qc = qualifyLike tc c
+>         checkNewConstr (NewtypeConstructor c' l' (ForAll n' ty')) =
+>           qc == c' && length tvs == n' && l == l' &&
+>           snd (toConstrType cx tc tvs [] [ty]) == ty'
 >         checkNewConstr _ = False
 
+> checkMethodImport :: ValueEnv -> QualIdent -> Ident -> IMethodDecl -> Error ()
+> checkMethodImport tyEnv cls tv (IMethodDecl p f _ ty) =
+>   checkValueInfo "method" checkMethod tyEnv p qf
+>   where qf = qualifyLike cls f
+>         checkMethod (Value f' _ (ForAll _ ty')) =
+>           qf == f' && toMethodType cls tv ty == ty'
+>         checkMethod _ = False
+
 > checkPrecInfo :: (PrecInfo -> Bool) -> PEnv -> Position
 >               -> QualIdent -> Error ()
 > checkPrecInfo check pEnv p op = checkImported checkInfo op
->   where checkInfo m op' =
+>   where what = "precedence"
+>         checkInfo m op' =
 >           case qualLookupTopEnv op pEnv of
 >             [] -> errorAt p (noPrecedence m op')
->             [pi] ->
->               unless (check pi)
->                      (errorAt p (importConflict "precedence" m op'))
->             _ -> internalError "checkPrecInfo"
+>             [pi] -> unless (check pi) (errorAt p (importConflict what m op'))
+>             _ -> errorAt p (inconsistentImports what op)
 
 > checkTypeInfo :: String -> (TypeInfo -> Maybe (Error ())) -> TCEnv -> Position
 >               -> QualIdent -> Error ()
@@ -145,7 +213,7 @@
 >             [] -> errorAt p (notExported what m tc')
 >             [ti] ->
 >               fromMaybe (errorAt p (importConflict what m tc')) (check ti)
->             _ -> internalError "checkTypeInfo"
+>             _ -> errorAt p (inconsistentImports what tc)
 
 > checkValueInfo :: String -> (ValueInfo -> Bool) -> ValueEnv -> Position
 >                -> QualIdent -> Error ()
@@ -154,13 +222,23 @@
 >           case qualLookupTopEnv x tyEnv of
 >             [] -> errorAt p (notExported what m x')
 >             [vi] -> unless (check vi) (errorAt p (importConflict what m x'))
->             _ -> internalError "checkValueInfo"
+>             _ -> errorAt p (inconsistentImports what x)
+
+> checkInstInfo :: (Context -> MethodList -> Bool) -> InstEnv -> Position
+>               -> QualIdent -> QualIdent -> Maybe ModuleIdent -> Error ()
+> checkInstInfo checkInst iEnv p cls tc m =
+>   checkImported checkInfo (maybe qualify qualifyWith m anonId)
+>   where checkInfo m' _ =
+>           case lookupEnv (CT cls tc) iEnv of
+>             Just (m,cx,fs)
+>               | m /= m' -> errorAt p (noInstance m' cls tc)
+>               | otherwise ->
+>                   unless (checkInst cx fs)
+>                          (errorAt p (instanceConflict m' cls tc))
+>             Nothing -> errorAt p (noInstance m' cls tc)
 
 > checkImported :: (ModuleIdent -> Ident -> Error ()) -> QualIdent -> Error ()
-> checkImported f x =
->   case splitQualIdent x of
->     (Just m,x') -> f m x'
->     (Nothing,_) -> return ()
+> checkImported f x = uncurry (f . fromJust) (splitQualIdent x)
 
 \end{verbatim}
 Error messages.
@@ -176,10 +254,27 @@
 >   "Inconsistent module interfaces\n" ++
 >   "Module " ++ moduleName m ++ " does not define a precedence for " ++ name x
 
+> noInstance :: ModuleIdent -> QualIdent -> QualIdent -> String
+> noInstance m cls tc =
+>   "Inconsistent module interfaces\n" ++
+>   "Module " ++ moduleName m ++ " does not define an instance " ++
+>   qualName cls ++ " " ++ qualName tc
+
 > importConflict :: String -> ModuleIdent -> Ident -> String
 > importConflict what m x =
 >   "Inconsistent module interfaces\n" ++
 >   "Declaration of " ++ what ++ " " ++ name x ++
 >   " does not match its definition in module " ++ moduleName m
 
+> instanceConflict :: ModuleIdent -> QualIdent -> QualIdent -> String
+> instanceConflict m cls tc =
+>   "Inconsistent module interfaces\n" ++
+>   "Declaration of instance " ++ qualName cls ++ " " ++ qualName tc ++
+>   " does not match its definition in module " ++ moduleName m
+
+> inconsistentImports :: String -> QualIdent -> String
+> inconsistentImports what x =
+>   "Inconsistent module interfaces\n" ++
+>   "Found inconsistent declarations for imported " ++ what ++ " " ++ qualName x
+
 \end{verbatim}
diff -u curry-0.9.11/IntfEquiv.lhs curry-0.9.11-classful/IntfEquiv.lhs
--- curry-0.9.11/IntfEquiv.lhs	2007-06-15 14:16:34.000000000 +0200
+++ curry-0.9.11-classful/IntfEquiv.lhs	2009-05-06 11:06:24.000000000 +0200
@@ -1,7 +1,7 @@
 % -*- LaTeX -*-
-% $Id: IntfEquiv.lhs 2148 2007-04-02 13:56:20Z wlux $
+% $Id: IntfEquiv.lhs 2815 2009-05-04 13:59:57Z wlux $
 %
-% Copyright (c) 2000-2007, Wolfgang Lux
+% Copyright (c) 2000-2008, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{IntfEquiv.lhs}
@@ -20,8 +20,9 @@
 \begin{verbatim}
 
 > module IntfEquiv(fixInterface, intfEquiv) where
-> import Base
+> import Curry
 > import List
+> import PredefIdent
 > import Set
 
 > infix 4 =~=, `eqvList`, `eqvSet`
@@ -37,12 +38,6 @@
 > xs `eqvSet` ys =
 >   null (deleteFirstsBy (=~=) xs ys ++ deleteFirstsBy (=~=) ys xs)
 
-> instance IntfEquiv a => IntfEquiv (Maybe a) where
->   Nothing =~= Nothing = True
->   Nothing =~= Just _  = False
->   Just _  =~= Nothing = False
->   Just x  =~= Just y  = x =~= y
-
 > instance IntfEquiv Interface where
 >   Interface m1 is1 ds1 =~= Interface m2 is2 ds2 =
 >     m1 == m2 && is1 `eqvSet` is2 && ds1 `eqvSet` ds2
@@ -53,27 +48,56 @@
 > instance IntfEquiv IDecl where
 >   IInfixDecl _ fix1 p1 op1 =~= IInfixDecl _ fix2 p2 op2 =
 >     fix1 == fix2 && p1 == p2 && op1 == op2
->   HidingDataDecl _ tc1 tvs1 =~= HidingDataDecl _ tc2 tvs2 =
->     tc1 == tc2 && tvs1 == tvs2
->   IDataDecl _ tc1 tvs1 cs1 =~= IDataDecl _ tc2 tvs2 cs2 =
->     tc1 == tc2 && tvs1 == tvs2 && cs1 `eqvList` cs2
->   INewtypeDecl _ tc1 tvs1 nc1 =~= INewtypeDecl _ tc2 tvs2 nc2 =
->     tc1 == tc2 && tvs1 == tvs2 && nc1 =~= nc2
->   ITypeDecl _ tc1 tvs1 ty1 =~= ITypeDecl _ tc2 tvs2 ty2 =
->     tc1 == tc2 && tvs1 == tvs2 && ty1 == ty2
+>   HidingDataDecl _ tc1 k1 tvs1 =~= HidingDataDecl _ tc2 k2 tvs2 =
+>     tc1 == tc2 && k1 == k2 && tvs1 == tvs2
+>   IDataDecl _ cx1 tc1 k1 tvs1 cs1 xs1 =~=
+>       IDataDecl _ cx2 tc2 k2 tvs2 cs2 xs2 =
+>     cx1 == cx2 && tc1 == tc2 && k1 == k2 && tvs1 == tvs2 &&
+>     cs1 `eqvList` cs2 && xs1 `eqvSet` xs2
+>   INewtypeDecl _ cx1 tc1 k1 tvs1 nc1 xs1 =~=
+>       INewtypeDecl _ cx2 tc2 k2 tvs2 nc2 xs2 =
+>     cx1 == cx2 && tc1 == tc2 && k1 == k2 && tvs1 == tvs2 &&
+>     nc1 =~= nc2 && xs1 `eqvSet` xs2
+>   ITypeDecl _ tc1 k1 tvs1 ty1 =~= ITypeDecl _ tc2 k2 tvs2 ty2 =
+>     tc1 == tc2 && k1 == k2 && tvs1 == tvs2 && ty1 == ty2
+>   HidingClassDecl _ cx1 cls1 k1 _ =~= HidingClassDecl _ cx2 cls2 k2 _ =
+>     cx1 == cx2 && cls1 == cls2 && k1 == k2
+>   IClassDecl _ cx1 cls1 k1 _ ds1 fs1' =~=
+>       IClassDecl _ cx2 cls2 k2 _ ds2 fs2' =
+>     cx1 == cx2 && cls1 == cls2 && k1 == k2 &&
+>     ds1 `eqvList` ds2 && fs1' `eqvSet` fs2'
+>   IInstanceDecl _ cx1 cls1 ty1 m1 fs1 =~=
+>       IInstanceDecl _ cx2 cls2 ty2 m2 fs2 =
+>     cx1 == cx2 && cls1 == cls2 && ty1 == ty2 && m1 == m2 &&
+>     sort fs1 == sort fs2
 >   IFunctionDecl _ f1 n1 ty1 =~= IFunctionDecl _ f2 n2 ty2 =
 >     f1 == f2 && n1 == n2 && ty1 == ty2
 >   _ =~= _ = False
 
 > instance IntfEquiv ConstrDecl where
->   ConstrDecl _ evs1 c1 tys1 =~= ConstrDecl _ evs2 c2 tys2 =
->     c1 == c2 && evs1 == evs2 && tys1 == tys2
->   ConOpDecl _ evs1 ty11 op1 ty12 =~= ConOpDecl _ evs2 ty21 op2 ty22 =
->     op1 == op2 && evs1 == evs2 && ty11 == ty21 && ty12 == ty22
+>   ConstrDecl _ evs1 cx1 c1 tys1 =~= ConstrDecl _ evs2 cx2 c2 tys2 =
+>     c1 == c2 && evs1 == evs2 && cx1 == cx2 && tys1 == tys2
+>   ConOpDecl _ evs1 cx1 ty11 op1 ty12 =~= ConOpDecl _ evs2 cx2 ty21 op2 ty22 =
+>     op1 == op2 && evs1 == evs2 && cx1 == cx2 && ty11 == ty21 && ty12 == ty22
+>   RecordDecl _ evs1 cx1 c1 fs1 =~= RecordDecl _ evs2 cx2 c2 fs2 =
+>     c1 == c2 && evs1 == evs2 && cx1 == cx2 && fs1 `eqvList` fs2
 >   _ =~= _ = False
 
+> instance IntfEquiv FieldDecl where
+>   FieldDecl _ ls1 ty1 =~= FieldDecl _ ls2 ty2 = ls1 == ls2 && ty1 == ty2
+
 > instance IntfEquiv NewConstrDecl where
 >   NewConstrDecl _ c1 ty1 =~= NewConstrDecl _ c2 ty2 = c1 == c2 && ty1 == ty2
+>   NewRecordDecl _ c1 l1 ty1 =~= NewRecordDecl _ c2 l2 ty2 =
+>     c1 == c2 && l1 == l2 && ty1 == ty2
+>   _ =~= _ = False
+
+> instance IntfEquiv IMethodDecl where
+>   IMethodDecl _ f1 n1 ty1 =~= IMethodDecl _ f2 n2 ty2 =
+>     f1 == f2 && n1 == n2 && ty1 == ty2
+
+> instance IntfEquiv Ident where
+>   (=~=) = (==)
 
 \end{verbatim}
 If we check for a change in the interface, we do not need to check the
@@ -97,41 +121,68 @@
 >   fix tcs = map (fix tcs)
 
 > instance FixInterface IDecl where
->   fix tcs (IDataDecl p tc tvs cs) = IDataDecl p tc tvs (fix tcs cs)
->   fix tcs (INewtypeDecl p tc tvs nc) = INewtypeDecl p tc tvs (fix tcs nc)
->   fix tcs (ITypeDecl p tc tvs ty) = ITypeDecl p tc tvs (fix tcs ty)
+>   fix _ (IInfixDecl p fix pr op) = IInfixDecl p fix pr op
+>   fix _ (HidingDataDecl p tc k tvs) = HidingDataDecl p tc k tvs
+>   fix tcs (IDataDecl p cx tc k tvs cs xs) =
+>     IDataDecl p (fix tcs cx) tc k tvs (fix tcs cs) xs
+>   fix tcs (INewtypeDecl p cx tc k tvs nc xs) =
+>     INewtypeDecl p (fix tcs cx) tc k tvs (fix tcs nc) xs
+>   fix tcs (ITypeDecl p tc k tvs ty) = ITypeDecl p tc k tvs (fix tcs ty)
+>   fix tcs (HidingClassDecl p cx cls k tv) =
+>     HidingClassDecl p (fix tcs cx) cls k tv
+>   fix tcs (IClassDecl p cx cls k tv ds fs') =
+>     IClassDecl p (fix tcs cx) cls k tv (fix tcs ds) fs'
+>   fix tcs (IInstanceDecl p cx cls ty m fs) =
+>     IInstanceDecl p (fix tcs cx) cls (fix tcs ty) m fs
 >   fix tcs (IFunctionDecl p f n ty) = IFunctionDecl p f n (fix tcs ty)
->   fix _ d = d
 
 > instance FixInterface ConstrDecl where
->   fix tcs (ConstrDecl p evs c tys) = ConstrDecl p evs c (fix tcs tys)
->   fix tcs (ConOpDecl p evs ty1 op ty2) =
->     ConOpDecl p evs (fix tcs ty1) op (fix tcs ty2)
+>   fix tcs (ConstrDecl p evs cx c tys) = ConstrDecl p evs cx c (fix tcs tys)
+>   fix tcs (ConOpDecl p evs cx ty1 op ty2) =
+>     ConOpDecl p evs cx (fix tcs ty1) op (fix tcs ty2)
+>   fix tcs (RecordDecl p evs cx c fs) = RecordDecl p evs cx c (fix tcs fs)
+
+> instance FixInterface FieldDecl where
+>   fix tcs (FieldDecl p ls ty) = FieldDecl p ls (fix tcs ty)
 
 > instance FixInterface NewConstrDecl where
 >   fix tcs (NewConstrDecl p c ty) = NewConstrDecl p c (fix tcs ty)
+>   fix tcs (NewRecordDecl p c l ty) = NewRecordDecl p c l (fix tcs ty)
+
+> instance FixInterface IMethodDecl where
+>   fix tcs (IMethodDecl p f n ty) = IMethodDecl p f n (fix tcs ty)
+
+> instance FixInterface QualTypeExpr where
+>   fix tcs (QualTypeExpr cx ty) = QualTypeExpr (fix tcs cx) (fix tcs ty)
+
+> instance FixInterface ClassAssert where
+>   fix tcs (ClassAssert cls ty) = ClassAssert cls (fix tcs ty)
 
 > instance FixInterface TypeExpr where
->   fix tcs (ConstructorType tc tys)
->     | not (isQualified tc) && not (isPrimTypeId tc) &&
->       tc' `notElemSet` tcs && null tys = VariableType tc'
->     | otherwise = ConstructorType tc (fix tcs tys)
+>   fix tcs (ConstructorType tc)
+>     | isQualified tc || isPrimTypeId tc' || tc' `elemSet` tcs =
+>         ConstructorType tc
+>     | otherwise = VariableType tc'
 >     where tc' = unqualify tc
 >   fix tcs (VariableType tv)
->     | tv `elemSet` tcs = ConstructorType (qualify tv) []
+>     | tv `elemSet` tcs = ConstructorType (qualify tv)
 >     | otherwise = VariableType tv
 >   fix tcs (TupleType tys) = TupleType (fix tcs tys)
 >   fix tcs (ListType ty) = ListType (fix tcs ty)
 >   fix tcs (ArrowType ty1 ty2) = ArrowType (fix tcs ty1) (fix tcs ty2)
+>   fix tcs (ApplyType ty1 ty2) = ApplyType (fix tcs ty1) (fix tcs ty2)
 
 > typeConstructors :: [IDecl] -> [Ident]
 > typeConstructors ds =
 >   [tc | (Nothing,tc) <- map splitQualIdent (foldr tcs [] ds)]
 >   where tcs (IInfixDecl _ _ _ _) tcs = tcs
->         tcs (HidingDataDecl _ tc _) tcs = tc : tcs
->         tcs (IDataDecl _ tc _ _) tcs = tc : tcs
->         tcs (INewtypeDecl _ tc _ _) tcs = tc : tcs
->         tcs (ITypeDecl _ tc _ _) tcs = tc : tcs
+>         tcs (HidingDataDecl _ tc _ _) tcs = tc : tcs
+>         tcs (IDataDecl _ _ tc _ _ _ _) tcs = tc : tcs
+>         tcs (INewtypeDecl _ _ tc _ _ _ _) tcs = tc : tcs
+>         tcs (ITypeDecl _ tc _ _ _) tcs = tc : tcs
+>         tcs (HidingClassDecl _ _ _ _ _) tcs = tcs
+>         tcs (IClassDecl _ _ _ _ _ _ _) tcs = tcs
+>         tcs (IInstanceDecl _ _ _ _ _ _) tcs = tcs
 >         tcs (IFunctionDecl _ _ _ _) tcs = tcs
 
 \end{verbatim}
Solo in curry-0.9.11-classful/: IntfQual.lhs
diff -u curry-0.9.11/IntfSyntaxCheck.lhs curry-0.9.11-classful/IntfSyntaxCheck.lhs
--- curry-0.9.11/IntfSyntaxCheck.lhs	2007-06-15 14:16:34.000000000 +0200
+++ curry-0.9.11-classful/IntfSyntaxCheck.lhs	2009-08-25 10:02:57.000000000 +0200
@@ -1,7 +1,7 @@
 % -*- LaTeX -*-
-% $Id: IntfSyntaxCheck.lhs 2148 2007-04-02 13:56:20Z wlux $
+% $Id: IntfSyntaxCheck.lhs 2900 2009-08-24 13:03:24Z wlux $
 %
-% Copyright (c) 2000-2007, Wolfgang Lux
+% Copyright (c) 2000-2009, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{IntfSyntaxCheck.lhs}
@@ -12,22 +12,26 @@
 addition, the compiler also checks that all type constructor
 applications are saturated. Since interface files are closed -- i.e.,
 they include declarations of all entities which are defined in other
-modules -- the compiler can perform this check without reference to
-the global environments.
+modules\footnote{Strictly speaking this is not true. The unit, list,
+  and tuple types are available in all modules but are included only
+  in the interface of the Prelude, which contains the definitions of
+  these types.} -- the compiler can perform this check without
+reference to the global environments.
 \begin{verbatim}
 
 > module IntfSyntaxCheck(intfSyntaxCheck) where
 > import Base
+> import Curry
+> import CurryPP
+> import CurryUtils
 > import Error
+> import IdentInfo
 > import List
-> import Maybe
 > import Monad
+> import Pretty
+> import PredefIdent
 > import TopEnv
 
-> intfSyntaxCheck :: [IDecl] -> Error [IDecl]
-> intfSyntaxCheck ds = mapE (checkIDecl env) ds
->   where env = foldr bindType (fmap typeKind initTCEnv) ds
-
 \end{verbatim}
 The compiler requires information about the arity of each defined type
 constructor as well as information whether the type constructor
@@ -35,14 +39,10 @@
 The latter must not occur in type expressions in interfaces.
 \begin{verbatim}
 
-> bindType :: IDecl -> TypeEnv -> TypeEnv
-> bindType (IInfixDecl _ _ _ _) = id
-> bindType (HidingDataDecl _ tc _) = qualBindTopEnv tc (Data tc [])
-> bindType (IDataDecl _ tc _ cs) =
->   qualBindTopEnv tc (Data tc (map constr (catMaybes cs)))
-> bindType (INewtypeDecl _ tc _ nc) = qualBindTopEnv tc (Data tc [nconstr nc])
-> bindType (ITypeDecl _ tc _ _) = qualBindTopEnv tc (Alias tc)
-> bindType (IFunctionDecl _ _ _ _) = id
+> intfSyntaxCheck :: [IDecl] -> Error [IDecl]
+> intfSyntaxCheck ds = mapE (checkIDecl env) ds
+>   where env = foldr bindType initTEnv (concatMap tidents (map unhide ds))
+>         bindType t = qualBindTopEnv (origName t) t
 
 \end{verbatim}
 The checks applied to the interface are similar to those performed
@@ -51,72 +51,199 @@
 
 > checkIDecl :: TypeEnv -> IDecl -> Error IDecl
 > checkIDecl _ (IInfixDecl p fix pr op) = return (IInfixDecl p fix pr op)
-> checkIDecl env (HidingDataDecl p tc tvs) =
->   checkTypeLhs env p tvs &&>
->   return (HidingDataDecl p tc tvs)
-> checkIDecl env (IDataDecl p tc tvs cs) =
->   checkTypeLhs env p tvs &&>
->   liftE (IDataDecl p tc tvs) (mapE (liftMaybe (checkConstrDecl env tvs)) cs)
-> checkIDecl env (INewtypeDecl p tc tvs nc) =
->   checkTypeLhs env p tvs &&>
->   liftE (INewtypeDecl p tc tvs) (checkNewConstrDecl env tvs nc)
-> checkIDecl env (ITypeDecl p tc tvs ty) =
->   checkTypeLhs env p tvs &&>
->   liftE (ITypeDecl p tc tvs) (checkClosedType env p tvs ty)
+> checkIDecl env (HidingDataDecl p tc k tvs) =
+>   do
+>     checkTypeLhs env p [] tvs
+>     return (HidingDataDecl p tc k tvs)
+> checkIDecl env (IDataDecl p cx tc k tvs cs xs) =
+>   do
+>     cx' <- checkTypeLhs env p cx tvs
+>     checkClosedContext p cx' tvs
+>     cs' <- mapE (checkConstrDecl env tvs) cs
+>     checkHiding True p tc (map constr cs ++ nub (concatMap labels cs)) xs
+>     return (IDataDecl p cx' tc k tvs cs' xs)
+> checkIDecl env (INewtypeDecl p cx tc k tvs nc xs) =
+>   do
+>     cx' <- checkTypeLhs env p cx tvs
+>     checkClosedContext p cx' tvs
+>     nc' <- checkNewConstrDecl env tvs nc
+>     checkHiding True p tc (nconstr nc : nlabel nc) xs
+>     return (INewtypeDecl p cx' tc k tvs nc' xs)
+> checkIDecl env (ITypeDecl p tc k tvs ty) =
+>   do
+>     checkTypeLhs env p [] tvs
+>     ty' <- checkClosedType env p tvs ty
+>     return (ITypeDecl p tc k tvs ty')
+> checkIDecl env (HidingClassDecl p cx cls k tv) =
+>   do
+>     cx' <- checkTypeLhs env p cx [tv]
+>     checkClosedContext p cx' [tv]
+>     mapE_ (checkSimpleConstraint "class" doc p) cx'
+>     return (HidingClassDecl p cx' cls k tv)
+>   where doc = ppQIdent cls <+> ppIdent tv
+> checkIDecl env (IClassDecl p cx cls k tv ds fs') =
+>   do
+>     cx' <- checkTypeLhs env p cx [tv]
+>     checkClosedContext p cx' [tv]
+>     ds' <-
+>       mapE_ (checkSimpleConstraint "class" doc p) cx' &&>
+>       mapE (checkIMethodDecl env tv) ds
+>     checkHiding False p cls (map imethod ds) fs'
+>     return (IClassDecl p cx' cls k tv ds' fs')
+>   where doc = ppQIdent cls <+> ppIdent tv
+> checkIDecl env (IInstanceDecl p cx cls ty m fs) =
+>   do
+>     (cx',ty') <- checkClass env p [] cls &&> checkInstType env p cx ty
+>     mapE_ (checkSimpleConstraint "instance" doc p) cx &&>
+>       mapE_ (errorAt p . multipleArity . fst) (duplicates (map fst fs))
+>     return (IInstanceDecl p cx' cls ty' m fs)
+>   where doc = ppQIdent cls <+> ppTypeExpr 2 ty
 > checkIDecl env (IFunctionDecl p f n ty) =
->   liftE (IFunctionDecl p f n) (checkType env p ty)
-
-> checkTypeLhs :: TypeEnv -> Position -> [Ident] -> Error ()
-> checkTypeLhs env p tvs =
->   mapE_ (errorAt p . noVariable) (nub tcs) &&>
->   mapE_ (errorAt p . nonLinear . fst) (duplicates tvs')
->   where (tcs,tvs') = partition isTypeConstr tvs
->         isTypeConstr tv = not (null (lookupTopEnv tv env))
+>   maybe (return ()) (checkArity p) n &&>
+>   liftE (IFunctionDecl p f n) (checkQualType env p ty)
+>   where checkArity p n =
+>           unless (n < toInteger (maxBound::Int)) (errorAt p (arityTooBig n))
+
+> checkTypeLhs :: TypeEnv -> Position -> [ClassAssert] -> [Ident]
+>              -> Error [ClassAssert]
+> checkTypeLhs env p cx tvs =
+>   mapE_ (errorAt p . nonLinear . fst) (duplicates tvs) &&>
+>   mapE (checkClassAssert env p tvs) cx
+
+> checkSimpleConstraint :: String -> Doc -> Position -> ClassAssert -> Error ()
+> checkSimpleConstraint what doc p (ClassAssert cls ty) =
+>   unless (isVariableType ty)
+>          (errorAt p (invalidSimpleConstraint what doc (ClassAssert cls ty)))
 
 > checkConstrDecl :: TypeEnv -> [Ident] -> ConstrDecl -> Error ConstrDecl
-> checkConstrDecl env tvs (ConstrDecl p evs c tys) =
->   checkTypeLhs env p evs &&>
->   liftE (ConstrDecl p evs c) (mapE (checkClosedType env p tvs') tys)
+> checkConstrDecl env tvs (ConstrDecl p evs cx c tys) =
+>   do
+>     cx' <- checkTypeLhs env p cx evs
+>     checkClosedContext p cx' tvs'
+>     tys' <- mapE (checkClosedType env p tvs') tys
+>     return (ConstrDecl p evs cx' c tys')
 >   where tvs' = evs ++ tvs
-> checkConstrDecl env tvs (ConOpDecl p evs ty1 op ty2) =
->   checkTypeLhs env p evs &&>
->   liftE2 (flip (ConOpDecl p evs) op)
->          (checkClosedType env p tvs' ty1)
->          (checkClosedType env p tvs' ty2)
+> checkConstrDecl env tvs (ConOpDecl p evs cx ty1 op ty2) =
+>   do
+>     cx' <- checkTypeLhs env p cx evs
+>     checkClosedContext p cx' tvs'
+>     (ty1',ty2') <-
+>       liftE (,) (checkClosedType env p tvs' ty1) &&&
+>       checkClosedType env p tvs' ty2
+>     return (ConOpDecl p evs cx' ty1' op ty2')
+>   where tvs' = evs ++ tvs
+> checkConstrDecl env tvs (RecordDecl p evs cx c fs) =
+>   do
+>     cx' <- checkTypeLhs env p cx evs
+>     checkClosedContext p cx' tvs'
+>     fs' <- mapE (checkFieldDecl env tvs') fs
+>     return (RecordDecl p evs cx' c fs')
 >   where tvs' = evs ++ tvs
 
+> checkFieldDecl :: TypeEnv -> [Ident] -> FieldDecl -> Error FieldDecl
+> checkFieldDecl env tvs (FieldDecl p ls ty) =
+>   liftE (FieldDecl p ls) (checkClosedType env p tvs ty)
+
 > checkNewConstrDecl :: TypeEnv -> [Ident] -> NewConstrDecl
 >                    -> Error NewConstrDecl
 > checkNewConstrDecl env tvs (NewConstrDecl p c ty) =
 >   liftE (NewConstrDecl p c) (checkClosedType env p tvs ty)
+> checkNewConstrDecl env tvs (NewRecordDecl p c l ty) =
+>   liftE (NewRecordDecl p c l) (checkClosedType env p tvs ty)
+
+> checkIMethodDecl :: TypeEnv -> Ident -> IMethodDecl -> Error IMethodDecl
+> checkIMethodDecl env tv (IMethodDecl p f n ty) =
+>   do
+>     ty' <- checkQualType env p ty
+>     unless (tv `elem` fv ty') (errorAt p (ambiguousType tv))
+>     when (tv `elem` cvars ty') (errorAt p (constrainedClassType tv))
+>     return (IMethodDecl p f n ty')
+>   where cvars (QualTypeExpr cx _) = [cvar ty | ClassAssert _ ty <- cx]
+>         cvar (VariableType tv) = tv
+>         cvar (ApplyType ty _) = cvar ty
 
 > checkClosedType :: TypeEnv -> Position -> [Ident] -> TypeExpr
 >                 -> Error TypeExpr
 > checkClosedType env p tvs ty =
 >   do
->     ty' <- checkType env p ty
+>     ty' <- checkType env p tvs ty
 >     mapE_ (errorAt p . unboundVariable)
 >           (nub (filter (`notElem` tvs) (fv ty')))
 >     return ty'
 
-> checkType :: TypeEnv -> Position -> TypeExpr -> Error TypeExpr
-> checkType env p (ConstructorType tc tys) =
->   liftE2 ($)
->          (case qualLookupTopEnv tc env of
->             []
->               | not (isQualified tc) && null tys ->
->                   return (const (VariableType (unqualify tc)))
->               | otherwise -> errorAt p (undefinedType tc)
->             [Data _ _] -> return (ConstructorType tc)
->             [Alias _] -> errorAt p (badTypeSynonym tc)
->             _ -> internalError "checkType")
->          (mapE (checkType env p) tys)
-> checkType env p (VariableType tv) =
->   checkType env p (ConstructorType (qualify tv) [])
-> checkType env p (TupleType tys) = liftE TupleType (mapE (checkType env p) tys)
-> checkType env p (ListType ty) = liftE ListType (checkType env p ty)
-> checkType env p (ArrowType ty1 ty2) =
->   liftE2 ArrowType (checkType env p ty1) (checkType env p ty2)
+> checkInstType :: TypeEnv -> Position -> [ClassAssert] -> TypeExpr
+>               -> Error ([ClassAssert],TypeExpr)
+> checkInstType env p cx ty =
+>   do
+>     QualTypeExpr cx' ty' <- checkQualType env p (QualTypeExpr cx ty)
+>     unless (isSimpleType ty' && not (isTypeSynonym env (typeConstr ty')) &&
+>             null (duplicates (fv ty')))
+>            (errorAt p (notSimpleType ty'))
+>     return (cx',ty')
+
+> checkQualType :: TypeEnv -> Position -> QualTypeExpr -> Error QualTypeExpr
+> checkQualType env p (QualTypeExpr cx ty) =
+>   do
+>     (cx',ty') <-
+>       liftE (,) (mapE (checkClassAssert env p []) cx) &&&
+>       checkType env p [] ty
+>     checkClosedContext p cx' (fv ty')
+>     return (QualTypeExpr cx' ty')
+
+> checkClassAssert :: TypeEnv -> Position -> [Ident] -> ClassAssert
+>                  -> Error ClassAssert
+> checkClassAssert env p tvs (ClassAssert cls ty) =
+>   do
+>     ty' <- checkClass env p tvs cls &&> checkType env p tvs ty
+>     unless (isVariableType (root ty'))
+>            (errorAt p (invalidConstraint (ClassAssert cls ty')))
+>     return (ClassAssert cls ty')
+>   where root (ApplyType ty _) = root ty
+>         root ty = ty
+
+> checkClosedContext :: Position -> [ClassAssert] -> [Ident] -> Error ()
+> checkClosedContext p cx tvs =
+>   mapE_ (errorAt p . unboundVariable) (nub (filter (`notElem` tvs) (fv cx)))
+
+> checkType :: TypeEnv -> Position -> [Ident] -> TypeExpr -> Error TypeExpr
+> checkType env p tvs (ConstructorType tc)
+>   | tc `elem` map qualify tvs = return (VariableType (unqualify tc))
+>   | otherwise =
+>       case qualLookupTopEnv tc env of
+>         []
+>           | isPrimTypeId tc' -> return (ConstructorType tc)
+>           | isQualified tc -> errorAt p (undefinedType tc)
+>           | otherwise -> return (VariableType tc')
+>           where tc' = unqualify tc
+>         [Data _ _] -> return (ConstructorType tc)
+>         [Alias _] -> errorAt p (badTypeSynonym tc)
+>         [Class _ _] -> errorAt p (undefinedType tc)
+>         _ -> internalError "checkType"
+> checkType env p tvs (VariableType tv)
+>   | tv `elem` tvs = return (VariableType tv)
+>   | otherwise = checkType env p tvs (ConstructorType (qualify tv))
+> checkType env p tvs (TupleType tys) =
+>   liftE TupleType (mapE (checkType env p tvs) tys)
+> checkType env p tvs (ListType ty) = liftE ListType (checkType env p tvs ty)
+> checkType env p tvs (ArrowType ty1 ty2) =
+>   liftE2 ArrowType (checkType env p tvs ty1) (checkType env p tvs ty2)
+> checkType env p tvs (ApplyType ty1 ty2) =
+>   liftE2 ApplyType (checkType env p tvs ty1) (checkType env p tvs ty2)
+
+> checkClass :: TypeEnv -> Position -> [Ident] -> QualIdent -> Error ()
+> checkClass env p tvs cls
+>   | cls `elem` map qualify tvs = errorAt p (undefinedClass cls)
+>   | otherwise =
+>       case qualLookupTopEnv cls env of
+>         [] -> errorAt p (undefinedClass cls)
+>         [Data _ _] -> errorAt p (undefinedClass cls)
+>         [Alias _] -> errorAt p (undefinedClass cls)
+>         [Class _ _] -> return ()
+>         _ -> internalError "checkClass"
+
+> checkHiding :: Bool -> Position -> QualIdent -> [Ident] -> [Ident] -> Error ()
+> checkHiding isType p tc xs xs' =
+>   mapE_ (errorAt p . noElement isType tc) (nub (filter (`notElem` xs) xs'))
 
 \end{verbatim}
 \ToDo{Much of the above code could be shared with module
@@ -125,9 +252,13 @@
 Auxiliary functions.
 \begin{verbatim}
 
-> liftMaybe :: Monad m => (a -> m b) -> Maybe a -> m (Maybe b)
-> liftMaybe f (Just x) = liftM Just (f x)
-> liftMaybe f Nothing = return Nothing
+> isTypeSynonym :: TypeEnv -> QualIdent -> Bool
+> isTypeSynonym env tc =
+>   case qualLookupTopEnv tc env of
+>     [] | isPrimTypeId (unqualify tc) -> False
+>     [Data _ _] -> False
+>     [Alias _] -> True
+>     _ -> internalError "isTypeSynonym"
 
 \end{verbatim}
 Error messages.
@@ -136,15 +267,24 @@
 > undefinedType :: QualIdent -> String
 > undefinedType tc = "Undefined type " ++ qualName tc
 
+> undefinedClass :: QualIdent -> String
+> undefinedClass cls = "Undefined type class " ++ qualName cls
+
+> multipleArity :: Ident -> String
+> multipleArity f =
+>   "Method " ++ name f ++ " occurs more than once in ARITY pragma"
+
 > nonLinear :: Ident -> String
 > nonLinear tv =
 >   "Type variable " ++ name tv ++
 >   " occurs more than once on left hand side of type declaration"
 
-> noVariable :: Ident -> String
-> noVariable tv =
->   "Type constructor " ++ name tv ++
->   " used in left hand side of type declaration"
+> noElement :: Bool -> QualIdent -> Ident -> String
+> noElement True tc x =
+>   "Hidden constructor or label " ++ name x ++ " is not defined for type " ++
+>   qualName tc
+> noElement False cls f =
+>   "Hidden method " ++ name f ++ " is not defined for class " ++ qualName cls
 
 > unboundVariable :: Ident -> String
 > unboundVariable tv = "Undefined type variable " ++ name tv
@@ -152,4 +292,35 @@
 > badTypeSynonym :: QualIdent -> String
 > badTypeSynonym tc = "Synonym type " ++ qualName tc ++ " in interface"
 
+> ambiguousType :: Ident -> String
+> ambiguousType tv =
+>   "Method type does not mention type variable " ++ name tv
+
+> constrainedClassType :: Ident -> String
+> constrainedClassType tv =
+>   "Method type context must not constrain type variable " ++ name tv
+
+> invalidSimpleConstraint :: String -> Doc -> ClassAssert -> String
+> invalidSimpleConstraint what doc ca = show $
+>   vcat [text "Illegal class constraint" <+> ppClassAssert ca,
+>         text "in" <+> text what <+> text "declaration" <+> doc,
+>         text "Constraints in class and instance declarations must be of the",
+>         text "form C u, where u is a type variable."]
+
+> invalidConstraint :: ClassAssert -> String
+> invalidConstraint ca = show $
+>   vcat [text "Illegal class constraint" <+> ppClassAssert ca,
+>         text "Constraints must be of the form C u or C (u t1 ... tn),",
+>         text "where u is a type variable and t1, ..., tn are types."]
+
+> notSimpleType :: TypeExpr -> String
+> notSimpleType ty = show $
+>   vcat [text "Illegal instance type" <+> ppTypeExpr 0 ty,
+>         text "The instance type must be of the form (T u1 ... un),",
+>         text "where T is not a type synonym and u1, ..., un are",
+>         text "mutually distinct type variables."]
+
+> arityTooBig :: Integer -> String
+> arityTooBig n = "Function arity out of range: " ++ show n
+
 \end{verbatim}
diff -u curry-0.9.11/KindCheck.lhs curry-0.9.11-classful/KindCheck.lhs
--- curry-0.9.11/KindCheck.lhs	2007-06-15 14:16:34.000000000 +0200
+++ curry-0.9.11-classful/KindCheck.lhs	2011-10-08 12:42:57.000000000 +0200
@@ -1,209 +1,620 @@
 % -*- LaTeX -*-
-% $Id: KindCheck.lhs 2101 2007-02-21 16:25:07Z wlux $
+% $Id: KindCheck.lhs 3056 2011-10-07 16:27:03Z wlux $
 %
-% Copyright (c) 1999-2007, Wolfgang Lux
+% Copyright (c) 1999-2011, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{KindCheck.lhs}
 \section{Kind Checking}
-Before type checking starts, the compiler applies kind checking to the
-type expressions in the current module. Because Curry currently does
-not support type classes, all types must be of first order kind
-($\star$).  This makes kind checking in Curry rather trivial; the
-compiler must only ensure that all type constructor applications are
-saturated.
+Before type checking, the compiler infers kinds for all type
+constructors and type classes defined in the current module and
+applies kind checking to the module's type signatures.
 \begin{verbatim}
 
 > module KindCheck(kindCheck,kindCheckGoal) where
 > import Base
+> import Combined
+> import Curry
 > import CurryPP
+> import CurryUtils
 > import Error
+> import Kinds
+> import KindSubst
+> import KindTrans
+> import List
 > import Monad
+> import PredefIdent
 > import Pretty
 > import SCC
 > import TopEnv
+> import Types
+> import TypeInfo
 > import TypeTrans
 
+> infixl 5 $-$
+
+> ($-$) :: Doc -> Doc -> Doc
+> x $-$ y = x $$ space $$ y
+
 \end{verbatim}
-Before checking the type expressions of a module, the compiler adds
-the types defined in the current module to the type constructor
-environment and ensures that the module contains no (mutually)
-recursive type synonyms, which are not allowed in Curry and could lead
-to non-termination during their expansion.
+In order to infer kinds for type constructors and type classes, the
+compiler first sorts the module's type and class declarations into
+minimal recursive binding groups and then applies kind inference to
+each declaration group in turn. Besides inferring kinds for the type
+constructors and type classes of a group, the compiler also checks
+that there are no mutually recursive type synonym definitions and that
+the super class hierarchy is acyclic. The former allows entering fully
+expanded type synonyms into the type environment.
 \begin{verbatim}
 
-> kindCheck :: ModuleIdent -> TCEnv -> [TopDecl] -> Error TCEnv
+> kindCheck :: ModuleIdent -> TCEnv -> [TopDecl a] -> Error TCEnv
 > kindCheck m tcEnv ds =
 >   do
->     checkSynonynms m tds
->     let tcEnv' = bindTypes m tds tcEnv
->     mapE_ (checkTopDecl tcEnv') ds
+>     checkSynonyms m ds &&> checkSuperClasses m ds
+>     tcEnv' <- foldM (kcDeclGroup m) tcEnv (scc bt (ft m) tds)
+>     mapE_ (run . kcTopDecl m tcEnv') ods
 >     return tcEnv'
->   where tds = filter isTypeDecl ds
+>   where (tds,ods) = partition isTypeDecl ds
 
 \end{verbatim}
 Kind checking of a goal is simpler because there are no type
 declarations.
 \begin{verbatim}
 
-> kindCheckGoal :: TCEnv -> Goal -> Error ()
-> kindCheckGoal tcEnv (Goal p e ds) =
->   checkExpr tcEnv p e &&> mapE_ (checkDecl tcEnv) ds
+> kindCheckGoal :: TCEnv -> Goal a -> Error ()
+> kindCheckGoal tcEnv g = run $ kcGoal tcEnv g
+
+\end{verbatim}
+The kind checker uses a nested state transformer monad in order to
+maintain the current substitution during kind inference and in order
+to generate fresh kind variables.
+\begin{verbatim}
+
+> type KcState a = StateT KindSubst (StateT Int Error) a
+
+> run :: KcState a -> Error a
+> run m = callSt (callSt m idSubst) 1
+
+\end{verbatim}
+Minimal recursive declaration groups are computed using the sets of
+bound and free type constructor and type class identifiers of the
+declarations.
+\begin{verbatim}
+
+> bt :: TopDecl a -> [Ident]
+> bt (DataDecl _ _ tc _ _ _) = [tc]
+> bt (NewtypeDecl _ _ tc _ _ _) = [tc]
+> bt (TypeDecl _ tc _ _) = [tc]
+> bt (ClassDecl _ _ cls _ _) = [cls]
+> bt (InstanceDecl _ _ _ _ _) = []
+> bt (DefaultDecl _ tys) = []
+> bt (BlockDecl _) = []
+
+> ft :: ModuleIdent -> TopDecl a -> [Ident]
+> ft m d = fts m d []
+
+> class HasType a where
+>   fts :: ModuleIdent -> a -> [Ident] -> [Ident]
+
+> instance HasType a => HasType [a] where
+>   fts m xs tcs = foldr (fts m) tcs xs
+
+> instance HasType (TopDecl a) where
+>   fts m (DataDecl _ cx _ _ cs clss) = fts m cx . fts m cs . fts m clss
+>   fts m (NewtypeDecl _ cx _ _ nc clss) = fts m cx . fts m nc . fts m clss
+>   fts m (TypeDecl _ _ _ ty) = fts m ty
+>   fts m (ClassDecl _ cx _ _ ds) = fts m cx . fts m ds
+>   fts m (InstanceDecl _ cx cls ty ds) =
+>     fts m cx . fts m cls . fts m ty . fts m ds
+>   fts m (DefaultDecl _ tys) = fts m tys
+>   fts m (BlockDecl d) = fts m d
+
+> instance HasType DClass where
+>   fts m (DClass _ cls) = fts m cls
+
+> instance HasType ConstrDecl where
+>   fts m (ConstrDecl _ _ cx _ tys) = fts m cx . fts m tys
+>   fts m (ConOpDecl _ _ cx ty1 _ ty2) = fts m cx . fts m ty1 . fts m ty2
+>   fts m (RecordDecl _ _ cx _ fs) = fts m cx . fts m fs
+
+> instance HasType FieldDecl where
+>   fts m (FieldDecl _ _ ty) = fts m ty
+
+> instance HasType NewConstrDecl where
+>   fts m (NewConstrDecl _ _ ty) = fts m ty
+>   fts m (NewRecordDecl _ _ _ ty) = fts m ty
+
+> instance HasType (Decl a) where
+>   fts _ (InfixDecl _ _ _ _) = id
+>   fts m (TypeSig _ _ ty) = fts m ty
+>   fts m (FunctionDecl _ _ _ eqs) = fts m eqs
+>   fts m (ForeignDecl _ _ _ _ ty) = fts m ty
+>   fts m (PatternDecl _ _ rhs) = fts m rhs
+>   fts m (FreeDecl _ _) = id
+>   fts _ (TrustAnnot _ _ _) = id
+
+> instance HasType ClassAssert where
+>   fts m (ClassAssert cls ty) = fts m cls . fts m ty
+
+> instance HasType QualTypeExpr where
+>   fts m (QualTypeExpr cx ty) = fts m cx . fts m ty
+
+> instance HasType TypeExpr where
+>   fts m (ConstructorType tc) = fts m tc
+>   fts _ (VariableType _) = id
+>   fts m (TupleType tys) = (tupleId (length tys) :) . fts m tys
+>   fts m (ListType ty) = (listId :) . fts m ty
+>   fts m (ArrowType ty1 ty2) = (arrowId :) . fts m ty1 . fts m ty2
+>   fts m (ApplyType ty1 ty2) = fts m ty1 . fts m ty2
+
+> instance HasType (Equation a) where
+>   fts m (Equation _ _ rhs) = fts m rhs
+
+> instance HasType (Rhs a) where
+>   fts m (SimpleRhs _ e ds) = fts m e . fts m ds
+>   fts m (GuardedRhs es ds) = fts m es . fts m ds
+
+> instance HasType (CondExpr a) where
+>   fts m (CondExpr _ g e) = fts m g . fts m e
+
+> instance HasType (Expression a) where
+>   fts _ (Literal _ _) = id
+>   fts _ (Variable _ _) = id
+>   fts _ (Constructor _ _) = id
+>   fts m (Paren e) = fts m e
+>   fts m (Typed e ty) = fts m e . fts m ty
+>   fts m (Record _ _ fs) = fts m fs
+>   fts m (RecordUpdate e fs) = fts m e . fts m fs
+>   fts m (Tuple es) = fts m es
+>   fts m (List _ es) = fts m es
+>   fts m (ListCompr e qs) = fts m e . fts m qs
+>   fts m (EnumFrom e) = fts m e
+>   fts m (EnumFromThen e1 e2) = fts m e1 . fts m e2
+>   fts m (EnumFromTo e1 e2) = fts m e1 . fts m e2
+>   fts m (EnumFromThenTo e1 e2 e3) = fts m e1 . fts m e2 . fts m e3
+>   fts m (UnaryMinus e) = fts m e
+>   fts m (Apply e1 e2) = fts m e1 . fts m e2
+>   fts m (InfixApply e1 _ e2) = fts m e1 . fts m e2
+>   fts m (LeftSection e _) = fts m e
+>   fts m (RightSection _ e) = fts m e
+>   fts m (Lambda _ _ e) = fts m e
+>   fts m (Let ds e) = fts m ds . fts m e
+>   fts m (Do sts e) = fts m sts . fts m e
+>   fts m (IfThenElse e1 e2 e3) = fts m e1 . fts m e2 . fts m e3
+>   fts m (Case e as) = fts m e . fts m as
+>   fts m (Fcase e as) = fts m e . fts m as
+
+> instance HasType (Statement a) where
+>   fts m (StmtExpr e) = fts m e
+>   fts m (StmtBind _ _ e) = fts m e
+>   fts m (StmtDecl ds) = fts m ds
+
+> instance HasType (Alt a) where
+>   fts m (Alt _ _ rhs) = fts m rhs
+
+> instance HasType a => HasType (Field a) where
+>   fts m (Field _ x) = fts m x
+
+> instance HasType QualIdent where
+>   fts m x = maybe id (:) (localIdent m x)
 
 \end{verbatim}
 When synonym types are entered into the type environment, their right
 hand sides are already fully expanded. This is possible because Curry
-does not allow (mutually) recursive type synonyms, which is checked by
-function \texttt{checkSynonyms} below.
+does not allow (mutually) recursive type synonyms, which is checked in
+function \texttt{checkSynonyms} below. In addition, the compiler
+checks that the super class hierarchy is acyclic (in function
+\texttt{checkSuperClasses}).
+\begin{verbatim}
 
-Note that \texttt{bindTC} is passed the \emph{final} type constructor
-environment so that we do not need to pass the declarations to this
-function in any particular order.
-\begin{verbatim}
-
-> bindTypes :: ModuleIdent -> [TopDecl] -> TCEnv -> TCEnv
-> bindTypes m ds tcEnv = tcEnv'
->   where tcEnv' = foldr (bindTC m tcEnv') tcEnv ds
-
-> bindTC :: ModuleIdent -> TCEnv -> TopDecl -> TCEnv -> TCEnv
-> bindTC m _ (DataDecl _ tc tvs cs) =
->   globalBindTopEnv m tc (typeCon DataType m tc tvs (map (Just . constr) cs))
-> bindTC m _ (NewtypeDecl _ tc tvs (NewConstrDecl _ c _)) =
->   globalBindTopEnv m tc (typeCon RenamingType m tc tvs c)
-> bindTC m tcEnv (TypeDecl _ tc tvs ty) =
->   globalBindTopEnv m tc
->                    (typeCon AliasType m tc tvs (expandMonoType tcEnv tvs ty))
-> bindTC _ _ (BlockDecl _) = id
-
-> checkSynonynms :: ModuleIdent -> [TopDecl] -> Error ()
-> checkSynonynms m = mapE_ (typeDecl m) . scc bound free
->   where bound (DataDecl _ tc _ _) = [tc]
->         bound (NewtypeDecl _ tc _ _) = [tc]
+> checkSynonyms :: ModuleIdent -> [TopDecl a] -> Error ()
+> checkSynonyms m = mapE_ (typeDecl m) . scc bound free . filter isTypeDecl
+>   where isTypeDecl (TypeDecl _ _ _ _) = True
+>         isTypeDecl _ = False
 >         bound (TypeDecl _ tc _ _) = [tc]
->         bound (BlockDecl _) = []
->         free (DataDecl _ _ _ _) = []
->         free (NewtypeDecl _ _ _ _) = []
->         free (TypeDecl _ _ _ ty) = ft m ty []
->         free (BlockDecl _) = []
+>         free (TypeDecl _ _ _ ty) = fts m ty []
 
-> typeDecl :: ModuleIdent -> [TopDecl] -> Error ()
+> typeDecl :: ModuleIdent -> [TopDecl a] -> Error ()
 > typeDecl _ [] = internalError "typeDecl"
-> typeDecl _ [DataDecl _ _ _ _] = return ()
-> typeDecl _ [NewtypeDecl _ _ _ _] = return ()
 > typeDecl m [TypeDecl p tc _ ty]
->   | tc `elem` ft m ty [] = errorAt p (recursiveTypes [tc])
+>   | tc `elem` fts m ty [] = errorAt p (recursiveTypes [tc])
 >   | otherwise = return ()
 > typeDecl _ (TypeDecl p tc _ _ : ds) =
 >   errorAt p (recursiveTypes (tc : [tc' | TypeDecl _ tc' _ _ <- ds]))
 
-> ft :: ModuleIdent -> TypeExpr -> [Ident] -> [Ident]
-> ft m (ConstructorType tc tys) tcs =
->   maybe id (:) (localIdent m tc) (foldr (ft m) tcs tys)
-> ft _ (VariableType _) tcs = tcs
-> ft m (TupleType tys) tcs = foldr (ft m) tcs tys
-> ft m (ListType ty) tcs = ft m ty tcs
-> ft m (ArrowType ty1 ty2) tcs = ft m ty1 $ ft m ty2 $ tcs
-
-\end{verbatim}
-Kind checking is applied to all type expressions in the program.
-\begin{verbatim}
-
-> checkTopDecl :: TCEnv -> TopDecl -> Error ()
-> checkTopDecl tcEnv (DataDecl _ _ _ cs) = mapE_ (checkConstrDecl tcEnv) cs
-> checkTopDecl tcEnv (NewtypeDecl _ _ _ nc) = checkNewConstrDecl tcEnv nc
-> checkTopDecl tcEnv (TypeDecl p _ _ ty) = checkType tcEnv p ty
-> checkTopDecl tcEnv (BlockDecl d) = checkDecl tcEnv d
-
-> checkDecl :: TCEnv -> Decl -> Error ()
-> checkDecl _ (InfixDecl _ _ _ _) = return ()
-> checkDecl tcEnv (TypeSig p _ ty) = checkType tcEnv p ty
-> checkDecl tcEnv (FunctionDecl _ _ eqs) = mapE_ (checkEquation tcEnv) eqs
-> checkDecl tcEnv (ForeignDecl p _ _ _ _ ty) = checkType tcEnv p ty
-> checkDecl tcEnv (PatternDecl _ _ rhs) = checkRhs tcEnv rhs
-> checkDecl _ (FreeDecl _ _) = return ()
-> checkDecl _ (TrustAnnot _ _ _) = return ()
-
-> checkConstrDecl :: TCEnv -> ConstrDecl -> Error ()
-> checkConstrDecl tcEnv (ConstrDecl p _ _ tys) = mapE_ (checkType tcEnv p) tys
-> checkConstrDecl tcEnv (ConOpDecl p _ ty1 _ ty2) =
->   checkType tcEnv p ty1 &&> checkType tcEnv p ty2
-
-> checkNewConstrDecl :: TCEnv -> NewConstrDecl -> Error ()
-> checkNewConstrDecl tcEnv (NewConstrDecl p _ ty) = checkType tcEnv p ty
-
-> checkEquation :: TCEnv -> Equation -> Error ()
-> checkEquation tcEnv (Equation _ _ rhs) = checkRhs tcEnv rhs
-
-> checkRhs :: TCEnv -> Rhs -> Error ()
-> checkRhs tcEnv (SimpleRhs p e ds) =
->   checkExpr tcEnv p e &&> mapE_ (checkDecl tcEnv) ds
-> checkRhs tcEnv (GuardedRhs es ds) =
->   mapE_ (checkCondExpr tcEnv) es &&> mapE_ (checkDecl tcEnv) ds
-
-> checkCondExpr :: TCEnv -> CondExpr -> Error ()
-> checkCondExpr tcEnv (CondExpr p g e) =
->   checkExpr tcEnv p g &&> checkExpr tcEnv p e
-
-> checkExpr :: TCEnv -> Position -> Expression -> Error ()
-> checkExpr _ _ (Literal _) = return ()
-> checkExpr _ _ (Variable _) = return ()
-> checkExpr _ _ (Constructor _) = return ()
-> checkExpr tcEnv p (Paren e) = checkExpr tcEnv p e
-> checkExpr tcEnv p (Typed e ty) = checkExpr tcEnv p e &&> checkType tcEnv p ty
-> checkExpr tcEnv p (Tuple es) = mapE_ (checkExpr tcEnv p) es
-> checkExpr tcEnv p (List es) = mapE_ (checkExpr tcEnv p) es
-> checkExpr tcEnv p (ListCompr e qs) =
->   checkExpr tcEnv p e &&> mapE_ (checkStmt tcEnv p) qs
-> checkExpr tcEnv p (EnumFrom e) = checkExpr tcEnv p e
-> checkExpr tcEnv p (EnumFromThen e1 e2) =
->   checkExpr tcEnv p e1 &&> checkExpr tcEnv p e2
-> checkExpr tcEnv p (EnumFromTo e1 e2) =
->   checkExpr tcEnv p e1 &&> checkExpr tcEnv p e2
-> checkExpr tcEnv p (EnumFromThenTo e1 e2 e3) =
->   checkExpr tcEnv p e1 &&> checkExpr tcEnv p e2 &&> checkExpr tcEnv p e3
-> checkExpr tcEnv p (UnaryMinus _ e) = checkExpr tcEnv p e
-> checkExpr tcEnv p (Apply e1 e2) =
->   checkExpr tcEnv p e1 &&> checkExpr tcEnv p e2
-> checkExpr tcEnv p (InfixApply e1 _ e2) =
->   checkExpr tcEnv p e1 &&> checkExpr tcEnv p e2
-> checkExpr tcEnv p (LeftSection e _) = checkExpr tcEnv p e
-> checkExpr tcEnv p (RightSection _ e) = checkExpr tcEnv p e
-> checkExpr tcEnv p (Lambda _ e) = checkExpr tcEnv p e
-> checkExpr tcEnv p (Let ds e) =
->   mapE_ (checkDecl tcEnv) ds &&> checkExpr tcEnv p e
-> checkExpr tcEnv p (Do sts e) =
->   mapE_ (checkStmt tcEnv p) sts &&> checkExpr tcEnv p e
-> checkExpr tcEnv p (IfThenElse e1 e2 e3) =
->   checkExpr tcEnv p e1 &&> checkExpr tcEnv p e2 &&> checkExpr tcEnv p e3
-> checkExpr tcEnv p (Case e alts) =
->   checkExpr tcEnv p e &&> mapE_ (checkAlt tcEnv) alts
-
-> checkStmt :: TCEnv -> Position -> Statement -> Error ()
-> checkStmt tcEnv p (StmtExpr e) = checkExpr tcEnv p e
-> checkStmt tcEnv p (StmtBind _ e) = checkExpr tcEnv p e
-> checkStmt tcEnv _ (StmtDecl ds) = mapE_ (checkDecl tcEnv) ds
-
-> checkAlt :: TCEnv -> Alt -> Error ()
-> checkAlt tcEnv (Alt _ _ rhs) = checkRhs tcEnv rhs
-
-> checkType :: TCEnv -> Position -> TypeExpr -> Error ()
-> checkType tcEnv p (ConstructorType tc tys) =
->   unless (n == n') (errorAt p (wrongArity tc n n')) &&>
->   mapE_ (checkType tcEnv p) tys
->   where n = constrKind tc tcEnv
->         n' = length tys
-> checkType _ _ (VariableType _) = return ()
-> checkType tcEnv p (TupleType tys) = mapE_ (checkType tcEnv p) tys
-> checkType tcEnv p (ListType ty) = checkType tcEnv p ty
-> checkType tcEnv p (ArrowType ty1 ty2) =
->   checkType tcEnv p ty1 &&> checkType tcEnv p ty2
+> checkSuperClasses :: ModuleIdent -> [TopDecl a] -> Error ()
+> checkSuperClasses m =
+>   mapE_ (classDecl m) . scc bound free . filter isClassDecl
+>   where bound (ClassDecl _ _ cls _ _) = [cls]
+>         free (ClassDecl _ cx _ _ _) = fc m cx
+
+> classDecl :: ModuleIdent -> [TopDecl a] -> Error ()
+> classDecl _ [] = internalError "classDecl"
+> classDecl m [ClassDecl p cx cls _ _]
+>   | cls `elem` fc m cx = errorAt p (recursiveClasses [cls])
+>   | otherwise = return ()
+> classDecl _ (ClassDecl p _ cls _ _ : ds) =
+>   errorAt p (recursiveClasses (cls : [cls' | ClassDecl _ _ cls' _ _ <- ds]))
+> classDecl _ [d] = return ()
+
+> fc :: ModuleIdent -> [ClassAssert] -> [Ident]
+> fc m = foldr (\(ClassAssert cls _) -> maybe id (:) (localIdent m cls)) []
 
 \end{verbatim}
-Auxiliary functions.
+For each declaration group, the kind checker first enters new
+assumptions into the type environment. For a type constructor with
+arity $n$, we enter kind $k_1 \rightarrow \dots \rightarrow k_n
+\rightarrow k$, where $k_i$ are fresh type variables and $k$ is
+$\star$ for data and newtype type constructors and a fresh type
+variable for type synonym type constructors. For a type class we enter
+kind $k$, where $k$ is a fresh type variable. Next, the kind checker
+checks the declarations of the group within the extended environment,
+and finally the kind checker instantiates all free kind variables to
+$\star$ (cf.\ Sect.~4.6 of the revised Haskell'98
+report~\cite{PeytonJones03:Haskell}).
+
+As noted above, type synonyms are fully expanded while they are
+entered into the type environment. Unfortunately, this requires either
+sorting type synonym declarations properly or using the final type
+environment for the expansion. We have chosen the latter option here.
+Since recursive monadic bindings are not part of Haskell'98, we cannot
+insert the correct alias type expansions in \texttt{bindKind}, but
+have to do it while instantiating the remaining kind variables in
+\texttt{bindDefaultKind}.
+
+\ToDo{Simplify the implementation of \texttt{bindDefaultKind}. For
+  instance, one could separate the conversion into the internal type
+  representation and the expansion of aliases. Maybe one could even
+  avoid alias expansion here and perform it on the fly during type
+  inference. Using expanded alias types and mixing type conversion
+  with alias expansion is just a relict from earlier compiler versions
+  where the compiler could look up the definitions of only those type
+  identifiers during type inference which are visible in the source
+  code.}
 \begin{verbatim}
 
-> typeCon :: (QualIdent -> Int -> a) -> ModuleIdent -> Ident -> [Ident] -> a
-> typeCon f m tc tvs = f (qualifyWith m tc) (length tvs)
+> kcDeclGroup :: ModuleIdent -> TCEnv -> [TopDecl a] -> Error TCEnv
+> kcDeclGroup m tcEnv ds = run $
+>   do
+>     tcEnv' <- foldM (bindKind m) tcEnv ds
+>     mapM_ (kcTopDecl m tcEnv') ds
+>     theta <- fetchSt
+>     return (bindDefaultKinds m (fmap (subst theta) tcEnv') ds)
+>   where ts = concatMap bt ds
+>         bindDefaultKinds m tcEnv ds = tcEnv'
+>           where tcEnv' = foldr (bindDefaultKind m tcEnv') tcEnv ds
+
+> bindKind :: ModuleIdent -> TCEnv -> TopDecl a -> KcState TCEnv
+> bindKind m tcEnv (DataDecl _ _ tc tvs cs _) =
+>   bindTypeCon DataType m tc tvs (Just KindStar) (map constr cs) tcEnv
+> bindKind m tcEnv (NewtypeDecl _ _ tc tvs nc _) =
+>   bindTypeCon RenamingType m tc tvs (Just KindStar) (nconstr nc) tcEnv
+> bindKind m tcEnv (TypeDecl _ tc tvs ty) =
+>   bindTypeCon (flip AliasType (length tvs)) m tc tvs Nothing
+>               (expandMonoType tcEnv tvs ty) tcEnv
+> bindKind m tcEnv (ClassDecl _ cx cls tv ds) =
+>   bindTypeClass m cls clss (concatMap methods ds) tcEnv
+>   where QualType cx' _ =
+>           expandPolyType tcEnv (QualTypeExpr cx (VariableType tv))
+>         clss = [cls | TypePred cls _ <- cx']
+> bindKind _ tcEnv (InstanceDecl _ _ _ _ _) = return tcEnv
+> bindKind _ tcEnv (DefaultDecl _ _) = return tcEnv
+> bindKind _ tcEnv (BlockDecl _) = return tcEnv
+
+> bindTypeCon :: (QualIdent -> Kind -> a -> TypeInfo) -> ModuleIdent -> Ident
+>             -> [Ident] -> Maybe Kind -> a -> TCEnv -> KcState TCEnv
+> bindTypeCon f m tc tvs k x tcEnv =
+>   do
+>     k' <- maybe freshKindVar return k
+>     ks <- mapM (const freshKindVar) tvs
+>     return (globalBindTopEnv m tc (f tc' (foldr KindArrow k' ks) x) tcEnv)
+>   where tc' = qualifyWith m tc
+
+> bindTypeClass :: ModuleIdent -> Ident -> [QualIdent] -> [Ident] -> TCEnv
+>               -> KcState TCEnv
+> bindTypeClass m cls clss fs tcEnv =
+>   do
+>     k <- freshKindVar
+>     return (globalBindTopEnv m cls (TypeClass cls' k clss fs') tcEnv)
+>   where cls' = qualifyWith m cls
+>         fs' = [(f,0) | f <- fs]
+
+> bindDefaultKind :: ModuleIdent -> TCEnv -> TopDecl a -> TCEnv -> TCEnv
+> bindDefaultKind m _ (DataDecl _ _ tc _ _ _) tcEnv =
+>   case lookupTopEnv tc tcEnv of
+>     DataType tc' k cs : _ ->
+>       globalRebindTopEnv m tc (DataType tc' (defaultKind k) cs) tcEnv
+>     _ -> internalError "bindDefaultKind (DataDecl)"
+> bindDefaultKind m _ (NewtypeDecl _ _ tc _ _ _) tcEnv =
+>   case lookupTopEnv tc tcEnv of
+>     RenamingType tc' k nc : _ ->
+>       globalRebindTopEnv m tc (RenamingType tc' (defaultKind k) nc) tcEnv
+>     _ -> internalError "bindDefaultKind (RenamingDecl)"
+> bindDefaultKind m tcEnv' (TypeDecl _ tc tvs ty) tcEnv =
+>   case lookupTopEnv tc tcEnv of
+>     AliasType tc' n k _ : _ ->
+>       globalRebindTopEnv m tc (AliasType tc' n (defaultKind k) ty') tcEnv
+>     _ -> internalError "bindDefaultKind (TypeDecl)"
+>   where ty' = expandMonoType tcEnv' tvs ty
+> bindDefaultKind m _ (ClassDecl _ _ cls _ _) tcEnv =
+>   case lookupTopEnv cls tcEnv of
+>     TypeClass cls' k clss fs : _ ->
+>       globalRebindTopEnv m cls (TypeClass cls' (defaultKind k) clss fs) tcEnv
+>     _ -> internalError "bindDefaultKind (ClassDecl)"
+> bindDefaultKind _ _ (InstanceDecl _ _ _ _ _) tcEnv = tcEnv
+> bindDefaultKind _ _ (DefaultDecl _ _) tcEnv = tcEnv
+> bindDefaultKind _ _ (BlockDecl _) tcEnv = tcEnv
+
+\end{verbatim}
+After adding new assumptions to the environment, kind inference is
+applied to all declarations. The type environment is extended
+temporarily with bindings for the type variables occurring in the left
+hand side of type declarations and the free type variables of type
+signatures. While the kinds of the former are determined already by
+the kinds of their type constructors and type classes, respectively
+(see \texttt{bindKind} above), fresh kind variables are added for the
+latter. Obviously, all types specified in a default declaration must
+have kind $\star$.
+\begin{verbatim}
+
+> kcTopDecl :: ModuleIdent -> TCEnv -> TopDecl a -> KcState ()
+> kcTopDecl m tcEnv (DataDecl p cx tc tvs cs _) =
+>   kcContext tcEnv' p cx >> mapM_ (kcConstrDecl tcEnv') cs
+>   where tcEnv' = snd (bindTypeVars m tc tvs tcEnv)
+> kcTopDecl m tcEnv (NewtypeDecl p cx tc tvs nc _) =
+>   kcContext tcEnv' p cx >> kcNewConstrDecl tcEnv' nc
+>   where tcEnv' = snd (bindTypeVars m tc tvs tcEnv)
+> kcTopDecl m tcEnv (TypeDecl p tc tvs ty) =
+>   kcType tcEnv' p "type declaration" (ppTopDecl (TypeDecl p tc tvs ty)) k ty
+>   where (k,tcEnv') = bindTypeVars m tc tvs tcEnv
+> kcTopDecl m tcEnv (ClassDecl p cx cls tv ds) =
+>   kcContext tcEnv' p cx >> mapM_ (kcDecl tcEnv' [tv]) ds
+>   where tcEnv' = bindTypeVar tv (classKind (qualifyWith m cls) tcEnv) tcEnv
+> kcTopDecl _ tcEnv (InstanceDecl p cx cls ty ds) =
+>   do
+>     tcEnv' <- foldM bindFreshKind tcEnv (fv ty)
+>     kcContext tcEnv' p cx
+>     kcType tcEnv' p "instance declaration" doc (classKind cls tcEnv) ty
+>     mapM_ (kcDecl tcEnv []) ds
+>   where doc = ppTopDecl (InstanceDecl p cx cls ty [])
+> kcTopDecl _ tcEnv (DefaultDecl p tys) =
+>   do
+>     tcEnv' <- foldM bindFreshKind tcEnv (nub (fv tys))
+>     mapM_ (kcValueType tcEnv' p "default declaration" empty) tys
+> kcTopDecl _ tcEnv (BlockDecl d) = kcDecl tcEnv [] d
+
+> bindTypeVars :: ModuleIdent -> Ident -> [Ident] -> TCEnv -> (Kind,TCEnv)
+> bindTypeVars m tc tvs tcEnv =
+>   foldl (\(KindArrow k1 k2,tcEnv) tv -> (k2,bindTypeVar tv k1 tcEnv))
+>         (constrKind (qualifyWith m tc) tcEnv,tcEnv)
+>         tvs
+
+> bindTypeVar :: Ident -> Kind -> TCEnv -> TCEnv
+> bindTypeVar tv k = localBindTopEnv tv (TypeVar k)
+
+> bindFreshKind :: TCEnv -> Ident -> KcState TCEnv
+> bindFreshKind tcEnv tv =
+>   do
+>     k <- freshKindVar
+>     return (bindTypeVar tv k tcEnv)
+
+> kcGoal :: TCEnv -> Goal a -> KcState ()
+> kcGoal tcEnv (Goal p e ds) = kcExpr tcEnv p e >> mapM_ (kcDecl tcEnv []) ds
+
+> kcDecl :: TCEnv -> [Ident] -> Decl a -> KcState ()
+> kcDecl _ _ (InfixDecl _ _ _ _) = return ()
+> kcDecl tcEnv tvs (TypeSig p _ ty) = kcTypeSig tcEnv tvs p ty
+> kcDecl tcEnv _ (FunctionDecl _ _ _ eqs) = mapM_ (kcEquation tcEnv) eqs
+> kcDecl tcEnv tvs (ForeignDecl p _ _ _ ty) =
+>   kcTypeSig tcEnv tvs p (QualTypeExpr [] ty)
+> kcDecl tcEnv _ (PatternDecl _ _ rhs) = kcRhs tcEnv rhs
+> kcDecl _ _ (FreeDecl _ _) = return ()
+> kcDecl _ _ (TrustAnnot _ _ _) = return ()
+
+> kcConstrDecl :: TCEnv -> ConstrDecl -> KcState ()
+> kcConstrDecl tcEnv d@(ConstrDecl p evs cx _ tys) =
+>   do
+>     tcEnv' <- foldM bindFreshKind tcEnv evs
+>     kcContext tcEnv' p cx
+>     mapM_ (kcValueType tcEnv' p what doc) tys
+>   where what = "data constructor declaration"
+>         doc = ppConstr d
+> kcConstrDecl tcEnv d@(ConOpDecl p evs cx ty1 _ ty2) =
+>   do
+>     tcEnv' <- foldM bindFreshKind tcEnv evs
+>     kcContext tcEnv' p cx
+>     kcValueType tcEnv' p what doc ty1
+>     kcValueType tcEnv' p what doc ty2
+>   where what = "data constructor declaration"
+>         doc = ppConstr d
+> kcConstrDecl tcEnv (RecordDecl p evs cx _ fs) =
+>   do
+>     tcEnv' <- foldM bindFreshKind tcEnv evs
+>     kcContext tcEnv' p cx
+>     mapM_ (kcFieldDecl tcEnv') fs
+
+> kcFieldDecl :: TCEnv -> FieldDecl -> KcState ()
+> kcFieldDecl tcEnv d@(FieldDecl p _ ty) =
+>   kcValueType tcEnv p "labeled declaration" (ppFieldDecl d) ty
+
+> kcNewConstrDecl :: TCEnv -> NewConstrDecl -> KcState ()
+> kcNewConstrDecl tcEnv d@(NewConstrDecl p _ ty) =
+>   kcValueType tcEnv p "newtype constructor declaration" (ppNewConstr d) ty
+> kcNewConstrDecl tcEnv (NewRecordDecl p _ l ty) =
+>   kcFieldDecl tcEnv (FieldDecl p [l] ty)
+
+> kcEquation :: TCEnv -> Equation a -> KcState ()
+> kcEquation tcEnv (Equation _ _ rhs) = kcRhs tcEnv rhs
+
+> kcRhs :: TCEnv -> Rhs a -> KcState ()
+> kcRhs tcEnv (SimpleRhs p e ds) =
+>   kcExpr tcEnv p e >> mapM_ (kcDecl tcEnv []) ds
+> kcRhs tcEnv (GuardedRhs es ds) =
+>   mapM_ (kcCondExpr tcEnv) es >> mapM_ (kcDecl tcEnv []) ds
+
+> kcCondExpr :: TCEnv -> CondExpr a -> KcState ()
+> kcCondExpr tcEnv (CondExpr p g e) = kcExpr tcEnv p g >> kcExpr tcEnv p e
+
+> kcExpr :: TCEnv -> Position -> Expression a -> KcState ()
+> kcExpr _ _ (Literal _ _) = return ()
+> kcExpr _ _ (Variable _ _) = return ()
+> kcExpr _ _ (Constructor _ _) = return ()
+> kcExpr tcEnv p (Paren e) = kcExpr tcEnv p e
+> kcExpr tcEnv p (Typed e ty) = kcExpr tcEnv p e >> kcTypeSig tcEnv [] p ty
+> kcExpr tcEnv p (Record _ _ fs) = mapM_ (kcField tcEnv p) fs
+> kcExpr tcEnv p (RecordUpdate e fs) =
+>   kcExpr tcEnv p e >> mapM_ (kcField tcEnv p) fs
+> kcExpr tcEnv p (Tuple es) = mapM_ (kcExpr tcEnv p) es
+> kcExpr tcEnv p (List _ es) = mapM_ (kcExpr tcEnv p) es
+> kcExpr tcEnv p (ListCompr e qs) =
+>   kcExpr tcEnv p e >> mapM_ (kcStmt tcEnv p) qs
+> kcExpr tcEnv p (EnumFrom e) = kcExpr tcEnv p e
+> kcExpr tcEnv p (EnumFromThen e1 e2) = kcExpr tcEnv p e1 >> kcExpr tcEnv p e2
+> kcExpr tcEnv p (EnumFromTo e1 e2) = kcExpr tcEnv p e1 >> kcExpr tcEnv p e2
+> kcExpr tcEnv p (EnumFromThenTo e1 e2 e3) =
+>   kcExpr tcEnv p e1 >> kcExpr tcEnv p e2 >> kcExpr tcEnv p e3
+> kcExpr tcEnv p (UnaryMinus e) = kcExpr tcEnv p e
+> kcExpr tcEnv p (Apply e1 e2) = kcExpr tcEnv p e1 >> kcExpr tcEnv p e2
+> kcExpr tcEnv p (InfixApply e1 _ e2) = kcExpr tcEnv p e1 >> kcExpr tcEnv p e2
+> kcExpr tcEnv p (LeftSection e _) = kcExpr tcEnv p e
+> kcExpr tcEnv p (RightSection _ e) = kcExpr tcEnv p e
+> kcExpr tcEnv _ (Lambda p _ e) = kcExpr tcEnv p e
+> kcExpr tcEnv p (Let ds e) = mapM_ (kcDecl tcEnv []) ds >> kcExpr tcEnv p e
+> kcExpr tcEnv p (Do sts e) = mapM_ (kcStmt tcEnv p) sts >> kcExpr tcEnv p e
+> kcExpr tcEnv p (IfThenElse e1 e2 e3) =
+>   kcExpr tcEnv p e1 >> kcExpr tcEnv p e2 >> kcExpr tcEnv p e3
+> kcExpr tcEnv p (Case e alts) = kcExpr tcEnv p e >> mapM_ (kcAlt tcEnv) alts
+> kcExpr tcEnv p (Fcase e alts) = kcExpr tcEnv p e >> mapM_ (kcAlt tcEnv) alts
+
+> kcStmt :: TCEnv -> Position -> Statement a -> KcState ()
+> kcStmt tcEnv p (StmtExpr e) = kcExpr tcEnv p e
+> kcStmt tcEnv _ (StmtBind p _ e) = kcExpr tcEnv p e
+> kcStmt tcEnv _ (StmtDecl ds) = mapM_ (kcDecl tcEnv []) ds
+
+> kcAlt :: TCEnv -> Alt a -> KcState ()
+> kcAlt tcEnv (Alt _ _ rhs) = kcRhs tcEnv rhs
+
+> kcField :: TCEnv -> Position -> Field (Expression a) -> KcState ()
+> kcField tcEnv p (Field _ e) = kcExpr tcEnv p e
+
+> kcTypeSig :: TCEnv -> [Ident] -> Position -> QualTypeExpr -> KcState ()
+> kcTypeSig tcEnv tvs p (QualTypeExpr cx ty) =
+>   do
+>     tcEnv' <- foldM bindFreshKind tcEnv (filter (`notElem` tvs) (nub (fv ty)))
+>     kcContext tcEnv' p cx
+>     kcValueType tcEnv' p "type signature" doc ty
+>   where doc = ppQualTypeExpr (QualTypeExpr cx ty)
+
+> kcContext :: TCEnv -> Position -> [ClassAssert] -> KcState ()
+> kcContext tcEnv p = mapM_ (kcClassAssert tcEnv p)
+
+> kcClassAssert :: TCEnv -> Position -> ClassAssert -> KcState ()
+> kcClassAssert tcEnv p (ClassAssert cls ty) =
+>   kcType tcEnv p "class constraint" doc (classKind cls tcEnv) ty
+>   where doc = ppClassAssert (ClassAssert cls ty)
+
+> kcValueType :: TCEnv -> Position -> String -> Doc -> TypeExpr -> KcState ()
+> kcValueType tcEnv p what doc = kcType tcEnv p what doc KindStar
+
+> kcType :: TCEnv -> Position -> String -> Doc -> Kind -> TypeExpr -> KcState ()
+> kcType tcEnv p what doc k ty =
+>   kcTypeExpr tcEnv p "type expression" doc' 0 ty >>=
+>     unify p what (doc $-$ text "Type:" <+> doc') k
+>   where doc' = ppTypeExpr 0 ty
+
+> kcTypeExpr :: TCEnv -> Position -> String -> Doc -> Int -> TypeExpr
+>            -> KcState Kind
+> kcTypeExpr tcEnv p _ _ n (ConstructorType tc) =
+>   case aliasArity tc tcEnv of
+>     Just n'
+>       | n >= n' -> return (constrKind tc tcEnv)
+>       | otherwise -> errorAt p (partialAlias tc n' n)
+>     Nothing -> return (constrKind tc tcEnv)
+> kcTypeExpr tcEnv _ _ _ _ (VariableType tv) = return (varKind tv tcEnv)
+> kcTypeExpr tcEnv p what doc _ (TupleType tys) =
+>   do
+>     mapM_ (kcValueType tcEnv p what doc) tys
+>     return KindStar
+> kcTypeExpr tcEnv p what doc _ (ListType ty) =
+>   do
+>     kcValueType tcEnv p what doc ty
+>     return KindStar
+> kcTypeExpr tcEnv p what doc _ (ArrowType ty1 ty2) =
+>   do
+>     kcValueType tcEnv p what doc ty1
+>     kcValueType tcEnv p what doc ty2
+>     return KindStar
+> kcTypeExpr tcEnv p what doc n (ApplyType ty1 ty2) =
+>   do
+>     (alpha,beta) <-
+>       kcTypeExpr tcEnv p what doc (n + 1) ty1 >>=
+>       kcArrow p what (doc $-$ text "Type:" <+> ppTypeExpr 0 ty1)
+>     kcTypeExpr tcEnv p what doc 0 ty2 >>=
+>       unify p what (doc $-$ text "Type:" <+> ppTypeExpr 0 ty2) alpha
+>     return beta
+
+\end{verbatim}
+The function \texttt{kcArrow} checks that its argument can be used as
+an arrow kind $\alpha\rightarrow\beta$ and returns the pair
+$(\alpha,\beta)$.
+\begin{verbatim}
+
+> kcArrow :: Position -> String -> Doc -> Kind -> KcState (Kind,Kind)
+> kcArrow p what doc k =
+>   do
+>     theta <- fetchSt
+>     case subst theta k of
+>       KindStar -> errorAt p (nonArrowKind what doc KindStar)
+>       KindVariable kv ->
+>         do
+>           alpha <- freshKindVar
+>           beta <- freshKindVar
+>           updateSt_ (bindVar kv (KindArrow alpha beta))
+>           return (alpha,beta)
+>       KindArrow k1 k2 -> return (k1,k2)
+
+\end{verbatim}
+Unification uses Robinson's algorithm (cf., e.g., Chap.~9
+of~\cite{PeytonJones87:Book}).
+\begin{verbatim}
+
+> unify :: Position -> String -> Doc -> Kind -> Kind -> KcState ()
+> unify p what doc k1 k2 =
+>   do
+>     theta <- fetchSt
+>     let k1' = subst theta k1
+>     let k2' = subst theta k2
+>     maybe (errorAt p (kindMismatch what doc k1' k2'))
+>           (updateSt_ . compose)
+>           (unifyKinds k1' k2')
+
+> unifyKinds :: Kind -> Kind -> Maybe KindSubst
+> unifyKinds (KindVariable kv1) (KindVariable kv2)
+>   | kv1 == kv2 = Just idSubst
+>   | otherwise = Just (bindSubst kv1 (KindVariable kv2) idSubst)
+> unifyKinds (KindVariable kv) k
+>   | kv `elem` kindVars k = Nothing
+>   | otherwise = Just (bindSubst kv k idSubst)
+> unifyKinds k (KindVariable kv)
+>   | kv `elem` kindVars k = Nothing
+>   | otherwise = Just (bindSubst kv k idSubst)
+> unifyKinds KindStar KindStar = Just idSubst
+> unifyKinds (KindArrow k11 k12) (KindArrow k21 k22) =
+>   do
+>     theta <- unifyKinds k11 k21
+>     theta' <- unifyKinds (subst theta k12) (subst theta k22)
+>     Just (compose theta' theta)
+> unifyKinds _ _ = Nothing
+
+\end{verbatim}
+Fresh variables.
+\begin{verbatim}
+
+> fresh :: (Int -> a) -> KcState a
+> fresh f = liftM f (liftSt (updateSt (1 +)))
+
+> freshKindVar :: KcState Kind
+> freshKindVar = fresh KindVariable
 
 \end{verbatim}
 Error messages.
@@ -216,11 +627,30 @@
 >   where types comma [tc] = comma ++ " and " ++ name tc
 >         types _ (tc:tcs) = ", " ++ name tc ++ types "," tcs
 
-> wrongArity :: QualIdent -> Int -> Int -> String
-> wrongArity tc arity argc = show $
->   hsep [text "Type constructor", ppQIdent tc, text "requires",
+> recursiveClasses :: [Ident] -> String
+> recursiveClasses [tc] = "Recursive type class " ++ name tc
+> recursiveClasses (tc:tcs) =
+>   "Mutually recursive type classes " ++ name tc ++ types "" tcs
+>   where types comma [tc] = comma ++ " and " ++ name tc
+>         types _ (tc:tcs) = ", " ++ name tc ++ types "," tcs
+
+> nonArrowKind :: String -> Doc -> Kind -> String
+> nonArrowKind what doc k = show $
+>   vcat [text "Kind error in" <+> text what, doc,
+>         text "Kind:" <+> ppKind k,
+>         text "Cannot be applied"]
+
+> kindMismatch :: String -> Doc -> Kind -> Kind -> String
+> kindMismatch what doc k1 k2 = show $
+>   vcat [text "Kind error in" <+> text what, doc,
+>         text "Inferred kind:" <+> ppKind k2,
+>         text "Expected kind:" <+> ppKind k1]
+
+> partialAlias :: QualIdent -> Int -> Int -> String
+> partialAlias tc arity argc = show $
+>   hsep [text "Type synonym", ppQIdent tc, text "requires at least",
 >         int arity, text (plural arity "argument") <> comma,
->         text "but is applied to", int argc]
+>         text "but is applied to only", int argc]
 >   where plural n x = if n == 1 then x else x ++ "s"
 
 \end{verbatim}
Solo in curry-0.9.11-classful/: Kinds.lhs
Solo in curry-0.9.11-classful/: KindSubst.lhs
Solo in curry-0.9.11-classful/: KindTrans.lhs
Solo in curry-0.9.11-classful/: LazyPatterns.lhs
diff -u curry-0.9.11/LexComb.lhs curry-0.9.11-classful/LexComb.lhs
--- curry-0.9.11/LexComb.lhs	2007-06-15 14:16:36.000000000 +0200
+++ curry-0.9.11-classful/LexComb.lhs	2008-03-13 09:20:24.000000000 +0100
@@ -1,7 +1,7 @@
 % -*- LaTeX -*-
-% $Id: LexComb.lhs 1912 2006-05-03 14:53:33Z wlux $
+% $Id: LexComb.lhs 2632 2008-03-12 16:42:17Z wlux $
 %
-% Copyright (c) 1999-2005, Wolfgang Lux
+% Copyright (c) 1999-2008, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{LexComb.lhs}
@@ -21,7 +21,8 @@
 > import Position
 > import Error
 > import Char
-> import Numeric
+> import Numeric(lexDigits, readDec)
+> import Ratio
 
 > infixl 1 `thenL`, `thenL_`
 
@@ -78,15 +79,43 @@
 > convertIntegral b = foldl op 0
 >   where m `op` n = b * m + fromIntegral (digitToInt n)
 
-> convertSignedFloating :: RealFloat a => String -> String -> Int -> a
-> convertSignedFloating ('+':m) f e = convertFloating m f e
-> convertSignedFloating ('-':m) f e = - convertFloating m f e
-> convertSignedFloating m f e = convertFloating m f e
+> convertSignedFloat :: RealFrac a => String -> String -> Int -> a
+> convertSignedFloat ('+':m) f e = convertFloat m f e
+> convertSignedFloat ('-':m) f e = - convertFloat m f e
+> convertSignedFloat m f e = convertFloat m f e
 
-> convertFloating :: RealFloat a => String -> String -> Int -> a
-> convertFloating m f e =
+> convertFloat :: RealFrac a => String -> String -> Int -> a
+> convertFloat m f e =
 >   case readFloat (m ++ f ++ 'e' : show (e - length f)) of
 >     [(f,"")] -> f
->     _ -> error "internal error: invalid string (convertFloating)"
+>     _ -> error "internal error: invalid string (convertFloat)"
+
+\end{verbatim}
+The following definition has been copied -- almost -- verbatim from
+the revised Haskell'98 report~\cite{PeytonJones03:Haskell} except for
+the two special cases for nan and infinity, which are not needed here.
+We define \texttt{readFloat} here instead of importing it from the
+\texttt{Numeric} module because hbc's implementation incorrectly
+requires a \texttt{RealFloat} argument instead of a \texttt{RealFrac}
+one and \texttt{Ratio.Rational} -- obviously -- does not have a
+\texttt{RealFloat} instance.
+\begin{verbatim}
+
+> readFloat :: (RealFrac a) => ReadS a
+> readFloat r =
+>   [(fromRational ((n%1)*10^^(k-d)),t) | (n,d,s) <- readFix r,
+>                                         (k,t)   <- readExp s]
+>   where readFix r = [(read (ds++ds'), length ds', t) | (ds,d) <- lexDigits r,
+>                                                        (ds',t) <- lexFrac d ]
+>
+>         lexFrac ('.':ds) = lexDigits ds
+>         lexFrac s        = [("",s)]        
+>
+>         readExp (e:s) | e `elem` "eE" = readExp' s
+>         readExp s                     = [(0,s)]
+>
+>         readExp' ('-':s) = [(-k,t) | (k,t) <- readDec s]
+>         readExp' ('+':s) = readDec s
+>         readExp' s       = readDec s
 
 \end{verbatim}
Solo in curry-0.9.11: LICENSE
Solo in curry-0.9.11-classful/: LICENSE.asc
diff -u curry-0.9.11/Lift.lhs curry-0.9.11-classful/Lift.lhs
--- curry-0.9.11/Lift.lhs	2007-06-15 14:16:34.000000000 +0200
+++ curry-0.9.11-classful/Lift.lhs	2010-07-01 12:08:40.000000000 +0200
@@ -1,7 +1,7 @@
 % -*- LaTeX -*-
-% $Id: Lift.lhs 2220 2007-06-01 06:28:33Z wlux $
+% $Id: Lift.lhs 2971 2010-07-01 09:44:53Z wlux $
 %
-% Copyright (c) 2001-2007, Wolfgang Lux
+% Copyright (c) 2001-2010, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{Lift.lhs}
@@ -19,23 +19,28 @@
 
 > module Lift(lift) where
 > import Base
-> import Types
-> import TypeSubst
-> import Env
-> import TopEnv
 > import Combined
+> import Curry
+> import CurryUtils
+> import Env
 > import List
 > import Monad
+> import PredefIdent
 > import SCC
 > import Set
 > import Subst
+> import TopEnv
+> import TrustInfo
+> import Types
+> import TypeSubst
+> import Typing
 > import Utils
+> import ValueInfo
 
-> lift :: ValueEnv -> TrustEnv -> Module -> (Module,ValueEnv,TrustEnv)
+> lift :: ValueEnv -> TrustEnv -> Module Type -> (ValueEnv,TrustEnv,Module Type)
 > lift tyEnv trEnv (Module m es is ds) =
->   (Module m es is (concatMap liftTopDecl ds'),tyEnv',trEnv')
->   where (ds',tyEnv',trEnv') =
->           runSt (callSt (abstractModule m ds) tyEnv) trEnv
+>   (tyEnv',trEnv',Module m es is (concatMap liftTopDecl ds'))
+>   where (tyEnv',trEnv',ds') = runSt (callSt (abstractModule m ds) tyEnv) trEnv
 
 \end{verbatim}
 \paragraph{Abstraction}
@@ -54,38 +59,38 @@
 \begin{verbatim}
 
 > type AbstractState a = StateT ValueEnv (StateT TrustEnv Id) a
-> type AbstractEnv = Env Ident Expression
+> type AbstractEnv = Env Ident (Expression Type)
 
-> abstractModule :: ModuleIdent -> [TopDecl]
->                -> AbstractState ([TopDecl],ValueEnv,TrustEnv)
+> abstractModule :: ModuleIdent -> [TopDecl Type]
+>                -> AbstractState (ValueEnv,TrustEnv,[TopDecl Type])
 > abstractModule m ds =
 >   do
 >     ds' <- mapM (abstractTopDecl m) ds
 >     tyEnv' <- fetchSt
 >     trEnv' <- liftSt fetchSt
->     return (ds',tyEnv',trEnv')
+>     return (tyEnv',trEnv',ds')
 
-> abstractTopDecl :: ModuleIdent -> TopDecl -> AbstractState TopDecl
+> abstractTopDecl :: ModuleIdent -> TopDecl Type -> AbstractState (TopDecl Type)
 > abstractTopDecl m (BlockDecl d) =
 >   liftM BlockDecl (abstractDecl m "" [] emptyEnv d)
 > abstractTopDecl _ d = return d
 
-> abstractDecl :: ModuleIdent -> String -> [Ident] -> AbstractEnv -> Decl
->              -> AbstractState Decl
-> abstractDecl m _ lvs env (FunctionDecl p f eqs) =
->   liftM (FunctionDecl p f) (mapM (abstractEquation m lvs env) eqs)
+> abstractDecl :: ModuleIdent -> String -> [(Type,Ident)] -> AbstractEnv
+>              -> Decl Type -> AbstractState (Decl Type)
+> abstractDecl m _ lvs env (FunctionDecl p ty f eqs) =
+>   liftM (FunctionDecl p ty f) (mapM (abstractEquation m lvs env) eqs)
 > abstractDecl m pre lvs env (PatternDecl p t rhs) =
 >   liftM (PatternDecl p t) (abstractRhs m pre lvs env rhs)
 > abstractDecl _ _ _ _ d = return d
 
-> abstractEquation :: ModuleIdent -> [Ident] -> AbstractEnv -> Equation
->                  -> AbstractState Equation
+> abstractEquation :: ModuleIdent -> [(Type,Ident)] -> AbstractEnv
+>                  -> Equation Type -> AbstractState (Equation Type)
 > abstractEquation m lvs env (Equation p lhs@(FunLhs f ts) rhs) =
->   liftM (Equation p lhs)
->         (abstractRhs m (name f ++ ".") (lvs ++ bv ts) env rhs)
+>   liftM (Equation p lhs) (abstractRhs m (name f ++ ".") lvs' env rhs)
+>   where lvs' = lvs `addVars` concatMap termVars ts
 
-> abstractRhs :: ModuleIdent -> String -> [Ident] -> AbstractEnv -> Rhs
->             -> AbstractState Rhs
+> abstractRhs :: ModuleIdent -> String -> [(Type,Ident)] -> AbstractEnv
+>             -> Rhs Type -> AbstractState (Rhs Type)
 > abstractRhs m pre lvs env (SimpleRhs p e _) =
 >   liftM (flip (SimpleRhs p) []) (abstractExpr m pre lvs env e)
 
@@ -97,7 +102,7 @@
 hand sides.
 
 The abstraction of a recursive declaration group is complicated by the
-fact that not all functions need to call each in a recursive
+fact that not all functions need to call each other in a recursive
 declaration group. E.g., in the following example neither g nor h
 call each other.
 \begin{verbatim}
@@ -140,78 +145,42 @@
 that it is easy to check whether a function has been lifted by
 checking whether an entry for its untransformed name is still present
 in the type environment.
-
-In some cases, abstraction can turn a function into an alias for another
-function. For instance, consider the definition
-\begin{verbatim}
-  f z xs = map g xs where g x = z + x
-\end{verbatim}
-When the free variable \texttt{z} is abstracted in the local
-function \texttt{g}, the definition of \texttt{f} becomes
-\begin{verbatim}
-  f z xs = map (g z) xs where g z x = z + x
-\end{verbatim}
-where \texttt{g} is now an alias for \texttt{(+)}. We detect such
-alias definitions and resolve them on the fly and thus transform
-\texttt{f} into the more efficient form
-\begin{verbatim}
-  f z xs = map ((+) z) xs
-\end{verbatim}
-Note that we do not attempt to reorder free variables in order to make
-aliasing possible when there is more than one free variable. At
-present, the compiler recognizes alias definitions only in
-non-recursive binding groups. Since such binding groups always
-consist of only a single definition and the free variables are
-returned in the order of their occurrence in the function body, there
-is no need for reordering.
 \begin{verbatim}
 
-> abstractDeclGroup :: ModuleIdent -> String -> [Ident] -> AbstractEnv
->                   -> [Decl] -> Expression -> AbstractState Expression
+> abstractDeclGroup :: ModuleIdent -> String -> [(Type,Ident)] -> AbstractEnv
+>                   -> [Decl Type] -> Expression Type
+>                   -> AbstractState (Expression Type)
 > abstractDeclGroup m pre lvs env ds e =
->   liftSt fetchSt >>= \trEnv ->
->   abstractFunDecls m pre (lvs ++ bv vds) trEnv env (scc bv (qfv m) fds) vds e
+>   abstractFunDecls m pre lvs' env (scc bv (qfv m) fds) vds e
 >   where (fds,vds) = partition isFunDecl ds
+>         lvs' = lvs `addVars` concatMap declVars vds
 
-> abstractFunDecls :: ModuleIdent -> String -> [Ident] -> TrustEnv
->                  -> AbstractEnv -> [[Decl]] -> [Decl] -> Expression
->                  -> AbstractState Expression
-> abstractFunDecls m pre lvs _ env [] vds e =
+> abstractFunDecls :: ModuleIdent -> String -> [(Type,Ident)] -> AbstractEnv
+>                  -> [[Decl Type]] -> [Decl Type] -> Expression Type
+>                  -> AbstractState (Expression Type)
+> abstractFunDecls m pre lvs env [] vds e =
 >   do
 >     vds' <- mapM (abstractDecl m pre lvs env) vds
 >     e' <- abstractExpr m pre lvs env e
 >     return (Let vds' e')
-> abstractFunDecls m pre lvs trEnv env (fds:fdss) vds e =
->   case fds of
->     [FunctionDecl _ f [Equation _ (FunLhs _ ts) (SimpleRhs _ e' _)]]
->       | f `notElem` qfv m e' && maybe True (Trust==) (lookupEnv f trEnv) &&
->         all isVarPattern ts && isFunction e'' &&
->         fvs' ++ [mkVar v | VariablePattern v <- ts] == es ->
->           abstractFunDecls m pre lvs trEnv env' fdss vds e
->       where (e'',es) = unapply e' []
->             fvs' = map mkVar fvs
->             env' = bindEnv f (apply e'' fvs') env
->     _ ->
->       do
->         fs' <- liftM (\tyEnv -> filter (not . isLifted tyEnv) fs) fetchSt
->         -- update type environment
->         updateSt_ (abstractFunTypes m pre fvs fs')
->         -- update trust annotation environment
->         liftSt (updateSt_ (abstractFunAnnots m pre fs'))
->         fds' <- mapM (abstractFunDecl m pre fvs lvs env')
->                      [d | d <- fds, any (`elem` fs') (bv d)]
->         e' <- abstractFunDecls m pre lvs trEnv env' fdss vds e
->         return (Let fds' e')
+> abstractFunDecls m pre lvs env (fds:fdss) vds e =
+>   do
+>     tyEnv <- fetchSt
+>     let fs' = filter (not . isLifted tyEnv pre) fs
+>         fds' = [d | d <- fds, any (`elem` fs') (bv d)]
+>         env' = foldr (bindF (map (uncurry mkVar) fvs)) env fs
+>     fds'' <-
+>       mapM (abstractFunDecl m pre fvs) fds' >>=
+>       mapM (abstractDecl m pre lvs env')
+>     e' <- abstractFunDecls m pre lvs env' fdss vds e
+>     return (Let fds'' e')
 >   where fs = bv fds
->         fvs = filter (`elem` lvs) (toListSet fvsRhs)
->         env' = foldr (bindF (map mkVar fvs)) env fs
->         fvsRhs = unionSets
->           [fromListSet (maybe [v] (qfv m) (lookupEnv v env)) | v <- qfv m fds]
->         bindF fvs f = bindEnv f (apply (mkFun m pre f) fvs)
->         isLifted tyEnv f = null (lookupTopEnv f tyEnv)
->         isFunction (Variable v) = v `notElem` map qualify lvs
->         isFunction (Constructor c) = True
->         isFunction _ = False
+>         fvs = filter ((`elemSet` fvsRhs) . snd) lvs
+>         fvsRhs = fromListSet $
+>           concat [maybe [v] (qfv m) (lookupEnv v env) | v <- qfv m fds]
+>         bindF fvs f = bindEnv f (apply (mkFun m pre undefined f) fvs)
+>         isLifted tyEnv pre f =
+>           not (null (lookupTopEnv (liftIdent pre f) tyEnv))
 
 \end{verbatim}
 When the free variables of a function are abstracted, the type of the
@@ -226,70 +195,73 @@
 variables in order to avoid an inadvertent name capturing.
 \begin{verbatim}
 
-> abstractFunTypes :: ModuleIdent -> String -> [Ident] -> [Ident]
->                  -> ValueEnv -> ValueEnv
-> abstractFunTypes m pre fvs fs tyEnv = foldr abstractFunType tyEnv fs
->   where tys = map (rawType . flip varType tyEnv) fvs
->         abstractFunType f tyEnv =
->           globalBindFun m (liftIdent pre f) n (genType ty) (unbindFun f tyEnv)
->           where n = length tys + arity (qualify f) tyEnv
->                 ty = foldr TypeArrow (rawType (varType f tyEnv)) tys
->         genType ty =
->           ForAll (length tvs) (subst (foldr2 bindSubst idSubst tvs tvs') ty)
+> abstractFunDecl :: ModuleIdent -> String -> [(Type,Ident)] -> Decl Type
+>                 -> AbstractState (Decl Type)
+> abstractFunDecl m pre fvs (FunctionDecl p ty f eqs) =
+>   do
+>     updateSt_ (globalBindFun m f' (eqnArity (head eqs')) (polyType ty'))
+>     liftSt (updateSt_ (abstractFunAnnot pre f))
+>     return (FunctionDecl p ty' f' eqs')
+>   where f' = liftIdent pre f
+>         ty' = genType (foldr (TypeArrow . fst) ty fvs)
+>         eqs' = map (addVars f') eqs
+>         addVars f (Equation p (FunLhs _ ts) rhs) =
+>           Equation p (FunLhs f (map (uncurry VariablePattern) fvs ++ ts)) rhs
+>         genType ty = subst (foldr2 bindSubst idSubst tvs tvs') ty
 >           where tvs = nub (typeVars ty)
 >                 tvs' = map TypeVariable [0..]
-
-> abstractFunAnnots :: ModuleIdent -> String -> [Ident]
->                   -> Env Ident a -> Env Ident a
-> abstractFunAnnots m pre fs env = foldr abstractFunAnnot env fs
->   where abstractFunAnnot f env =
->           case lookupEnv f env of
->             Just ev -> bindEnv (liftIdent pre f) ev (unbindEnv f env)
->             Nothing -> env
-
-> abstractFunDecl :: ModuleIdent -> String -> [Ident] -> [Ident]
->                 -> AbstractEnv -> Decl -> AbstractState Decl
-> abstractFunDecl m pre fvs lvs env (FunctionDecl p f eqs) =
->   abstractDecl m pre lvs env (FunctionDecl p f' (map (addVars f') eqs))
+> abstractFunDecl m pre _ (ForeignDecl p fi ty f ty') =
+>   do
+>     updateSt_ (globalBindFun m f' (foreignArity ty) (polyType ty))
+>     liftSt (updateSt_ (abstractFunAnnot pre f))
+>     return (ForeignDecl p fi ty f' ty')
 >   where f' = liftIdent pre f
->         addVars f (Equation p (FunLhs _ ts) rhs) =
->           Equation p (FunLhs f (map VariablePattern fvs ++ ts)) rhs
-> abstractFunDecl m pre _ lvs env (ForeignDecl p cc s ie f ty) =
->   return (ForeignDecl p cc s ie (liftIdent pre f) ty)
-
-> abstractExpr :: ModuleIdent -> String -> [Ident] -> AbstractEnv
->              -> Expression -> AbstractState Expression
-> abstractExpr _ _ _ _ (Literal l) = return (Literal l)
-> abstractExpr m pre lvs env (Variable v)
->   | isQualified v = return (Variable v)
->   | otherwise = maybe (return (Variable v)) (abstractExpr m pre lvs env)
->                       (lookupEnv (unqualify v) env)
-> abstractExpr _ _ _ _ (Constructor c) = return (Constructor c)
+
+> abstractFunAnnot :: String -> Ident -> Env Ident a -> Env Ident a
+> abstractFunAnnot pre f env =
+>   case lookupEnv f env of
+>     Just ev -> bindEnv (liftIdent pre f) ev (unbindEnv f env)
+>     Nothing -> env
+
+> abstractExpr :: ModuleIdent -> String -> [(Type,Ident)] -> AbstractEnv
+>              -> Expression Type -> AbstractState (Expression Type)
+> abstractExpr _ _ _ _ (Literal ty l) = return (Literal ty l)
+> abstractExpr m pre lvs env (Variable ty v)
+>   | isQualified v = return (Variable ty v)
+>   | otherwise =
+>       maybe (return (Variable ty v)) (abstractExpr m pre lvs env . absType ty)
+>             (lookupEnv (unqualify v) env)
+>   where absType ty (Variable _ v) = Variable ty v
+>         absType ty (Apply e1 e2) =
+>           Apply (absType (typeOf e2 `TypeArrow` ty) e1) e2
+>         absType _ _ = internalError "absType"
+> abstractExpr _ _ _ _ (Constructor ty c) = return (Constructor ty c)
 > abstractExpr m pre lvs env (Apply e1 e2) =
 >   do
 >     e1' <- abstractExpr m pre lvs env e1
 >     e2' <- abstractExpr m pre lvs env e2
 >     return (Apply e1' e2')
+> abstractExpr m pre lvs env (Lambda p ts e) =
+>   abstractDeclGroup m pre lvs env [funDecl p ty f ts e] (mkVar ty f)
+>   where f = lambdaId p
+>         ty = typeOf (Lambda p ts e)
 > abstractExpr m pre lvs env (Let ds e) = abstractDeclGroup m pre lvs env ds e
 > abstractExpr m pre lvs env (Case e alts) =
 >   do
 >     e' <- abstractExpr m pre lvs env e
 >     alts' <- mapM (abstractAlt m pre lvs env) alts
 >     return (Case e' alts')
-> abstractExpr m _ _ _ _ = internalError "abstractExpr"
-
-> abstractAlt :: ModuleIdent -> String -> [Ident] -> AbstractEnv -> Alt
->             -> AbstractState Alt
-> abstractAlt m pre lvs env (Alt p t rhs) =
->   liftM (Alt p t) (abstractRhs m pre (lvs ++ bv t) env rhs)
-
-> abstractCondExpr :: ModuleIdent -> String -> [Ident] -> AbstractEnv
->                  -> CondExpr -> AbstractState CondExpr
-> abstractCondExpr m pre lvs env (CondExpr p g e) =
+> abstractExpr m pre lvs env (Fcase e alts) =
 >   do
->     g' <- abstractExpr m pre lvs env g
 >     e' <- abstractExpr m pre lvs env e
->     return (CondExpr p g' e')
+>     alts' <- mapM (abstractAlt m pre lvs env) alts
+>     return (Fcase e' alts')
+
+> abstractAlt :: ModuleIdent -> String -> [(Type,Ident)] -> AbstractEnv
+>             -> Alt Type -> AbstractState (Alt Type)
+> abstractAlt m pre lvs env (Alt p t rhs) =
+>   liftM (Alt p t) (abstractRhs m pre lvs' env rhs)
+>   where lvs' = lvs `addVars` termVars t
 
 \end{verbatim}
 \paragraph{Lifting}
@@ -297,98 +269,71 @@
 to the top-level.
 \begin{verbatim}
 
-> liftTopDecl :: TopDecl -> [TopDecl]
+> liftTopDecl :: TopDecl a -> [TopDecl a]
 > liftTopDecl (BlockDecl d) = map BlockDecl (liftFunDecl d)
 > liftTopDecl d = [d]
 
-> liftFunDecl :: Decl -> [Decl]
-> liftFunDecl (FunctionDecl p f eqs) = (FunctionDecl p f eqs' : concat dss')
+> liftFunDecl :: Decl a -> [Decl a]
+> liftFunDecl (FunctionDecl p ty f eqs) =
+>   (FunctionDecl p ty f eqs' : concat dss')
 >   where (eqs',dss') = unzip (map liftEquation eqs)
 > liftFunDecl d = [d]
 
-> liftVarDecl :: Decl -> (Decl,[Decl])
+> liftVarDecl :: Decl a -> (Decl a,[Decl a])
 > liftVarDecl (PatternDecl p t rhs) = (PatternDecl p t rhs',ds')
 >   where (rhs',ds') = liftRhs rhs
 > liftVarDecl (FreeDecl p vs) = (FreeDecl p vs,[])
 
-> liftEquation :: Equation -> (Equation,[Decl])
+> liftEquation :: Equation a -> (Equation a,[Decl a])
 > liftEquation (Equation p lhs rhs) = (Equation p lhs rhs',ds')
 >   where (rhs',ds') = liftRhs rhs
 
-> liftRhs :: Rhs -> (Rhs,[Decl])
+> liftRhs :: Rhs a -> (Rhs a,[Decl a])
 > liftRhs (SimpleRhs p e _) = (SimpleRhs p e' [],ds')
 >   where (e',ds') = liftExpr e
 
-> liftDeclGroup :: [Decl] -> ([Decl],[Decl])
+> liftDeclGroup :: [Decl a] -> ([Decl a],[Decl a])
 > liftDeclGroup ds = (vds',concat (map liftFunDecl fds ++ dss'))
 >   where (fds,vds) = partition isFunDecl ds
 >         (vds',dss') = unzip (map liftVarDecl vds)
 
-> liftExpr :: Expression -> (Expression,[Decl])
-> liftExpr (Literal l) = (Literal l,[])
-> liftExpr (Variable v) = (Variable v,[])
-> liftExpr (Constructor c) = (Constructor c,[])
+> liftExpr :: Expression a -> (Expression a,[Decl a])
+> liftExpr (Literal a l) = (Literal a l,[])
+> liftExpr (Variable a v) = (Variable a v,[])
+> liftExpr (Constructor a c) = (Constructor a c,[])
 > liftExpr (Apply e1 e2) = (Apply e1' e2',ds' ++ ds'')
 >   where (e1',ds') = liftExpr e1
 >         (e2',ds'') = liftExpr e2
 > liftExpr (Let ds e) = (mkLet ds' e',ds'' ++ ds''')
 >   where (ds',ds'') = liftDeclGroup ds
 >         (e',ds''') = liftExpr e
->         mkLet ds e = if null ds then e else Let ds e
 > liftExpr (Case e alts) = (Case e' alts',concat (ds':dss'))
 >   where (e',ds') = liftExpr e
 >         (alts',dss') = unzip (map liftAlt alts)
-> liftExpr _ = internalError "liftExpr"
+> liftExpr (Fcase e alts) = (Fcase e' alts',concat (ds':dss'))
+>   where (e',ds') = liftExpr e
+>         (alts',dss') = unzip (map liftAlt alts)
 
-> liftAlt :: Alt -> (Alt,[Decl])
+> liftAlt :: Alt a -> (Alt a,[Decl a])
 > liftAlt (Alt p t rhs) = (Alt p t rhs',ds')
 >   where (rhs',ds') = liftRhs rhs
 
-> liftCondExpr :: CondExpr -> (CondExpr,[Decl])
-> liftCondExpr (CondExpr p g e) = (CondExpr p g' e',ds' ++ ds'')
->   where (g',ds') = liftExpr g
->         (e',ds'') = liftExpr e
-
 \end{verbatim}
 \paragraph{Auxiliary definitions}
 \begin{verbatim}
 
-> isFunDecl :: Decl -> Bool
-> isFunDecl (FunctionDecl _ _ _) = True
-> isFunDecl (ForeignDecl _ _ _ _ _ _) = True
-> isFunDecl _ = False
-
-> isVarPattern :: ConstrTerm -> Bool
-> isVarPattern (LiteralPattern _) = False
-> isVarPattern (VariablePattern _) = True
-> isVarPattern (ConstructorPattern _ _) = False
-> isVarPattern (AsPattern _ t) = isVarPattern t
-
-> mkFun :: ModuleIdent -> String -> Ident -> Expression
-> mkFun m pre f = Variable (qualifyWith m (liftIdent pre f))
-
-> mkVar :: Ident -> Expression
-> mkVar v = Variable (qualify v)
-
-> apply :: Expression -> [Expression] -> Expression
-> apply = foldl Apply
-
-> unapply :: Expression -> [Expression] -> (Expression,[Expression])
-> unapply (Literal l) es = (Literal l,es)
-> unapply (Variable v) es = (Variable v,es)
-> unapply (Constructor c) es = (Constructor c,es)
-> unapply (Apply e1 e2) es = unapply e1 (e2:es)
-> unapply (Let ds e) es = (Let ds e,es)
-> unapply (Case e alts) es = (Case e alts,es)
+> mkFun :: ModuleIdent -> String -> a -> Ident -> Expression a
+> mkFun m pre ty f = Variable ty (qualifyWith m (liftIdent pre f))
 
 > globalBindFun :: ModuleIdent -> Ident -> Int -> TypeScheme
 >               -> ValueEnv -> ValueEnv
 > globalBindFun m f n ty = globalBindTopEnv m f (Value (qualifyWith m f) n ty)
 
-> unbindFun :: Ident -> ValueEnv -> ValueEnv
-> unbindFun = localUnbindTopEnv
-
 > liftIdent :: String -> Ident -> Ident
 > liftIdent prefix x = renameIdent (mkIdent (prefix ++ name x)) (uniqueId x)
 
+> addVars :: [(a,Ident)] -> [(Ident,b,a)] -> [(a,Ident)]
+> addVars vs lvs = vs ++ [(ty,v) | (v,_,ty) <- lvs, v `notElem` vs']
+>   where vs' = map snd vs
+
 \end{verbatim}
diff -u curry-0.9.11/LLParseComb.lhs curry-0.9.11-classful/LLParseComb.lhs
--- curry-0.9.11/LLParseComb.lhs	2007-06-15 14:16:36.000000000 +0200
+++ curry-0.9.11-classful/LLParseComb.lhs	2008-04-22 23:42:01.000000000 +0200
@@ -1,7 +1,7 @@
 % -*- LaTeX -*-
-% $Id: LLParseComb.lhs 1782 2005-10-06 13:45:22Z wlux $
+% $Id: LLParseComb.lhs 2679 2008-04-22 15:04:17Z wlux $
 %
-% Copyright (c) 1999-2005, Wolfgang Lux
+% Copyright (c) 1999-2008, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{LLParseComb.lhs}
@@ -23,7 +23,7 @@
 > module LLParseComb(Symbol(..),Parser,
 >                    applyParser,prefixParser, position,succeed,symbol,
 >                    (<?>),(<|>),(<|?>),(<*>),(<\>),(<\\>),
->                    opt,(<$>),(<$->),(<*->),(<-*>),(<**>),(<??>),(<.>),
+>                    opt,(<$>),(<$->),(<*->),(<-*>),(<**>),(<?*>),(<**?>),(<.>),
 >                    many,many1, sepBy,sepBy1, chainr,chainr1,chainl,chainl1,
 >                    bracket,ops, layoutOn,layoutOff,layoutEnd) where
 > import Prelude hiding(lex)
@@ -36,7 +36,7 @@
 > import LexComb
 
 > infixl 5 <\>, <\\>
-> infixl 4 <*>, <$>, <$->, <*->, <-*>, <**>, <??>, <.>
+> infixl 4 <*>, <$>, <$->, <*->, <-*>, <**>, <?*>, <**?>, <.>
 > infixl 3 <|>, <|?>
 > infixl 2 <?>, `opt`
 
@@ -47,7 +47,6 @@
 > class (Ord s,Show s) => Symbol s where
 >   isEOF :: s -> Bool
 
-> type Empty = Bool
 > type SuccessCont s a = Position -> s -> L a
 > type FailureCont a = Position -> String -> L a
 > type Lexer s a = SuccessCont s a -> FailureCont a -> L a
@@ -102,7 +101,7 @@
 
 > symbol :: Symbol s => s -> Parser s s a
 > symbol s = Parser Nothing (addToFM s p zeroFM)
->   where p lexer success fail pos s = lexer (success s) fail
+>   where p lexer success fail _ s = lexer (success s) fail
 
 > (<?>) :: Symbol s => Parser s a b -> String -> Parser s a b
 > p <?> msg = p <|> Parser (Just pfail) zeroFM
@@ -212,12 +211,15 @@
 > (<**>) :: Symbol s => Parser s a c -> Parser s (a -> b) c -> Parser s b c
 > p <**> q = flip ($) <$> p <*> q
 
-> (<??>) :: Symbol s => Parser s a b -> Parser s (a -> a) b -> Parser s a b
-> p <??> q = p <**> (q `opt` id)
+> (<?*>) :: Symbol s => Parser s (a -> a) b -> Parser s a b -> Parser s a b
+> p <?*> q = (p `opt` id) <*> q
+
+> (<**?>) :: Symbol s => Parser s a b -> Parser s (a -> a) b -> Parser s a b
+> p <**?> q = p <**> (q `opt` id)
 
 > (<.>) :: Symbol s => Parser s (a -> b) d -> Parser s (b -> c) d
 >       -> Parser s (a -> c) d
-> p1 <.> p2 = p1 <**> ((.) <$> p2)
+> p <.> q = p <**> ((.) <$> q)
 
 > many :: Symbol s => Parser s a b -> Parser s [a] b
 > many p = many1 p `opt` []
diff -u curry-0.9.11/MachInterp.lhs curry-0.9.11-classful/MachInterp.lhs
--- curry-0.9.11/MachInterp.lhs	2007-06-15 14:16:35.000000000 +0200
+++ curry-0.9.11-classful/MachInterp.lhs	2013-05-13 09:54:55.000000000 +0200
@@ -1,7 +1,7 @@
 % -*- LaTeX -*-
-% $Id: MachInterp.lhs 1893 2006-04-12 17:51:56Z wlux $
+% $Id: MachInterp.lhs 3135 2013-05-12 15:51:52Z wlux $
 %
-% Copyright (c) 1998-2006, Wolfgang Lux
+% Copyright (c) 1998-2013, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{MachInterp.lhs}
@@ -49,7 +49,7 @@
 \end{verbatim}
 A \texttt{let} statement allocates and initializes a group of nodes.
 In order to handle mutually recursive nodes, allocation and
-initialization of nodes have to be separated.
+initialization of nodes are separated.
 \begin{verbatim}
 
 > letNodes :: [(String,NodePtr -> MachStateT ())] -> Instruction -> Instruction
@@ -66,7 +66,7 @@
 > initChar :: Char -> NodePtr -> MachStateT ()
 > initChar c ptr = updateNode ptr (CharNode c)
 
-> initInt :: Int -> NodePtr -> MachStateT ()
+> initInt :: Integer -> NodePtr -> MachStateT ()
 > initInt i ptr = updateNode ptr (IntNode i)
 
 > initFloat :: Double -> NodePtr -> MachStateT ()
@@ -75,49 +75,39 @@
 > initConstr :: NodeTag -> [String] -> NodePtr -> MachStateT ()
 > initConstr (ConstructorTag t c n) vs ptr
 >   | length vs == n =
->       do
->         ptrs <- readState (getVars vs)
->         updateNode ptr (ConstructorNode t c ptrs)
+>       readState (getVars vs) >>= updateNode ptr . ConstructorNode t c
 >   | otherwise = fail "Type error in initConstr"
 
 > initClosure :: Function -> [String] -> NodePtr -> MachStateT ()
 > initClosure (f,code,n) vs ptr
 >   | length vs <= n =
->       do
->         ptrs <- readState (getVars vs)
->         updateNode ptr (ClosureNode f n code ptrs)
+>       readState (getVars vs) >>= updateNode ptr . ClosureNode f n code
 >   | otherwise = fail "Type error in initClosure"
 
 > initLazy :: Function -> [String] -> NodePtr -> MachStateT ()
 > initLazy (f,code,n) vs ptr
 >   | length vs == n =
->       do
->         ptrs <- readState (getVars vs)
->         space <- readState curSpace
->         updateNode ptr (LazyNode f n code ptrs space)
+>       readState (getVars vs) >>= updateNode ptr . LazyNode f n code
 >   | otherwise = fail "Type error in initLazy"
 
 > initFree :: NodePtr -> MachStateT ()
-> initFree ptr =
->   do
->     space <- readState curSpace
->     updateNode ptr (VarNode [] [] space)
+> initFree ptr = updateNode ptr (VarNode [] [])
 
 > initIndir :: String -> NodePtr -> MachStateT ()
-> initIndir v ptr =
->   do
->     ptr' <- readState (getVar v)
->     updateNode ptr (IndirNode ptr')
+> initIndir v ptr = readState (getVar v) >>= updateNode ptr . IndirNode
+
+> initQueueMe :: NodePtr -> MachStateT ()
+> initQueueMe ptr = updateNode ptr (QueueMeNode [])
 
 \end{verbatim}
-As a matter of convenience, we provide also some allocation functions,
+As a matter of convenience, we also provide some allocation functions,
 which initialize fresh nodes directly.
 \begin{verbatim}
 
 > allocChar :: Char -> MachStateT NodePtr
 > allocChar c = read'updateState (allocNode (CharNode c))
 
-> allocInt :: Int -> MachStateT NodePtr
+> allocInt :: Integer -> MachStateT NodePtr
 > allocInt i = read'updateState (allocNode (IntNode i))
 
 > allocFloat :: Double -> MachStateT NodePtr
@@ -127,10 +117,7 @@
 > allocData t c ptrs = read'updateState (allocNode (ConstructorNode t c ptrs))
 
 > allocVariables :: Int -> MachStateT [NodePtr]
-> allocVariables n =
->   do
->     space <- readState curSpace
->     read'updateState (allocNodes (replicate n (VarNode [] [] space)))
+> allocVariables n = read'updateState (allocNodes (replicate n (VarNode [] [])))
 
 > allocClosure :: Function -> [NodePtr] -> MachStateT NodePtr
 > allocClosure (f,code,n) ptrs
@@ -140,19 +127,18 @@
 
 > allocLazy :: Function -> [NodePtr] -> MachStateT NodePtr
 > allocLazy (f,code,n) ptrs
->   | length ptrs == n =
->       do
->         space <- readState curSpace
->         read'updateState (allocNode (LazyNode f n code ptrs space))
+>   | length ptrs == n = read'updateState (allocNode (LazyNode f n code ptrs))
 >   | otherwise = fail "Type error in allocLazy"
 
 \end{verbatim}
 \subsubsection{Evaluation of Nodes}
-An \texttt{enter} statement starts the evaluation of the referenced
+An \texttt{eval} statement starts the evaluation of the referenced
 node to weak head normal form. When the node is already in weak head
-normal form it is returned to the caller. If the node is a suspended
+normal form it is returned to the caller. If the node is a lazy
 application, it will be overwritten with a queue-me node that is later
-overwritten with the result of the application.
+overwritten with the result of the application. If the node is a
+global application, the current search is suspended and the global
+node is evaluated by the enclosing computation.
 \begin{verbatim}
 
 > enter :: String -> Instruction
@@ -163,65 +149,55 @@
 >               do
 >                 updateState (pushNodes ptrs)
 >                 code
->         enterNode ptr lazy@(LazyNode f n code ptrs space)
+>         enterNode ptr lazy@(LazyNode f n code ptrs)
 >           | length ptrs == n =
->               readState (isALocalSpace space) >>= \so ->
->               if so then
->                 do
->                   updateState (saveBinding ptr lazy)
->                   updateNode ptr (QueueMeNode [] space)
->                   updateState (pushNode ptr)
->                   updateState (pushCont update)
->                   updateState (pushNodes ptrs)
->                   code
->               else
->                 suspendSearch ptr lazy (resume ptr)
+>               do
+>                 updateState (saveBinding ptr lazy)
+>                 updateNode ptr (QueueMeNode [])
+>                 updateState (pushNode ptr)
+>                 updateState (pushCont update)
+>                 updateState (pushNodes ptrs)
+>                 code
 >           | otherwise = fail "Wrong number of arguments in lazy application"
->         enterNode ptr lazy@(QueueMeNode wq space) =
->           readState (isALocalSpace space) >>= \so ->
->           if so then
->             do
->               thd <- readState (suspendThread (resume ptr))
->               updateState (saveBinding ptr lazy)
->               updateNode ptr (QueueMeNode (thd:wq) space)
->               switchContext
->           else
->             suspendSearch ptr lazy (resume ptr)
+>         enterNode ptr lazy@(QueueMeNode wq) =
+>           do
+>             thd <- readState (suspendThread (resume ptr))
+>             updateState (saveBinding ptr lazy)
+>             updateNode ptr (QueueMeNode (thd:wq))
+>             switchContext
 >         enterNode _ (IndirNode ptr) = deref ptr >>= enterNode ptr
+>         enterNode ptr lazy@(GlobalAppNode _ _) =
+>           suspendSearch ptr lazy (resume ptr)
 >         enterNode ptr _ = retNode ptr
 >         resume ptr = deref ptr >>= resumeNode ptr
->         resumeNode _ (LazyNode _ _ _ _ _) =
+>         resumeNode _ (LazyNode _ _ _ _) =
 >           fail "Indirection to unevaluated lazy application node"
->         resumeNode _ (QueueMeNode _ _) =
+>         resumeNode _ (QueueMeNode _) =
 >           fail "Indirection to locked lazy application node"
 >         resumeNode _ (IndirNode ptr) = deref ptr >>= resumeNode ptr
 >         resumeNode ptr _ = retNode ptr
 >         update = read'updateState popNodes2 >>= uncurry update'
 >         update' ptr lptr = deref lptr >>= updateLazy ptr lptr
->         updateLazy ptr lptr lazy@(QueueMeNode wq space) =
->           readState (isALocalSpace space) >>= \so ->
->           if so then
->             do
->               updateState (saveBinding lptr lazy)
->               updateNode lptr (IndirNode ptr)
->               updateState (pushNode ptr)
->               updateState (wakeThreads wq)
->               ret
->           else
->             fail "Attempt to update non-local lazy application node"
->         updateLazy _ _ (LazyNode _ _ _ _ _) =
+>         updateLazy ptr lptr lazy@(QueueMeNode wq) =
+>           do
+>             updateState (saveBinding lptr lazy)
+>             updateNode lptr (IndirNode ptr)
+>             updateState (pushNode ptr)
+>             updateState (wakeThreads wq)
+>             ret
+>         updateLazy _ _ (LazyNode _ _ _ _) =
 >           fail "Unlocked lazy application in update frame"
 >         updateLazy _ _ _ = fail "No lazy application in update frame"
 
 \end{verbatim}
 \subsubsection{Function Evaluation}
-An \texttt{exec} statement pushes the referenced nodes onto the data
-stack and enters the specified function. Upon entry, this functions
-initializes a fresh local environment with the nodes from the data
-stack and then executes its code. At the end, the function returns to
-the current context from either the return or the update stack. If
-both stacks are empty, the current thread terminates which eventually
-may cause a deadlock.
+A function call pushes the arguments onto the data stack and enters
+the specified function. Upon entry, the called function initializes a
+fresh local environment with the nodes from the data stack and then
+executes its code. At the end, the function returns to the current
+context from either the return or the update stack. If both stacks are
+empty, the current thread terminates which eventually may cause a
+deadlock.
 \begin{verbatim}
 
 > exec :: Function -> [String] -> Instruction
@@ -270,60 +246,15 @@
 > prim2 _ _ = fail "Wrong number of arguments in CCall"
 
 \end{verbatim}
-\subsubsection{Pattern Binding Updates}
-In order to avoid a space leak with lazy matching of pattern bindings,
-the compiler generates specially crafted selector functions that
-update all variables of a pattern when one of its selector functions
-is evaluated. To this end, the corresponding lazy application nodes
-are overwritten with queue-me nodes when the selector is entered --
-this prevents any of the other selectors from being evaluated
-concurrently -- and updated with the nodes from the pattern when
-pattern matching in the selector function succeeds. The former task is
-handled by \texttt{lock} statements, the latter by the \texttt{update}
-statements. Note that a selector function is entered only when the
-corresponding lazy application node is local to the current search
-space. As the applications for the other pattern variables are
-obviously created in the same space, neither \texttt{lock} nor
-\texttt{update} need to handle non-local nodes.
-\begin{verbatim}
-
-> lock :: String -> Instruction -> Instruction
-> lock v next = readState (getVar v) >>= lock
->   where lock ptr = deref ptr >>= lockNode ptr
->         lockNode ptr lazy@(LazyNode _ _ _ _ space) =
->           readState (isALocalSpace space) >>= \so ->
->           if so then
->             do
->               updateState (saveBinding ptr lazy)
->               updateNode ptr (QueueMeNode [] space)
->               next
->           else
->             fail "Attempt to lock a non-local lazy application"
->         lockNode _ _ = fail "No lazy application in lock"
-
-> update :: String -> String -> Instruction -> Instruction
-> update v1 v2 next = readState (getVar v1) >>= update
->   where update ptr = deref ptr >>= updateLazy ptr
->         updateLazy ptr lazy@(QueueMeNode wq space) =
->           readState (isALocalSpace space) >>= \so ->
->           if so then
->             do
->               updateState (saveBinding ptr lazy)
->               readState (getVar v2) >>= updateNode ptr . IndirNode
->               updateState (wakeThreads wq)
->               next
->           else
->             fail "Attempt to update non-local lazy application node"
->         updateLazy _ _ = fail "No lazy application in update"
-
-\end{verbatim}
 \subsubsection{Case Selection}
 A \texttt{switch} statement selects the code branch matched by
 the tag of the specified node. Depending on the mode of the switch
 statement, an unbound variable either suspends the current thread
 until the variable is instantiated (\texttt{rigid}) or instantiates
-the variable non-deterministically (\texttt{flex}).  If no case
-matches, the default actions is chosen.
+the variable non-deterministically (\texttt{flex}). If no case
+matches, the default action is chosen. Global variables are never
+instantiated. Instead, the current search is suspended until the
+variable is instantiated in the enclosing computation.
 
 After instantiating a variable, the abstract machine checks that all
 constraints on the variable are still entailed and then wakes all
@@ -331,10 +262,10 @@
 another variable, the wait queues are concatenated instead of waking
 the suspended threads. In addition, we must check the constraints of
 the other variable as well because both constraint lists can include a
-disequality between the variables. If the other variable is not a
-local variable and there are constraints on the bound variable or it
-has a non-empty wait-queue, we must suspend the current search until
-the variable is bound.
+disequality between the variables. If a variable is bound to a global
+variable and the local variable has constraints or blocked threads, we
+must suspend the current search until the global variable is
+instantiated.
 
 Note that \texttt{bindVar} must check whether the variable node has
 been bound already. This may happen if a search strategy restricts the
@@ -345,7 +276,7 @@
   goal xs = length xs =:= 1
   nonNull (_:_) = success
 \end{verbatim}
-the goal variable is bound to a cons node before the search
+the goal variable is bound to a list node before the search
 continuations are resumed that were returned by the inner \texttt{try}
 application.
 \begin{verbatim}
@@ -353,21 +284,20 @@
 > switchRigid :: String -> [(NodeTag,NodePtr -> Instruction)]
 >             -> (NodePtr -> Instruction) -> Instruction
 > switchRigid v dispatchTable dflt = rigidSwitch
->   where rigidSwitch =
->           switch v ((VariableTag,delay rigidSwitch) : dispatchTable) dflt
+>   where rigidSwitch = switch v dispatchTable' dflt
+>         dispatchTable' =
+>           (VariableTag,delay rigidSwitch) :
+>           (GlobalVarTag,delaySearch rigidSwitch) :
+>           dispatchTable
 
 > delay :: Instruction -> NodePtr -> Instruction
 > delay cont vptr = deref vptr >>= delayNode vptr
->   where delayNode vptr var@(VarNode cs wq space) =
->           readState (isALocalSpace space) >>= \so ->
->           if so then
->             do
->               thd <- readState (suspendThread cont)
->               updateState (saveBinding vptr var)
->               updateNode vptr (VarNode cs (thd:wq) space)
->               switchContext
->           else
->             suspendSearch vptr var cont
+>   where delayNode vptr var@(VarNode cs wq) =
+>           do
+>             thd <- readState (suspendThread cont)
+>             updateState (saveBinding vptr var)
+>             updateNode vptr (VarNode cs (thd:wq))
+>             switchContext
 
 > switchFlex :: String -> [(NodeTag,NodePtr -> Instruction)]
 >            -> (NodePtr -> Instruction) -> Instruction
@@ -375,33 +305,34 @@
 >   where flexSwitch = switch v dispatchTable' dflt
 >         dispatchTable'
 >           | null alts = dispatchTable
->           | otherwise = (VariableTag,tryBind alts flexSwitch) : dispatchTable
+>           | otherwise =
+>               (VariableTag,tryBind alts flexSwitch) :
+>               (GlobalVarTag,delaySearch flexSwitch) :
+>               dispatchTable
 >         alts = map instantiate dispatchTable
 
 > tryBind :: [NodePtr -> Instruction] -> Instruction -> NodePtr -> Instruction
 > tryBind (alt:alts) cont vptr = deref vptr >>= tryBindNode vptr
->   where tryBindNode vptr var@(VarNode cs wq space) =
->           readState (isALocalSpace space) >>= \so ->
->           if so then
->             if null alts then
->               alt vptr
->             else
+>   where tryBindNode vptr var@(VarNode cs wq)
+>           | null alts = alt vptr
+>           | otherwise =
 >               do
 >                 thd <- read'updateState (yieldSuspendThread (resume vptr))
 >                 case thd of
 >                   Just thd ->
 >                     do
 >                       updateState (saveBinding vptr var)
->                       updateNode vptr (VarNode cs (thd:wq) space)
+>                       updateNode vptr (VarNode cs (thd:wq))
 >                       switchContext
->                   Nothing -> choices vptr
->           else
->             suspendSearch vptr var cont
+>                   Nothing -> choice vptr
 >         resume ptr = deref ptr >>= resumeNode ptr
 >         resumeNode _ (IndirNode ptr) = resume ptr
->         resumeNode ptr (VarNode _ _ _) = choices ptr
+>         resumeNode ptr (VarNode _ _) = choice ptr
 >         resumeNode _ _ = cont
->         choices vptr = tryChoices (map ($ vptr) (alt:alts))
+>         choice vptr = tryChoice (map ($ vptr) (alt:alts))
+
+> delaySearch :: Instruction -> NodePtr -> Instruction
+> delaySearch cont vptr = deref vptr >>= flip (suspendSearch vptr) cont
 
 > instantiate ::(NodeTag,NodePtr -> Instruction) -> NodePtr -> Instruction
 > instantiate (tag,body) vptr =
@@ -415,23 +346,17 @@
 >         freshNode (ConstructorTag t c n) = allocVariables n >>= allocData t c
 
 > bindVar :: NodePtr -> Node -> NodePtr -> Instruction -> Instruction
-> bindVar vptr var@(VarNode cs wq space) ptr next =
->   readState (isALocalSpace space) >>= \so ->
->   if so then
->     deref ptr >>= bindVarNode ptr
->   else
->     bindUnify vptr ptr next
+> bindVar vptr var@(VarNode cs wq) ptr next = deref ptr >>= bindVarNode ptr
 >   where bindVarNode _ (IndirNode ptr) = deref ptr >>= bindVarNode ptr
->         bindVarNode ptr node@(VarNode cs2 wq2 space2) =
->           readState (isALocalSpace space2) >>= \so ->
->           if so then
->             do
->               updateState (saveBinding vptr var)
->               updateNode vptr (IndirNode ptr)
->               updateState (saveBinding ptr node)
->               updateNode ptr (VarNode [] (wq ++ wq2) space2)
->               checkConstraints ptr (cs ++ cs2) next
->           else if (null cs && null wq) then
+>         bindVarNode ptr node@(VarNode cs2 wq2) =
+>           do
+>             updateState (saveBinding vptr var)
+>             updateNode vptr (IndirNode ptr)
+>             updateState (saveBinding ptr node)
+>             updateNode ptr (VarNode [] (wq ++ wq2))
+>             checkConstraints ptr (cs ++ cs2) next
+>         bindVarNode ptr node@(GlobalVarNode _ _) =
+>           if null cs && null wq then
 >             do
 >               updateState (saveBinding vptr var)
 >               updateNode vptr (IndirNode ptr)
@@ -499,28 +424,28 @@
 
 \end{verbatim}
 \subsubsection{Non-deterministic Evaluation}
-A \texttt{choices} statement executes its alternatives
+A \texttt{choice} statement executes its alternatives
 non-deterministically. If there are other threads which can proceed
 with a deterministic computation, the current thread is suspended
 until these threads either finish or suspend.
 \begin{verbatim}
 
-> choices :: [Instruction] -> Instruction
-> choices [] = failAndBacktrack
-> choices (alt:alts)
+> choice :: [Instruction] -> Instruction
+> choice [] = failAndBacktrack
+> choice (alt:alts)
 >   | null alts = alt
 >   | otherwise = read'updateState (yieldThread try) >>= \so ->
 >                 if so then switchContext else try
->   where try = tryChoices (alt:alts)
+>   where try = tryChoice (alt:alts)
 
-> tryChoices :: [Instruction] -> Instruction
-> tryChoices (alt:alts) = readState curContext >>= try
+> tryChoice :: [Instruction] -> Instruction
+> tryChoice (alt:alts) = readState curContext >>= try
 >   where try IOContext = fail "Cannot duplicate the world"
 >         try GlobalContext =
 >           do
 >             updateState (pushChoicepoint (tryNext alts))
 >             alt
->         try _ = choicesSearch (alt:alts)
+>         try _ = choiceSearch (alt:alts)
 >         tryNext (alt:alts) =
 >           do
 >             updateState (updChoicepoint alts)
@@ -555,67 +480,7 @@
 
 \end{verbatim}
 \subsection{Primitives}
-\subsubsection{Basic functions}
-The primitive \texttt{failed} causes an explicit failure in the
-program.
-\begin{verbatim}
-
-> failedFunction :: Function
-> failedFunction = ("failed",entry [] failAndBacktrack,0)
-
-\end{verbatim}
-The primitive \texttt{seq} evaluates both of its arguments
-sequentially to head normal form. The result of the first argument is
-discarded and the result of the second is returned.
-\begin{verbatim}
-
-> seqFunction :: Function
-> seqFunction = ("seq",seqCode,2)
-
-> seqCode :: Instruction
-> seqCode =
->   entry ["x","y"] $
->   seqStmts "_" (enter "x") (enter "y")
-
-\end{verbatim}
-The primitive \texttt{ensureNotFree} evaluates its argument to head
-normal form. If the result is an unbound variable, the current thread
-is suspended until the variable is instantiated.
-\begin{verbatim}
-
-> ensureNotFreeFunction :: Function
-> ensureNotFreeFunction = ("ensureNotFree",ensureNotFreeCode,1)
-
-> ensureNotFreeCode = 
->   entry ["x"] $
->   evalRigid "x" retNode
-
-> evalRigid :: String -> (NodePtr -> Instruction) -> Instruction
-> evalRigid x = seqStmts x' (enter x) . switchRigid x' []
->   where x' = '_':x
-
-\end{verbatim}
-The operator \texttt{:} is implemented in order to handle partial
-applications of the \texttt{:} constructor.
-\begin{verbatim}
-
-> nil :: MachStateT NodePtr
-> nil = read'updateState (atom nilTag)
-
-> cons :: NodePtr -> NodePtr -> MachStateT NodePtr
-> cons hd tl = allocData tag cName [hd,tl]
->   where ConstructorTag tag cName 2 = consTag
-
-> consFunction :: Function
-> consFunction = (":", consCode, 2)
-
-> consCode :: Instruction
-> consCode =
->   entry ["hd","tl"] $
->   letNodes [("cons",initConstr consTag ["hd","tl"])] $
->   enter "cons"
-
-\end{verbatim}
+\subsubsection{Application Functions}
 There is a -- potentially -- unlimited number of functions
 \texttt{@}$i$, which are used by the compiler for implementing
 applications of a function variable to $i$ arguments.\footnote{For
@@ -656,59 +521,27 @@
 \end{verbatim}
 In order to handle partial applications of data constructors, the
 compiler provides an auxiliary function for each data constructor,
-which returns a new constructor node from the supplied arguments.
+which returns a new constructor node with the supplied arguments.
 \begin{verbatim}
 
 > constrFunction :: Int -> String -> Int -> Function
 > constrFunction t c n = (c,constrCode t c n,n)
 
 > constrCode :: Int -> String -> Int -> Instruction
-> constrCode t c n =
->   read'updateState (popNodes n) >>= allocData t c >>= retNode
-
-> tupleFunctions :: [Function]
-> tupleFunctions = map tupleFunction [0..]
-
-> tupleFunction :: Int -> Function
-> tupleFunction n
->   | n >= 2 = constrFunction 0 ("(" ++ replicate (n - 1) ',' ++ ")") n
->   | otherwise = error "tuples must have arity >= 2"
+> constrCode t c n = read'updateState (popNodes n) >>= allocData t c >>= retNode
 
 \end{verbatim}
 \subsubsection{Arithmetic Operations}\label{sec:mach-arithmetic}
+All arithmetic operations are implemented as primitives.
 \begin{verbatim}
 
-> ordFunction, chrFunction :: Function
-> ordFunction = ("ord", ordCode, 1)
-> chrFunction = ("chr", chrCode, 1)
-
-> ordCode,chrCode :: Instruction
-> ordCode = entry ["c"] $ evalRigid "c" (\c -> primOrd c >>= retNode)
-> chrCode = entry ["i"] $ evalRigid "i" (\i -> primChr i >>= retNode)
-
 > ordPrimitive,chrPrimitive :: Primitive
 > ordPrimitive = ("primOrd",prim1 primOrd)
 > chrPrimitive = ("primChr",prim1 primChr)
 
 > primOrd, primChr :: NodePtr -> MachStateT NodePtr
-> primOrd = withChar "ord" (allocInt . ord)
-> primChr = withInt "chr" (allocChar . chr)
-
-> addIntFunction, subIntFunction, multIntFunction :: Function
-> quotIntFunction, remIntFunction, divIntFunction, modIntFunction :: Function
-> addIntFunction = ("+", intCode "+" (+), 2)
-> subIntFunction = ("-", intCode "-" (-), 2)
-> multIntFunction = ("*", intCode "*" (*), 2)
-> quotIntFunction = ("quot", intCode "quot" quot, 2)
-> remIntFunction = ("rem", intCode "rem" rem, 2)
-> divIntFunction = ("div", intCode "div" div, 2)
-> modIntFunction = ("mod", intCode "mod" mod, 2)
-
-> intCode :: String -> (Int -> Int -> Int) -> Instruction
-> intCode what op =
->   entry ["x","y"] $ evalRigid "x"
->                   $ \x -> evalRigid "y"
->                   $ \y -> primIntOp what op x y >>= retNode
+> primOrd = withChar "ord" (allocInt . toInteger . ord)
+> primChr = withInt "chr" (allocChar . chr . fromInteger)
 
 > addIntPrimitive, subIntPrimitive, mulIntPrimitive :: Primitive
 > quotIntPrimitive, remIntPrimitive :: Primitive
@@ -721,24 +554,11 @@
 > divIntPrimitive = ("primDivInt", prim2 $ primIntOp "div" div)
 > modIntPrimitive = ("primModInt", prim2 $ primIntOp "mod" mod)
 
-> primIntOp :: String -> (Int -> Int -> Int) -> NodePtr -> NodePtr
+> primIntOp :: String -> (Integer -> Integer -> Integer) -> NodePtr -> NodePtr
 >           -> MachStateT NodePtr
 > primIntOp what op x y =
 >   withInt what (\i -> withInt what (\j -> allocInt (i `op` j)) y) x
 
-> addFloatFunction, subFloatFunction :: Function
-> multFloatFunction, divFloatFunction :: Function
-> addFloatFunction = ("+.",floatCode "+." (+),2)
-> subFloatFunction = ("-.",floatCode "-." (-),2)
-> multFloatFunction = ("*.",floatCode "*." (*),2)
-> divFloatFunction = ("/.",floatCode "/." (/),2)
-
-> floatCode :: String -> (Double -> Double -> Double) -> Instruction
-> floatCode what op =
->   entry ["x","y"] $ evalRigid "x"
->                   $ \x -> evalRigid "y"
->                   $ \y -> primFloatOp what op x y >>= retNode
-
 > addFloatPrimitive, subFloatPrimitive :: Primitive
 > mulFloatPrimitive, divFloatPrimitive :: Primitive
 > addFloatPrimitive = ("primAddFloat", prim2 $ primFloatOp "+." (+))
@@ -751,34 +571,18 @@
 > primFloatOp what op x y =
 >  withFloat what (\e -> withFloat what (\f -> allocFloat (e `op` f)) y) x
 
-> floatFromIntFunction :: Function
-> floatFromIntFunction = ("floatFromInt",floatFromIntCode,1)
-
-> floatFromIntCode :: Instruction
-> floatFromIntCode =
->   entry ["x"] $ evalRigid "x" $ \i -> primFloat i >>= retNode
-
 > floatPrimitive :: Primitive
 > floatPrimitive = ("primFloat", prim1 primFloat)
 
 > primFloat :: NodePtr -> MachStateT NodePtr
 > primFloat = withInt "floatFromInt" (allocFloat . fromIntegral)
 
-> truncateFloatFunction, roundFloatFunction :: Function
-> truncateFloatFunction =
->   ("truncateFloat",intFromFloatCode "truncateFloat" truncate,1)
-> roundFloatFunction = ("roundFloat",intFromFloatCode "roundFloat" round,1)
-
-> intFromFloatCode :: String -> (Double -> Int) -> Instruction
-> intFromFloatCode what fromDouble =
->   entry ["x"] $ evalRigid "x"
->               $ \f -> primFromFloat what fromDouble f >>= retNode
-
 > truncPrimitive, roundPrimitive :: Primitive
 > truncPrimitive = ("primTrunc", prim1 $ primFromFloat "truncateFloat" truncate)
 > roundPrimitive = ("primRound", prim1 $ primFromFloat "roundFloat" round)
 
-> primFromFloat :: String -> (Double -> Int) -> NodePtr -> MachStateT NodePtr
+> primFromFloat :: String -> (Double -> Integer) -> NodePtr
+>               -> MachStateT NodePtr
 > primFromFloat what fromDouble = withFloat what (allocInt . fromDouble)
 
 > withChar :: String -> (Char -> MachStateT a) -> NodePtr -> MachStateT a
@@ -786,7 +590,7 @@
 >   where withCharNode code (CharNode c) = code c
 >         withCharNode _ _ = fail (what ++ ": invalid argument")
 
-> withInt :: String -> (Int -> MachStateT a) -> NodePtr -> MachStateT a
+> withInt :: String -> (Integer -> MachStateT a) -> NodePtr -> MachStateT a
 > withInt what code ptr = deref ptr >>= withIntNode code
 >   where withIntNode code (IntNode i) = code i
 >         withIntNode _ _ = fail (what ++ ": invalid argument")
@@ -799,7 +603,7 @@
 \end{verbatim}
 \subsubsection{Comparing Nodes}
 The operator \texttt{(==)} compares two data terms for equality and
-returns either \texttt{True} or \texttt{False}. In constrast to
+returns either \texttt{True} or \texttt{False}. In contrast to
 equality constraints, this function is rigid. In addition, we support
 equality checks only for literals and data terms, but not for partial
 applications.
@@ -861,7 +665,7 @@
 \end{verbatim}
 The \texttt{compare} function compares two data terms and returns one
 of the values \texttt{LT}, \texttt{EQ}, \texttt{GT} defined in the
-\texttt{prelude}.
+\texttt{Prelude}.
 \begin{verbatim}
 
 > compareFunction :: Function
@@ -916,27 +720,16 @@
 >     if nodeTag node == eqTag then compareArgs ptrs else retNode ptr
 
 \end{verbatim}
-\subsubsection{Basic Constraint Functions}
-The \texttt{success} function implements the trivial constraint, which
-is always satisfied.
-\begin{verbatim}
-
-> success :: MachStateT NodePtr
-> success = read'updateState (atom successTag)
-
-> successFunction :: Function
-> successFunction = ("success",successCode,0)
-
-> successCode :: Instruction
-> successCode = entry [] (success >>= retNode)
-
-\end{verbatim}
+\subsubsection{Concurrent Conjunction}
 The concurrent conjunction operator \texttt{\&} evaluates two
 constraints concurrently. It tries to avoid the creation of a
 new thread whenever this is possible. Note that the result of
-\texttt{\&} may still be an unbound variable.
+\texttt{\&} may be an unbound variable.
 \begin{verbatim}
 
+> success :: MachStateT NodePtr
+> success = read'updateState (atom successTag)
+
 > concConjFunction :: Function
 > concConjFunction = ("&",concConjCode,2)
 
@@ -944,26 +737,41 @@
 > concConjCode =
 >   entry ["c1","c2"] $
 >   switch "c1"
->          [(LazyTag,suspension),(QueueMeTag,queueMe),(VariableTag,variable)]
+>          [(LazyTag,suspension),(QueueMeTag,queueMe),(VariableTag,variable),
+>           (GlobalAppTag,globalApp),(GlobalVarTag,variable)]
 >          (const (enter "c2"))
 >   where suspension ptr1 =
 >           switch "c2"
 >                  [(LazyTag,const (concurrent ptr1)),
 >                   (QueueMeTag,const sequential),
->                   (VariableTag,const sequential)]
+>                   (VariableTag,const sequential),
+>                   (GlobalAppTag,const (concurrent ptr1)),
+>                   (GlobalVarTag,const sequential)]
 >                  (const (enter "c1"))
 >         queueMe ptr1 =
 >           switch "c2"
 >                  [(LazyTag,const (flipArguments >> sequential)),
 >                   (QueueMeTag,const sequential),
->                   (VariableTag,const sequential)]
+>                   (VariableTag,const sequential),
+>                   (GlobalAppTag,const (flipArguments >> sequential)),
+>                   (GlobalVarTag,const sequential)]
 >                  (const (enter "c1"))
 >         variable ptr1 =
 >           switch "c2"
 >                  [(LazyTag,const (flipArguments >> sequential)),
 >                   (QueueMeTag,const (flipArguments >> sequential)),
->                   (VariableTag,wait ptr1)]
+>                   (VariableTag,wait ptr1),
+>                   (GlobalAppTag,const (flipArguments >> sequential)),
+>                   (GlobalVarTag,wait ptr1)]
 >                  (const (retNode ptr1))
+>         globalApp ptr1 =
+>           switch "c2"
+>                  [(LazyTag,const sequential),
+>                   (QueueMeTag,const sequential),
+>                   (VariableTag,const sequential),
+>                   (GlobalAppTag,const sequential),
+>                   (GlobalVarTag,const sequential)]
+>                  (const (enter "c1"))
 >         concurrent ptr1 =
 >           do
 >             updateState (interruptThread (flipArguments >> sequential))
@@ -975,7 +783,9 @@
 >           switch "_c1"
 >                  [(LazyTag,const (fail "This cannot happen")),
 >                   (QueueMeTag,const (fail "This cannot happen")),
->                   (VariableTag,variable)]
+>                   (VariableTag,variable),
+>                   (GlobalAppTag,const (fail "This cannot happen")),
+>                   (GlobalVarTag,variable)]
 >                  (const (enter "c2"))
 >         wait ptr1 ptr2 =
 >           do
@@ -993,9 +803,8 @@
 Following the semantics, we have to ensure that both arguments are
 evaluated to weak head normal before we actually unify the arguments.
 When we have to unify two data constructors or a data constructor and
-a variable, we also have to start the unification of the data
-constructors' arguments, where these unifications can proceed
-concurrently.
+a variable, we also have to unify of the arguments of the data
+constructors, which can proceed concurrently.
 \begin{verbatim}
 
 > unifyFunction :: Function
@@ -1021,31 +830,25 @@
 >     unifyNodes ptr1 node1 ptr2 node2
 
 > unifyNodes :: NodePtr -> Node -> NodePtr -> Node -> Instruction
-> unifyNodes ptr1 var1@(VarNode _ _ space1) ptr2 var2@(VarNode _ _ space2)
+> unifyNodes ptr1 var1@(VarNode _ _) ptr2 var2@(VarNode _ _)
 >   | ptr1 == ptr2 = unifySuccess
->   | otherwise =
->       readState (isALocalSpace space1) >>= \so ->
->       if so then
->         bindVar ptr1 var1 ptr2 unifySuccess
->       else
->         readState (isALocalSpace space2) >>= \so ->
->         if so then
->           bindVar ptr2 var2 ptr1 unifySuccess
->         else
->           suspendSearch ptr1 var1 (unifyTerms ptr1 ptr2)
-> unifyNodes ptr1 var@(VarNode _ _ space) ptr2 node =
->   readState (isALocalSpace space) >>= \so ->
->   if so then
->     occursCheck ptr1 node >>= \occurs ->
->     if occurs then
->       failAndBacktrack
->     else
->       do
->         (ptr',ptrs) <- freshTerm ptr2 node
->         bindVar ptr1 var ptr' (unifyArgs ptrs)
+>   | otherwise = bindVar ptr1 var1 ptr2 unifySuccess
+> unifyNodes ptr1 var1@(VarNode _ _) ptr2 var2@(GlobalVarNode _ _) =
+>   bindVar ptr1 var1 ptr2 unifySuccess
+> unifyNodes ptr1 var1@(GlobalVarNode _ _) ptr2 var2@(VarNode _ _) =
+>   bindVar ptr2 var2 ptr1 unifySuccess
+> unifyNodes ptr1 var1@(GlobalVarNode _ _) ptr2 var2@(GlobalVarNode _ _)
+>   | ptr1 == ptr2 = unifySuccess
+>   | otherwise = suspendSearch ptr1 var1 (unifyTerms ptr1 ptr2)
+> unifyNodes ptr1 var@(VarNode _ _) ptr2 node =
+>   occursCheck ptr1 node >>= \occurs ->
+>   if occurs then
+>     failAndBacktrack
 >   else
->     suspendSearch ptr1 var (unifyTerms ptr1 ptr2)
-> unifyNodes ptr1 node ptr2 var@(VarNode _ _ _) =
+>     do
+>       (ptr',ptrs) <- freshTerm ptr2 node
+>       bindVar ptr1 var ptr' (unifyArgs ptrs)
+> unifyNodes ptr1 node ptr2 var@(VarNode _ _) =
 >   unifyNodes ptr2 var ptr1 node
 > unifyNodes _ (CharNode c) _ (CharNode d)
 >   | c == d = unifySuccess
@@ -1098,7 +901,7 @@
 >             enter "c"
 
 > unifySuccess :: Instruction
-> unifySuccess = successCode
+> unifySuccess = success >>= retNode
 
 > occursCheck :: NodePtr -> Node -> MachStateT Bool
 > occursCheck vptr (ConstructorNode _ _ args)
@@ -1130,14 +933,14 @@
 >         vars <- allocVariables (length ptrs)
 >         ptr' <- allocClosure (f,code,n) vars
 >         return (ptr',zip vars ptrs)
->   | otherwise = fail (f ++ "applied to too many arguments")
+>   | otherwise = fail (f ++ " applied to too many arguments")
 > freshTerm ptr _ = return (ptr,[])
 
 \end{verbatim}
 \subsubsection{Disequality Constraints}
 Disequality constraints are implemented by the primitive function
 \texttt{=/=}. This function evaluates both arguments to head normal
-form, first. If one argument is a local variable node, the other
+form, first. If one argument is a (local) variable node, the other
 argument is evaluated to normal form and added as a constraint to the
 variable. Otherwise the tags of both arguments are compared and if
 they match the disequality is distributed over the arguments of the
@@ -1175,41 +978,38 @@
 >     diseqNodes ptr1 node ptr2 node'
 
 > diseqNodes :: NodePtr -> Node -> NodePtr -> Node -> Instruction
-> diseqNodes ptr1 var1@(VarNode cs1 wq1 space1)
->            ptr2 var2@(VarNode cs2 wq2 space2)
+> diseqNodes ptr1 var1@(VarNode cs1 wq1) ptr2 var2@(VarNode cs2 wq2)
 >   | ptr1 == ptr2 = failAndBacktrack
 >   | otherwise =
->       readState (isALocalSpace space1) >>= \so ->
->       if so then
->         do
->           updateState (saveBinding ptr1 var1)
->           updateNode ptr1 (VarNode (DisEq ptr2 : cs1) wq1 space1)
->           diseqSuccess
->       else
->         readState (isALocalSpace space2) >>= \so ->
->         if so then
->           do
->             updateState (saveBinding ptr2 var2)
->             updateNode ptr1 (VarNode (DisEq ptr1 : cs2) wq2 space2)
->             diseqSuccess
->         else
->           suspendSearch ptr1 var1 (diseqTerms ptr1 ptr2)
-> diseqNodes ptr1 var@(VarNode cs wq space) ptr2 node =
->   readState (isALocalSpace space) >>= \so ->
->   if so then
->     occursCheck ptr1 node >>= \occurs ->
->     if occurs then
->       diseqSuccess
->     else
 >       do
->         updateState (saveBinding ptr1 var)
->         (ptr',ptrs) <- freshTerm ptr2 node
->         updateNode ptr1 (VarNode (DisEq ptr2 : cs) wq space)
->         -- force evaluation of arguments to data terms!
->         unifyArgs (map (\(_,ptr) -> (ptr,ptr)) ptrs)
+>         updateState (saveBinding ptr1 var1)
+>         updateNode ptr1 (VarNode (DisEq ptr2 : cs1) wq1)
+>         diseqSuccess
+> diseqNodes ptr1 var1@(VarNode cs1 wq1) ptr2 var2@(GlobalVarNode _ _) =
+>   do
+>     updateState (saveBinding ptr1 var1)
+>     updateNode ptr1 (VarNode (DisEq ptr2 : cs1) wq1)
+>     diseqSuccess
+> diseqNodes ptr1 var1@(GlobalVarNode _ _) ptr2 var2@(VarNode cs2 wq2) =
+>   do
+>     updateState (saveBinding ptr2 var2)
+>     updateNode ptr1 (VarNode (DisEq ptr1 : cs2) wq2)
+>     diseqSuccess
+> diseqNodes ptr1 var1@(GlobalVarNode _ _) ptr2 var2@(GlobalVarNode _ _)
+>   | ptr1 == ptr2 = failAndBacktrack
+>   | otherwise = suspendSearch ptr1 var1 (diseqTerms ptr1 ptr2)
+> diseqNodes ptr1 var@(VarNode cs wq) ptr2 node =
+>   occursCheck ptr1 node >>= \occurs ->
+>   if occurs then
+>     diseqSuccess
 >   else
->     suspendSearch ptr1 var (diseqTerms ptr1 ptr2)
-> diseqNodes ptr1 node ptr2 var@(VarNode _ _ _) =
+>     do
+>       updateState (saveBinding ptr1 var)
+>       (ptr',ptrs) <- freshTerm ptr2 node
+>       updateNode ptr1 (VarNode (DisEq ptr2 : cs) wq)
+>       -- force evaluation of arguments to data terms!
+>       unifyArgs (map (\(_,ptr) -> (ptr,ptr)) ptrs)
+> diseqNodes ptr1 node ptr2 var@(VarNode _ _) =
 >   diseqNodes ptr2 var ptr1 node
 > diseqNodes _ (CharNode c) _ (CharNode d)
 >   | c /= d = diseqSuccess
@@ -1235,19 +1035,71 @@
 > diseqArgs [] = failAndBacktrack
 > diseqArgs ((ptr1,ptr2) : ptrs)
 >   | null ptrs = diseqFirst
->   | otherwise = choices [diseqFirst,diseqArgs ptrs]
+>   | otherwise = choice [diseqFirst,diseqArgs ptrs]
 >   where diseqFirst = updateState (pushNodes [ptr1,ptr2]) >> diseqCode
 
 > diseqSuccess :: Instruction
-> diseqSuccess = successCode
+> diseqSuccess = success >>= retNode
+
+\end{verbatim}
+\subsubsection{Pattern Binding Updates}
+Two primitive functions support the implementation of pattern bindings
+(cf.\ Sect.~\ref{sec:pattern-bindings}). The function
+\texttt{pbUpdate} overwrites a lazy application node with the
+application result and the function \texttt{pbReturn} returns a
+particular component of a pattern. In contrast to normal updates,
+\texttt{pbUpdate} must be prepared to update unevaluated applications
+as well as queue-me nodes. The semantics of the function
+\texttt{pbReturn} is similar to that of \texttt{(Prelude.\&>)} in that
+the first argument is a constraint and \texttt{pbReturn} returns the
+second argument when the constraint is satisfied. However, since the
+constraint is supposed to update the lazy application node that
+evaluates the \texttt{pbReturn} application, it discards its own
+update frame.
+\begin{verbatim}
+
+> pbUpdateFunction, pbReturnFunction :: Function
+> pbUpdateFunction = ("pbUpdate",pbUpdateCode,2)
+> pbReturnFunction = ("pbReturn",pbReturnCode,2)
+
+> pbUpdateCode :: Instruction
+> pbUpdateCode = read'updateState popNodes2 >>= uncurry update
+>   where update lptr ptr = deref lptr >>= updateLazy lptr ptr
+>         updateLazy lptr ptr lazy@(LazyNode _ _ _ _) =
+>           do
+>             updateState (saveBinding lptr lazy)
+>             updateNode lptr (IndirNode ptr)
+>             success >>= retNode
+>         updateLazy lptr ptr lazy@(QueueMeNode wq) =
+>           do
+>             updateState (saveBinding lptr lazy)
+>             updateNode lptr (IndirNode ptr)
+>             updateState (wakeThreads wq)
+>             success >>= retNode
+>         updateLazy _ ptr lazy@(IndirNode lptr) = update lptr ptr
+>         updateLazy _ _ _ = fail "Invalid pattern binding update"
+
+> pbReturnCode :: Instruction
+> pbReturnCode =
+>   do
+>     read'updateState popCont
+>     read'updateState (popNodes 3) >>= updateState . pushNodes . take 2
+>     entry ["p","v"] $ seqStmts "_p" (enter "p")
+>                     $ switchRigid "_p" [(successTag,const (enter "v"))]
+>                     $ const (fail "Type error in pattern binding update")
 
 \end{verbatim}
 \subsubsection{Encapsulated Search}
 The primitive function \texttt{try} starts the reduction of a search
 goal in a new local search space. After evaluating the argument to a
 closure (of arity 1), the code creates a new empty search space and an
-unbound (goal) variable, applies the search goal to that variable,
-and starts the reduction of this application.
+unbound (goal) variable, applies the search goal to that variable, and
+starts reduction of this application. All arguments of the closure are
+wrapped in global application nodes, since these nodes correspond to
+free variables of the search goal.
+
+\ToDo{Do not wrap atomic nodes at all and use global variable nodes
+  for all closure arguments which are in head normal form already.}
 \begin{verbatim}
 
 > tryFunction :: Function
@@ -1257,21 +1109,25 @@
 > tryCode =
 >   entry ["g"] $ seqStmts "_g" (enter "g")
 >               $ switchRigid "_g" [(ClosureTag,solve)]
->                             (const (fail "try: bad argument type!"))
+>               $ const (fail "try: bad argument type!")
 >   where solve ptr = deref ptr >>= solveNode
 >         solveNode goal =
 >           do
 >             space <- read'updateState newSearchSpace
->             goalVar <- read'updateState (allocNode (VarNode [] [] space))
->             goalApp <- applyGoal goal goalVar space
+>             goalVar <- read'updateState (allocNode (VarNode [] []))
+>             goalApp <- applyGoal goal goalVar
 >             updateState (pushSearchContext goalApp goalVar space)
 >             updateState newThread
 >             updateState (setVar "c" goalApp)
->             enter "c"
->         applyGoal (ClosureNode f n code ptrs) var space
+>             seqStmts "_c" (enter "c")
+>                      $ switchRigid "_c" [(successTag,retNode)]
+>                      $ const (fail "try: bad goal result type!")
+>         applyGoal (ClosureNode f n code ptrs) var
 >           | length ptrs + 1 == n =
->               read'updateState
->                 (allocNode (LazyNode f n code (ptrs ++ [var]) space))
+>               do
+>                 ptrs' <- globalArgs ptrs
+>                 read'updateState
+>                   (allocNode (LazyNode f n code (ptrs' ++ [var])))
 >           | otherwise = fail "try: invalid search goal"
 
 \end{verbatim}
@@ -1280,6 +1136,9 @@
 returns an empty list.
 \begin{verbatim}
 
+> nil :: MachStateT NodePtr
+> nil = read'updateState (atom nilTag)
+
 > failSearch :: Instruction
 > failSearch =
 >   do
@@ -1288,13 +1147,13 @@
 >     nil >>= retNode
 
 \end{verbatim}
-When the ready queue inside the encapsulated search becomes empty,
-this may be either due to the fact that goal has been successfully
-evaluated or because a deadlock has occurred. These cases can be
-distinguished by looking at the lazy application created for the goal.
-If it is in head normal form and ground, the goal has been solved. In
-this case, a singleton list containing a solved goal continuation is
-returned to the caller, otherwise the calling thread is suspended.
+When the ready queue becomes empty inside an encapsulated search, this
+may be either due to the goal being successfully evaluated or because
+a deadlock has occurred. These cases can be distinguished by looking
+at the lazy application created for the goal. If it is in head normal
+form and ground, the goal has been solved. In this case, a singleton
+list containing a solved goal continuation is returned to the caller,
+otherwise the calling thread is suspended.
 
 Because we cannot restore search continuations into an arbitrary
 search space, the value bound to the goal variable is copied into the
@@ -1303,7 +1162,7 @@
 \begin{verbatim}
 
 > list1 :: NodePtr -> MachStateT NodePtr
-> list1 x = nil >>= cons x
+> list1 x = list [x]
 
 > stoppedSearch :: Instruction
 > stoppedSearch =
@@ -1312,12 +1171,8 @@
 >     (goalApp,goalVar) <- read'updateState popSearchContext
 >     node <- derefPtr goalApp >>= deref
 >     case node of
->       LazyNode _ _ _ _ _ -> fail "Search goal not locked!"
->       QueueMeNode _ _ ->
->         do
->           readState (suspendThread undefined)
->           switchContext
->       VarNode _ _ _ ->
+>       LazyNode _ _ _ _ -> fail "Search goal not locked!"
+>       QueueMeNode _ ->
 >         do
 >           readState (suspendThread undefined)
 >           switchContext
@@ -1335,12 +1190,7 @@
 >             arg <- read'updateState popNode
 >             node <- deref arg
 >             case node of
->               VarNode _ _ space ->
->                 readState (isALocalSpace space) >>= \so ->
->                 if so then
->                   bindVar arg node solution successCode
->                 else
->                   unify arg solution
+>               VarNode _ _ -> bindVar arg node solution unifySuccess
 >               _ -> unify arg solution
 >         unify arg solution =
 >           do
@@ -1351,16 +1201,18 @@
 \ToDo{Find a way to restore a search space within an arbitrary other
   search space.}
 
-If a \texttt{choices} statement is executed in a local search space,
+If a \texttt{choice} statement is executed in a local search space,
 the current computation is interrupted and a list with one search
 continuation for each alternative is returned from \texttt{try}.
 \begin{verbatim}
 
 > list :: [NodePtr] -> MachStateT NodePtr
 > list = foldr (\x m -> m >>= cons x) nil
+>   where cons hd tl = allocData tag cName [hd,tl]
+>         ConstructorTag tag cName 2 = consTag
 
-> choicesSearch :: [Instruction] -> Instruction
-> choicesSearch alts =
+> choiceSearch :: [Instruction] -> Instruction
+> choiceSearch alts =
 >   do
 >     updateState (interruptThread undefined)
 >     rq <- readState saveContinuation
@@ -1388,12 +1240,8 @@
 >                   arg <- read'updateState popNode
 >                   node <- deref arg
 >                   case node of
->                     VarNode _ _ space ->
->                       readState (isALocalSpace space) >>= \so ->
->                       if so then
->                         bindVar arg node goalVar (continueGoal goalApp)
->                       else
->                         unify arg goalVar (continueGoal goalApp)
+>                     VarNode _ _ ->
+>                       bindVar arg node goalVar (continueGoal goalApp)
 >                     _ -> unify arg goalVar (continueGoal goalApp)
 >               else
 >                 fail "Cannot restore search continuation in non-root space"
@@ -1409,15 +1257,15 @@
 >             enter "c"
 
 \end{verbatim}
-When the search goal was solved, the solution of the goal is copied
-into the current search space using \texttt{copyGraph}. We must be
-careful to preserve the sharing of variable nodes when they are
-copied. In addition, we must copy only local variables. The same would
-hold for unevaluated lazy applications. However, the result bound to
-the goal variable cannot contain any unevaluated applications. In
-order to preserve the sharing of local variables, every copied
-variable is temporarily bound to its copy. This binding is recorded on
-the trail and is undone after the graph has been copied.
+When a solved search goal is applied, the solution of the goal is
+copied into the current search space using \texttt{copyGraph}. We must
+be careful to preserve sharing of variable nodes when they are copied.
+In addition, we must copy only local variables. The same would hold
+for unevaluated lazy applications. However, the result bound to the
+goal variable cannot contain any unevaluated applications. In order to
+preserve sharing of local variables, every copied variable is
+temporarily bound to its copy. This binding is recorded on the trail
+and is undone after the graph has been copied.
 
 Note that we use a temporary search context here to be able to undo
 the bindings performed during copying.
@@ -1441,40 +1289,41 @@
 >                 args' <- mapM (copy goalSpace curSpace) args
 >                 read'updateState
 >                   (allocNode (ConstructorNode tag cName args'))
->         copyNode goalSpace curSpace ptr var@(VarNode cs wq space) =
->           space `isLocalSpaceOf` goalSpace >>= \so ->
->           if so then
->             if null wq then
->               do
->                 cs' <- mapM (copyConstraint goalSpace curSpace) cs
->                 ptr' <-
->                   read'updateState (allocNode (VarNode cs' [] curSpace))
->                 updateState (saveBinding ptr var)
->                 updateNode ptr (IndirNode ptr')
->                 return ptr'
->             else
->               fail "cannot copy variable with non-empty waitlist"
+>         copyNode goalSpace curSpace ptr var@(VarNode cs wq) =
+>           if null wq then
+>             do
+>               cs' <- mapM (copyConstraint goalSpace curSpace) cs
+>               ptr' <- read'updateState (allocNode (VarNode cs' []))
+>               updateState (saveBinding ptr var)
+>               updateNode ptr (IndirNode ptr')
+>               return ptr'
 >           else
->             return ptr
+>             fail "cannot copy variable with non-empty waitlist"
 >         copyNode goalSpace curSpace ptr (ClosureNode name arity code args)
 >           | not (null args) =
 >               do
 >                 args' <- mapM (copy goalSpace curSpace) args
 >                 read'updateState
 >                   (allocNode (ClosureNode name arity code args'))
->         copyNode _ _ _ (LazyNode _ _ _ _ _) =
+>         copyNode _ _ _ (LazyNode _ _ _ _) =
 >           fail "cannot copy unevaluated lazy application node"
->         copyNode _ _ _ (QueueMeNode _ _) =
+>         copyNode _ _ _ (QueueMeNode _) =
 >           fail "cannot copy locked lazy application node"
 >         copyNode goalSpace curSpace ptr (IndirNode ptr') =
 >           copy goalSpace curSpace ptr'
+>         copyNode goalSpace curSpace ptr (GlobalAppNode ptr' space) =
+>           space `isLocalSpaceOf` curSpace >>= \so ->
+>           return (if so then ptr' else ptr)
+>         copyNode goalSpace curSpace ptr (GlobalVarNode ptr' space) =
+>           space `isLocalSpaceOf` curSpace >>= \so ->
+>           return (if so then ptr' else ptr)
 >         copyNode _ _ ptr _ = return ptr
 >         copyConstraint goalSpace curSpace (DisEq ptr) =
 >           liftM DisEq (copy goalSpace curSpace ptr)
 
 \end{verbatim}
-Inside an encapsulated search, non-local variables must not be bound
-and non-local lazy applications must not be evaluated. Otherwise,
+Inside an encapsulated search, free variables of the search goal must
+not be bound nor evaluated within the encapsulated search. Otherwise,
 the program could become unsound. For instance, consider the program
 \begin{verbatim}
   coin = 0
@@ -1482,40 +1331,96 @@
   main = (x,map unpack (all (\y -> y =:= x))) where x = coin
 \end{verbatim}
 If \texttt{x} were evaluated in the local search space, either the
-global choicepoint for the evaluation of \texttt{coin} would be lost
+global choice point for the evaluation of \texttt{coin} would be lost
 (because it occurs inside the encapsulated search), or the pair
-\texttt{(0,[0,1])} would be computed. For that reason, an
-encapsulated search and its calling thread are suspended until a
-non-local variable is instantiated and a non-local lazy application is
-evaluated outside the local search space, respectively.
+\texttt{(0,[0,1])} would be computed. For that reason, all free
+variables are wrapped in global application and global variable nodes
+and the current search is suspended when a global application node
+must be evaluated or a global variable node is matched. After the
+application has been evaluated or the variable has been instantiated,
+the global reference node is overwritten with a shallow copy of the
+result or bound variable whose arguments are wrapped in global
+application nodes. If the result of evaluating a global application is
+an unbound logical variable, a global variable node is returned
+instead.
+
+\ToDo{Do not wrap atomic arguments at all and use global variable
+  nodes for all arguments which are in head normal form already.}
 \begin{verbatim}
 
 > suspendSearch :: NodePtr -> Node -> Instruction -> Instruction
 > suspendSearch ptr node next =
 >   do
+>     assertGlobalRef node
 >     updateState (interruptThread next)
 >     cont <- readState saveContinuation
 >     space <- read'updateState saveSearchSpace
 >     (goalApp,goalVar) <- read'updateState popSearchContext
->     updateState (pushCont (resumeSearch goalApp goalVar cont space))
+>     updateState (pushCont (resumeSearch ptr goalApp goalVar cont space))
 >     updateState initEnv
->     updateState (setVar "x" ptr)
->     suspend node
->   where suspend (VarNode _ _ _) = switchRigid "x" [] retNode
->         suspend (LazyNode _ _ _ _ _) = enter "x"
->         suspend (QueueMeNode _ _) = enter "x"
->         suspend _ = fail "Bad node in suspendSearch"
+>     suspend ptr node
+>   where assertGlobalRef (GlobalAppNode _ space) =
+>           readState (isALocalSpace space) >>= \so ->
+>           when so (fail "suspendSearch: global application is not global")
+>         assertGlobalRef (GlobalVarNode _ space) =
+>           readState (isALocalSpace space) >>= \so ->
+>           when so (fail "suspendSearch: Global variable is not global")
+>         assertGlobalRef _ = fail "suspendSearch: Not a global reference"
+>         suspend ptr node@(GlobalAppNode ptr' space) =
+>           readState (isALocalSpace space) >>= \so ->
+>           if so then
+>             updateState (setVar "x" ptr') >> enter "x"
+>           else
+>             suspendSearch ptr node (retNode ptr)
+>         suspend ptr node@(GlobalVarNode ptr' space) =
+>           readState (isALocalSpace space) >>= \so ->
+>           if so then
+>             updateState (setVar "x" ptr') >> switchRigid "x" [] retNode
+>           else
+>             suspendSearch ptr node (retNode ptr)
 
 > resumeSearch ::
->     NodePtr -> NodePtr -> ThreadQueue -> SearchSpace -> Instruction
-> resumeSearch goalApp goalVar cont space =
+>     NodePtr -> NodePtr -> NodePtr -> ThreadQueue -> SearchSpace -> Instruction
+> resumeSearch gptr goalApp goalVar cont space =
 >   do
->     read'updateState popNode
+>     ptr <- read'updateState popNode
+>     deref gptr >>= updateState . saveBinding gptr
+>     deref ptr >>= globalNode ptr >>= updateNode gptr
 >     space' <- read'updateState newSearchSpace
 >     updateState (pushSearchContext goalApp goalVar space')
 >     updateState (restoreSearchSpace space)
 >     updateState (resumeContinuation cont)
 >     switchContext
+>   where globalNode ptr (CharNode _) = return (IndirNode ptr)
+>         globalNode ptr (IntNode _) = return (IndirNode ptr)
+>         globalNode ptr (FloatNode _) = return (IndirNode ptr)
+>         globalNode _ (ConstructorNode t c ptrs) =
+>           do
+>             ptrs' <- globalArgs ptrs
+>             ptr <- read'updateState (allocNode (ConstructorNode t c ptrs'))
+>             return (IndirNode ptr)
+>         globalNode ptr (VarNode _ _) =
+>           readState curSpace >>= return . GlobalVarNode ptr
+>         globalNode _ (ClosureNode f n code ptrs)
+>           | length ptrs < n =
+>               do
+>                 ptrs' <- globalArgs ptrs
+>                 ptr <-
+>                   read'updateState (allocNode (ClosureNode f n code ptrs'))
+>                 return (IndirNode ptr)
+>         globalNode _ (IndirNode ptr) = deref ptr >>= globalNode ptr
+>         globalNode ptr (SearchContinuation _ _ _ _) = return (IndirNode ptr)
+>         globalNode _ (GlobalAppNode ptr space) =
+>           return (GlobalAppNode ptr space)
+>         globalNode _ (GlobalVarNode ptr space) =
+>           return (GlobalVarNode ptr space)
+>         globalNode _ _ = fail "resumeSearch: non-hnf result"
+
+> globalArgs :: [NodePtr] -> MachStateT [NodePtr]
+> globalArgs ptrs =
+>   do
+>     space <- readState curSpace
+>     mapM (\ptr -> read'updateState (allocNode (GlobalAppNode ptr space))) ptrs
 
 \end{verbatim}
 \subsubsection{Monadic I/O Operations}
@@ -1524,41 +1429,6 @@
 > unit :: MachStateT NodePtr
 > unit = read'updateState (atom unitTag)
 
-> doneFunction,returnFunction,bind'Function,bindFunction :: Function
-> doneFunction = ("done",doneCode,1)
-> returnFunction = ("return",returnCode,2)
-> bind'Function = (">>",bind'Code,3)
-> bindFunction = (">>=",bindCode,3)
-
-> doneCode :: Instruction
-> doneCode = entry ["_"] (unit >>= retNode)
-
-> returnCode :: Instruction
-> returnCode = entry ["x","_"] (readState (getVar "x") >>= retNode)
-
-> bind'Code :: Instruction
-> bind'Code = 
->   entry ["m1","m2","_"]
->         (seqStmts "" (exec applyFunction ["m1","_"])
->                  (exec applyFunction ["m2","_"]))
-
-> bindCode :: Instruction
-> bindCode =
->   entry ["m1","m2","_"]
->         (seqStmts "x" (exec applyFunction ["m1","_"])
->               (seqStmts "f" (exec applyFunction ["m2","x"])
->                     (exec applyFunction ["f","_"])))
-
-> unsafePerformFunction :: Function
-> unsafePerformFunction = ("unsafePerformIO",unsafePerformCode,1)
-
-> unsafePerformCode :: Instruction
-> unsafePerformCode =
->   entry ["m"] $
->   do
->     unit >>= updateState . setVar "_"
->     exec applyFunction ["m","_"]
-
 > getCharFunction,getLineFunction,putCharFunction,putStrFunction :: Function
 > getCharFunction = ("getChar",getCharCode,1)
 > getLineFunction = ("getLine",getLineCode,1)
@@ -1569,7 +1439,7 @@
 > getCharCode =
 >   entry ["_"] $
 >   do
->     c <- liftIO $ catch (liftM Just getChar) handleEOF
+>     c <- liftIO $ IO.catch (liftM Just getChar) handleEOF
 >     maybe (fail "End of file") allocChar c >>= retNode
 >   where handleEOF e = if isEOFError e then return Nothing else ioError e
 
@@ -1577,7 +1447,7 @@
 > getLineCode =
 >   entry ["_"] $
 >   do
->     cs <- liftIO $ catch getLine handleEOF
+>     cs <- liftIO $ IO.catch getLine handleEOF
 >     mapM allocChar cs >>= list >>= retNode
 >   where handleEOF e = if isEOFError e then return [] else ioError e
 
@@ -1592,7 +1462,7 @@
 > putStrCode =
 >   entry ["cs","_"]
 >         (seqStmts "_cs" (enter "cs")
->           (switchRigid "_cs" [(nilTag,const (exec doneFunction ["_"])),
+>           (switchRigid "_cs" [(nilTag,const (unit >>= retNode)),
 >                               (consTag,putStrHead)]
 >                        (const (fail "putStr: bad argument type!"))))
 >   where putStrHead ptr = deref ptr >>= putStrNode
@@ -1650,7 +1520,7 @@
 the nullary tuple as input argument and expect the monadic function to
 return just the result. Actually, this result is discarded.
 
-To handle both modes of operation, we provide two entry-points for the
+To handle both modes of operation, we provide two entry points for the
 abstract machine: The function \texttt{start} reduces a goal
 expression and displays the resulting disjunctive expressions, whereas
 \texttt{startIO} reduces a monadic expression. We make use of the
@@ -1690,7 +1560,7 @@
 >             disjunct <- browse freeVars goal
 >             disjuncts <- failAndBacktrack >>= showResults (n+1) freeVars goal
 >             return (sep . disjunct . disjuncts)
->           where sep = if n > 0 then showString " | " else id
+>           where sep = if n > 0 then showChar '\n' else id
 >         allocGoal (f,code,n) vs
 >           | length vs < n = allocClosure (f,code,n) vs
 >           | otherwise = allocLazy (f,code,n) vs
diff -u curry-0.9.11/mach.lhs curry-0.9.11-classful/mach.lhs
--- curry-0.9.11/mach.lhs	2007-06-15 14:16:35.000000000 +0200
+++ curry-0.9.11-classful/mach.lhs	2013-05-13 09:54:58.000000000 +0200
@@ -1,7 +1,7 @@
 % -*- LaTeX -*-
-% $Id: mach.lhs 1912 2006-05-03 14:53:33Z wlux $
+% $Id: mach.lhs 3136 2013-05-12 15:53:27Z wlux $
 %
-% Copyright (c) 1998-2006, Wolfgang Lux
+% Copyright (c) 1998-2013, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{mach.lhs}
@@ -25,6 +25,7 @@
 > import Combined
 > import IO
 > import System
+> import Utils
 
 > data Option =
 >     Help
@@ -165,8 +166,8 @@
 >           alsoCommand1 opts inienv curenv script
 >           where (script,_) = break isSpace s
 >         alsoCommand1 opts inienv curenv script =
->           catch (readScript (verbose opts) (tracer opts) curenv script)
->                 (\e -> do putStrLn (show e); return curenv) >>=
+>           IO.catch (readScript (verbose opts) (tracer opts) curenv script)
+>                    (\e -> do putStrLn (show e); return curenv) >>=
 >           toploop opts inienv
 >         evalCommand opts inienv curenv s =
 >           do
@@ -263,8 +264,4 @@
 >         tracer' AbbrevStackTrace = Just (traceStack (dumpPtr 1))
 >         tracer' FullStackTrace = Just (traceStack (dumpPtr 25))
 
-> putErr, putErrLn :: String -> IO ()
-> putErr = hPutStr stderr
-> putErrLn = hPutStr stderr . (++ "\n")
-
 \end{verbatim}
diff -u curry-0.9.11/MachLoader.lhs curry-0.9.11-classful/MachLoader.lhs
--- curry-0.9.11/MachLoader.lhs	2007-06-15 14:16:35.000000000 +0200
+++ curry-0.9.11-classful/MachLoader.lhs	2011-10-08 12:42:52.000000000 +0200
@@ -1,7 +1,7 @@
 % -*- LaTeX -*-
-% $Id: MachLoader.lhs 1866 2006-03-02 17:34:02Z wlux $
+% $Id: MachLoader.lhs 3054 2011-10-07 15:19:59Z wlux $
 %
-% Copyright (c) 1998-2005, Wolfgang Lux
+% Copyright (c) 1998-2011, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{MachLoader.lhs}
@@ -47,7 +47,7 @@
 > function = lookupEnv
 
 \end{verbatim}
-In the translation of the statements, we provide the possibility to
+As part of the translation of statements, we provide the option to
 instrument the code, e.g., for tracing purposes. The optional
 instrumenting function is inserted before each statement. Note the use
 of a circular environment to lookup function names. This is necessary
@@ -56,32 +56,30 @@
 
 > type Instrument = Stmt -> Instruction -> Instruction
 
-> translate :: Maybe Instrument -> ConstrEnv -> FunEnv -> [(Name,[Name],Stmt)]
->          -> FunEnv
+> translate :: Maybe Instrument -> ConstrEnv -> FunEnv
+>           -> [(Visibility,Name,[Name],Stmt)] -> FunEnv
 > translate instrument cEnv fEnv fs = fEnv'
 >   where fEnv' = foldr (bindFun . translFun instrument cEnv fEnv') fEnv fs
 
-> translFun :: Maybe Instrument -> ConstrEnv -> FunEnv -> (Name,[Name],Stmt)
->           -> (Name,Int,Instruction)
-> translFun instrument cEnv fEnv (f,vs,st) =
+> translFun :: Maybe Instrument -> ConstrEnv -> FunEnv
+>           -> (Visibility,Name,[Name],Stmt) -> (Name,Int,Instruction)
+> translFun instrument cEnv fEnv (_,f,vs,st) =
 >   (f,length vs,entry (map show vs) (transl st))
 >   where transl = maybe translStmt translInstrumented instrument
 >         translInstrumented instrument st = instrument st (translStmt st)
->         translStmt (Return e) = returnNode (translExpr e)
->         translStmt (Enter v) = enter (show v)
+>         translStmt (Return e) = returnNode (translExpr Nothing e)
+>         translStmt (Eval v) = enter (show v)
 >         translStmt (Exec f vs) = exec (lookupFun f fEnv) (map show vs)
 >         translStmt (CCall _ _ cc) = translCCall cc
->         translStmt (Seq st1 st2) = translStmt0 st1 (transl st2)
+>         translStmt (Seq (v :<- st1) st2) =
+>           seqStmts (show v) (transl st1) (transl st2)
+>         translStmt (Let ds st) = letNodes ns (transl st)
+>           where ns = [(show v,translExpr (Just v) n) | Bind v n <- ds]
 >         translStmt (Switch rf v cases) =
 >           uncurry (switch rf (show v)) (translCases cases)
 >           where switch Rigid = switchRigid
 >                 switch Flex = switchFlex
->         translStmt (Choices alts) = choices (map transl alts)
->         translStmt0 (Lock v) = lock (show v)
->         translStmt0 (Update v1 v2) = update (show v1) (show v2)
->         translStmt0 (v :<- st) = seqStmts (show v) (transl st)
->         translStmt0 (Let bds) =
->           letNodes [(show v,translExpr n) | Bind v n <- bds]
+>         translStmt (Choice alts) = choice (map transl alts)
 >         translCCall (StaticCall f vs) =
 >           cCall (lookupPrim f primEnv) (map (show . snd) vs)
 >         translCCall (DynamicCall _ _) =
@@ -96,17 +94,21 @@
 >                 isDefault _ = False
 >         translCase (Case t st) =
 >           (caseTag cEnv t,bindArgs (translPattern t) (transl st))
->         translExpr (Lit c) = translLiteral c
->         translExpr (Constr c vs) =
+>         translExpr _ (Lit c) = translLiteral c
+>         translExpr _ (Constr c vs) =
 >           initConstr (lookupConstr c cEnv) (map show vs)
->         translExpr (Papp f vs) = initClosure (lookupFun f fEnv) (map show vs)
->         translExpr (Closure f vs) =
+>         translExpr _ (Papp f vs) =
 >           initClosure (lookupFun f fEnv) (map show vs)
->         translExpr (Lazy f vs) = initLazy (lookupFun f fEnv) (map show vs)
->         translExpr Free = initFree
->         translExpr (Var v) = initIndir (show v)
+>         translExpr _ (Closure f vs) =
+>           initClosure (lookupFun f fEnv) (map show vs)
+>         translExpr _ (Lazy f vs) = initLazy (lookupFun f fEnv) (map show vs)
+>         translExpr _ Free = initFree
+>         translExpr v (Var v')
+>           | v == Just v' = initQueueMe
+>           | otherwise = initIndir (show v')
 >         translLiteral (Char c) = initChar c
 >         translLiteral (Int i) = initInt i
+>         translLiteral (Integer i) = initInt i
 >         translLiteral (Float f) = initFloat f
 >         translPattern (LitCase _) = bindLiteral
 >         translPattern (ConstrCase _ vs) = bindData (map show vs)
@@ -172,22 +174,25 @@
 >           putStr ("data@" ++ show adr) >>
 >           when (d > 0)
 >                (putStr ('(' : name) >> dumpArgs (d-1) args >> putChar ')')
->         dumpNode d adr (VarNode cs wq space) =
->           putStr ("var@" ++ show adr ++ showSpace space)
+>         dumpNode d adr (VarNode cs wq) = putStr ("var@" ++ show adr)
 >         dumpNode d adr (ClosureNode name _ _ args) =
 >           putStr ("clos@" ++ show adr) >>
 >           when (d > 0)
 >                (putStr ('(' : name) >> dumpArgs (d-1) args >> putChar ')')
->         dumpNode d adr (LazyNode name _ _ args space) =
+>         dumpNode d adr (LazyNode name _ _ args) =
 >           putStr ("lazy@" ++ show adr) >>
 >           when (d > 0)
->                (putStr ('(' : name) >> dumpArgs (d-1) args >> putChar ')') >>
->           putStr (showSpace space)
->         dumpNode d adr (QueueMeNode wq space) =
->           putStr ("lock@" ++ show adr ++ showSpace space)
+>                (putStr ('(' : name) >> dumpArgs (d-1) args >> putChar ')')
+>         dumpNode d adr (QueueMeNode wq) = putStr ("lock@" ++ show adr)
 >         dumpNode d adr (IndirNode ptr) =
 >           putStr ("indir@" ++ show adr) >>
 >           when (d > 0) (putChar '(' >> dumpPtr (d-1) ptr >> putChar ')')
+>         dumpNode d adr (GlobalAppNode ptr space) =
+>           putStr ("gapp@" ++ show adr ++ showSpace space) >>
+>           when (d > 0) (putChar '(' >> dumpPtr (d-1) ptr >> putChar ')')
+>         dumpNode d adr (GlobalVarNode ptr space) =
+>           putStr ("gvar@" ++ show adr ++ showSpace space) >>
+>           when (d > 0) (putChar '(' >> dumpPtr (d-1) ptr >> putChar ')')
 >         dumpNode d adr (SearchContinuation _ _ _ _) =
 >           putStr ("cont@" ++ show adr)
 >         showSpace GlobalSpace = ""
@@ -206,22 +211,18 @@
 \begin{verbatim}
 
 > initConstrEnv :: ConstrEnv
-> initConstrEnv =
->   foldr bindTag emptyEnv [nilTag,consTag,unitTag,successTag]
->   where bindTag (ConstructorTag t c n) = bindEnv c (ConstructorTag t c n)
+> initConstrEnv = emptyEnv
 
 > bindConstr :: (ConstrDecl,Int) -> ConstrEnv -> ConstrEnv
-> bindConstr (ConstrDecl c tys,t) =
->   bindEnv c' (ConstructorTag t (snd $ splitQualified $ c') (length tys))
+> bindConstr (ConstrDecl _ c tys,t) =
+>   bindEnv c' (ConstructorTag t c' (length tys))
 >   where c' = demangle c
 
 > lookupConstr :: Name -> ConstrEnv -> NodeTag
 > lookupConstr c env =
 >   case lookupEnv c' env of
 >     Just x -> x
->     Nothing
->       | isTupleName c' -> (ConstructorTag 0 c' (length c' - 1))
->       | otherwise -> error ("Undefined constructor: " ++ c')
+>     Nothing -> error ("Undefined constructor: " ++ c')
 >   where c' = demangle c
 
 > tagWithArity :: Name -> Int -> ConstrEnv -> NodeTag
@@ -240,21 +241,16 @@
 > litTag :: Literal -> NodeTag
 > litTag (Char c) = CharTag c
 > litTag (Int i) = IntTag i
+> litTag (Integer i) = IntTag i
 > litTag (Float f) = FloatTag f
 
 > initFunEnv :: FunEnv
 > initFunEnv = foldr bindFun emptyEnv [
->       consFunction,failedFunction,successFunction,concConjFunction,
->       seqFunction,ensureNotFreeFunction,tryFunction,
+>       concConjFunction,tryFunction,
 >       equalFunction,compareFunction,unifyFunction,diseqFunction,
->       addIntFunction,subIntFunction,multIntFunction,
->       quotIntFunction,remIntFunction,divIntFunction,modIntFunction,
->       ordFunction,chrFunction,
->       addFloatFunction,subFloatFunction,multFloatFunction,divFloatFunction,
->       floatFromIntFunction,roundFloatFunction,truncateFloatFunction,
->       doneFunction,returnFunction,bind'Function,bindFunction,
+>       pbUpdateFunction,pbReturnFunction,
 >       getCharFunction,getLineFunction,putCharFunction,putStrFunction,
->       unsafePerformFunction,curryExitFunction
+>       curryExitFunction
 >     ]
 >   where bindFun fn@(name,_,_) = bindEnv name fn
 
@@ -263,7 +259,7 @@
 >   where f' = demangle f
 
 > bindConstrFun :: (ConstrDecl,Int) -> FunEnv -> FunEnv
-> bindConstrFun (ConstrDecl c tys,t) =
+> bindConstrFun (ConstrDecl _ c tys,t) =
 >   bindEnv c' (constrFunction t c' (length tys))
 >   where c' = demangle c
 
@@ -273,16 +269,14 @@
 >     Just f -> f
 >     Nothing
 >       | isApName f' -> applyFunctions !! (apArity f' - 1)
->       | isTupleName f' -> tupleFunctions !! (tupleArity f')
 >       | otherwise -> error ("Undefined function: " ++ f')
 >   where f' = demangle f
 >         isApName ('@':cs) = all isDigit cs
 >         isApName _ = False
 >         apArity ('@':cs) = if null cs then 1 else read cs
->         tupleArity f' = length f' - 1
 
 \end{verbatim}
-The environment holding the \verb|ccall|able primitives does not change.
+The environment holding the \verb|ccall|able primitives is fixed.
 \begin{verbatim}
 
 > primEnv :: PrimEnv
diff -u curry-0.9.11/MachResult.lhs curry-0.9.11-classful/MachResult.lhs
--- curry-0.9.11/MachResult.lhs	2007-06-15 14:16:36.000000000 +0200
+++ curry-0.9.11-classful/MachResult.lhs	2012-10-23 18:33:43.000000000 +0200
@@ -1,7 +1,7 @@
 % -*- LaTeX -*-
-% $Id: MachResult.lhs 1889 2006-04-06 16:55:47Z wlux $
+% $Id: MachResult.lhs 3103 2012-10-21 10:50:16Z wlux $
 %
-% Copyright (c) 1998-2006, Wolfgang Lux
+% Copyright (c) 1998-2012, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{MachResult.lhs}
@@ -9,16 +9,17 @@
 When we construct the answer expression from the final state of the
 computation, all (free) variables are given unique names. For the
 global free variables, these are the names which where specified at
-the program startup. The other variables are assigned fresh names. For
-the answer part of the result, we will consider only those variables
-which have been bound to some value (even if it is another unbound
-variable). As a side effect, the process shown below constructs the
-list of variables used in the answer expression.
+program startup. The other variables are assigned fresh names. For the
+answer part of the result, we will consider only those variables which
+have been bound to some value (even if it is another variable). As a
+side effect, the process shown below constructs the list of variables
+used in the answer expression.
 \begin{verbatim}
 
 > module MachResult where
 > import MachTypes
 > import MachNode
+> import Char
 > import List
 > import Set
 > import Monad
@@ -50,46 +51,59 @@
 >     Ptr adr ref <- derefPtr ptr
 >     node <- readRef ref
 >     exp <- browseExpression 0 names adr node
->     return (showsAnswer (nodeTag node == successTag) (answer ++ cstrs) exp)
+>     return (showsAnswer (isSuccess node) (answer ++ cstrs) exp)
 >   where names = variableNames freeVars
+>         isSuccess (ConstructorNode _ cName []) = cName == success
+>           where ConstructorTag _ success _ = successTag
+>         isSuccess _ = False
 
 > browseExpression :: Int -> [String] -> Integer -> Node -> BrowseState ShowS
 > browseExpression p names adr (CharNode c) = return (shows c)
-> browseExpression p names adr (IntNode i) = return (shows i)
-> browseExpression p names adr (FloatNode f) = return (shows f)
+> browseExpression p names adr (IntNode i) = return (showsPrec p i)
+> browseExpression p names adr (FloatNode f) = return (showsPrec p f)
 > browseExpression p names adr (ConstructorNode _ name args)
->   | isTupleName name = liftM showsTuple (mapM (browseElem names) args)
+>   | isTupleName name = liftM showsTuple (mapM (browseArg 0 names) args)
 >   | name == cons =
 >       do
->         mbCs <- getString args
->         case mbCs of
->           Just cs -> return (shows cs)
->           Nothing -> liftM showsList (browseList names args)
->   | otherwise = liftM (showsTerm p name) (mapM (browseArg names) args)
+>         kind <- listKind args
+>         case kind of
+>           String cs -> return (shows cs)
+>           ClosedList -> liftM showsList (browseList names args)
+>           OpenList -> liftM (uncurry (showsCons p)) (browseCons names args)
+>   | otherwise =
+>       liftM (showsTerm p (unqualify name)) (mapM (browseArg 11 names) args)
 >   where ConstructorTag _ cons _ = consTag
-> browseExpression p names adr (VarNode _ _ _) =
+> browseExpression p names adr (VarNode _ _) =
 >   liftM showString (varName names adr)
 > browseExpression p names adr (ClosureNode name _ _ args) =
->   liftM (showsTerm p name) (mapM (browseArg names) args)
-> browseExpression p names adr (LazyNode name arity code args _) =
+>   liftM (showsTerm p name) (mapM (browseArg 11 names) args)
+> browseExpression p names adr (LazyNode name arity code args) =
 >   browseExpression p names adr (ClosureNode name arity code args)
-> browseExpression p names adr (QueueMeNode _ _) =
+> browseExpression p names adr (QueueMeNode _) =
 >   return (showString "Suspended")
-> browseExpression p names adr (IndirNode (Ptr adr' ref)) =
->   readRef ref >>= browseExpression p names adr'
+> browseExpression p names _ (IndirNode (Ptr adr ref)) =
+>   readRef ref >>= browseExpression p names adr
+> browseExpression p names _ (GlobalAppNode (Ptr adr ref) _) =
+>   readRef ref >>= browseExpression p names adr
+> browseExpression p names _ (GlobalVarNode (Ptr adr ref) _) =
+>   readRef ref >>= browseExpression p names adr
 > browseExpression p names adr (SearchContinuation _ _ _ _) =
 >   return (showString "<search>")
 
-> browseArg :: [String] -> NodePtr -> BrowseState ShowS
-> browseArg names (Ptr adr ref) = readRef ref >>= browseExpression 1 names adr
+> browseArg :: Int -> [String] -> NodePtr -> BrowseState ShowS
+> browseArg p names (Ptr adr ref) = readRef ref >>= browseExpression p names adr
 
-> browseElem :: [String] -> NodePtr -> BrowseState ShowS
-> browseElem names (Ptr adr ref) = readRef ref >>= browseExpression 0 names adr
+> browseCons :: [String] -> [NodePtr] -> BrowseState (ShowS,ShowS)
+> browseCons names [head,tail] =
+>   do
+>     hd <- browseArg 6 names head
+>     tl <- browseArg 5 names tail
+>     return (hd,tl)
 
 > browseList :: [String] -> [NodePtr] -> BrowseState ShowS
 > browseList names [head,tail] =
 >   do
->     hd <- browseElem names head
+>     hd <- browseArg 0 names head
 >     tl <- derefPtr tail >>= browseTail names
 >     return (hd . tl)
 
@@ -104,18 +118,34 @@
 >   where ConstructorTag _ nil _  = nilTag
 >         ConstructorTag _ cons _ = consTag
 
-> getString :: [NodePtr] -> BrowseState (Maybe String)
-> getString [head,tail] =
+> data ListKind = String String | ClosedList | OpenList
+
+> listKind :: [NodePtr] -> BrowseState ListKind
+> listKind [head,tail] =
 >   do
->     mbC <- getStringHead head
->     case mbC of
->       Just c ->
+>     kind <- tailKind tail
+>     case kind of
+>       String cs ->
 >         do
->           mbCs <- getStringTail tail
->           case mbCs of
->             Just cs -> return (Just (c:cs))
->             Nothing -> return Nothing
->       Nothing -> return Nothing
+>           mbC <- getStringHead head
+>           case mbC of
+>             Just c -> return (String (c:cs))
+>             Nothing -> return ClosedList
+>       ClosedList -> return ClosedList
+>       OpenList -> return OpenList
+
+> tailKind :: NodePtr -> BrowseState ListKind
+> tailKind (Ptr _ ref) =
+>   readRef ref >>= \node ->
+>   case node of
+>     ConstructorNode _ cName args
+>       | cName == nil -> return (String [])
+>       | cName == cons -> listKind args
+>       | otherwise -> return OpenList
+>     IndirNode ptr -> tailKind ptr
+>     _ -> return OpenList
+>   where ConstructorTag _ nil _  = nilTag
+>         ConstructorTag _ cons _ = consTag
 
 > getStringHead :: NodePtr -> BrowseState (Maybe Char)
 > getStringHead (Ptr _ ref) =
@@ -125,25 +155,12 @@
 >     IndirNode ptr -> getStringHead ptr
 >     _ -> return Nothing
 
-> getStringTail :: NodePtr -> BrowseState (Maybe String)
-> getStringTail (Ptr _ ref) =
->   readRef ref >>= \node ->
->   case node of
->     ConstructorNode _ cName args
->       | cName == nil -> return (Just [])
->       | cName == cons -> getString args
->       | otherwise -> return Nothing
->     IndirNode ptr -> getStringTail ptr
->     _ -> return Nothing
->   where ConstructorTag _ nil _  = nilTag
->         ConstructorTag _ cons _ = consTag
-
 > browseSubsts :: [String] -> [(String,NodePtr)] -> BrowseState [ShowS]
 > browseSubsts names freeVars =
 >   mapM readVar freeVars >>= mapM (browseSubst names) . filter isBound
 >   where readVar (name,Ptr adr ref) =
 >           readRef ref >>= \node -> return (name,adr,node)
->         isBound (_,_,VarNode _ _ _) = False
+>         isBound (_,_,VarNode _ _) = False
 >         isBound _ = True
 
 > browseSubst :: [String] -> (String,Integer,Node) -> BrowseState ShowS
@@ -158,7 +175,7 @@
 >   mapM (browseConstraint names) . concat
 >   where constraints (Ptr adr ref) =
 >           varName names adr >>= \name ->
->           readRef ref >>= \(VarNode cs _ _) ->
+>           readRef ref >>= \(VarNode cs _) ->
 >           return [(name,c) | c <- cs]
 
 > browseConstraint :: [String] -> (String,Constraint) -> BrowseState ShowS
@@ -171,12 +188,12 @@
 >   readRef ref >>= \node ->
 >   case node of
 >     ConstructorNode _ _ args -> foldM constrainedVars vars args
->     VarNode cstrs _ _
+>     VarNode cstrs _
 >       | ptr `notElemSet` vars && not (null cstrs) ->
 >           foldM constrainedVars (addToSet ptr vars) [ptr | DisEq ptr <- cstrs]
 >       | otherwise -> return vars
 >     ClosureNode _ _ _ args -> foldM constrainedVars vars args
->     LazyNode _ _ _ args _ -> foldM constrainedVars vars args
+>     LazyNode _ _ _ args -> foldM constrainedVars vars args
 >     IndirNode ptr -> constrainedVars vars ptr
 >     _ -> return vars
 
@@ -188,7 +205,7 @@
 
 > showsTerm :: Int -> String -> [ShowS] -> ShowS
 > showsTerm p root args =
->   showParen (not (null args) && p > 0) (catBy " " (showString root : args))
+>   showParen (not (null args) && p > 10) (catBy " " (showString root : args))
 
 > showsTuple :: [ShowS] -> ShowS
 > showsTuple args = braces ('(',')') (catBy "," args)
@@ -196,6 +213,9 @@
 > showsList :: ShowS -> ShowS
 > showsList = braces ('[',']')
 
+> showsCons :: Int -> ShowS -> ShowS -> ShowS
+> showsCons p hd tl = showParen (p > 5) (hd . showChar ':' . tl)
+
 > catBy :: String -> [ShowS] -> ShowS
 > catBy sep = cat . intersperse (showString sep)
 
@@ -222,7 +242,7 @@
 \end{verbatim}
 The list of variable names is initialized with the names of the global
 variables, followed by a supply of generated names. This generator
-is just a copy of the function used to generate fresh variables names
+is just a copy of the function used to generate fresh variable names
 in the interpreter \ToDo{So they should probably be joined into a
 single utility function}. Note that we use lowercase letters for
 variable names here, too.
@@ -235,3 +255,25 @@
 >         genName c i = '_' : c : if i == 0 then "" else show i
 
 \end{verbatim}
+When (saturated) data constructor applications are shown in the
+result, we strip the module prefixes from the data constructor names
+to make the output more readable. Stripping is implemented in function
+\texttt{unqualify}, which assumes that a module identifier starts with
+an alphabetic character and continues up to the next period.
+\begin{verbatim}
+
+> unqualify :: String -> String
+> unqualify [] = []
+> unqualify (c:cs)
+>   | isAlpha c =
+>       case break ('.' ==) cs of
+>         (_,[]) -> c:cs
+>         (prefix,'.':cs')
+>           | null cs' || isDigit (head cs') -> c:cs
+>           | otherwise -> unqualify cs'
+>           where sep cs1 cs2
+>                   | null cs2 = cs1
+>                   | otherwise = cs1 ++ '.':cs2
+>   | otherwise = c:cs
+
+\end{verbatim}
diff -u curry-0.9.11/MachTypes.lhs curry-0.9.11-classful/MachTypes.lhs
--- curry-0.9.11/MachTypes.lhs	2007-06-15 14:16:36.000000000 +0200
+++ curry-0.9.11-classful/MachTypes.lhs	2010-08-31 09:23:03.000000000 +0200
@@ -1,7 +1,7 @@
 % -*- LaTeX -*-
-% $Id: MachTypes.lhs 1893 2006-04-12 17:51:56Z wlux $
+% $Id: MachTypes.lhs 3002 2010-08-30 19:41:06Z wlux $
 %
-% Copyright (c) 1998-2006, Wolfgang Lux
+% Copyright (c) 1998-2009, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \subsection{Basic Types}
@@ -43,10 +43,10 @@
 
 In order to implement the heap we use mutable references, which are
 provided by most Haskell implementations. Every node allocated in the
-heap is also assigned an ``address''. We use a simple counter for that
-purpose.
+heap is also assigned an ``address''. We use a simple allocation
+counter for that purpose, which is part of the machine's state.
 \subsubsection{Functions}
-A function is described by its name, entry-point, and arity.
+A function is described by its name, entry point, and arity.
 \begin{verbatim}
 
 > type Function = (String,Instruction,Int)
@@ -56,23 +56,14 @@
 The heap contains nodes which are used to build a graph corresponding
 to the final result of the goal being evaluated.
 
-Integer and floating-point numbers are represented by the
-corresponding cases in the \texttt{Node} type and consists of the
-number's value.
-
-A variable node represents an unbound variable. It has three fields,
-the first contains a list of constraints for the variable, the second
-contains the list of threads that have been delayed for that variable,
-and the third contains the search space in which the variable was
-created. Once the variable is instantiated the node will be
-overwritten destructively.
+Integer and floating-point numbers are represented by the respective
+cases of the \texttt{Node} type and comprise only the number's value.
 
-Indirection nodes are used when a variable or a lazy application node
-is overwritten in order to preserve the sharing of nodes. An
-indirection node solely consists of a pointer to the new node.
-
-Partial applications nodes represent partial applications of data
-constructors and functions.
+A variable node represents an unbound variable and has two fields. The
+first field holds a list of constraints for the variable and the
+second holds the list of threads that are blocked by the variable.
+Once the variable is instantiated the node is overwritten
+destructively.
 
 Closure and lazy application nodes represent functions and their
 applications. A plain function corresponds to a closure node without
@@ -80,33 +71,50 @@
 function, the arity, and the list of arguments to which the function
 has been applied. In addition, the name of the function is included in
 order to make the output more readable. Besides that it has no
-semantic meaning.
-
-In contrast to closure nodes, lazy application nodes are overwritten
-with their result after they have been evaluated. In addition to the
-fields of a closure node, lazy application nodes also include the
-search space in which the node was constructed.
+semantic meaning. In contrast to closure nodes, lazy application nodes
+are overwritten with their result after they have been
+evaluated.
+
+Partial applications of functions are represented by closure nodes as
+well using fewer arguments than the function's arity. Partial
+applications of data constructors cannot be represented directly.
+However, when a program is loaded an auxiliary function with the same
+name is implicitly defined for each data constructor for this purpose.
 
 In order to prevent multiple threads from evaluating the same
 application, lazy application nodes are overwritten by a queue-me node
 when a thread starts their evaluation. A wait queue similar to
-variable nodes is used to collect the threads that have been delayed
-on this node. Once evaluation of a lazy application completes
-successfully, the queue-me node is overwritten by the result of the
-evaluation.
-
-Search continuation nodes are used to represent the alternative
-continuations returned by the \texttt{try} operator. A search
-continuation saves the goal application and variable of the goal being
-evaluated. In addition, the state of all local threads and the
-corresponding search space are saved in this node.
+variable nodes is used to collect the threads that wait for the
+application's result becoming available. Once evaluation of a lazy
+application completes successfully, the queue-me node is overwritten
+with (an indirection pointing to) the result of the application.
+
+Indirection nodes are used when a variable or a lazy application node
+is overwritten in order to preserve the sharing of nodes. An
+indirection node solely consists of a pointer to the new node.
+
+Global application and global variable nodes represent (possibly
+unevaluated) applications and (possible unbound) logical variables,
+respectively, that are passed as free variables to search goals. These
+global reference nodes combine a pointer to the referenced node and
+the search space in which that node is defined. \\
+\textbf{Invariant:} \emph{The interpreter maintains the invariant that
+  the search space field of a global reference node to which a search
+  goal has direct access never refers to the goal's local search
+  space.}
+
+Search continuation nodes represent the alternative continuations
+returned by an encapsulated search. A search continuation saves the
+goal application and variable of the goal being evaluated. In
+addition, the state of all local threads and the corresponding search
+space are saved.
 \begin{verbatim}
 
 > data NodeTag =
->     CharTag Char | IntTag Int | FloatTag Double
+>     CharTag Char | IntTag Integer | FloatTag Double
 >   | ConstructorTag Int String Int | VariableTag
 >   | ClosureTag | LazyTag | QueueMeTag
->   | IndirTag | SearchTag
+>   | IndirTag | GlobalAppTag | GlobalVarTag | SearchTag
 >   deriving Show
 > instance Eq NodeTag where
 >   CharTag c == CharTag d = c == d
@@ -118,17 +126,21 @@
 >   LazyTag == LazyTag = True
 >   QueueMeTag == QueueMeTag = True
 >   IndirTag == IndirTag = True
+>   GlobalAppTag == GlobalAppTag = True
+>   GlobalVarTag == GlobalVarTag = True
 >   SearchTag == SearchTag = True
 >   _ == _ = False
 
 > data Node =
->     CharNode Char | IntNode Int | FloatNode Double
+>     CharNode Char | IntNode Integer | FloatNode Double
 >   | ConstructorNode Int String [NodePtr]
->   | VarNode [Constraint] ThreadQueue SearchSpace
+>   | VarNode [Constraint] ThreadQueue
 >   | ClosureNode String Int Instruction [NodePtr]
->   | LazyNode String Int Instruction [NodePtr] SearchSpace
->   | QueueMeNode ThreadQueue SearchSpace
+>   | LazyNode String Int Instruction [NodePtr]
+>   | QueueMeNode ThreadQueue
 >   | IndirNode NodePtr
+>   | GlobalAppNode NodePtr SearchSpace
+>   | GlobalVarNode NodePtr SearchSpace
 >   | SearchContinuation NodePtr NodePtr ThreadQueue SearchSpace
 
 > instance Show Node where
@@ -141,28 +153,31 @@
 >   showsPrec p (ConstructorNode tag name args) = showParen (p >= 10) $
 >     showString "ConstructorNode " . shows tag . showChar ' ' .
 >       showString name . flip (foldr showArg) args
->     where showArg arg = showChar ' ' . showsPrec 1 arg
->   showsPrec p (VarNode constraints waitqueue space) = showParen (p >= 10) $
->     showString "VarNode " . showsPrec 1 constraints . showChar ' ' .
->       showsPrec 1 waitqueue . showChar ' ' . showsPrec 1 space
+>     where showArg arg = showChar ' ' . shows arg
+>   showsPrec p (VarNode constraints waitqueue) = showParen (p >= 10) $
+>     showString "VarNode " . shows constraints . showChar ' ' . shows waitqueue
 >   showsPrec p (ClosureNode name arity code args) = showParen (p >= 10) $
 >     showString "ClosureNode " . showString name . showChar ' ' .
 >       shows arity . flip (foldr showArg) args
->     where showArg arg = showChar ' ' . showsPrec 1 arg
->   showsPrec p (LazyNode name arity code args space) = showParen (p >= 10) $
+>     where showArg arg = showChar ' ' . shows arg
+>   showsPrec p (LazyNode name arity code args) = showParen (p >= 10) $
 >     showString "LazyNode " . showString name . showChar ' ' .
->       shows arity . flip (foldr showArg) args . showChar ' ' .
->         showsPrec 1 space
->     where showArg arg = showChar ' ' . showsPrec 1 arg
->   showsPrec p (QueueMeNode waitqueue space) = showParen (p >= 10) $
->     showString "QueueMeNode " . showsPrec 1 waitqueue . showChar ' ' .
->       showsPrec 1 space
+>       shows arity . flip (foldr showArg) args
+>     where showArg arg = showChar ' ' . shows arg
+>   showsPrec p (QueueMeNode waitqueue) =
+>     showParen (p >= 10) $ showString "QueueMeNode " . shows waitqueue
 >   showsPrec p (IndirNode ptr) =
->     showParen (p >= 10) $ showString "IndirNode " . showsPrec 1 ptr
+>     showParen (p >= 10) $ showString "IndirNode " . shows ptr
+>   showsPrec p (GlobalAppNode ptr space) = showParen (p >= 10) $
+>     showString "GlobalAppNode " . shows ptr . showChar ' ' .
+>       showsPrec 10 space
+>   showsPrec p (GlobalVarNode ptr space) = showParen (p >= 10) $
+>     showString "GlobalVarNode " . shows ptr . showChar ' ' .
+>       showsPrec 10 space
 >   showsPrec p (SearchContinuation app var rq space) = showParen (p >= 10) $
->     showString "SearchContinuation " . showsPrec 1 app . showChar ' ' .
->       showsPrec 1 var . showChar ' ' . showsPrec 1 rq . showChar ' ' .
->         showsPrec 1 space
+>     showString "SearchContinuation " . shows app . showChar ' ' .
+>       shows var . showChar ' ' . shows rq . showChar ' ' .
+>         showsPrec 10 space
 
 > data NodePtr = Ptr Integer (Ref Node)
 > instance Eq NodePtr where
@@ -177,21 +192,24 @@
 > nodeTag (IntNode i) = IntTag i
 > nodeTag (FloatNode f) = FloatTag f
 > nodeTag (ConstructorNode t c xs) = ConstructorTag t c (length xs)
-> nodeTag (VarNode _ _ _) = VariableTag
+> nodeTag (VarNode _ _) = VariableTag
 > nodeTag (ClosureNode _ _ _ _) = ClosureTag
-> nodeTag (LazyNode _ _ _ _ _) = LazyTag
-> nodeTag (QueueMeNode _ _) = QueueMeTag
+> nodeTag (LazyNode _ _ _ _) = LazyTag
+> nodeTag (QueueMeNode _) = QueueMeTag
 > nodeTag (IndirNode _) = IndirTag
+> nodeTag (GlobalAppNode _ _) = GlobalAppTag
+> nodeTag (GlobalVarNode _ _) = GlobalVarTag
 > nodeTag (SearchContinuation _ _ _ _) = SearchTag
 
 > nilTag, consTag, unitTag, successTag :: NodeTag
-> nilTag  = ConstructorTag 0 "[]" 0
-> consTag = ConstructorTag 1 ":" 2
-> unitTag = ConstructorTag 0 "()" 0
-> successTag = ConstructorTag 0 "Success" 0
+> nilTag  = ConstructorTag 0 "Prelude.[]" 0
+> consTag = ConstructorTag 1 "Prelude.:" 2
+> unitTag = ConstructorTag 0 "Prelude.()" 0
+> successTag = ConstructorTag 0 "Prelude.Success" 0
 
 > isTupleName :: String -> Bool
-> isTupleName ('(':',':cs) = dropWhile (',' ==) cs == ")"
+> isTupleName ('P':'r':'e':'l':'u':'d':'e':'.':'(':',':cs) =
+>   dropWhile (',' ==) cs == ")"
 > isTupleName _ = False
 
 \end{verbatim}
diff -u curry-0.9.11/Makefile-bin.in curry-0.9.11-classful/Makefile-bin.in
--- curry-0.9.11/Makefile-bin.in	2007-06-15 14:16:33.000000000 +0200
+++ curry-0.9.11-classful/Makefile-bin.in	2009-03-30 13:58:15.000000000 +0200
@@ -1,8 +1,8 @@
 # Makefile for the binary distribution of the Curry compiler -*- makefile -*-
 #
-# $Id: Makefile-bin.in 2231 2007-06-06 14:41:15Z wlux $
+# $Id: Makefile-bin.in 2768 2009-03-26 09:10:57Z wlux $
 #
-# Copyright (c) 2002-2007, Wolfgang Lux
+# Copyright (c) 2002-2009, Wolfgang Lux
 #
 
 # package information
@@ -16,6 +16,7 @@
 # install directories
 prefix = @prefix@
 exec_prefix = @exec_prefix@
+datarootdir = @datarootdir@
 bindir = @bindir@
 libdir = @libdir@
 mandir = @mandir@
diff -u curry-0.9.11/Makefile.in curry-0.9.11-classful/Makefile.in
--- curry-0.9.11/Makefile.in	2007-06-15 14:16:33.000000000 +0200
+++ curry-0.9.11-classful/Makefile.in	2013-05-13 09:54:58.000000000 +0200
@@ -1,8 +1,8 @@
 # Makefile for the Curry compiler
 #
-# $Id: Makefile.in 2239 2007-06-10 00:46:39Z wlux $
+# $Id: Makefile.in 3136 2013-05-12 15:53:27Z wlux $
 #
-# Copyright (c) 2000-2007 Wolfgang Lux
+# Copyright (c) 2000-2013 Wolfgang Lux
 # See LICENSE for the full license.
 #
 
@@ -18,14 +18,16 @@
 # install directories
 prefix = @prefix@
 exec_prefix = @exec_prefix@
+datarootdir = @datarootdir@
 bindir = @bindir@
 libdir = @libdir@
 mandir = @mandir@
 
 # compiler definitions
 HC = @HC@
-HCFLAGS = @HCFLAGS@
+HFLAGS = @HFLAGS@
 HC_PATH_STYLE = @HC_PATH_STYLE@
+HASKELL = @HASKELL@
 
 LATEX = latex
 BIBTEX = bibtex
@@ -45,12 +47,22 @@
 cycc_SRCS = \
 	cycc.hs \
 	Ident.lhs \
+	PredefIdent.lhs \
+	Kinds.lhs \
 	Types.lhs \
-	CurrySyntax.lhs \
+	PredefTypes.lhs \
+	Curry.lhs \
+	CurryUtils.lhs \
 	CurryPP.lhs \
 	CurryLexer.lhs \
 	CurryParser.lhs \
 	Base.lhs \
+	Interfaces.lhs \
+	IdentInfo.lhs \
+	TypeInfo.lhs \
+	InstInfo.lhs \
+	ValueInfo.lhs \
+	PrecInfo.lhs \
 	ImportSyntaxCheck.lhs \
 	TypeSyntaxCheck.lhs \
 	SyntaxCheck.lhs \
@@ -62,19 +74,31 @@
 	Renaming.lhs \
 	PrecCheck.lhs \
 	KindCheck.lhs \
+	InstCheck.lhs \
+	Deriving.lhs \
 	TypeCheck.lhs \
 	IntfSyntaxCheck.lhs \
+	IntfQual.lhs \
 	IntfCheck.lhs \
 	IntfEquiv.lhs \
 	Imports.lhs \
 	Exports.lhs \
+	KindSubst.lhs \
+	KindTrans.lhs \
 	TypeSubst.lhs \
 	TypeTrans.lhs \
 	Typing.lhs \
+	TrustInfo.lhs \
 	Trust.lhs \
 	Qual.lhs \
 	Desugar.lhs \
+	Records.lhs \
+	Newtype.lhs \
+	LazyPatterns.lhs \
+	CaseMatch.lhs \
 	Simplify.lhs \
+	PatternBind.lhs \
+	DictTrans.lhs \
 	Lift.lhs \
 	IL.lhs \
 	ILPP.lhs \
@@ -90,6 +114,9 @@
 	CPS.lhs \
 	CGen.lhs \
 	Modules.lhs \
+	Goals.lhs \
+	Common.lhs \
+	SplitModule.lhs \
 	Options.lhs \
 	Unlit.lhs \
 	LexComb.lhs \
@@ -108,7 +135,11 @@
 	GetOpt.hs \
 	Utils.lhs \
 	$(PATHUTILS_LHS) \
-	$(IOEXTS_LHS)
+	$(IOEXTS_LHS) \
+	$(cycc_$(HASKELL)_SRCS)
+cycc_hs2010_SRCS = hs2010/Char.hs hs2010/Directory.hs hs2010/IO.hs \
+	hs2010/List.hs hs2010/Maybe.hs hs2010/Monad.hs hs2010/Ratio.hs \
+	hs2010/System.hs
 cycc_XXX  = $(cycc_SRCS:.hs=.hi)
 cycc_INTF = $(cycc_XXX:.lhs=.hi)
 cycc_OBJS = $(cycc_INTF:.hi=.o)
@@ -116,8 +147,9 @@
 cymk_SRCS = \
 	cymk.hs \
 	Ident.lhs \
+	PredefIdent.lhs \
 	CurryDeps.lhs \
-	CurrySyntax.lhs \
+	Curry.lhs \
 	CurryLexer.lhs \
 	CurryParser.lhs \
 	Unlit.lhs \
@@ -130,13 +162,22 @@
 	Set.lhs \
 	Position.lhs \
 	GetOpt.hs \
-	$(PATHUTILS_LHS)
+	Utils.lhs \
+	$(PATHUTILS_LHS) \
+	$(cymk_$(HASKELL)_SRCS)
+cymk_hs2010_SRCS = hs2010/Char.hs hs2010/Directory.hs hs2010/IO.hs \
+	hs2010/List.hs hs2010/Maybe.hs hs2010/Monad.hs hs2010/Ratio.hs \
+	hs2010/System.hs
 cymk_XXX  = $(cymk_SRCS:.hs=.hi)
 cymk_INTF = $(cymk_XXX:.lhs=.hi)
 cymk_OBJS = $(cymk_INTF:.hi=.o)
 
 newer_SRCS = \
-	newer.lhs
+	newer.lhs \
+	Utils.lhs \
+	$(newer_$(HASKELL)_SRCS)
+newer_hs2010_SRCS = hs2010/Directory.hs hs2010/IO.hs hs2010/List.hs \
+	hs2010/System.hs hs2010/Time.hs
 newer_XXX  = $(newer_SRCS:.hs=.hi)
 newer_INTF = $(newer_XXX:.lhs=.hi)
 newer_OBJS = $(newer_INTF:.hi=.o)
@@ -160,7 +201,11 @@
 	Set.lhs \
 	Position.lhs \
 	Utils.lhs \
-	$(PATHUTILS_LHS)
+	$(PATHUTILS_LHS) \
+	$(cam2c_$(HASKELL)_SRCS)
+cam2c_hs2010_SRCS = hs2010/Char.hs hs2010/Directory.hs hs2010/IO.hs \
+	hs2010/List.hs hs2010/Maybe.hs hs2010/Monad.hs hs2010/Ratio.hs \
+	hs2010/System.hs
 cam2c_XXX  = $(cam2c_SRCS:.hs=.hi)
 cam2c_INTF = $(cam2c_XXX:.lhs=.hi)
 cam2c_OBJS = $(cam2c_INTF:.hi=.o)
@@ -189,7 +234,10 @@
 	Map.lhs \
 	Set.lhs \
 	Utils.lhs \
-	$(IOEXTS_LHS)
+	$(IOEXTS_LHS) \
+	$(mach_$(HASKELL)_SRCS)
+mach_hs2010_SRCS = hs2010/Char.hs hs2010/IO.hs hs2010/List.hs \
+	hs2010/Maybe.hs hs2010/Monad.hs hs2010/Ratio.hs hs2010/System.hs
 mach_XXX  = $(mach_SRCS:.hs=.hi)
 mach_INTF = $(mach_XXX:.lhs=.hi)
 mach_OBJS = $(mach_INTF:.hi=.o)
@@ -200,6 +248,10 @@
 IOEXTS_LHS = @IOExts_lhs@
 IOEXTS_SRCS = ghc/IOExts.lhs hbc/IOExts.lhs nhc/IOExts.lhs
 
+HS2010_SRCS = hs2010/Char.hs hs2010/Directory.hs hs2010/IO.hs hs2010/List.hs \
+	      hs2010/Maybe.hs hs2010/Monad.hs hs2010/Ratio.hs hs2010/System.hs \
+	      hs2010/Time.hs
+
 SRCS = $(cycc_SRCS) $(cymk_SRCS) $(newer_SRCS) $(cam2c_SRCS) $(mach_SRCS)
 INTF = $(cycc_INTF) $(cymk_INTF) $(newer_INTF) $(cam2c_INTF) $(mach_INTF)
 OBJS = $(cycc_OBJS) $(cymk_OBJS) $(newer_OBJS) $(cam2c_OBJS) $(mach_OBJS)
@@ -208,7 +260,8 @@
 	configure configure.in aclocal.m4 config.guess config.sub install-sh \
 	Makefile.in ghc.mk ghc-make.mk hbc.mk nhc.mk makedoc.in in-place-config \
 	configure-bin.in Makefile-bin.in in-place-config-bin \
-	$(SCRIPTS:=.in) $(man_MANS:=.in) $(SRCS) $(PATHUTILS_SRCS) $(IOEXTS_SRCS)
+	$(SCRIPTS:=.in) $(man_MANS:=.in) $(SRCS) \
+	$(PATHUTILS_SRCS) $(IOEXTS_SRCS) $(HS2010_SRCS)
 
 # default target, build all programs and the library
 all: scripts programs runtime curry mans
@@ -226,14 +279,14 @@
 # runtime library
 .PHONY: runtime
 runtime: FORCE
-	cd runtime && $(MAKE) $(MFLAGS)
+	cd runtime && $(MAKE)
 
 # Curry library
-.PHONY: curry icurry
+.PHONY: curry icurry ccurry
 curry: cycc runtime
-	cd curry && $(MAKE) $(MFLAGS)
-icurry: cycc
-	cd curry && $(MAKE) $(MFLAGS) icurry
+	cd curry && $(MAKE)
+icurry ccurry: cycc
+	cd curry && $(MAKE) $@
 
 # manual pages
 mans: $(man_MANS)
@@ -261,7 +314,7 @@
 	./makedoc pdflatex
 
 tex: FORCE
-	cd runtime; $(MAKE) $(MFLAGS) tex
+	cd runtime; $(MAKE) tex
 
 makedoc: Makefile $(srcdir)/makedoc.in
 	./config.status $@
@@ -279,15 +332,28 @@
 # link all source files into the current directory
 # NB if $(srcdir) is a relative path we have to modify the paths for target
 #    files which are located in subdirectories
+# NB The seemingly contrived $(MAKEFLAGS:M-s:S/=/=/) substitution is used in
+#    order to check for the presence of -s among the command line flags in
+#    a portable way. GNU make and other POSIX compatible make commands
+#    collect all single letter options -- if any -- in the first word of
+#    $(MAKEFLAGS). BSD make commands, on the other hand, use a separate word
+#    for each single letter option. In order to make the -s option the first
+#    word if present, we use BSD make's :M variable modifier, which filters
+#    $(MAKEFLAGS) keeping only those words which match the pattern following
+#    :M. Since other make commands do not understand this modifier, we also
+#    add the identity substitution :S/=/=/, which yields a System V compatible
+#    variable substitution of the form :SUFFIX=REPL.
 .DEFAULT:
 	@test ! -r $@ -a -f $(srcdir)/$@ && \
 	(test -d $(@D) || mkdir $(@D)) && \
 	if expr $(srcdir) : '/.*' >/dev/null; then \
-		(case "$(MFLAGS)" in -*s*) ;; *) set -x;; esac; \
+		(set dummy $(MAKEFLAGS:M-s:S/=/=/); \
+		 case $$2 in *=*) set -x;; *s*) ;; *) set -x;; esac; \
 		 ln -s $(srcdir)/$@ $@); \
 	else \
 		srcdir=`echo $@ | sed -e 's:[^/]*$$::' -e 's:[^/]*/:../:g'` && \
-		(case "$(MFLAGS)" in -*s*) ;; *) set -x;; esac; \
+		(set dummy $(MAKEFLAGS:M-s:S/=/=/); \
+		 case $$2 in *=*) set -x;; *s*) ;; *) set -x;; esac; \
 		 ln -s $${srcdir}$(srcdir)/$@ $@); \
 	fi
 
@@ -356,16 +422,17 @@
 	mkdir $(distdir)
 	mkdir $(distdir)/unix $(distdir)/windows
 	mkdir $(distdir)/ghc $(distdir)/hbc $(distdir)/nhc
+	mkdir $(distdir)/hs2010
 	for f in $(DISTFILES); do cp $(srcdir)/$$f $(distdir)/$$f; done
 	for d in $(SUBDIRS); do \
 		mkdir $(distdir)/$$d && \
-		(cd $$d && $(MAKE) $(MFLAGS) distdir distdir=../$(distdir)/$$d) || \
+		(cd $$d && $(MAKE) distdir distdir=../$(distdir)/$$d) || \
 		exit $$?; \
 	done
 
 bindist: bindistdir
 	rm -f $(bindistdir).tar $(bindistdir).tar.gz
-	cd $(bindistdir) && autoconf
+	cd $(bindistdir) && autoconf && rm -rf autom4te.cache
 	tar -cf $(bindistdir).tar $(bindistdir)
 	gzip $(bindistdir).tar
 	rm -rf $(bindistdir)
@@ -391,7 +458,7 @@
 		cp $(srcdir)/$$f.in $(bindistdir)/man || exit $$?; \
 	done
 	for d in $(SUBDIRS); do \
-		(cd $$d && $(MAKE) $(MFLAGS) bindistdir distdir=../$(bindistdir)) || \
+		(cd $$d && $(MAKE) bindistdir distdir=../$(bindistdir)) || \
 		exit $$?; \
 	done
 
@@ -402,7 +469,7 @@
 .PRECIOUS: Makefile
 Makefile: $(srcdir)/Makefile.in config.status
 	./config.status $@
-	$(MAKE) $(MFLAGS) depend
+	$(MAKE) depend
 
 cyc: $(srcdir)/cyc.in $(srcdir)/in-place-config config.status
 	./config.status $@
@@ -446,14 +513,32 @@
 depend: depend-dir depend-subdirs
 
 # recursive invocations
+# NB The seemingly contrived $(MAKEFLAGS:M-s:S/=/=/) and $(MAKEFLAGS:M-k:S/=/=/)
+#    substitutions are used in order to check for the presence of -s and -k,
+#    respectively, among the command line flags in a portable way. GNU make
+#    and other POSIX compatible make commands collect all single letter options
+#    -- if any -- in the first word of $(MAKEFLAGS). BSD make commands, on the
+#    other hand, use a separate word for each single letter option. In order to
+#    make the -s and -k options the first word if present, we use BSD make's
+#    :M variable modifier, which filters $(MAKEFLAGS) keeping only those words
+#    which match the pattern following :M. Since other make commands do not
+#    understand this modifier, we also add the identity substitution :S/=/=/,
+#    which yields a System V compatible variable substitution of the form
+#    :SUFFIX=REPL.
 mostlyclean-subdirs clean-subdirs distclean-subdirs maintainerclean-subdirs \
 depend-subdirs install-subdirs:
 	@fail=; subdirs="$(SUBDIRS)"; \
+	set dummy $(MAKEFLAGS:M-s:S/=/=/); s=$$2; \
+	set dummy $(MAKEFLAGS:M-k:S/=/=/); k=$$2; \
 	for d in $$subdirs; do \
 		target=`echo $@ | sed 's/-subdirs$$//'`; \
-		echo "Making $$target in $$d"; \
-		(cd $$d && $(MAKE) $(MFLAGS) $$target) || \
-		case "$(MFLAGS)" in -*k*) fail=yes;; *) exit $$?;; esac; \
+		case $$s in \
+			*=*) echo "Making $$target in $$d";; \
+			*s*) ;; \
+			*) echo "Making $$target in $$d"; \
+		esac; \
+		(cd $$d && $(MAKE) $$target) || \
+		case $$k in *=*) exit $$?;; *k*) fail=yes;; *) exit $$?;; esac; \
 	done; \
 	test -z "$$fail"
 
diff -u curry-0.9.11/Modules.lhs curry-0.9.11-classful/Modules.lhs
--- curry-0.9.11/Modules.lhs	2007-06-15 14:16:34.000000000 +0200
+++ curry-0.9.11-classful/Modules.lhs	2013-05-13 09:54:58.000000000 +0200
@@ -1,7 +1,7 @@
 % -*- LaTeX -*-
-% $Id: Modules.lhs 2228 2007-06-02 10:21:59Z wlux $
+% $Id: Modules.lhs 3136 2013-05-12 15:53:27Z wlux $
 %
-% Copyright (c) 1999-2007, Wolfgang Lux
+% Copyright (c) 1999-2013, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{Modules.lhs}
@@ -9,80 +9,72 @@
 This module controls the compilation of modules.
 \begin{verbatim}
 
-> module Modules(compileModule,compileGoal,typeGoal) where
-> import Base
-> import Unlit(unlit)
-> import CurryParser(parseSource,parseInterface,parseGoal)
-> import ImportSyntaxCheck(checkImports)
-> import TypeSyntaxCheck(typeSyntaxCheck,typeSyntaxCheckGoal)
-> import SyntaxCheck(syntaxCheck,syntaxCheckGoal)
-> import ExportSyntaxCheck(checkExports)
-> import Renaming(rename,renameGoal)
-> import PrecCheck(precCheck,precCheckGoal)
-> import KindCheck(kindCheck,kindCheckGoal)
-> import TypeCheck(typeCheck,typeCheckGoal)
-> import CaseCheck(caseCheck,caseCheckGoal)
-> import UnusedCheck(unusedCheck,unusedCheckGoal)
-> import ShadowCheck(shadowCheck,shadowCheckGoal)
-> import OverlapCheck(overlapCheck,overlapCheckGoal)
-> import IntfSyntaxCheck(intfSyntaxCheck)
-> import IntfCheck(intfCheck)
-> import IntfEquiv(fixInterface,intfEquiv)
-> import Imports(importInterface,importInterfaceIntf,importUnifyData)
-> import Exports(exportInterface)
-> import Trust(trustEnv)
-> import Qual(Qual(..))
-> import Desugar(desugar,goalModule)
-> import Simplify(simplify)
-> import Lift(lift)
-> import qualified IL
-> import ILTrans(ilTrans,ilTransIntf)
-> import ILLift(liftProg)
-> import DTransform(dTransform,dAddMain)
-> import ILCompile(camCompile,camCompileData,fun)
-> import qualified CamPP(ppModule)
-> import CGen(genMain,genModule)
-> import CCode(CFile,mergeCFile)
-> import CPretty(ppCFile)
-> import CurryPP(ppModule,ppInterface,ppIDecl,ppGoal)
-> import qualified ILPP(ppModule)
-> import Options(Options(..),CaseMode(..),Warn(..),Dump(..))
-> import Env
-> import TopEnv
+> module Modules(compileModule) where
+> import CaseCheck
 > import Combined
+> import Common
+> import Curry
+> import CurryParser
+> import CurryUtils
+> import Deriving
 > import Error
-> import IO
+> import ExportSyntaxCheck
+> import Exports
+> import IdentInfo
+> import ImportSyntaxCheck
+> import InstCheck
+> import InstInfo
+> import Interfaces
+> import KindCheck
 > import List
-> import Maybe
 > import Monad
-> import PathUtils
-> import Pretty
-> import TypeTrans
-> import Typing
+> import Options
+> import OverlapCheck
+> import Position
+> import PrecCheck
+> import PrecInfo
+> import PredefIdent
+> import Qual
+> import Renaming
+> import ShadowCheck
+> import SyntaxCheck
+> import Types
+> import TypeCheck
+> import TypeInfo
+> import TypeSyntaxCheck
+> import Unlit
+> import UnusedCheck
 > import Utils
+> import ValueInfo
 
 \end{verbatim}
 The function \texttt{compileModule} is the main entry point of this
 module for compiling a Curry source module. It applies syntax and type
 checking to the module and translates the code into one or more C code
-files. The module's interface is updated when necessary.
+files. The module's interface is updated when necessary. Note that the
+interface is computed from the environments returned by the front end
+but the source code \emph{after} applying the program transformations
+(cf.\ Sect.~\ref{sec:exports}).
 
-The compiler automatically loads the prelude when compiling a module
--- except for the prelude itself -- by adding an appropriate import
+The compiler automatically loads the Prelude when compiling a module
+-- except for the Prelude itself -- by adding an appropriate import
 declaration to the module.
 \begin{verbatim}
 
 > compileModule :: Options -> FilePath -> ErrorT IO ()
 > compileModule opts fn =
 >   do
->     (mEnv,pEnv,tcEnv,tyEnv,m) <- loadModule paths dbg cm ws fn
->     let (tyEnv',trEnv,m',dumps) = transModule dbg tr tcEnv tyEnv m
+>     (pEnv,tcEnv,iEnv,tyEnv,m) <- loadModule paths dbg cm ws fn
+>     let (tcEnv',tyEnv',trEnv,m',dumps) = transModule dbg tr tcEnv tyEnv m
 >     liftErr $ mapM_ (doDump opts) dumps
->     let intf = exportInterface m pEnv tcEnv tyEnv'
+>     let intf = exportInterface m' pEnv tcEnv iEnv tyEnv
 >     liftErr $ unless (noInterface opts) (updateInterface fn intf)
->     let (il,dumps) = ilTransModule split dbg tyEnv' trEnv m'
+>     let (tcEnv'',tyEnv'',trEnv',m'',dumps) =
+>           dictTrans tcEnv' iEnv tyEnv' trEnv m'
 >     liftErr $ mapM_ (doDump opts) dumps
->     let (ccode,dumps) = genCodeModule (bindModule intf mEnv) il
+>     let (il,dumps) = ilTransModule dbg tcEnv'' tyEnv'' trEnv' Nothing m''
+>     liftErr $ mapM_ (doDump opts) dumps
+>     let (ccode,dumps) = genCodeModule split dbg tcEnv'' il
 >     liftErr $ mapM_ (doDump opts) dumps >>
 >               writeCode (output opts) fn ccode
 >   where paths = importPath opts
@@ -93,306 +85,69 @@
 >         ws = warn opts
 
 > loadModule :: [FilePath] -> Bool -> CaseMode -> [Warn] -> FilePath
->            -> ErrorT IO (ModuleEnv,PEnv,TCEnv,ValueEnv,Module)
+>            -> ErrorT IO (PEnv,TCEnv,InstEnv,ValueEnv,Module QualType)
 > loadModule paths debug caseMode warn fn =
 >   do
 >     Module m es is ds <- liftErr (readFile fn) >>= okM . parseModule fn
 >     let is' = importPrelude debug fn m is
->     mEnv <- loadInterfaces paths [] emptyEnv m (modules is')
->     okM $ checkInterfaces mEnv
->     (pEnv,tcEnv,tyEnv,m') <- okM $ checkModule mEnv (Module m es is' ds)
->     liftErr $ mapM_ putErrLn $ warnModule caseMode warn m'
->     return (mEnv,pEnv,tcEnv,tyEnv,m')
+>     mEnv <- loadInterfaces paths m (modules is')
+>     (tEnv,vEnv,m') <- okM $ checkModuleSyntax mEnv (Module m es is' ds)
+>     liftErr $ mapM_ putErrLn $ warnModuleSyntax caseMode warn mEnv m'
+>     (pEnv,tcEnv,iEnv,tyEnv,m'') <- okM $ checkModule mEnv tEnv vEnv m'
+>     liftErr $ mapM_ putErrLn $ warnModule warn tyEnv m''
+>     return (pEnv,tcEnv,iEnv,tyEnv,m'')
 >   where modules is = [P p m | ImportDecl p m _ _ _ <- is]
 
-> parseModule :: FilePath -> String -> Error Module
+> parseModule :: FilePath -> String -> Error (Module ())
 > parseModule fn s = unlitLiterate fn s >>= parseSource fn
 
-> checkModule :: ModuleEnv -> Module -> Error (PEnv,TCEnv,ValueEnv,Module)
-> checkModule mEnv (Module m es is ds) =
->   do
->     (pEnv,tcEnv,tyEnv) <- importModules mEnv' is
->     (tEnv,ds') <- typeSyntaxCheck m tcEnv ds
->     (vEnv,ds'') <- syntaxCheck m tyEnv ds'
->     es' <- checkExports m is tEnv vEnv es
->     (pEnv',ds''') <- precCheck m pEnv $ rename ds''
->     tcEnv' <- kindCheck m tcEnv ds'''
->     tyEnv' <- typeCheck m tcEnv' tyEnv ds'''
->     let (pEnv'',tcEnv'',tyEnv'') = qualifyEnv mEnv' m pEnv' tcEnv' tyEnv'
->     return (pEnv'',tcEnv'',tyEnv'',Module m (Just es') is (qual tyEnv' ds'''))
->   where mEnv' = sanitizeInterfaces m mEnv
-
-> warnModule :: CaseMode -> [Warn] -> Module -> [String]
-> warnModule caseMode warn m =
->   caseCheck caseMode m ++ unusedCheck warn m ++
->   shadowCheck warn m ++ overlapCheck warn m
-
-> transModule :: Bool -> Trust -> TCEnv -> ValueEnv -> Module
->             -> (ValueEnv,TrustEnv,Module,[(Dump,Doc)])
-> transModule debug tr tcEnv tyEnv m = (tyEnv'',trEnv,simplified,dumps)
->   where (desugared,tyEnv') = desugar tcEnv tyEnv m
->         trEnv = if debug then trustEnv tr desugared else emptyEnv
->         (simplified,tyEnv'') = simplify tyEnv' trEnv desugared
->         dumps =
->           [(DumpRenamed,ppModule m),
->            (DumpTypes,ppTypes tcEnv (localBindings tyEnv)),
->            (DumpDesugared,ppModule desugared),
->            (DumpSimplified,ppModule simplified)]
-
-> ilTransModule :: Bool -> Bool -> ValueEnv -> TrustEnv -> Module
->               -> (Either IL.Module [IL.Module],[(Dump,Doc)])
-> ilTransModule False debug tyEnv trEnv m = (Left il,dumps)
->   where (il,dumps) = ilTransModule1 id debug tyEnv trEnv m
-> ilTransModule True debug tyEnv trEnv m = (Right il,concat (transpose dumps))
->   where (il,dumps) =
->           unzip $ map (ilTransModule1 id debug tyEnv trEnv) (splitModule m)
-
-> ilTransModule1 :: (IL.Module -> IL.Module) -> Bool -> ValueEnv -> TrustEnv
->                -> Module -> (IL.Module,[(Dump,Doc)])
-> ilTransModule1 debugAddMain debug tyEnv trEnv m = (ilDbg,dumps)
->   where (lifted,tyEnv',trEnv') = lift tyEnv trEnv m
->         il = ilTrans tyEnv' lifted
->         ilDbg
->           | debug = debugAddMain (dTransform (trustedFun trEnv') il)
->           | otherwise = il
->         dumps =
->           [(DumpLifted,ppModule lifted),
->            (DumpIL,ILPP.ppModule il)] ++
->           [(DumpTransformed,ILPP.ppModule ilDbg) | debug]
-
-> genCodeModule :: ModuleEnv -> Either IL.Module [IL.Module]
->               -> (Either CFile [CFile],[(Dump,Doc)])
-> genCodeModule mEnv (Left il) = (Left ccode,dumps)
->   where (ccode,dumps) = genCode (ilImports mEnv il) il
-> genCodeModule mEnv (Right il) = (Right ccode,concat (transpose dumps))
->   where IL.Module m is ds = mergeILModules il
->         (ccode,dumps) =
->           unzip $ map (genCode (ilImports mEnv (IL.Module m is ds) ++ ds)) il
-
-> genCode :: [IL.Decl] -> IL.Module -> (CFile,[(Dump,Doc)])
-> genCode ds il = (ccode,dumps)
->   where ilNormal = liftProg il
->         cam = camCompile ilNormal
->         imports = camCompileData ds
->         ccode = genModule imports cam
->         dumps =
->           [(DumpNormalized,ILPP.ppModule ilNormal),
->            (DumpCam,CamPP.ppModule cam)]
-
-> qualifyEnv :: ModuleEnv -> ModuleIdent -> PEnv -> TCEnv -> ValueEnv
->            -> (PEnv,TCEnv,ValueEnv)
-> qualifyEnv mEnv m pEnv tcEnv tyEnv =
->   (foldr (uncurry (globalBindTopEnv m)) pEnv' (localBindings pEnv),
->    foldr (uncurry (globalBindTopEnv m)) tcEnv' (localBindings tcEnv),
->    foldr (uncurry (bindTopEnv m)) tyEnv' (localBindings tyEnv))
->   where (pEnv',tcEnv',tyEnv') =
->           foldl importInterfaceIntf initEnvs (map snd (envToList mEnv))
-
-> splitModule :: Module -> [Module]
-> splitModule (Module m es is ds) = [Module m es is [d] | d <- ds, isCodeDecl d]
->   where isCodeDecl (DataDecl _ _ _ cs) = not (null cs)
->         isCodeDecl (NewtypeDecl _ _ _ _) = True
->         isCodeDecl (TypeDecl _ _ _ _) = False
->         isCodeDecl (BlockDecl d) = isValueDecl d
-
-> mergeILModules :: [IL.Module] -> IL.Module
-> mergeILModules ms = IL.Module m (concat iss) (concat dss)
->   where IL.Module m _ _ : _ = ms
->         (iss,dss) = unzip [(is,ds) | IL.Module _ is ds <- ms]
-
-> ilImports :: ModuleEnv -> IL.Module -> [IL.Decl]
-> ilImports mEnv (IL.Module _ is _) =
->   concat [ilTransIntf i | (m,i) <- envToList mEnv, m `elem` is]
-
-> trustedFun :: TrustEnv -> QualIdent -> Bool
-> trustedFun trEnv f = maybe True (Trust ==) (lookupEnv (unqualify f) trEnv)
-
-> writeCode :: Maybe FilePath -> FilePath -> Either CFile [CFile] -> IO ()
-> writeCode tfn sfn (Left cfile) = writeCCode ofn cfile
->   where ofn = fromMaybe (rootname sfn ++ cExt) tfn
-> writeCode tfn sfn (Right cfiles) = zipWithM_ (writeCCode . mkFn) [1..] cfiles
->   where prefix = fromMaybe (rootname sfn) tfn
->         mkFn i = prefix ++ show i ++ cExt
-
-> writeGoalCode :: Maybe FilePath -> CFile -> IO ()
-> writeGoalCode tfn = writeCCode ofn
->   where ofn = fromMaybe (internalError "No filename for startup code") tfn
-
-> writeCCode :: FilePath -> CFile -> IO ()
-> writeCCode fn = writeFile fn . showln . ppCFile
-
-> showln :: Show a => a -> String
-> showln x = shows x "\n"
-
-\end{verbatim}
-A goal is compiled with respect to the interface of a given module. If
-no module is specified, the Curry \texttt{Prelude} is used. All
-entities exported from the main module and the \texttt{Prelude} are in
-scope with their unqualified names. In addition, the entities exported
-from all loaded interfaces are in scope with their qualified names.
-\begin{verbatim}
-
-> data Task = Eval | Type
-
-> compileGoal :: Options -> Maybe String -> [FilePath] -> ErrorT IO ()
-> compileGoal opts g fns =
->   do
->     (mEnv,tcEnv,tyEnv,g') <- loadGoal Eval paths dbg cm ws m g fns
->     let (vs,m',tyEnv') = goalModule dbg tyEnv m mainId g'
->     let (tyEnv'',trEnv,m'',dumps) = transModule dbg tr tcEnv tyEnv' m'
->     liftErr $ mapM_ (doDump opts) dumps
->     let (il,dumps) = ilTransModule1 (dAddMain mainId) dbg tyEnv'' trEnv m''
->     liftErr $ mapM_ (doDump opts) dumps
->     let (ccode,dumps) = genCodeGoal mEnv (qualifyWith m mainId) vs il
->     liftErr $ mapM_ (doDump opts) dumps >>
->               writeGoalCode (output opts) ccode
->   where m = mkMIdent []
->         paths = importPath opts
->         dbg = debug opts
->         tr = if trusted opts then Trust else Suspect
->         cm = caseMode opts
->         ws = warn opts
-
-> typeGoal :: Options -> String -> [FilePath] -> ErrorT IO ()
-> typeGoal opts g fns =
->   do
->     (_,tcEnv,tyEnv,Goal _ e _) <-
->       loadGoal Type paths False cm ws (mkMIdent []) (Just g) fns
->     liftErr $ print (ppType tcEnv (typeOf tyEnv e))
->   where paths = importPath opts
->         cm = caseMode opts
->         ws = warn opts
-
-> loadGoal :: Task -> [FilePath] -> Bool -> CaseMode -> [Warn]
->          -> ModuleIdent -> Maybe String -> [FilePath]
->          -> ErrorT IO (ModuleEnv,TCEnv,ValueEnv,Goal)
-> loadGoal task paths debug caseMode warn m g fns =
+> checkModuleSyntax :: ModuleEnv -> Module a -> Error (TypeEnv,FunEnv,Module a)
+> checkModuleSyntax mEnv (Module m es is ds) =
 >   do
->     (mEnv,m') <- loadGoalModules paths debug fns
->     (tcEnv,tyEnv,g') <-
->       okM $ maybe (return (mainGoal m')) parseGoal g >>=
->             checkGoal task mEnv m (nub [m',preludeMIdent])
->     liftErr $ mapM_ putErrLn $ warnGoal caseMode warn m g'
->     return (mEnv,tcEnv,tyEnv,g')
->   where mainGoal m = Goal (first "") (Variable (qualifyWith m mainId)) []
-
-> loadGoalModules :: [FilePath] -> Bool -> [FilePath]
->                 -> ErrorT IO (ModuleEnv,ModuleIdent)
-> loadGoalModules paths debug fns =
->   do
->     mEnv <- foldM (loadInterface paths []) emptyEnv ms
->     (mEnv',ms') <- mapAccumM (loadGoalInterface paths) mEnv fns
->     okM $ checkInterfaces mEnv'
->     return (mEnv',last (preludeMIdent:ms'))
->   where ms = map (P (first "")) (preludeMIdent : [debugPreludeMIdent | debug])
-
-> loadGoalInterface :: [FilePath] -> ModuleEnv -> FilePath
->                   -> ErrorT IO (ModuleEnv,ModuleIdent)
-> loadGoalInterface paths mEnv fn
->   | extension fn `elem` [srcExt,litExt,intfExt] || pathSep `elem` fn =
->       compileInterface paths [] mEnv (interfaceName fn)
->   | otherwise =
->       do
->         mEnv' <- loadInterface paths [] mEnv (P (first "") m)
->         return (mEnv',m)
->   where m = mkMIdent (components ('.':fn))
->         components [] = []
->         components (_:cs) =
->           case break ('.' ==) cs of
->             (cs',cs'') -> cs' : components cs''
-
-> checkGoal :: Task -> ModuleEnv -> ModuleIdent -> [ModuleIdent] -> Goal
->           -> Error (TCEnv,ValueEnv,Goal)
-> checkGoal task mEnv m ms g =
->   do
->     let (pEnv,tcEnv,tyEnv) = importInterfaces mEnv ms
->     g' <- typeSyntaxCheckGoal tcEnv g >>=
->           syntaxCheckGoal tyEnv >>=
->           precCheckGoal m pEnv . renameGoal
->     tyEnv' <- kindCheckGoal tcEnv g' >>
->               typeCheckGoal m tcEnv tyEnv g'
->     return (qualifyGoal task mEnv m pEnv tcEnv tyEnv' g')
-
-> qualifyGoal :: Task -> ModuleEnv -> ModuleIdent -> PEnv -> TCEnv -> ValueEnv
->             -> Goal -> (TCEnv,ValueEnv,Goal)
-> qualifyGoal Eval mEnv m pEnv tcEnv tyEnv g = (tcEnv',tyEnv',qual tyEnv g)
->   where (_,tcEnv',tyEnv') = qualifyEnv mEnv m pEnv tcEnv tyEnv
-> qualifyGoal Type _ _ _ tcEnv tyEnv g = (tcEnv,tyEnv,g)
-
-> warnGoal :: CaseMode -> [Warn] -> ModuleIdent -> Goal -> [String]
-> warnGoal caseMode warn m g =
->   caseCheckGoal caseMode g ++ unusedCheckGoal warn m g ++
->   shadowCheckGoal warn g ++ overlapCheckGoal warn g
-
-> genCodeGoal :: ModuleEnv -> QualIdent -> Maybe [Ident] -> IL.Module
->             -> (CFile,[(Dump,Doc)])
-> genCodeGoal mEnv qGoalId vs il = (mergeCFile ccode ccode',dumps)
->   where (ccode,dumps) = genCode (ilImports mEnv il) il
->         ccode' = genMain (fun qGoalId) (fmap (map name) vs)
-
-\end{verbatim}
-The function \texttt{importModules} brings the declarations of all
-imported modules into scope in the current module.
-\begin{verbatim}
+>     is' <- importSyntaxCheck mEnv is
+>     let (tEnv,iSet,vEnv) = importModuleIdents mEnv is'
+>     (tEnv',ds') <- typeSyntaxCheck m tEnv iSet ds
+>     (vEnv',ds'') <- syntaxCheck m tEnv' vEnv ds'
+>     es' <- checkExports m is' tEnv' vEnv' es
+>     return (tEnv',vEnv',Module m (Just es') is' ds'')
+
+> checkModule :: ModuleEnv -> TypeEnv -> FunEnv -> Module ()
+>             -> Error (PEnv,TCEnv,InstEnv,ValueEnv,Module QualType)
+> checkModule mEnv tEnv vEnv (Module m es is ds) =
+>   do
+>     let (k1,ds') = rename k0 ds
+>     let (pEnv,tcEnv,iEnv,tyEnv) = importModules mEnv is
+>     let (pEnv',tcEnv',tyEnv') = qualifyEnv1 mEnv is pEnv tcEnv tyEnv
+>     (pEnv'',ds'') <- precCheck m tcEnv' pEnv' (qual1 tEnv vEnv ds')
+>     tcEnv'' <- kindCheck m tcEnv' ds''
+>     iEnv' <- instCheck m tcEnv'' iEnv ds''
+>     (k2,deriv) <- liftM (rename k1) (derive m pEnv'' tcEnv'' iEnv' ds'')
+>     (tyEnv'',ds''') <- typeCheck m tcEnv'' iEnv' tyEnv' (ds'' ++ deriv)
+>     let (pEnv''',tcEnv''',tyEnv''') =
+>           qualifyEnv2 mEnv m pEnv'' tcEnv'' tyEnv''
+>     return (pEnv''',tcEnv''',iEnv',tyEnv''',
+>             Module m es is (qual2 tEnv vEnv ds'''))
 
-> importModules :: ModuleEnv -> [ImportDecl] -> Error (PEnv,TCEnv,ValueEnv)
-> importModules mEnv ds =
->   do
->     ds' <- mapE checkImportDecl ds
->     let (pEnv,tcEnv,tyEnv) = foldl importModule initEnvs ds'
->     return (pEnv,importUnifyData tcEnv,tyEnv)
+> importSyntaxCheck :: ModuleEnv -> [ImportDecl] -> Error [ImportDecl]
+> importSyntaxCheck mEnv ds = mapE checkImportDecl ds
 >   where checkImportDecl (ImportDecl p m q asM is) =
 >           liftE (ImportDecl p m q asM)
 >                 (checkImports (moduleInterface m mEnv) is)
->         importModule envs (ImportDecl _ m q asM is) =
->           importInterface (fromMaybe m asM) q is envs (moduleInterface m mEnv)
 
-> moduleInterface :: ModuleIdent -> ModuleEnv -> Interface
-> moduleInterface m mEnv =
->   fromMaybe (internalError "moduleInterface") (lookupEnv m mEnv)
-
-> initEnvs :: (PEnv,TCEnv,ValueEnv)
-> initEnvs = (initPEnv,initTCEnv,initDCEnv)
-
-\end{verbatim}
-The function \texttt{importInterfaces} brings the declarations of all
-loaded modules into scope with their qualified names and in addition
-brings the declarations of the specified modules into scope with their
-unqualified names too.
-\begin{verbatim}
-
-> importInterfaces :: ModuleEnv -> [ModuleIdent] -> (PEnv,TCEnv,ValueEnv)
-> importInterfaces mEnv ms = (pEnv,importUnifyData tcEnv,tyEnv)
->   where (pEnv,tcEnv,tyEnv) =
->           foldl (uncurry . importModule) initEnvs (envToList mEnv)
->         importModule envs m = importInterface m (m `notElem` ms) Nothing envs
+> warnModuleSyntax :: CaseMode -> [Warn] -> ModuleEnv -> Module a -> [String]
+> warnModuleSyntax caseMode warn mEnv m =
+>   caseCheck caseMode m ++ unusedCheck warn m ++ shadowCheck warn mEnv m
+
+> warnModule :: [Warn] -> ValueEnv -> Module a -> [String]
+> warnModule warn tyEnv m = overlapCheck warn tyEnv m
 
 \end{verbatim}
-When mutually recursive modules are compiled, it may be possible that
-the imported interfaces include entities that are supposed to be
-defined in the current module. These entities must not be imported
-into the current module in any way because they might be in conflict
-with the actual definitions in the current module.
-\begin{verbatim}
-
-> sanitizeInterfaces :: ModuleIdent -> ModuleEnv -> ModuleEnv
-> sanitizeInterfaces m mEnv = fmap (sanitizeInterface m) (unbindModule m mEnv)
-
-> sanitizeInterface :: ModuleIdent -> Interface -> Interface
-> sanitizeInterface m (Interface m' is' ds') =
->   Interface m' is' (filter ((Just m /=) . fst . splitQualIdent . entity) ds')
->   where entity (IInfixDecl _ _ _ op) = op
->         entity (HidingDataDecl _ tc _) = tc
->         entity (IDataDecl _ tc _ _) = tc
->         entity (INewtypeDecl _ tc _ _) = tc
->         entity (ITypeDecl _ tc _ _) = tc
->         entity (IFunctionDecl _ f _ _) = f
-
-\end{verbatim}
-The prelude is imported implicitly into every module that does not
-import the prelude explicitly with an import declaration. Obviously,
-no import declaration is added to the prelude itself. Furthermore, the
-module \texttt{DebugPrelude} is imported into every module when it is
+The Prelude is imported implicitly into every module other than the
+Prelude. If the module does not import the Prelude explicitly, the
+added declaration brings all Prelude entities with qualified and
+unqualified names into scope. Otherwise, only the identifiers of the
+unit, list, and tuple types are imported. Furthermore, the module
+\texttt{DebugPrelude} is imported into every module when it is
 compiled for debugging. However, none of its entities are brought into
 scope because the debugging transformation is applied to the
 intermediate language.
@@ -401,10 +156,11 @@
 > importPrelude :: Bool -> FilePath -> ModuleIdent
 >               -> [ImportDecl] -> [ImportDecl]
 > importPrelude debug fn m is =
->   imp True preludeMIdent True ++ imp debug debugPreludeMIdent False ++ is
+>   imp True preludeMIdent (preludeMIdent `notElem` ms) ++
+>   imp debug debugPreludeMIdent False ++ is
 >   where p = first fn
->         ms = m : [m | ImportDecl _ m _ _ _ <- is]
->         imp cond m all = [importDecl p m all | cond && m `notElem` ms]
+>         ms = [m | ImportDecl _ m _ _ _ <- is]
+>         imp cond m' all = [importDecl p m' all | cond && m /= m']
 
 > importDecl :: Position -> ModuleIdent -> Bool -> ImportDecl
 > importDecl p m all =
@@ -412,122 +168,6 @@
 >              (if all then Nothing else Just (Importing p []))
 
 \end{verbatim}
-If an import declaration for a module is found, the compiler loads the
-module's interface unless a load is already pending. Such is possible
-in the case of cyclic module dependencies, which are accepted as an
-extension to the Curry language. An error is reported only if a module
-contains an import declaration directly importing itself.
-\begin{verbatim}
-
-> loadInterfaces :: [FilePath] -> [ModuleIdent] -> ModuleEnv
->                -> ModuleIdent -> [P ModuleIdent] -> ErrorT IO ModuleEnv
-> loadInterfaces paths ctxt mEnv m ms =
->   do
->     okM $ sequenceE_ [errorAt p (cyclicImport m) | P p m' <- ms, m == m']
->     foldM (loadInterface paths ctxt) mEnv ms
-
-> loadInterface :: [FilePath] -> [ModuleIdent] -> ModuleEnv -> P ModuleIdent
->               -> ErrorT IO ModuleEnv
-> loadInterface paths ctxt mEnv (P p m)
->   | m `elem` ctxt || isJust (lookupEnv m mEnv) = return mEnv
->   | otherwise =
->       liftErr (lookupInterface paths m) >>=
->       maybe (errorAt p (interfaceNotFound m))
->             (compileModuleInterface paths ctxt mEnv m)
-
-> compileModuleInterface :: [FilePath] -> [ModuleIdent] -> ModuleEnv
->                        -> ModuleIdent -> FilePath -> ErrorT IO ModuleEnv
-> compileModuleInterface paths ctxt mEnv m fn =
->   do
->     (mEnv',m') <- compileInterface paths ctxt mEnv fn
->     unless (m == m') (errorAt (first fn) (wrongInterface m m'))
->     return mEnv'
-
-\end{verbatim}
-After parsing an interface, all of its imported interfaces are
-recursively loaded and entered into the module environment. In
-addition, the compiler applies syntax checking to the interface, which
-is possible because interface files are self-contained.
-
-\ToDo{Avoid recursive loading of imported interfaces. All information
-that is needed for compiling a module is present in the interfaces
-that are imported directly from that module.}
-\begin{verbatim}
-
-> compileInterface :: [FilePath] -> [ModuleIdent] -> ModuleEnv
->                  -> FilePath -> ErrorT IO (ModuleEnv,ModuleIdent)
-> compileInterface paths ctxt mEnv fn =
->   do
->     Interface m is ds <- liftErr (readFile fn) >>= okM . parseInterface fn
->     mEnv' <- loadInterfaces paths (m:ctxt) mEnv m (modules is)
->     ds' <- okM $ intfSyntaxCheck ds
->     return (bindModule (Interface m is ds') mEnv',m)
->   where modules is = [P p m | IImportDecl p m <- is]
-
-\end{verbatim}
-After all interface files have been loaded, the compiler checks that
-re-exported definitions in the interfaces are compatible with their
-original definitions in order to ensure that the set of loaded
-interfaces is consistent.
-\begin{verbatim}
-
-> checkInterfaces :: ModuleEnv -> Error ()
-> checkInterfaces mEnv = mapE_ (checkInterface mEnv . snd) (envToList mEnv)
-
-> checkInterface :: ModuleEnv -> Interface -> Error ()
-> checkInterface mEnv (Interface m is ds) = intfCheck m pEnv tcEnv tyEnv ds
->   where (pEnv,tcEnv,tyEnv) = foldl importModule initEnvs is
->         importModule envs (IImportDecl _ m) =
->           importInterfaceIntf envs (moduleInterface m mEnv)
-
-\end{verbatim}
-After checking a module successfully, the compiler may need to update
-the module's interface file. The file will be updated only if the
-interface has been changed or the file did not exist before.
-
-The code below is a little bit tricky because we must make sure that the
-interface file is closed before rewriting the interface -- even if it
-has not been read completely. On the other hand, we must not apply
-\texttt{hClose} too early. Note that there is no need to close the
-interface explicitly if the interface check succeeds because the whole
-file must have been read in this case. In addition, we do not update
-the interface file in this case and therefore it doesn't matter when
-the file is closed.
-\begin{verbatim}
-
-> updateInterface :: FilePath -> Interface -> IO ()
-> updateInterface sfn i =
->   do
->     eq <- catch (matchInterface ifn i) (const (return False))
->     unless eq (writeInterface ifn i)
->   where ifn = interfaceName sfn
-
-> matchInterface :: FilePath -> Interface -> IO Bool
-> matchInterface ifn i =
->   do
->     h <- openFile ifn ReadMode
->     s <- hGetContents h
->     case parseInterface ifn s of
->       Ok i' | i `intfEquiv` fixInterface i' -> return True
->       _ -> hClose h >> return False
-
-> writeInterface :: FilePath -> Interface -> IO ()
-> writeInterface ifn = writeFile ifn . showln . ppInterface
-
-> interfaceName :: FilePath -> FilePath
-> interfaceName fn = rootname fn ++ intfExt
-
-\end{verbatim}
-The compiler searches for interface files in the import search path
-using the extension \texttt{".icurry"}. Note that the current
-directory is always searched first.
-\begin{verbatim}
-
-> lookupInterface :: [FilePath] -> ModuleIdent -> IO (Maybe FilePath)
-> lookupInterface paths m = lookupFile (ifn : [catPath p ifn | p <- paths])
->   where ifn = foldr1 catPath (moduleQualifiers m) ++ intfExt
-
-\end{verbatim}
 Literate source files use the extension \texttt{".lcurry"}.
 \begin{verbatim}
 
@@ -539,77 +179,6 @@
 >   where (es,s') = unlit fn s
 
 > isLiterateSource :: FilePath -> Bool
-> isLiterateSource fn = litExt `isSuffixOf` fn
-
-\end{verbatim}
-The \texttt{doDump} function writes the selected information to the
-standard output.
-\begin{verbatim}
-
-> doDump :: Options -> (Dump,Doc) -> IO ()
-> doDump opts (d,x) =
->   when (d `elem` dump opts)
->        (print (text hd $$ text (replicate (length hd) '=') $$ x))
->   where hd = dumpHeader d
-
-> dumpHeader :: Dump -> String
-> dumpHeader DumpRenamed = "Module after renaming"
-> dumpHeader DumpTypes = "Types"
-> dumpHeader DumpDesugared = "Source code after desugaring"
-> dumpHeader DumpSimplified = "Source code after simplification"
-> dumpHeader DumpLifted = "Source code after lifting"
-> dumpHeader DumpIL = "Intermediate code"
-> dumpHeader DumpTransformed = "Transformed code" 
-> dumpHeader DumpNormalized = "Intermediate code after normalization"
-> dumpHeader DumpCam = "Abstract machine code"
-
-\end{verbatim}
-The function \texttt{ppTypes} is used for pretty-printing the types
-from the type environment.
-\begin{verbatim}
-
-> ppTypes :: TCEnv -> [(Ident,ValueInfo)] -> Doc
-> ppTypes tcEnv = vcat . map ppInfo
->   where ppInfo (c,DataConstructor _ _ (ForAll _ ty)) =
->           ppIDecl (mkDecl c ty) <+> text "-- data constructor"
->         ppInfo (c,NewtypeConstructor _ (ForAll _ ty)) =
->           ppIDecl (mkDecl c ty) <+> text "-- newtype constructor"
->         ppInfo (x,Value _ _ (ForAll _ ty)) = ppIDecl (mkDecl x ty)
->         mkDecl f ty =
->           IFunctionDecl undefined (qualify f) Nothing (fromType tcEnv ty)
-
-\end{verbatim}
-Various file name extensions.
-\begin{verbatim}
-
-> cExt = ".c"
-> srcExt = ".curry"
-> litExt = ".lcurry"
-> intfExt = ".icurry"
-
-\end{verbatim}
-Auxiliary functions. Unfortunately, hbc's \texttt{IO} module lacks a
-definition of \texttt{hPutStrLn}.
-\begin{verbatim}
-
-> putErr :: String -> IO ()
-> putErr = hPutStr stderr
-
-> putErrLn :: String -> IO ()
-> putErrLn s = putErr (unlines [s])
-
-\end{verbatim}
-Error messages.
-\begin{verbatim}
-
-> interfaceNotFound :: ModuleIdent -> String
-> interfaceNotFound m = "Interface for module " ++ moduleName m ++ " not found"
-
-> cyclicImport :: ModuleIdent -> String
-> cyclicImport m = "Module " ++ moduleName m ++ " imports itself"
-
-> wrongInterface :: ModuleIdent -> ModuleIdent -> String
-> wrongInterface m m' =
->   "Expected interface for " ++ show m ++ " but found " ++ show m'
+> isLiterateSource fn = ".lcurry" `isSuffixOf` fn
 
 \end{verbatim}
diff -u curry-0.9.11/newer.lhs curry-0.9.11-classful/newer.lhs
--- curry-0.9.11/newer.lhs	2007-06-15 14:16:35.000000000 +0200
+++ curry-0.9.11-classful/newer.lhs	2013-05-13 09:54:58.000000000 +0200
@@ -1,33 +1,40 @@
 % -*- LaTeX -*-
-% $Id: newer.lhs 1744 2005-08-23 16:17:12Z wlux $
+% $Id: newer.lhs 3136 2013-05-12 15:53:27Z wlux $
 %
-% Copyright (c) 2002, Wolfgang Lux
+% Copyright (c) 2002-2013, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{newer.lhs}
-\section{Compute whether a file is out-of-date}
-Unfortunately, not all versions of the Unix \verb|test| program
+\section{Compute whether a file is out of date}
+Unfortunately, not all versions of the Unix \verb|test| utility
 support the switches \verb|-nt| and \verb|-ot| to compare the
 modification dates of their arguments. Even worse, on some systems
-(e.g., Solaris 2.7) the \verb|test| program supports these switches
-but the default Bourne shell has a builtin \verb|test| that does not
-handle these switches.
-
-In order to avoid complex dependencies on the operating system we
-use our own program in order to check whether a file is out-of-date
--- i.e. newer than -- with respect to some other files it depends
-on. If checked file does not exist it is considered out-of-date as
-well and an error occurs if any of the dependencies does not exist.
+(e.g., Solaris 7) the \verb|test| program supports these switches but
+the default Bourne shell has a builtin \verb|test| that does not
+handle them.
+
+In order to avoid complex dependencies on the operating system, we use
+our own program to check whether a file is out of date with respect to
+some or all of its dependencies. If the checked file does not exist it
+is considered out of date as well and an error occurs if any of the
+dependencies does not exist.
 
-The program exits with return code 0 if the file is not out-of-date
+The program exits with return code 0 if the file is not out of date
 and 1 otherwise. In case of an error, the program exits with return
 code 2.
+
+Note that the program silently ignores dependencies whose name starts
+with \texttt{-M}. This is done in order to ease processing of the
+\texttt{link} commands generated by the \texttt{CurryDeps} module (see
+Sect.~\ref{sec:dependencies}).
 \begin{verbatim}
 
-> import IO
 > import Directory
+> import IO
+> import List
 > import System
 > import Time
+> import Utils
 
 > main =
 >   do
@@ -43,12 +50,13 @@
 
 > newer prog [] = badUsage prog
 > newer prog (file:deps) =
->   catch (do t <- getModificationTime file; allM (isNewer t) deps)
->         (const (return False))
+>   IO.catch (do t <- getModificationTime file
+>                allM (isNewer t) (filter (not . ("-M" `isPrefixOf`)) deps))
+>            (const (return False))
 
 > isNewer t file =
->   catch (do t' <-  getModificationTime file; return (t > t'))
->         (\ioe -> do print ioe; exitWith (ExitFailure 2))
+>   IO.catch (do t' <- getModificationTime file; return (t > t'))
+>            (\ioe -> do print ioe; exitWith (ExitFailure 2))
 
 > allM :: Monad m => (a -> m Bool) -> [a] -> m Bool
 > allM f xs = andM (map f xs)
@@ -58,11 +66,3 @@
 >   where m1 >>& m2 = m1 >>= \b -> if b then m2 else return False
 
 \end{verbatim}
-Unfortunately, the \texttt{hPutStrLn} function is not defined hbc's
-\texttt{IO} library.
-\begin{verbatim}
-
-> putErr s = hPutStr stderr s
-> putErrLn s = putErr (s ++ "\n")
-
-\end{verbatim}
Solo in curry-0.9.11: NEWS
Solo in curry-0.9.11-classful/: NEWS.asc
Solo in curry-0.9.11-classful/: Newtype.lhs
Sottodirectory in comune: curry-0.9.11/nhc e curry-0.9.11-classful/nhc
Solo in curry-0.9.11-classful/: nhc.htm
diff -u curry-0.9.11/nhc.mk curry-0.9.11-classful/nhc.mk
--- curry-0.9.11/nhc.mk	2007-06-15 14:16:33.000000000 +0200
+++ curry-0.9.11-classful/nhc.mk	2008-03-13 09:20:32.000000000 +0100
@@ -1,30 +1,46 @@
 # Specific rules for building with nhc
-# $Id: nhc.mk 2239 2007-06-10 00:46:39Z wlux $
+# $Id: nhc.mk 2638 2008-03-13 08:07:44Z wlux $
 #
-# Copyright (c) 2002-2007, Wolfgang Lux
+# Copyright (c) 2002-2008, Wolfgang Lux
 # See LICENSE for the full license.
 #
 
 # specific definitions for nhc
-HMAKE = hmake -nhc98
-NHC_HCFLAGS = +CTS -H8M -CTS -Inhc -I$(HC_PATH_STYLE)
+HMAKE = hmake
+NHC_HFLAGS = -nhc98 +CTS -H8M -CTS -Inhc -I$(HC_PATH_STYLE)
 
 # programs
+# NB The seemingly contrived $(MAKEFLAGS:M-s:S/=/=/) substitution is used in
+#    order to check for the presence of -s among the command line flags in
+#    a portable way. GNU make and other POSIX compatible make commands
+#    collect all single letter options -- if any -- in the first word of
+#    $(MAKEFLAGS). BSD make commands, on the other hand, use a separate word
+#    for each single letter option. In order to make the -s option the first
+#    word if present, we use BSD make's :M variable modifier, which filters
+#    $(MAKEFLAGS) keeping only those words which match the pattern following
+#    :M. Since other make commands do not understand this modifier, we also
+#    add the identity substitution :S/=/=/, which yields a System V compatible
+#    variable substitution of the form :SUFFIX=REPL.
 cycc: $(cycc_SRCS)
-	@case "$(MFLAGS)" in -*s*) q=-q;; *) q=;; esac; \
-	$(HMAKE) $$q $(HCFLAGS) $(NHC_HCFLAGS) $@
+	@set dummy $(MAKEFLAGS:M-s:S/=/=/); \
+	case $$2 in *=*) q=;; *s*) q=-q;; *) q=;; esac; \
+	$(HMAKE) $$q $(HFLAGS) $(NHC_HFLAGS) $@
 cymk: $(cymk_SRCS)
-	@case "$(MFLAGS)" in -*s*) q=-q;; *) q=;; esac; \
-	$(HMAKE) $$q $(HCFLAGS) $(NHC_HCFLAGS) $@
+	@set dummy $(MAKEFLAGS:M-s:S/=/=/); \
+	case $$2 in *=*) q=;; *s*) q=-q;; *) q=;; esac; \
+	$(HMAKE) $$q $(HFLAGS) $(NHC_HFLAGS) $@
 newer: $(newer_SRCS)
-	@case "$(MFLAGS)" in -*s*) q=-q;; *) q=;; esac; \
-	$(HMAKE) $$q $(HCFLAGS) $(NHC_HCFLAGS) $@
+	@set dummy $(MAKEFLAGS:M-s:S/=/=/); \
+	case $$2 in *=*) q=;; *s*) q=-q;; *) q=;; esac; \
+	$(HMAKE) $$q $(HFLAGS) $(NHC_HFLAGS) $@
 cam2c: $(cam2c_SRCS)
-	@case "$(MFLAGS)" in -*s*) q=-q;; *) q=;; esac; \
-	$(HMAKE) $$q $(HCFLAGS) $(NHC_HCFLAGS) $@
+	@set dummy $(MAKEFLAGS:M-s:S/=/=/); \
+	case $$2 in *=*) q=;; *s*) q=-q;; *) q=;; esac; \
+	$(HMAKE) $$q $(HFLAGS) $(NHC_HFLAGS) $@
 mach: $(mach_SRCS)
-	@case "$(MFLAGS)" in -*s*) q=-q;; *) q=;; esac; \
-	$(HMAKE) $$q $(HCFLAGS) $(NHC_HCFLAGS) $@
+	@set dummy $(MAKEFLAGS:M-s:S/=/=/); \
+	case $$2 in *=*) q=;; *s*) q=-q;; *) q=;; esac; \
+	$(HMAKE) $$q $(HFLAGS) $(NHC_HFLAGS) $@
 
 # compute the dependencies
 depend-dir:
diff -u curry-0.9.11/Options.lhs curry-0.9.11-classful/Options.lhs
--- curry-0.9.11/Options.lhs	2007-06-15 14:16:34.000000000 +0200
+++ curry-0.9.11-classful/Options.lhs	2011-10-08 12:42:54.000000000 +0200
@@ -1,7 +1,7 @@
 % -*- LaTeX -*-
-% $Id: Options.lhs 1913 2006-05-07 13:44:36Z wlux $
+% $Id: Options.lhs 3055 2011-10-07 15:44:49Z wlux $
 %
-% Copyright (c) 2001-2003, Wolfgang Lux
+% Copyright (c) 2001-2011, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{Options.lhs}
@@ -67,7 +67,14 @@
 >     DumpRenamed                       -- dump source after renaming
 >   | DumpTypes                         -- dump types after typechecking
 >   | DumpDesugared                     -- dump source after desugaring
+>   | DumpUnlabeled                     -- dump source after removing labels
+>   | DumpNewtype                       -- dump source after removing newtypes
+>   | DumpUnlazy                        -- dump source after lifting lazy patt.
+>   | DumpFlatCase                      -- dump source after case flattening
 >   | DumpSimplified                    -- dump source after simplification
+>   | DumpPBU                           -- dump source with pattern updates
+>   | DumpDict                          -- dump source with dictionaries
+>   | DumpSpecialize                    -- dump source after specialization
 >   | DumpLifted                        -- dump source after lambda-lifting
 >   | DumpIL                            -- dump IL code after translation
 >   | DumpTransformed                   -- dump transformed code
@@ -100,9 +107,9 @@
 >     Option "e" ["eval"] (OptArg Eval "GOAL")
 >            "generate code to evaluate GOAL",
 >     Option "t" ["type"] (ReqArg Type "GOAL")
->            "print type of GOAL",
+>            "compute type of GOAL",
 >     Option "o" ["output"] (ReqArg Output "FILE")
->            "write code to FILE",
+>            "write code or type to FILE",
 >     Option "" ["no-icurry"] (NoArg NoInterface)
 >            "do not create an interface file",
 >     Option "" ["split-code"] (NoArg SplitCode)
@@ -139,8 +146,22 @@
 >            "dump types after type-checking",
 >     Option "" ["dump-desugared"] (NoArg (Dump [DumpDesugared]))
 >            "dump source code after desugaring",
+>     Option "" ["dump-unlabeled"] (NoArg (Dump [DumpUnlabeled]))
+>            "dump source code after removing field labels",
+>     Option "" ["dump-newremoved"] (NoArg (Dump [DumpNewtype]))
+>            "dump source code after removing newtypes",
+>     Option "" ["dump-unlazy"] (NoArg (Dump [DumpUnlazy]))
+>            "dump source code after lifting lazy patterns",
+>     Option "" ["dump-flattened"] (NoArg (Dump [DumpFlatCase]))
+>            "dump source code after case flattening",
 >     Option "" ["dump-simplified"] (NoArg (Dump [DumpSimplified]))
 >            "dump source code after simplification",
+>     Option "" ["dump-pbu"] (NoArg (Dump [DumpPBU]))
+>            "dump source code with pattern binding updates",
+>     Option "" ["dump-dict"] (NoArg (Dump [DumpDict]))
+>            "dump source code with dictionaries",
+>     Option "" ["dump-specialize"] (NoArg (Dump [DumpSpecialize]))
+>            "dump source code after specialization",
 >     Option "" ["dump-lifted"] (NoArg (Dump [DumpLifted]))
 >            "dump source code after lambda-lifting",
 >     Option "" ["dump-il"] (NoArg (Dump [DumpIL]))
diff -u curry-0.9.11/OverlapCheck.lhs curry-0.9.11-classful/OverlapCheck.lhs
--- curry-0.9.11/OverlapCheck.lhs	2007-06-15 14:16:34.000000000 +0200
+++ curry-0.9.11-classful/OverlapCheck.lhs	2011-10-08 12:42:57.000000000 +0200
@@ -1,163 +1,217 @@
 % -*- LaTeX -*-
-% $Id: OverlapCheck.lhs 1913 2006-05-07 13:44:36Z wlux $
+% $Id: OverlapCheck.lhs 3056 2011-10-07 16:27:03Z wlux $
 %
-% Copyright (c) 2006, Wolfgang Lux
+% Copyright (c) 2006-2011, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{OverlapCheck.lhs}
 \section{Checking for Rules with Overlapping Patterns}
-The compiler can also report rules with overlapping left hand side
-patterns, which causes a non-deterministic evaluation of the
-corresponding functions.
+The compiler can report warnings for functions with overlapping left
+hand sides and flexible case expressions with overlapping patterns,
+which both may cause unintended non-deterministic evaluation.
 \begin{verbatim}
 
 > module OverlapCheck(overlapCheck, overlapCheckGoal) where
-> import Base
+> import Curry
+> import CurryUtils
 > import List
 > import Options
-
-> overlapCheck :: [Warn] -> Module -> [String]
-> overlapCheck v (Module m _ _ ds) =
->   report v $ overlap noPosition [d | BlockDecl d <- ds] []
+> import Position
+> import PredefIdent
+> import Utils
+> import ValueInfo
+
+> overlapCheck :: [Warn] -> ValueEnv -> Module a -> [String]
+> overlapCheck v tyEnv (Module m _ _ ds) =
+>   report v $ overlap tyEnv noPosition ds []
 >   where noPosition = error "noPosition"
 
-> overlapCheckGoal :: [Warn] -> Goal -> [String]
-> overlapCheckGoal v (Goal p e ds) = report v $ overlap p (SimpleRhs p e ds) []
+> overlapCheckGoal :: [Warn] -> ValueEnv -> Goal a -> [String]
+> overlapCheckGoal v tyEnv (Goal p e ds) =
+>   report v $ overlap tyEnv p (SimpleRhs p e ds) []
 
-> report :: [Warn] -> [P Ident] -> [String]
+> report :: [Warn] -> [P (Maybe Ident)] -> [String]
 > report ws
 >   | WarnOverlap `elem` ws = map format
 >   | otherwise = const []
 
-> format :: P Ident -> String
-> format (P p x) =
+> format :: P (Maybe Ident) -> String
+> format (P p (Just x)) =
 >   atP p ("Warning: " ++ name x ++ " has overlapping rules")
+> format (P p Nothing) =
+>   atP p ("Warning: overlapping patterns in fcase expression")
 
 \end{verbatim}
-The names of the functions with overlapping left hand side patterns
-are collected with a simple traversal of the syntax tree.
+The names and the source locations of functions with overlapping left
+hand side patterns as well as the source locations of flexible case
+expressions with overlapping patterns are collected with a simple
+traversal of the syntax tree.
 \begin{verbatim}
 
 > class Syntax a where
->   overlap :: Position -> a -> [P Ident] -> [P Ident]
+>   overlap :: ValueEnv -> Position -> a -> [P (Maybe Ident)]
+>           -> [P (Maybe Ident)]
 
 > instance Syntax a => Syntax [a] where
->   overlap p xs ys = foldr (overlap p) ys xs
+>   overlap tyEnv p xs ys = foldr (overlap tyEnv p) ys xs
+
+> instance Syntax (TopDecl a) where
+>   overlap _ _ (DataDecl _ _ _ _ _ _) = id
+>   overlap _ _ (NewtypeDecl _ _ _ _ _ _) = id
+>   overlap _ _ (TypeDecl _ _ _ _) = id
+>   overlap tyEnv _ (ClassDecl p _ _ _ ds) = overlap tyEnv p ds 
+>   overlap tyEnv _ (InstanceDecl p _ _ _ ds) = overlap tyEnv p ds 
+>   overlap _ _ (DefaultDecl _ _) = id
+>   overlap tyEnv p (BlockDecl d) = overlap tyEnv p d
+
+> instance Syntax (Decl a) where
+>   overlap _ _ (InfixDecl _ _ _ _) = id
+>   overlap _ _ (TypeSig _ _ _) = id
+>   overlap tyEnv _ (FunctionDecl p _ f eqs) =
+>     ([P p (Just f) | isNonDet tyEnv tss] ++) . overlap tyEnv p eqs
+>     where tss = [snd (flatLhs lhs) | (Equation _ lhs _) <- eqs]
+>   overlap _ _ (ForeignDecl _ _ _ _ _) = id
+>   overlap tyEnv _ (PatternDecl p _ rhs) = overlap tyEnv p rhs
+>   overlap _ _ (FreeDecl _ _) = id
+>   overlap _ _ (TrustAnnot _ _ _) = id
+
+> instance Syntax (Equation a) where
+>   overlap tyEnv _ (Equation p _ rhs) = overlap tyEnv p rhs
+
+> instance Syntax (Rhs a) where
+>   overlap tyEnv _ (SimpleRhs p e ds) = overlap tyEnv p ds . overlap tyEnv p e
+>   overlap tyEnv p (GuardedRhs es ds) = overlap tyEnv p ds . overlap tyEnv p es
+
+> instance Syntax (CondExpr a) where
+>   overlap tyEnv _ (CondExpr p g e) = overlap tyEnv p g . overlap tyEnv p e
+
+> instance Syntax (Expression a) where
+>   overlap _ _ (Literal _ _) = id
+>   overlap _ _ (Variable _ _) = id
+>   overlap _ _ (Constructor _ _) = id
+>   overlap tyEnv p (Paren e) = overlap tyEnv p e
+>   overlap tyEnv p (Typed e _) = overlap tyEnv p e
+>   overlap tyEnv p (Record _ _ fs) = overlap tyEnv p fs
+>   overlap tyEnv p (RecordUpdate e fs) = overlap tyEnv p e . overlap tyEnv p fs
+>   overlap tyEnv p (Tuple es) = overlap tyEnv p es
+>   overlap tyEnv p (List _ es) = overlap tyEnv p es
+>   overlap tyEnv p (ListCompr e qs) = overlap tyEnv p qs . overlap tyEnv p e
+>   overlap tyEnv p (EnumFrom e) = overlap tyEnv p e
+>   overlap tyEnv p (EnumFromThen e1 e2) =
+>     overlap tyEnv p e1 . overlap tyEnv p e2
+>   overlap tyEnv p (EnumFromTo e1 e2) = overlap tyEnv p e1 . overlap tyEnv p e2
+>   overlap tyEnv p (EnumFromThenTo e1 e2 e3) =
+>     overlap tyEnv p e1 . overlap tyEnv p e2 . overlap tyEnv p e3
+>   overlap tyEnv p (UnaryMinus e) = overlap tyEnv p e
+>   overlap tyEnv p (Apply e1 e2) = overlap tyEnv p e1 . overlap tyEnv p e2
+>   overlap tyEnv p (InfixApply e1 _ e2) =
+>     overlap tyEnv p e1 . overlap tyEnv p e2
+>   overlap tyEnv p (LeftSection e _) = overlap tyEnv p e
+>   overlap tyEnv p (RightSection _ e) = overlap tyEnv p e
+>   overlap tyEnv _ (Lambda p _ e) = overlap tyEnv p e
+>   overlap tyEnv p (Let ds e) = overlap tyEnv p ds . overlap tyEnv p e
+>   overlap tyEnv p (Do sts e) = overlap tyEnv p sts . overlap tyEnv p e
+>   overlap tyEnv p (IfThenElse e1 e2 e3) =
+>     overlap tyEnv p e1 . overlap tyEnv p e2 . overlap tyEnv p e3
+>   overlap tyEnv p (Case e as) = overlap tyEnv p e . overlap tyEnv p as
+>   overlap tyEnv p (Fcase e as) =
+>     overlap tyEnv p e .
+>     ([P p' Nothing | isNonDet tyEnv tss] ++) . overlap tyEnv p as
+>     where p' = head [p | Alt p _ _ <- as]
+>           tss = [[t] | (Alt _ t _) <- as]
+
+> instance Syntax (Statement a) where
+>   overlap tyEnv p (StmtExpr e) = overlap tyEnv p e
+>   overlap tyEnv _ (StmtBind p _ e) = overlap tyEnv p e
+>   overlap tyEnv p (StmtDecl ds) = overlap tyEnv p ds
 
-> instance Syntax Decl where
->   overlap _ (FunctionDecl p f eqs) =
->     ([P p f | isNonDet eqs] ++) . overlap p eqs
->   overlap _ (PatternDecl p _ rhs) = overlap p rhs
->   overlap _ _ = id
-
-> instance Syntax Equation where
->   overlap _ (Equation p _ rhs) = overlap p rhs
-
-> instance Syntax Rhs where
->   overlap _ (SimpleRhs p e ds) = overlap p ds . overlap p e
->   overlap p (GuardedRhs es ds) = overlap p ds . overlap p es
-
-> instance Syntax CondExpr where
->   overlap _ (CondExpr p g e) = overlap p g . overlap p e
-
-> instance Syntax Expression where
->   overlap _ (Literal _) = id
->   overlap _ (Variable _) = id
->   overlap _ (Constructor _) = id
->   overlap p (Paren e) = overlap p e
->   overlap p (Typed e _) = overlap p e
->   overlap p (Tuple es) = overlap p es
->   overlap p (List es) = overlap p es
->   overlap p (ListCompr e qs) = overlap p qs . overlap p e
->   overlap p (EnumFrom e) = overlap p e
->   overlap p (EnumFromThen e1 e2) = overlap p e1 . overlap p e2
->   overlap p (EnumFromTo e1 e2) = overlap p e1 . overlap p e2
->   overlap p (EnumFromThenTo e1 e2 e3) =
->     overlap p e1 . overlap p e2 . overlap p e3
->   overlap p (UnaryMinus _ e) = overlap p e
->   overlap p (Apply e1 e2) = overlap p e1 . overlap p e2
->   overlap p (InfixApply e1 _ e2) = overlap p e1 . overlap p e2
->   overlap p (LeftSection e _) = overlap p e
->   overlap p (RightSection _ e) = overlap p e
->   overlap p (Lambda _ e) = overlap p e
->   overlap p (Let ds e) = overlap p ds . overlap p e
->   overlap p (Do sts e) = overlap p sts . overlap p e
->   overlap p (IfThenElse e1 e2 e3) =
->     overlap p e1 . overlap p e2 . overlap p e3
->   overlap p (Case e as) = overlap p e . overlap p as
-
-> instance Syntax Statement where
->   overlap p (StmtExpr e) = overlap p e
->   overlap p (StmtBind _ e) = overlap p e
->   overlap p (StmtDecl ds) = overlap p ds
+> instance Syntax (Alt a) where
+>   overlap tyEnv _ (Alt p _ rhs) = overlap tyEnv p rhs
 
-> instance Syntax Alt where
->   overlap _ (Alt p _ rhs) = overlap p rhs
+> instance Syntax a => Syntax (Field a) where
+>   overlap tyEnv p (Field l x) = overlap tyEnv p x
 
 \end{verbatim}
-The code checking whether a function has rules with overlapping
-patterns is essentially a simplified version of the pattern matching
-algorithm implemented in module \texttt{ILTrans} (see
-Sect.~\ref{sec:il-trans}).
+The code checking whether the equations of a function and the
+alternatives of a flexible case expression, respectively, have
+overlapping patterns is essentially a simplified version of the
+pattern matching algorithm implemented in module \texttt{ILTrans} (see
+Sect.~\ref{sec:flatcase}).
+
+\ToDo{Implement a similar check to report completely overlapped
+  patterns, and thus unreachable alternatives, in rigid case
+  expressions.}
 \begin{verbatim}
 
-> isNonDet :: [Equation] -> Bool
-> isNonDet eqs =
->   isOverlap [map desugar (snd (flatLhs lhs)) | Equation _ lhs _ <- eqs]
+> isNonDet :: ValueEnv -> [[ConstrTerm a]] -> Bool
+> isNonDet tyEnv tss = isOverlap (map (map (desugar tyEnv)) tss)
 
-> isOverlap :: [[ConstrTerm]] -> Bool
+> isOverlap :: [[ConstrTerm ()]] -> Bool
 > isOverlap (ts:tss) =
 >   not (null tss) &&
 >   case matchInductive (ts:tss) of
 >      [] -> True
 >      tss:_ -> any isOverlap tss
 
-> matchInductive :: [[ConstrTerm]] -> [[[[ConstrTerm]]]]
+> matchInductive :: [[ConstrTerm ()]] -> [[[[ConstrTerm ()]]]]
 > matchInductive =
 >   map groupRules . filter isInductive . transpose . map (matches id)
->   where isInductive = all (not . isVariablePattern . fst)
+>   where isInductive = all (not . isVarPattern . fst)
 
-> groupRules :: [(ConstrTerm,[ConstrTerm])] -> [[[ConstrTerm]]]
+> groupRules :: [(ConstrTerm (),a)] -> [[a]]
 > groupRules [] = []
 > groupRules ((t,ts):tss) = (ts:map snd same) : groupRules tss
 >   where (same,other) = partition ((t ==) . fst) tss
 
-> matches :: ([ConstrTerm] -> [ConstrTerm]) -> [ConstrTerm]
->         -> [(ConstrTerm,[ConstrTerm])]
+> matches :: ([ConstrTerm a] -> [ConstrTerm a]) -> [ConstrTerm a]
+>         -> [(ConstrTerm a,[ConstrTerm a])]
 > matches _ [] = []
 > matches f (t:ts) = (t',f (ts' ++ ts)) : matches (f . (t:)) ts
 >   where (t',ts') = match t
->         match (ConstructorPattern c ts) = (ConstructorPattern c [],ts)
->         match (LiteralPattern l) = (LiteralPattern l,[])
->         match (VariablePattern v) = (VariablePattern v,[])
-
-> isVariablePattern :: ConstrTerm -> Bool
-> isVariablePattern (LiteralPattern _) = False
-> isVariablePattern (ConstructorPattern _ _) = False
-> isVariablePattern (VariablePattern _) = True
+>         match (ConstructorPattern a c ts) = (ConstructorPattern a c [],ts)
+>         match (LiteralPattern a l) = (LiteralPattern a l,[])
+>         match (VariablePattern a v) = (VariablePattern a v,[])
 
 \end{verbatim}
 Unfortunately, the code has not been desugared yet.
+
+Note that rational literals are equivalent to applications of
+constructor \texttt{Ratio.:\%} and therefore in principle should be
+desugared into applications of that constructor. However, since
+\texttt{Ratio.:\%} is not exported from module \texttt{Ratio}, this is
+not relevant in practice.
 \begin{verbatim}
 
-> desugar :: ConstrTerm -> ConstrTerm
-> desugar (LiteralPattern l) =
+> desugar :: ValueEnv -> ConstrTerm a -> ConstrTerm ()
+> desugar tyEnv (LiteralPattern a l) =
 >   case l of
->     String cs -> desugar (ListPattern (map (LiteralPattern . Char) cs))
->     _ -> LiteralPattern l
-> desugar (NegativePattern _ l) = desugar (LiteralPattern (negateLit l))
->   where negateLit (Int v i) = Int v (-i)
->         negateLit (Float f) = Float (-f)
-> desugar (VariablePattern v) = VariablePattern anonId
-> desugar (ConstructorPattern c ts) = ConstructorPattern c (map desugar ts)
-> desugar (InfixPattern t1 op t2) = desugar (ConstructorPattern op [t1,t2])
-> desugar (ParenPattern t) = desugar t
-> desugar (TuplePattern ts) = desugar (ConstructorPattern c ts)
+>     String cs ->
+>       desugar tyEnv (ListPattern a (map (LiteralPattern a . Char) cs))
+>     _ -> LiteralPattern () l
+> desugar tyEnv (NegativePattern a l) =
+>   desugar tyEnv (LiteralPattern a (negateLit l))
+>   where negateLit (Integer i) = Integer (-i)
+>         negateLit (Rational r) = Rational (-r)
+> desugar _ (VariablePattern _ v) = VariablePattern () anonId
+> desugar tyEnv (ConstructorPattern _ c ts) =
+>   ConstructorPattern () c (map (desugar tyEnv) ts)
+> desugar _ (FunctionPattern _ _ _) = VariablePattern () anonId
+> desugar tyEnv (InfixPattern a t1 op t2) =
+>   desugar tyEnv (desugarOp a op [t1,t2])
+>   where desugarOp a (InfixConstr _ op) = ConstructorPattern a op
+>         desugarOp a (InfixOp _ op) = FunctionPattern a op
+> desugar tyEnv (ParenPattern t) = desugar tyEnv t
+> desugar tyEnv (RecordPattern a c fs) =
+>   ConstructorPattern () c (map (argument tyEnv) (orderFields fs ls))
+>   where ls = fst3 (conType c tyEnv)
+>         argument tyEnv = maybe (VariablePattern () anonId) (desugar tyEnv)
+> desugar tyEnv (TuplePattern ts) =
+>   ConstructorPattern () c (map (desugar tyEnv) ts)
 >   where c = qTupleId (length ts)
-> desugar (ListPattern ts) = desugar (foldr cons nil ts)
->   where nil = ConstructorPattern qNilId []
->         cons t1 t2 = ConstructorPattern qConsId [t1,t2]
-> desugar (AsPattern _ t) = desugar t
-> desugar (LazyPattern _) = VariablePattern anonId
+> desugar tyEnv (ListPattern a ts) = desugar tyEnv (foldr cons nil ts)
+>   where nil = ConstructorPattern a qNilId []
+>         cons t1 t2 = ConstructorPattern a qConsId [t1,t2]
+> desugar tyEnv (AsPattern _ t) = desugar tyEnv t
+> desugar _ (LazyPattern _) = VariablePattern () anonId
 
 \end{verbatim}
Solo in curry-0.9.11-classful/: PatternBind.lhs
diff -u curry-0.9.11/PrecCheck.lhs curry-0.9.11-classful/PrecCheck.lhs
--- curry-0.9.11/PrecCheck.lhs	2007-06-15 14:16:34.000000000 +0200
+++ curry-0.9.11-classful/PrecCheck.lhs	2011-10-08 12:42:57.000000000 +0200
@@ -1,7 +1,7 @@
 % -*- LaTeX -*-
-% $Id: PrecCheck.lhs 2235 2007-06-08 10:12:15Z wlux $
+% $Id: PrecCheck.lhs 3056 2011-10-07 16:27:03Z wlux $
 %
-% Copyright (c) 2001-2006, Wolfgang Lux
+% Copyright (c) 2001-2011, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{PrecCheck.lhs}
@@ -15,9 +15,14 @@
 
 > module PrecCheck(precCheck,precCheckGoal) where
 > import Base
+> import Curry
+> import CurryUtils
 > import Error
 > import Maybe
+> import PrecInfo
+> import PredefIdent
 > import TopEnv
+> import TypeInfo
 
 \end{verbatim}
 For each declaration group, the compiler extends the precedence
@@ -26,7 +31,7 @@
 default precedence to an operator.
 \begin{verbatim}
 
-> bindPrecs :: ModuleIdent -> [Decl] -> PEnv -> PEnv
+> bindPrecs :: ModuleIdent -> [Decl a] -> PEnv -> PEnv
 > bindPrecs m ds pEnv = foldr bindPrec pEnv ds
 >   where bindPrec (InfixDecl _ fix pr ops) pEnv
 >           | p == defaultPrec = pEnv
@@ -38,6 +43,44 @@
 > bindP m p op = bindTopEnv m op (PrecInfo (qualifyWith m op) p)
 
 \end{verbatim}
+At the top-level of a module, we must be careful to not use the
+precedence of an imported function with the same name as a locally
+defined function. For instance, if module $M$ imports module $M'$ and
+both $M$ and $M'$ define a function $f$, the compiler must not use the
+precedence of $M'.f$ while checking the left hand side of $M.f$, in
+particular if $M$ does not contain a fixity declaration for $f$. To
+this end, the compiler removes all precedences from the precedence
+environment which could conflict with a local function declaration
+before adding the local fixity declarations.
+\begin{verbatim}
+
+> cleanPrecs :: Decl a -> PEnv -> PEnv
+> cleanPrecs d pEnv = foldr localUnimportTopEnv pEnv (bv d)
+
+\end{verbatim}
+We must also be careful with the left hand sides of class and instance
+method implementations because their method names have been renamed
+uniquely. In addition, for instance methods we must be careful to use
+the method's precedence as defined in the module defining the
+instance's class and not simply use the precedence which accidentally
+happens to be defined for the method's name in the current module. In
+order to get things straight, we extend the precedence environment
+locally for the renamed methods of a class or instance declaration,
+looking up the correct precedences in the environment with an
+appropriate qualification (see the \texttt{ClassDecl} and
+\texttt{InstanceDecl} equations of \texttt{checkTopDecl} below).
+\begin{verbatim}
+
+> bindMethodPrecs :: ModuleIdent -> (Ident -> QualIdent) -> [Decl a] -> PEnv
+>                 -> PEnv
+> bindMethodPrecs m qual ds pEnv =
+>   foldr bindPrec pEnv [f | FunctionDecl _ _ f _ <- ds]
+>   where bindPrec f pEnv =
+>           maybe id (bindTopEnv m f)
+>                 (listToMaybe (qualLookupTopEnv (qual (unRenameIdent f)) pEnv))
+>                 pEnv
+
+\end{verbatim}
 With the help of the precedence environment, the compiler checks all
 infix applications and sections in the program. This pass will modify
 the parse tree such that for nested infix applications the operator
@@ -47,34 +90,57 @@
 because it is used for constructing the module's interface.
 \begin{verbatim}
 
-> precCheck :: ModuleIdent -> PEnv -> [TopDecl] -> Error (PEnv,[TopDecl])
-> precCheck m pEnv ds =
+> precCheck :: ModuleIdent -> TCEnv -> PEnv -> [TopDecl a]
+>           -> Error (PEnv,[TopDecl a])
+> precCheck m tcEnv pEnv ds =
 >   do
->     ds' <- mapE (checkTopDecl m pEnv') ds
->     return (pEnv',ds')
->   where pEnv' = bindPrecs m [d | BlockDecl d <- ds] pEnv
+>     ds'' <- mapE (checkTopDecl m tcEnv pEnv') ds
+>     return (pEnv',ds'')
+>   where ds' = concatMap decls ds
+>         pEnv' = bindPrecs m ds' (foldr cleanPrecs pEnv ds')
+>         decls (ClassDecl _ _ _ _ ds) = ds
+>         decls (BlockDecl d) = [d]
+>         decls _ = []
 
-> precCheckGoal :: ModuleIdent -> PEnv -> Goal -> Error Goal
+> precCheckGoal :: ModuleIdent -> PEnv -> Goal a -> Error (Goal a)
 > precCheckGoal m pEnv (Goal p e ds) =
 >   liftE2 (Goal p) (checkExpr m p pEnv' e) (mapE (checkDecl m pEnv') ds)
 >   where pEnv' = bindPrecs m ds pEnv
 
-> checkTopDecl :: ModuleIdent -> PEnv -> TopDecl -> Error TopDecl
-> checkTopDecl m pEnv (BlockDecl d) = liftE BlockDecl (checkDecl m pEnv d)
-> checkTopDecl _ _ d = return d
-
-> checkDecl :: ModuleIdent -> PEnv -> Decl -> Error Decl
-> checkDecl m pEnv (FunctionDecl p f eqs) =
->   liftE (FunctionDecl p f) (mapE (checkEqn m pEnv) eqs)
+> checkTopDecl :: ModuleIdent -> TCEnv -> PEnv -> TopDecl a -> Error (TopDecl a)
+> checkTopDecl _ _ _ (DataDecl p cx tc tvs cs clss) =
+>   return (DataDecl p cx tc tvs cs clss)
+> checkTopDecl _ _ _ (NewtypeDecl p cx tc tvs nc clss) =
+>   return (NewtypeDecl p cx tc tvs nc clss)
+> checkTopDecl _ _ _ (TypeDecl p tc tvs ty) = return (TypeDecl p tc tvs ty)
+> checkTopDecl m _ pEnv (ClassDecl p cx cls tv ds) =
+>   liftE (ClassDecl p cx cls tv) (mapE (checkDecl m pEnv') ds)
+>   where pEnv' = bindMethodPrecs m qualify ds pEnv
+> checkTopDecl m tcEnv pEnv (InstanceDecl p cx cls ty ds) =
+>   liftE (InstanceDecl p cx cls ty) (mapE (checkDecl m pEnv') ds)
+>   where pEnv' = bindMethodPrecs m qual ds pEnv
+>         qual =
+>           maybe qualify (qualifyLike . origName)
+>                 (listToMaybe (qualLookupTopEnv cls tcEnv))
+> checkTopDecl _ _ _ (DefaultDecl p tys) = return (DefaultDecl p tys)
+> checkTopDecl m _ pEnv (BlockDecl d) = liftE BlockDecl (checkDecl m pEnv d)
+
+> checkDecl :: ModuleIdent -> PEnv -> Decl a -> Error (Decl a)
+> checkDecl _ _ (InfixDecl p fix pr ops) = return (InfixDecl p fix pr ops)
+> checkDecl _ _ (TypeSig p fs ty) = return (TypeSig p fs ty)
+> checkDecl m pEnv (FunctionDecl p a f eqs) =
+>   liftE (FunctionDecl p a f) (mapE (checkEqn m pEnv) eqs)
+> checkDecl _ _ (ForeignDecl p fi a f ty) = return (ForeignDecl p fi a f ty)
 > checkDecl m pEnv (PatternDecl p t rhs) =
 >   liftE2 (PatternDecl p) (checkConstrTerm p pEnv t) (checkRhs m pEnv rhs)
-> checkDecl _ _ d = return d
+> checkDecl _ _ (FreeDecl p vs) = return (FreeDecl p vs)
+> checkDecl _ _ (TrustAnnot p tr fs) = return (TrustAnnot p tr fs)
 
-> checkEqn :: ModuleIdent -> PEnv -> Equation -> Error Equation
+> checkEqn :: ModuleIdent -> PEnv -> Equation a -> Error (Equation a)
 > checkEqn m pEnv (Equation p lhs rhs) =
 >   liftE2 (Equation p) (checkLhs p pEnv lhs) (checkRhs m pEnv rhs)
 
-> checkLhs :: Position -> PEnv -> Lhs -> Error Lhs
+> checkLhs :: Position -> PEnv -> Lhs a -> Error (Lhs a)
 > checkLhs p pEnv (FunLhs f ts) =
 >   liftE (FunLhs f) (mapE (checkConstrTerm p pEnv) ts)
 > checkLhs p pEnv (OpLhs t1 op t2) =
@@ -90,29 +156,33 @@
 > checkLhs p pEnv (ApLhs lhs ts) =
 >   liftE2 ApLhs (checkLhs p pEnv lhs) (mapE (checkConstrTerm p pEnv) ts)
 
-> checkConstrTerm :: Position -> PEnv -> ConstrTerm -> Error ConstrTerm
-> checkConstrTerm _ _ (LiteralPattern l) = return (LiteralPattern l)
-> checkConstrTerm _ _ (NegativePattern op l) = return (NegativePattern op l)
-> checkConstrTerm _ _ (VariablePattern v) = return (VariablePattern v)
-> checkConstrTerm p pEnv (ConstructorPattern c ts) =
->   liftE (ConstructorPattern c) (mapE (checkConstrTerm p pEnv) ts)
-> checkConstrTerm p pEnv (InfixPattern t1 op t2) =
+> checkConstrTerm :: Position -> PEnv -> ConstrTerm a -> Error (ConstrTerm a)
+> checkConstrTerm _ _ (LiteralPattern a l) = return (LiteralPattern a l)
+> checkConstrTerm _ _ (NegativePattern a l) = return (NegativePattern a l)
+> checkConstrTerm _ _ (VariablePattern a v) = return (VariablePattern a v)
+> checkConstrTerm p pEnv (ConstructorPattern a c ts) =
+>   liftE (ConstructorPattern a c) (mapE (checkConstrTerm p pEnv) ts)
+> checkConstrTerm p pEnv (FunctionPattern a f ts) =
+>   liftE (FunctionPattern a f) (mapE (checkConstrTerm p pEnv) ts)
+> checkConstrTerm p pEnv (InfixPattern a t1 op t2) =
 >   do
 >     (t1',t2') <-
 >       liftE (,) (checkConstrTerm p pEnv t1) &&& checkConstrTerm p pEnv t2
->     fixPrecT p pEnv t1' op t2'
+>     fixPrecT p pEnv a t1' op t2'
 > checkConstrTerm p pEnv (ParenPattern t) =
 >   liftE ParenPattern (checkConstrTerm p pEnv t)
+> checkConstrTerm p pEnv (RecordPattern a c fs) =
+>   liftE (RecordPattern a c) (mapE (checkField (checkConstrTerm p pEnv)) fs)
 > checkConstrTerm p pEnv (TuplePattern ts) =
 >   liftE TuplePattern (mapE (checkConstrTerm p pEnv) ts)
-> checkConstrTerm p pEnv (ListPattern ts) =
->   liftE ListPattern (mapE (checkConstrTerm p pEnv) ts)
+> checkConstrTerm p pEnv (ListPattern a ts) =
+>   liftE (ListPattern a) (mapE (checkConstrTerm p pEnv) ts)
 > checkConstrTerm p pEnv (AsPattern v t) =
 >   liftE (AsPattern v) (checkConstrTerm p pEnv t)
 > checkConstrTerm p pEnv (LazyPattern t) =
 >   liftE LazyPattern (checkConstrTerm p pEnv t)
 
-> checkRhs :: ModuleIdent -> PEnv -> Rhs -> Error Rhs
+> checkRhs :: ModuleIdent -> PEnv -> Rhs a -> Error (Rhs a)
 > checkRhs m pEnv (SimpleRhs p e ds) =
 >   liftE2 (SimpleRhs p) (checkExpr m p pEnv' e) (mapE (checkDecl m pEnv') ds)
 >   where pEnv' = bindPrecs m ds pEnv
@@ -122,18 +192,25 @@
 >          (mapE (checkDecl m pEnv') ds)
 >   where pEnv' = bindPrecs m ds pEnv
 
-> checkCondExpr :: ModuleIdent -> PEnv -> CondExpr -> Error CondExpr
+> checkCondExpr :: ModuleIdent -> PEnv -> CondExpr a -> Error (CondExpr a)
 > checkCondExpr m pEnv (CondExpr p g e) =
 >   liftE2 (CondExpr p) (checkExpr m p pEnv g) (checkExpr m p pEnv e)
 
-> checkExpr :: ModuleIdent -> Position -> PEnv -> Expression -> Error Expression
-> checkExpr _ _ _ (Literal l) = return (Literal l)
-> checkExpr _ _ _ (Variable v) = return (Variable v)
-> checkExpr _ _ _ (Constructor c) = return (Constructor c)
+> checkExpr :: ModuleIdent -> Position -> PEnv -> Expression a
+>           -> Error (Expression a)
+> checkExpr _ _ _ (Literal a l) = return (Literal a l)
+> checkExpr _ _ _ (Variable a v) = return (Variable a v)
+> checkExpr _ _ _ (Constructor a c) = return (Constructor a c)
 > checkExpr m p pEnv (Paren e) = liftE Paren (checkExpr m p pEnv e)
 > checkExpr m p pEnv (Typed e ty) = liftE (flip Typed ty) (checkExpr m p pEnv e)
+> checkExpr m p pEnv (Record a c fs) =
+>   liftE (Record a c) (mapE (checkField (checkExpr m p pEnv)) fs)
+> checkExpr m p pEnv (RecordUpdate e fs) =
+>   liftE2 RecordUpdate
+>          (checkExpr m p pEnv e)
+>          (mapE (checkField (checkExpr m p pEnv)) fs)
 > checkExpr m p pEnv (Tuple es) = liftE Tuple (mapE (checkExpr m p pEnv) es)
-> checkExpr m p pEnv (List es) = liftE List (mapE (checkExpr m p pEnv) es)
+> checkExpr m p pEnv (List a es) = liftE (List a) (mapE (checkExpr m p pEnv) es)
 > checkExpr m p pEnv (ListCompr e qs) =
 >   liftE2 ListCompr (checkExpr m p pEnv' e) (mapE (checkStmt m p pEnv') qs)
 >   where pEnv' = bindPrecs m [d | StmtDecl ds <- qs, d <- ds] pEnv
@@ -147,8 +224,7 @@
 >          (checkExpr m p pEnv e1)
 >          (checkExpr m p pEnv e2)
 >          (checkExpr m p pEnv e3)
-> checkExpr m p pEnv (UnaryMinus op e) =
->   liftE (UnaryMinus op) (checkExpr m p pEnv e)
+> checkExpr m p pEnv (UnaryMinus e) = liftE UnaryMinus (checkExpr m p pEnv e)
 > checkExpr m p pEnv (Apply e1 e2) =
 >   liftE2 Apply (checkExpr m p pEnv e1) (checkExpr m p pEnv e2)
 > checkExpr m p pEnv (InfixApply e1 op e2) =
@@ -165,8 +241,8 @@
 >     e' <- checkExpr m p pEnv e
 >     checkRSection p pEnv op e'
 >     return (RightSection op e')
-> checkExpr m p pEnv (Lambda ts e) =
->   liftE2 Lambda (mapE (checkConstrTerm p pEnv) ts) (checkExpr m p pEnv e)
+> checkExpr m _ pEnv (Lambda p ts e) =
+>   liftE2 (Lambda p) (mapE (checkConstrTerm p pEnv) ts) (checkExpr m p pEnv e)
 > checkExpr m p pEnv (Let ds e) =
 >   liftE2 Let (mapE (checkDecl m pEnv') ds) (checkExpr m p pEnv' e)
 >   where pEnv' = bindPrecs m ds pEnv
@@ -180,17 +256,23 @@
 >          (checkExpr m p pEnv e3)
 > checkExpr m p pEnv (Case e alts) =
 >   liftE2 Case (checkExpr m p pEnv e) (mapE (checkAlt m pEnv) alts)
+> checkExpr m p pEnv (Fcase e alts) =
+>   liftE2 Fcase (checkExpr m p pEnv e) (mapE (checkAlt m pEnv) alts)
 
-> checkStmt :: ModuleIdent -> Position -> PEnv -> Statement -> Error Statement
+> checkStmt :: ModuleIdent -> Position -> PEnv -> Statement a
+>           -> Error (Statement a)
 > checkStmt m p pEnv (StmtExpr e) = liftE StmtExpr (checkExpr m p pEnv e)
+> checkStmt m _ pEnv (StmtBind p t e) =
+>   liftE2 (StmtBind p) (checkConstrTerm p pEnv t) (checkExpr m p pEnv e)
 > checkStmt m _ pEnv (StmtDecl ds) = liftE StmtDecl (mapE (checkDecl m pEnv) ds)
-> checkStmt m p pEnv (StmtBind t e) =
->   liftE2 StmtBind (checkConstrTerm p pEnv t) (checkExpr m p pEnv e)
 
-> checkAlt :: ModuleIdent -> PEnv -> Alt -> Error Alt
+> checkAlt :: ModuleIdent -> PEnv -> Alt a -> Error (Alt a)
 > checkAlt m pEnv (Alt p t rhs) =
 >   liftE2 (Alt p) (checkConstrTerm p pEnv t) (checkRhs m pEnv rhs)
 
+> checkField :: (a -> Error a) -> Field a -> Error (Field a)
+> checkField check (Field l x) = liftE (Field l) (check x)
+
 \end{verbatim}
 The functions \texttt{fixPrec}, \texttt{fixUPrec}, and
 \texttt{fixRPrec} check the relative precedences of adjacent infix
@@ -213,38 +295,39 @@
 \texttt{fixPrec} is called.
 \begin{verbatim}
 
-> fixPrec :: Position -> PEnv -> Expression -> InfixOp -> Expression
->         -> Error Expression
-> fixPrec p pEnv (UnaryMinus uop e1) op e2
->   | pr < 6 || pr == 6 && fix == InfixL =
->       fixRPrec p pEnv (UnaryMinus uop e1) op e2
->   | pr > 6 = fixUPrec p pEnv uop e1 op e2
->   | otherwise = errorAt p $ ambiguousParse "unary" (qualify uop) (opName op)
+> fixPrec :: Position -> PEnv -> Expression a -> InfixOp a -> Expression a
+>         -> Error (Expression a)
+> fixPrec p pEnv (UnaryMinus e1) op e2
+>   | pr < 6 || pr == 6 && fix == InfixL = fixRPrec p pEnv (UnaryMinus e1) op e2
+>   | pr > 6 = fixUPrec p pEnv e1 op e2
+>   | otherwise =
+>       errorAt p $ ambiguousParse "unary" (qualify minusId) (opName op)
 >   where OpPrec fix pr = opPrec op pEnv
 > fixPrec p pEnv e1 op e2 = fixRPrec p pEnv e1 op e2
 
-> fixUPrec :: Position -> PEnv -> Ident -> Expression -> InfixOp -> Expression
->          -> Error Expression
-> fixUPrec p pEnv _ _ op (UnaryMinus uop _) =
->   errorAt p $ ambiguousParse "operator" (opName op) (qualify uop)
-> fixUPrec p pEnv uop e1 op1 (InfixApply e2 op2 e3)
+> fixUPrec :: Position -> PEnv -> Expression a -> InfixOp a -> Expression a
+>          -> Error (Expression a)
+> fixUPrec p pEnv _ op (UnaryMinus _) =
+>   errorAt p $ ambiguousParse "operator" (opName op) (qualify minusId)
+> fixUPrec p pEnv e1 op1 (InfixApply e2 op2 e3)
 >   | pr2 < 6 || pr2 == 6 && fix2 == InfixL =
 >       do
->         e' <- fixUPrec p pEnv uop e1 op1 e2
+>         e' <- fixUPrec p pEnv e1 op1 e2
 >         return (InfixApply e' op2 e3)
 >   | pr2 > 6 =
->       liftE (UnaryMinus uop) (fixRPrec p pEnv e1 op1 (InfixApply e2 op2 e3))
->   | otherwise = errorAt p $ ambiguousParse "unary" (qualify uop) (opName op2)
+>       liftE UnaryMinus (fixRPrec p pEnv e1 op1 (InfixApply e2 op2 e3))
+>   | otherwise =
+>       errorAt p $ ambiguousParse "unary" (qualify minusId) (opName op2)
 >   where OpPrec fix1 pr1 = opPrec op1 pEnv
 >         OpPrec fix2 pr2 = opPrec op2 pEnv
-> fixUPrec _ _ uop e1 op e2 = return (UnaryMinus uop (InfixApply e1 op e2))
+> fixUPrec _ _ e1 op e2 = return (UnaryMinus (InfixApply e1 op e2))
 
-> fixRPrec :: Position -> PEnv -> Expression -> InfixOp -> Expression
->          -> Error Expression
-> fixRPrec p pEnv e1 op (UnaryMinus uop e2)
->   | pr < 6 = return (InfixApply e1 op (UnaryMinus uop e2))
+> fixRPrec :: Position -> PEnv -> Expression a -> InfixOp a -> Expression a
+>          -> Error (Expression a)
+> fixRPrec p pEnv e1 op (UnaryMinus e2)
+>   | pr < 6 = return (InfixApply e1 op (UnaryMinus e2))
 >   | otherwise =
->       errorAt p $ ambiguousParse "operator" (opName op) (qualify uop)
+>       errorAt p $ ambiguousParse "operator" (opName op) (qualify minusId)
 >   where OpPrec _ pr = opPrec op pEnv
 > fixRPrec p pEnv e1 op1 (InfixApply e2 op2 e3)
 >   | pr1 < pr2 || pr1 == pr2 && fix1 == InfixR && fix2 == InfixR =
@@ -269,10 +352,11 @@
 section, respectively.
 \begin{verbatim}
 
-> checkLSection :: Position -> PEnv -> InfixOp -> Expression -> Error ()
-> checkLSection p pEnv op (UnaryMinus uop _)
+> checkLSection :: Position -> PEnv -> InfixOp a -> Expression a -> Error ()
+> checkLSection p pEnv op (UnaryMinus _)
 >   | pr < 6 || pr == 6 && fix == InfixL = return ()
->   | otherwise = errorAt p $ ambiguousParse "unary" (qualify uop) (opName op)
+>   | otherwise =
+>       errorAt p $ ambiguousParse "unary" (qualify minusId) (opName op)
 >   where OpPrec fix pr = opPrec op pEnv
 > checkLSection p pEnv op1 (InfixApply _ op2 _)
 >   | pr1 < pr2 || pr1 == pr2 && fix1 == InfixL && fix2 == InfixL = return ()
@@ -282,10 +366,11 @@
 >         OpPrec fix2 pr2 = opPrec op2 pEnv
 > checkLSection _ _ _ _ = return ()
 
-> checkRSection :: Position -> PEnv -> InfixOp -> Expression -> Error ()
-> checkRSection p pEnv op (UnaryMinus uop _)
+> checkRSection :: Position -> PEnv -> InfixOp a -> Expression a -> Error ()
+> checkRSection p pEnv op (UnaryMinus _)
 >   | pr < 6 = return ()
->   | otherwise = errorAt p $ ambiguousParse "unary" (qualify uop) (opName op)
+>   | otherwise =
+>       errorAt p $ ambiguousParse "unary" (qualify minusId) (opName op)
 >   where OpPrec _ pr = opPrec op pEnv
 > checkRSection p pEnv op1 (InfixApply _ op2 _)
 >   | pr1 < pr2 || pr1 == pr2 && fix1 == InfixR && fix2 == InfixR = return ()
@@ -308,31 +393,32 @@
 that of unary negation.
 \begin{verbatim}
 
-> fixPrecT :: Position -> PEnv -> ConstrTerm -> QualIdent -> ConstrTerm
->          -> Error ConstrTerm
-> fixPrecT p pEnv t1@(NegativePattern uop l) op t2
->   | pr < 6 || pr == 6 && fix == InfixL = fixRPrecT p pEnv t1 op t2
->   | otherwise = errorAt p $ invalidParse "unary" uop op
->   where OpPrec fix pr = prec op pEnv
-> fixPrecT p pEnv t1 op t2 = fixRPrecT p pEnv t1 op t2
-
-> fixRPrecT :: Position -> PEnv -> ConstrTerm -> QualIdent -> ConstrTerm
->           -> Error ConstrTerm
-> fixRPrecT p pEnv t1 op t2@(NegativePattern uop l)
->   | pr < 6 = return (InfixPattern t1 op t2)
->   | otherwise = errorAt p $ invalidParse "unary" uop op
->   where OpPrec _ pr = prec op pEnv
-> fixRPrecT p pEnv t1 op1 (InfixPattern t2 op2 t3)
+> fixPrecT :: Position -> PEnv -> a -> ConstrTerm a -> InfixOp ()
+>          -> ConstrTerm a -> Error (ConstrTerm a)
+> fixPrecT p pEnv a t1@(NegativePattern _ _) op t2
+>   | pr < 6 || pr == 6 && fix == InfixL = fixRPrecT p pEnv a t1 op t2
+>   | otherwise = errorAt p $ invalidParse "unary" minusId (opName op)
+>   where OpPrec fix pr = opPrec op pEnv
+> fixPrecT p pEnv a t1 op t2 = fixRPrecT p pEnv a t1 op t2
+
+> fixRPrecT :: Position -> PEnv -> a -> ConstrTerm a -> InfixOp ()
+>           -> ConstrTerm a -> Error (ConstrTerm a)
+> fixRPrecT p pEnv a t1 op t2@(NegativePattern _ _)
+>   | pr < 6 = return (InfixPattern a t1 op t2)
+>   | otherwise = errorAt p $ invalidParse "unary" minusId (opName op)
+>   where OpPrec _ pr = opPrec op pEnv
+> fixRPrecT p pEnv a1 t1 op1 (InfixPattern a2 t2 op2 t3)
 >   | pr1 < pr2 || pr1 == pr2 && fix1 == InfixR && fix2 == InfixR =
->       return (InfixPattern t1 op1 (InfixPattern t2 op2 t3))
+>       return (InfixPattern a1 t1 op1 (InfixPattern a2 t2 op2 t3))
 >   | pr1 > pr2 || pr1 == pr2 && fix1 == InfixL && fix2 == InfixL =
 >       do
->         t' <- fixPrecT p pEnv t1 op1 t2
->         return (InfixPattern t' op2 t3)
->   | otherwise = errorAt p $ ambiguousParse "operator" op1 op2
->   where OpPrec fix1 pr1 = prec op1 pEnv
->         OpPrec fix2 pr2 = prec op2 pEnv
-> fixRPrecT _ _ t1 op t2 = return (InfixPattern t1 op t2)
+>         t' <- fixPrecT p pEnv a2 t1 op1 t2
+>         return (InfixPattern a1 t' op2 t3)
+>   | otherwise =
+>       errorAt p $ ambiguousParse "operator" (opName op1) (opName op2)
+>   where OpPrec fix1 pr1 = opPrec op1 pEnv
+>         OpPrec fix2 pr2 = opPrec op2 pEnv
+> fixRPrecT _ _ a t1 op t2 = return (InfixPattern a t1 op t2)
 
 \end{verbatim}
 The functions \texttt{checkOpL} and \texttt{checkOpR} check the left
@@ -341,28 +427,28 @@
 left-hand side of the declaration is invalid.
 \begin{verbatim}
 
-> checkOpL :: Position -> PEnv -> Ident -> ConstrTerm -> Error ()
-> checkOpL p pEnv op (NegativePattern uop _)
+> checkOpL :: Position -> PEnv -> Ident -> ConstrTerm a -> Error ()
+> checkOpL p pEnv op (NegativePattern _ _)
 >   | pr < 6 || pr == 6 && fix == InfixL = return ()
->   | otherwise = errorAt p $ invalidParse "unary" uop (qualify op)
+>   | otherwise = errorAt p $ invalidParse "unary" minusId (qualify op)
 >   where OpPrec fix pr = prec (qualify op) pEnv
-> checkOpL p pEnv op1 (InfixPattern _ op2 _)
+> checkOpL p pEnv op1 (InfixPattern _ _ op2 _)
 >   | pr1 < pr2 || pr1 == pr2 && fix1 == InfixL && fix2 == InfixL = return ()
->   | otherwise = errorAt p $ invalidParse "operator" op1 op2
+>   | otherwise = errorAt p $ invalidParse "operator" op1 (opName op2)
 >   where OpPrec fix1 pr1 = prec (qualify op1) pEnv
->         OpPrec fix2 pr2 = prec op2 pEnv
+>         OpPrec fix2 pr2 = opPrec op2 pEnv
 > checkOpL _ _ _ _ = return ()
 
-> checkOpR :: Position -> PEnv -> Ident -> ConstrTerm -> Error ()
-> checkOpR p pEnv op (NegativePattern uop _)
+> checkOpR :: Position -> PEnv -> Ident -> ConstrTerm a -> Error ()
+> checkOpR p pEnv op (NegativePattern _ _)
 >   | pr < 6 = return ()
->   | otherwise = errorAt p $ invalidParse "unary" uop (qualify op)
+>   | otherwise = errorAt p $ invalidParse "unary" minusId (qualify op)
 >   where OpPrec _ pr = prec (qualify op) pEnv
-> checkOpR p pEnv op1 (InfixPattern _ op2 _)
+> checkOpR p pEnv op1 (InfixPattern _ _ op2 _)
 >   | pr1 < pr2 || pr1 == pr2 && fix1 == InfixR && fix2 == InfixR = return ()
->   | otherwise = errorAt p $ invalidParse "operator" op1 op2
+>   | otherwise = errorAt p $ invalidParse "operator" op1 (opName op2)
 >   where OpPrec fix1 pr1 = prec (qualify op1) pEnv
->         OpPrec fix2 pr2 = prec op2 pEnv
+>         OpPrec fix2 pr2 = opPrec op2 pEnv
 > checkOpR _ _ _ _ = return ()
 
 \end{verbatim}
@@ -374,7 +460,7 @@
 definition.
 \begin{verbatim}
 
-> opPrec :: InfixOp -> PEnv -> OpPrec
+> opPrec :: InfixOp a -> PEnv -> OpPrec
 > opPrec op = prec (opName op)
 
 > prec :: QualIdent -> PEnv -> OpPrec
Solo in curry-0.9.11-classful/: PrecInfo.lhs
Solo in curry-0.9.11-classful/: PredefIdent.lhs
Solo in curry-0.9.11-classful/: PredefTypes.lhs
diff -u curry-0.9.11/Qual.lhs curry-0.9.11-classful/Qual.lhs
--- curry-0.9.11/Qual.lhs	2007-06-15 14:16:34.000000000 +0200
+++ curry-0.9.11-classful/Qual.lhs	2011-10-08 12:42:57.000000000 +0200
@@ -1,119 +1,254 @@
 % -*- LaTeX -*-
-% $Id: Qual.lhs 2228 2007-06-02 10:21:59Z wlux $
+% $Id: Qual.lhs 3056 2011-10-07 16:27:03Z wlux $
 %
-% Copyright (c) 2001-2007, Wolfgang Lux
+% Copyright (c) 2001-2011, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{Qual.lhs}
-\section{Proper Qualification}
-After checking the module and before starting the translation into the
-intermediate language, the compiler properly qualifies all
-constructors and (global) functions occurring in a pattern or
-expression such that their module prefix matches the module of their
-definition. This is done also for functions and constructors declared
-in the current module. Only functions and variables declared in local
-declarations groups as well as function arguments remain unchanged.
+\section{Qualification}
+After syntax checking and before kind checking, the compiler removes
+unnecessary module qualifiers from all identifiers in the current
+module and changes the module qualifiers of those entities whose name
+would otherwise be ambiguous to match the modules containing their
+definitions. This policy allows the compiler to add references to
+prelude entities into the source code without risk of name conflicts
+and at the same time avoids messing up error messages with lots of
+redundant module qualifiers.
+
+After type checking succeeds, the compiler adds correct module
+qualifiers to all entites except for entities defined in local
+declaration groups.
+
+Exporting the types \texttt{Qual} and \texttt{Phase} is necessary in
+order to compile this module with hbc.
 \begin{verbatim}
 
-> module Qual(Qual(..)) where
+> module Qual(Qual, Phase, qual1, qual2) where
 > import Base
+> import Curry
+> import IdentInfo
 > import TopEnv
 
+> data Phase = One | Two
+
+> qual1, qual2 :: Qual a => TypeEnv -> FunEnv -> a -> a
+> qual1 = qual One
+> qual2 = qual Two
+
 > class Qual a where
->   qual :: ValueEnv -> a -> a
+>   qual :: Phase -> TypeEnv -> FunEnv -> a -> a
 
 > instance Qual a => Qual [a] where
->   qual tyEnv = map (qual tyEnv)
-
-> instance Qual Goal where
->   qual tyEnv (Goal p e ds) = Goal p (qual tyEnv e) (qual tyEnv ds)
+>   qual phase tEnv vEnv = map (qual phase tEnv vEnv)
 
-> instance Qual TopDecl where
->   qual tyEnv (BlockDecl d) = BlockDecl (qual tyEnv d)
->   qual _ d = d
-
-> instance Qual Decl where
->   qual tyEnv (FunctionDecl p f eqs) = FunctionDecl p f (qual tyEnv eqs)
->   qual tyEnv (PatternDecl p t rhs) =
->     PatternDecl p (qual tyEnv t) (qual tyEnv rhs)
->   qual _ d = d
-
-> instance Qual Equation where
->   qual tyEnv (Equation p lhs rhs) =
->     Equation p (qual tyEnv lhs) (qual tyEnv rhs)
-
-> instance Qual Lhs where
->   qual tyEnv (FunLhs f ts) = FunLhs f (qual tyEnv ts)
->   qual tyEnv (OpLhs t1 op t2) = OpLhs (qual tyEnv t1) op (qual tyEnv t2)
->   qual tyEnv (ApLhs lhs ts) = ApLhs (qual tyEnv lhs) (qual tyEnv ts)
-
-> instance Qual ConstrTerm where
->   qual _ (LiteralPattern l) = LiteralPattern l
->   qual _ (NegativePattern op l) = NegativePattern op l
->   qual _ (VariablePattern v) = VariablePattern v
->   qual tyEnv (ConstructorPattern c ts) =
->     ConstructorPattern (qual tyEnv c) (qual tyEnv ts)
->   qual tyEnv (InfixPattern t1 op t2) =
->     InfixPattern (qual tyEnv t1) (qual tyEnv op) (qual tyEnv t2)
->   qual tyEnv (ParenPattern t) = ParenPattern (qual tyEnv t)
->   qual tyEnv (TuplePattern ts) = TuplePattern (qual tyEnv ts)
->   qual tyEnv (ListPattern ts) = ListPattern (qual tyEnv ts)
->   qual tyEnv (AsPattern v t) = AsPattern v (qual tyEnv t)
->   qual tyEnv (LazyPattern t) = LazyPattern (qual tyEnv t)
-
-> instance Qual Rhs where
->   qual tyEnv (SimpleRhs p e ds) = SimpleRhs p (qual tyEnv e) (qual tyEnv ds) 
->   qual tyEnv (GuardedRhs es ds) = GuardedRhs (qual tyEnv es) (qual tyEnv ds)
-
-> instance Qual CondExpr where
->   qual tyEnv (CondExpr p g e) = CondExpr p (qual tyEnv g) (qual tyEnv e)
-
-> instance Qual Expression where
->   qual _ (Literal l) = Literal l
->   qual tyEnv (Variable v) = Variable (qual tyEnv v)
->   qual tyEnv (Constructor c) = Constructor (qual tyEnv c)
->   qual tyEnv (Paren e) = Paren (qual tyEnv e)
->   qual tyEnv (Typed e ty) = Typed (qual tyEnv e) ty
->   qual tyEnv (Tuple es) = Tuple (qual tyEnv es)
->   qual tyEnv (List es) = List (qual tyEnv es)
->   qual tyEnv (ListCompr e qs) = ListCompr (qual tyEnv e) (qual tyEnv qs)
->   qual tyEnv (EnumFrom e) = EnumFrom (qual tyEnv e)
->   qual tyEnv (EnumFromThen e1 e2) =
->     EnumFromThen (qual tyEnv e1) (qual tyEnv e2)
->   qual tyEnv (EnumFromTo e1 e2) = EnumFromTo (qual tyEnv e1) (qual tyEnv e2)
->   qual tyEnv (EnumFromThenTo e1 e2 e3) =
->     EnumFromThenTo (qual tyEnv e1) (qual tyEnv e2) (qual tyEnv e3)
->   qual tyEnv (UnaryMinus op e) = UnaryMinus op (qual tyEnv e)
->   qual tyEnv (Apply e1 e2) = Apply (qual tyEnv e1) (qual tyEnv e2)
->   qual tyEnv (InfixApply e1 op e2) =
->     InfixApply (qual tyEnv e1) (qual tyEnv op) (qual tyEnv e2)
->   qual tyEnv (LeftSection e op) = LeftSection (qual tyEnv e) (qual tyEnv op)
->   qual tyEnv (RightSection op e) = RightSection (qual tyEnv op) (qual tyEnv e)
->   qual tyEnv (Lambda ts e) = Lambda (qual tyEnv ts) (qual tyEnv e)
->   qual tyEnv (Let ds e) = Let (qual tyEnv ds) (qual tyEnv e)
->   qual tyEnv (Do sts e) = Do (qual tyEnv sts) (qual tyEnv e)
->   qual tyEnv (IfThenElse e1 e2 e3) =
->     IfThenElse (qual tyEnv e1) (qual tyEnv e2) (qual tyEnv e3)
->   qual tyEnv (Case e alts) = Case (qual tyEnv e) (qual tyEnv alts)
-
-> instance Qual Statement where
->   qual tyEnv (StmtExpr e) = StmtExpr (qual tyEnv e)
->   qual tyEnv (StmtBind t e) = StmtBind (qual tyEnv t) (qual tyEnv e)
->   qual tyEnv (StmtDecl ds) = StmtDecl (qual tyEnv ds)
-
-> instance Qual Alt where
->   qual tyEnv (Alt p t rhs) = Alt p (qual tyEnv t) (qual tyEnv rhs)
-
-> instance Qual InfixOp where
->   qual tyEnv (InfixOp op) = InfixOp (qual tyEnv op)
->   qual tyEnv (InfixConstr op) = InfixConstr (qual tyEnv op)
-
-> instance Qual QualIdent where
->   qual tyEnv x
->     | isRenamed (unqualify x) = x
->     | otherwise =
->         case qualLookupTopEnv x tyEnv of
->           [y] -> origName y
->           _ -> internalError ("qual: " ++ show x)
+> instance Qual (Goal a) where
+>   qual phase tEnv vEnv (Goal p e ds) =
+>     Goal p (qual phase tEnv vEnv e) (qual phase tEnv vEnv ds)
+
+> instance Qual (TopDecl a) where
+>   qual phase tEnv vEnv (DataDecl p cx tc tvs cs clss) =
+>     DataDecl p (qual phase tEnv vEnv cx) tc tvs (qual phase tEnv vEnv cs)
+>              (qual phase tEnv vEnv clss)
+>   qual phase tEnv vEnv (NewtypeDecl p cx tc tvs nc clss) =
+>     NewtypeDecl p (qual phase tEnv vEnv cx) tc tvs (qual phase tEnv vEnv nc)
+>                 (qual phase tEnv vEnv clss)
+>   qual phase tEnv vEnv (TypeDecl p tc tvs ty) =
+>     TypeDecl p tc tvs (qual phase tEnv vEnv ty)
+>   qual phase tEnv vEnv (ClassDecl p cx cls tv ds) =
+>     ClassDecl p (qual phase tEnv vEnv cx) cls tv (qual phase tEnv vEnv ds)
+>   qual phase tEnv vEnv (InstanceDecl p cx cls ty ds) =
+>     InstanceDecl p (qual phase tEnv vEnv cx)
+>                  (qualIdent phase tEnv cls)
+>                  (qual phase tEnv vEnv ty)
+>                  (qual phase tEnv vEnv ds)
+>   qual phase tEnv vEnv (DefaultDecl p tys) =
+>     DefaultDecl p (qual phase tEnv vEnv tys)
+>   qual phase tEnv vEnv (BlockDecl d) = BlockDecl (qual phase tEnv vEnv d)
+
+> instance Qual DClass where
+>   qual phase tEnv _ (DClass p cls) = DClass p (qualIdent phase tEnv cls)
+
+> instance Qual ConstrDecl where
+>   qual phase tEnv vEnv (ConstrDecl p evs cx c tys) =
+>     ConstrDecl p evs (qual phase tEnv vEnv cx) c (qual phase tEnv vEnv tys)
+>   qual phase tEnv vEnv (ConOpDecl p evs cx ty1 op ty2) =
+>     ConOpDecl p evs (qual phase tEnv vEnv cx)
+>               (qual phase tEnv vEnv ty1) op (qual phase tEnv vEnv ty2)
+>   qual phase tEnv vEnv (RecordDecl p evs cx c fs) =
+>     RecordDecl p evs (qual phase tEnv vEnv cx) c (qual phase tEnv vEnv fs)
+
+> instance Qual FieldDecl where
+>   qual phase tEnv vEnv (FieldDecl p ls ty) =
+>     FieldDecl p ls (qual phase tEnv vEnv ty)
+
+> instance Qual NewConstrDecl where
+>   qual phase tEnv vEnv (NewConstrDecl p c ty) =
+>     NewConstrDecl p c (qual phase tEnv vEnv ty)
+>   qual phase tEnv vEnv (NewRecordDecl p c l ty) =
+>     NewRecordDecl p c l (qual phase tEnv vEnv ty)
+
+> instance Qual QualTypeExpr where
+>   qual phase tEnv vEnv (QualTypeExpr cx ty) =
+>     QualTypeExpr (qual phase tEnv vEnv cx) (qual phase tEnv vEnv ty)
+
+> instance Qual ClassAssert where
+>   qual phase tEnv vEnv (ClassAssert cls ty) =
+>     ClassAssert (qualIdent phase tEnv cls) (qual phase tEnv vEnv ty)
+
+> instance Qual TypeExpr where
+>   qual phase tEnv vEnv (ConstructorType c) =
+>     ConstructorType (qualIdent phase tEnv c)
+>   qual _ _ _ (VariableType tv) = VariableType tv
+>   qual phase tEnv vEnv (TupleType tys) = TupleType (qual phase tEnv vEnv tys)
+>   qual phase tEnv vEnv (ListType ty) = ListType (qual phase tEnv vEnv ty)
+>   qual phase tEnv vEnv (ArrowType ty1 ty2) =
+>     ArrowType (qual phase tEnv vEnv ty1) (qual phase tEnv vEnv ty2)
+>   qual phase tEnv vEnv (ApplyType ty1 ty2) =
+>     ApplyType (qual phase tEnv vEnv ty1) (qual phase tEnv vEnv ty2)
+
+> instance Qual (Decl a) where
+>   qual _ _ _ (InfixDecl p fix pr ops) = InfixDecl p fix pr ops
+>   qual phase tEnv vEnv (TypeSig p fs ty) =
+>     TypeSig p fs (qual phase tEnv vEnv ty)
+>   qual phase tEnv vEnv (FunctionDecl p a f eqs) =
+>     FunctionDecl p a f (qual phase tEnv vEnv eqs)
+>   qual phase tEnv vEnv (ForeignDecl p fi a f ty) =
+>     ForeignDecl p fi a f (qual phase tEnv vEnv ty)
+>   qual phase tEnv vEnv (PatternDecl p t rhs) =
+>     PatternDecl p (qual phase tEnv vEnv t) (qual phase tEnv vEnv rhs)
+>   qual _ _ _ (FreeDecl p vs) = FreeDecl p vs
+>   qual _ _ _ (TrustAnnot p tr fs) = TrustAnnot p tr fs
+
+> instance Qual (Equation a) where
+>   qual phase tEnv vEnv (Equation p lhs rhs) =
+>     Equation p (qual phase tEnv vEnv lhs) (qual phase tEnv vEnv rhs)
+
+> instance Qual (Lhs a) where
+>   qual phase tEnv vEnv (FunLhs f ts) = FunLhs f (qual phase tEnv vEnv ts)
+>   qual phase tEnv vEnv (OpLhs t1 op t2) =
+>     OpLhs (qual phase tEnv vEnv t1) op (qual phase tEnv vEnv t2)
+>   qual phase tEnv vEnv (ApLhs lhs ts) =
+>     ApLhs (qual phase tEnv vEnv lhs) (qual phase tEnv vEnv ts)
+
+> instance Qual (ConstrTerm a) where
+>   qual _ _ _ (LiteralPattern a l) = LiteralPattern a l
+>   qual _ _ _ (NegativePattern a l) = NegativePattern a l
+>   qual _ _ _ (VariablePattern a v) = VariablePattern a v
+>   qual phase tEnv vEnv (ConstructorPattern a c ts) =
+>     ConstructorPattern a (qualIdent phase vEnv c) (qual phase tEnv vEnv ts)
+>   qual phase tEnv vEnv (FunctionPattern a f ts) =
+>     FunctionPattern a (qualIdent phase vEnv f) (qual phase tEnv vEnv ts)
+>   qual phase tEnv vEnv (InfixPattern a t1 op t2) =
+>     InfixPattern a
+>                  (qual phase tEnv vEnv t1)
+>                  (qual phase tEnv vEnv op)
+>                  (qual phase tEnv vEnv t2)
+>   qual phase tEnv vEnv (ParenPattern t) =
+>     ParenPattern (qual phase tEnv vEnv t)
+>   qual phase tEnv vEnv (RecordPattern a c fs) =
+>     RecordPattern a (qualIdent phase vEnv c) (qual phase tEnv vEnv fs)
+>   qual phase tEnv vEnv (TuplePattern ts) =
+>     TuplePattern (qual phase tEnv vEnv ts)
+>   qual phase tEnv vEnv (ListPattern a ts) =
+>     ListPattern a (qual phase tEnv vEnv ts)
+>   qual phase tEnv vEnv (AsPattern v t) = AsPattern v (qual phase tEnv vEnv t)
+>   qual phase tEnv vEnv (LazyPattern t) = LazyPattern (qual phase tEnv vEnv t)
+
+> instance Qual (Rhs a) where
+>   qual phase tEnv vEnv (SimpleRhs p e ds) =
+>     SimpleRhs p (qual phase tEnv vEnv e) (qual phase tEnv vEnv ds)
+>   qual phase tEnv vEnv (GuardedRhs es ds) =
+>     GuardedRhs (qual phase tEnv vEnv es) (qual phase tEnv vEnv ds)
+
+> instance Qual (CondExpr a) where
+>   qual phase tEnv vEnv (CondExpr p g e) =
+>     CondExpr p (qual phase tEnv vEnv g) (qual phase tEnv vEnv e)
+
+> instance Qual (Expression a) where
+>   qual _ _ _ (Literal a l) = Literal a l
+>   qual phase _ vEnv (Variable a v) = Variable a (qualIdent phase vEnv v)
+>   qual phase _ vEnv (Constructor a c) = Constructor a (qualIdent phase vEnv c)
+>   qual phase tEnv vEnv (Paren e) = Paren (qual phase tEnv vEnv e)
+>   qual phase tEnv vEnv (Typed e ty) =
+>     Typed (qual phase tEnv vEnv e) (qual phase tEnv vEnv ty)
+>   qual phase tEnv vEnv (Record a c fs) =
+>     Record a (qualIdent phase vEnv c) (qual phase tEnv vEnv fs)
+>   qual phase tEnv vEnv (RecordUpdate e fs) =
+>     RecordUpdate (qual phase tEnv vEnv e) (qual phase tEnv vEnv fs)
+>   qual phase tEnv vEnv (Tuple es) = Tuple (qual phase tEnv vEnv es)
+>   qual phase tEnv vEnv (List a es) = List a (qual phase tEnv vEnv es)
+>   qual phase tEnv vEnv (ListCompr e qs) =
+>     ListCompr (qual phase tEnv vEnv e) (qual phase tEnv vEnv qs)
+>   qual phase tEnv vEnv (EnumFrom e) = EnumFrom (qual phase tEnv vEnv e)
+>   qual phase tEnv vEnv (EnumFromThen e1 e2) =
+>     EnumFromThen (qual phase tEnv vEnv e1) (qual phase tEnv vEnv e2)
+>   qual phase tEnv vEnv (EnumFromTo e1 e2) =
+>     EnumFromTo (qual phase tEnv vEnv e1) (qual phase tEnv vEnv e2)
+>   qual phase tEnv vEnv (EnumFromThenTo e1 e2 e3) =
+>     EnumFromThenTo (qual phase tEnv vEnv e1)
+>                    (qual phase tEnv vEnv e2)
+>                    (qual phase tEnv vEnv e3)
+>   qual phase tEnv vEnv (UnaryMinus e) = UnaryMinus (qual phase tEnv vEnv e)
+>   qual phase tEnv vEnv (Apply e1 e2) =
+>     Apply (qual phase tEnv vEnv e1) (qual phase tEnv vEnv e2)
+>   qual phase tEnv vEnv (InfixApply e1 op e2) =
+>     InfixApply (qual phase tEnv vEnv e1)
+>                (qual phase tEnv vEnv op)
+>                (qual phase tEnv vEnv e2)
+>   qual phase tEnv vEnv (LeftSection e op) =
+>     LeftSection (qual phase tEnv vEnv e) (qual phase tEnv vEnv op)
+>   qual phase tEnv vEnv (RightSection op e) =
+>     RightSection (qual phase tEnv vEnv op) (qual phase tEnv vEnv e)
+>   qual phase tEnv vEnv (Lambda p ts e) =
+>     Lambda p (qual phase tEnv vEnv ts) (qual phase tEnv vEnv e)
+>   qual phase tEnv vEnv (Let ds e) =
+>     Let (qual phase tEnv vEnv ds) (qual phase tEnv vEnv e)
+>   qual phase tEnv vEnv (Do sts e) =
+>     Do (qual phase tEnv vEnv sts) (qual phase tEnv vEnv e)
+>   qual phase tEnv vEnv (IfThenElse e1 e2 e3) =
+>     IfThenElse (qual phase tEnv vEnv e1)
+>                (qual phase tEnv vEnv e2)
+>                (qual phase tEnv vEnv e3)
+>   qual phase tEnv vEnv (Case e alts) =
+>     Case (qual phase tEnv vEnv e) (qual phase tEnv vEnv alts)
+>   qual phase tEnv vEnv (Fcase e alts) =
+>     Fcase (qual phase tEnv vEnv e) (qual phase tEnv vEnv alts)
+
+> instance Qual (Statement a) where
+>   qual phase tEnv vEnv (StmtExpr e) = StmtExpr (qual phase tEnv vEnv e)
+>   qual phase tEnv vEnv (StmtBind p t e) =
+>     StmtBind p (qual phase tEnv vEnv t) (qual phase tEnv vEnv e)
+>   qual phase tEnv vEnv (StmtDecl ds) = StmtDecl (qual phase tEnv vEnv ds)
+
+> instance Qual (Alt a) where
+>   qual phase tEnv vEnv (Alt p t rhs) =
+>     Alt p (qual phase tEnv vEnv t) (qual phase tEnv vEnv rhs)
+
+> instance Qual (InfixOp a) where
+>   qual phase _ vEnv (InfixOp a op) = InfixOp a (qualIdent phase vEnv op)
+>   qual phase _ vEnv (InfixConstr a op) =
+>     InfixConstr a (qualIdent phase vEnv op)
+
+> instance Qual a => Qual (Field a) where
+>   qual phase tEnv vEnv (Field l x) =
+>     Field (qualIdent phase vEnv l) (qual phase tEnv vEnv x)
+
+> qualIdent :: Entity a => Phase -> TopEnv a -> QualIdent -> QualIdent
+> qualIdent One env x
+>   | isQualified x =
+>       case qualLookupTopEnv x env of
+>         [y] ->
+>           case lookupTopEnv x' env of
+>             [z] | origName y == origName z -> qualify x'
+>             _ -> origName y
+>           where x' = unqualify x
+>         _ -> internalError ("qualIdent: " ++ show x)
+>   | otherwise = x
+> qualIdent Two env x
+>   | isQualified x || isRenamed (unqualify x) = x
+>   | otherwise =
+>       case qualLookupTopEnv x env of
+>         [y] -> origName y
+>         _ -> internalError ("qualIdent: " ++ show x)
 
 \end{verbatim}
Solo in curry-0.9.11: README
Solo in curry-0.9.11-classful/: Records.lhs
diff -u curry-0.9.11/Renaming.lhs curry-0.9.11-classful/Renaming.lhs
--- curry-0.9.11/Renaming.lhs	2007-06-15 14:16:34.000000000 +0200
+++ curry-0.9.11-classful/Renaming.lhs	2011-10-08 12:42:57.000000000 +0200
@@ -1,7 +1,7 @@
 % -*- LaTeX -*-
-% $Id: Renaming.lhs 2101 2007-02-21 16:25:07Z wlux $
+% $Id: Renaming.lhs 3056 2011-10-07 16:27:03Z wlux $
 %
-% Copyright (c) 1999-2007, Wolfgang Lux
+% Copyright (c) 1999-2011, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{Renaming.lhs}
@@ -22,9 +22,10 @@
 after type checking was performed.
 \begin{verbatim}
 
-> module Renaming(rename,renameGoal) where
+> module Renaming(Key,k0,rename,renameGoal) where
 > import Base
 > import Combined
+> import Curry
 > import Env
 > import Maybe
 > import Monad
@@ -46,13 +47,24 @@
 
 \end{verbatim}
 In order to thread the counter used for generating unique keys, we use
-a simple state monad.
+a simple state monad. Since renaming is applied independently to
+source code declarations and derived instance declarations, the
+counter's value must be returned from the state monad when renaming is
+finished and used as new initial state upon the next invocation of the
+renaming state monad. The global variable \texttt{k0} provides the
+initial counter value for the first invocation of the renaming state
+monad. We use the private \texttt{Key} type in order to hide the
+counter's representation from client modules.
 \begin{verbatim}
 
+> newtype Key = Key Int
 > type RenameState a = StateT Int Id a
 
-> run :: RenameState a -> a
-> run m = runSt m (globalKey + 1)
+> run :: RenameState a -> Key -> (Key,a)
+> run m (Key k) = runSt (m >>= \x -> fetchSt >>= \k' -> return (Key k',x)) k
+
+> k0 :: Key
+> k0 = Key (globalKey + 1)
 
 > globalKey :: Int
 > globalKey = uniqueId (mkIdent "")
@@ -94,110 +106,202 @@
 syntax tree and renames all type and expression variables.
 \begin{verbatim}
 
-> rename :: [TopDecl] -> [TopDecl]
-> rename ds = run (mapM renameTopDecl ds)
+> rename :: Key -> [TopDecl a] -> (Key,[TopDecl a])
+> rename k ds = run (mapM renameTopDecl ds) k
 
-> renameGoal :: Goal -> Goal
-> renameGoal (Goal p e ds) = run $
+> renameGoal :: Key -> Goal a -> (Key,Goal a)
+> renameGoal k (Goal p e ds) = flip run k $
 >   do
 >     env' <- bindVars emptyEnv (bv ds)
 >     ds' <- mapM (renameDecl env') ds
 >     e' <- renameExpr env' e
 >     return (Goal p e' ds')
 
-> renameTopDecl :: TopDecl -> RenameState TopDecl
-> renameTopDecl (DataDecl p tc tvs cs) =
+> renameTopDecl :: TopDecl a -> RenameState (TopDecl a)
+> renameTopDecl (DataDecl p cx tc tvs cs clss) =
 >   do
 >     env <- bindVars emptyEnv tvs
->     liftM2 (DataDecl p tc)
->            (mapM (renameVar env) tvs)
->            (mapM (renameConstrDecl env) cs)
-> renameTopDecl (NewtypeDecl p tc tvs nc) =
+>     cx' <- mapM (renameClassAssert env) cx
+>     tvs' <- mapM (renameVar env) tvs
+>     cs' <- mapM (renameConstrDecl env) cs
+>     return (DataDecl p cx' tc tvs' cs' clss)
+> renameTopDecl (NewtypeDecl p cx tc tvs nc clss) =
 >   do
 >     env <- bindVars emptyEnv tvs
->     liftM2 (NewtypeDecl p tc)
->            (mapM (renameVar env) tvs)
->            (renameNewConstrDecl env nc)
+>     cx' <- mapM (renameClassAssert env) cx
+>     tvs' <- mapM (renameVar env) tvs
+>     nc' <- renameNewConstrDecl env nc
+>     return (NewtypeDecl p cx' tc tvs' nc' clss)
 > renameTopDecl (TypeDecl p tc tvs ty) =
 >   do
 >     env <- bindVars emptyEnv tvs
 >     liftM2 (TypeDecl p tc) (mapM (renameVar env) tvs) (renameType env ty)
+> renameTopDecl (ClassDecl p cx cls tv ds) =
+>   do
+>     env <- bindVars emptyEnv [tv]
+>     env' <- bindVars emptyEnv [f | FunctionDecl _ _ f _ <- ds]
+>     liftM3 (flip (ClassDecl p) cls)
+>            (mapM (renameClassAssert env) cx)
+>            (renameVar env tv)
+>            (mapM (renameMethodDecl env env') ds)
+> renameTopDecl (InstanceDecl p cx cls ty ds) =
+>   do
+>     env <- bindVars emptyEnv (fv ty)
+>     env' <- bindVars emptyEnv [f | FunctionDecl _ _ f _ <- ds]
+>     liftM3 (flip (InstanceDecl p) cls)
+>            (mapM (renameClassAssert env) cx)
+>            (renameType env ty)
+>            (mapM (renameMethodDecl emptyEnv env') ds)
+> renameTopDecl (DefaultDecl p tys) =
+>   do
+>     tys' <- mapM (renameTypeSig emptyEnv . QualTypeExpr []) tys
+>     return (DefaultDecl p [ty | QualTypeExpr _ ty <- tys'])
 > renameTopDecl (BlockDecl d) = liftM BlockDecl (renameDecl emptyEnv d)
 
 > renameConstrDecl :: RenameEnv -> ConstrDecl -> RenameState ConstrDecl
-> renameConstrDecl env (ConstrDecl p evs c tys) =
+> renameConstrDecl env (ConstrDecl p evs cx c tys) =
 >   do
 >     env' <- bindVars env evs
 >     evs' <- mapM (renameVar env') evs
+>     cx' <- mapM (renameClassAssert env') cx
 >     tys' <- mapM (renameType env') tys
->     return (ConstrDecl p evs' c tys')
-> renameConstrDecl env (ConOpDecl p evs ty1 op ty2) =
+>     return (ConstrDecl p evs' cx' c tys')
+> renameConstrDecl env (ConOpDecl p evs cx ty1 op ty2) =
 >   do
 >     env' <- bindVars env evs
 >     evs' <- mapM (renameVar env') evs
+>     cx' <- mapM (renameClassAssert env') cx
 >     ty1' <- renameType env' ty1
 >     ty2' <- renameType env' ty2
->     return (ConOpDecl p evs' ty1' op ty2')
+>     return (ConOpDecl p evs' cx' ty1' op ty2')
+> renameConstrDecl env (RecordDecl p evs cx c fs) =
+>   do
+>     env' <- bindVars env evs
+>     evs' <- mapM (renameVar env') evs
+>     cx' <- mapM (renameClassAssert env') cx
+>     fs' <- mapM (renameFieldDecl env') fs
+>     return (RecordDecl p evs' cx' c fs')
+
+> renameFieldDecl :: RenameEnv -> FieldDecl -> RenameState FieldDecl
+> renameFieldDecl env (FieldDecl p ls ty) =
+>   liftM (FieldDecl p ls) (renameType env ty)
 
 > renameNewConstrDecl :: RenameEnv -> NewConstrDecl -> RenameState NewConstrDecl
 > renameNewConstrDecl env (NewConstrDecl p c ty) =
 >   liftM (NewConstrDecl p c) (renameType env ty)
+> renameNewConstrDecl env (NewRecordDecl p c l ty) =
+>   liftM (NewRecordDecl p c l) (renameType env ty)
 
-> renameTypeSig :: TypeExpr -> RenameState TypeExpr
-> renameTypeSig ty =
->   do
->     env' <- bindVars emptyEnv (fv ty)
->     renameType env' ty
+\end{verbatim}
+When renaming class and instance declarations, the compiler renames
+method identifiers in the left hand side of method implementations,
+but does not change method identifiers that occur in the right hand
+sides (nor in type signatures and fixity declarations). This nicely
+reflects the fact that the method identifier in the left hand side
+denotes a particular method implementation, whereas any occurrence of
+a method identifier in the right hand side denotes the overloaded type
+class method.
+\begin{verbatim}
+
+> renameMethodDecl :: RenameEnv -> RenameEnv -> Decl a -> RenameState (Decl a)
+> renameMethodDecl _ _ (InfixDecl p fix pr ops) =
+>   return (InfixDecl p fix pr ops)
+> renameMethodDecl env _ (TypeSig p fs ty) =
+>   liftM (TypeSig p fs) (renameTypeSig env ty)
+> renameMethodDecl _ env' (FunctionDecl p a f eqs) =
+>   do
+>     f' <- renameVar env' f
+>     liftM (FunctionDecl p a f') (mapM (renameEqn f' emptyEnv) eqs)
+> renameMethodDecl _ env' (TrustAnnot p tr fs) =
+>   liftM (TrustAnnot p tr) (mapM (renameVar env') fs)
+
+> renameTypeSig :: RenameEnv -> QualTypeExpr -> RenameState QualTypeExpr
+> renameTypeSig env ty =
+>   do
+>     env' <- bindVars env (filter (`notElem` tvs) (fv ty))
+>     renameQualType env' ty
+>   where tvs = map fst (envToList env)
+
+> renameQualType :: RenameEnv -> QualTypeExpr -> RenameState QualTypeExpr
+> renameQualType env (QualTypeExpr cx ty) =
+>   liftM2 QualTypeExpr (mapM (renameClassAssert env) cx) (renameType env ty)
+
+> renameClassAssert :: RenameEnv -> ClassAssert -> RenameState ClassAssert
+> renameClassAssert env (ClassAssert cls ty) =
+>   liftM (ClassAssert cls) (renameType env ty)
 
 > renameType :: RenameEnv -> TypeExpr -> RenameState TypeExpr
-> renameType env (ConstructorType tc tys) =
->   liftM (ConstructorType tc) (mapM (renameType env) tys)
+> renameType _ (ConstructorType tc) = return (ConstructorType tc)
 > renameType env (VariableType tv) = liftM VariableType (renameVar env tv)
 > renameType env (TupleType tys) = liftM TupleType (mapM (renameType env) tys)
 > renameType env (ListType ty) = liftM ListType (renameType env ty)
 > renameType env (ArrowType ty1 ty2) =
 >   liftM2 ArrowType (renameType env ty1) (renameType env ty2)
+> renameType env (ApplyType ty1 ty2) =
+>   liftM2 ApplyType (renameType env ty1) (renameType env ty2)
 
-> renameDecl :: RenameEnv -> Decl -> RenameState Decl
+> renameDecl :: RenameEnv -> Decl a -> RenameState (Decl a)
 > renameDecl env (InfixDecl p fix pr ops) =
 >   liftM (InfixDecl p fix pr) (mapM (renameVar env) ops)
 > renameDecl env (TypeSig p fs ty) =
->   liftM2 (TypeSig p) (mapM (renameVar env) fs) (renameTypeSig ty)
-> renameDecl env (FunctionDecl p f eqs) =
+>   liftM2 (TypeSig p) (mapM (renameVar env) fs) (renameTypeSig emptyEnv ty)
+> renameDecl env (FunctionDecl p a f eqs) =
 >   do
 >     f' <- renameVar env f
->     liftM (FunctionDecl p f') (mapM (renameEqn f' env) eqs)
-> renameDecl env (ForeignDecl p cc s ie f ty) =
->   liftM2 (ForeignDecl p cc s ie) (renameVar env f) (renameTypeSig ty)
+>     liftM (FunctionDecl p a f') (mapM (renameEqn f' env) eqs)
+> renameDecl env (ForeignDecl p fi a f ty) =
+>   do
+>     f' <- renameVar env f
+>     QualTypeExpr _ ty' <- renameTypeSig emptyEnv (QualTypeExpr [] ty)
+>     return (ForeignDecl p fi a f' ty')
 > renameDecl env (PatternDecl p t rhs) =
->   liftM2 (PatternDecl p) (renameConstrTerm env t) (renameRhs env rhs)
+>   liftM2 (PatternDecl p) (renameConstrTerm env env t) (renameRhs env rhs)
 > renameDecl env (FreeDecl p vs) =
->   liftM (FreeDecl p) (mapM (renameVar env) vs)
+>   liftM (FreeDecl p) (mapM (renameFreeVar env) vs)
 > renameDecl env (TrustAnnot p t fs) =
->   liftM (TrustAnnot p t)
->         (maybe (return Nothing) (liftM Just . mapM (renameVar env)) fs)
+>   liftM (TrustAnnot p t) (mapM (renameVar env) fs)
+
+> renameFreeVar :: RenameEnv -> FreeVar a -> RenameState (FreeVar a)
+> renameFreeVar env (FreeVar a v) = liftM (FreeVar a) (renameVar env v)
 
 \end{verbatim}
 Note that the root of the left hand side term of an equation must be
 equal to the name of the function declaration. This means that we must
 not rename this identifier in the same environment as its arguments.
+Similarly, we must be careful with function patterns. For instance,
+given the (contrived) definition \texttt{f (id id x) = x}, the
+argument is considered a function pattern with the first occurrence of
+\texttt{id} referring to the global definition of \texttt{Prelude.id}.
+The second occurrence of \texttt{id} in the function pattern
+introduces a local variable that shadows the global function.
+Nevertheless, the first occurrence of \texttt{id} must not be renamed.
+For that reason, \texttt{renameLhs} and \texttt{renameConstrTerm} are
+applied to two renaming environments. The first is the global
+environment in which the function is defined and the second is the
+local environment, which includes the function's arguments. Obviously,
+the same environment is used for both arguments in case of pattern
+declarations.
 \begin{verbatim}
 
-> renameEqn :: Ident -> RenameEnv -> Equation -> RenameState Equation
+> renameEqn :: Ident -> RenameEnv -> Equation a -> RenameState (Equation a)
 > renameEqn f env (Equation p lhs rhs) =
 >   do
 >     env' <- bindVars env (bv lhs)
->     liftM2 (Equation p) (renameLhs f env' lhs) (renameRhs env' rhs)
+>     liftM2 (Equation p) (renameLhs f env env' lhs) (renameRhs env' rhs)
 
-> renameLhs :: Ident -> RenameEnv -> Lhs -> RenameState Lhs
-> renameLhs f env (FunLhs _ ts) =
->   liftM (FunLhs f) (mapM (renameConstrTerm env) ts)
-> renameLhs f env (OpLhs t1 _ t2) =
->   liftM2 (flip OpLhs f) (renameConstrTerm env t1) (renameConstrTerm env t2)
-> renameLhs f env (ApLhs lhs ts) =
->   liftM2 ApLhs (renameLhs f env lhs) (mapM (renameConstrTerm env) ts)
+> renameLhs :: Ident -> RenameEnv -> RenameEnv -> Lhs a -> RenameState (Lhs a)
+> renameLhs f env env' (FunLhs _ ts) =
+>   liftM (FunLhs f) (mapM (renameConstrTerm env env') ts)
+> renameLhs f env env' (OpLhs t1 _ t2) =
+>   liftM2 (flip OpLhs f)
+>          (renameConstrTerm env env' t1)
+>          (renameConstrTerm env env' t2)
+> renameLhs f env env' (ApLhs lhs ts) =
+>   liftM2 ApLhs
+>          (renameLhs f env env' lhs)
+>          (mapM (renameConstrTerm env env') ts)
 
-> renameRhs :: RenameEnv -> Rhs -> RenameState Rhs
+> renameRhs :: RenameEnv -> Rhs a -> RenameState (Rhs a)
 > renameRhs env (SimpleRhs p e ds) =
 >   do
 >     env' <- bindVars env (bv ds)
@@ -211,49 +315,56 @@
 >     es' <- mapM (renameCondExpr env') es
 >     return (GuardedRhs es' ds')
 
-> renameLiteral :: RenameEnv -> Literal -> RenameState Literal
-> renameLiteral _ (Char c) = return (Char c)
-> renameLiteral env (Int x i) = liftM (flip Int i) (renameVar env x)
-> renameLiteral _ (Float f) = return (Float f)
-> renameLiteral _ (String s) = return (String s)
-
-> renameConstrTerm :: RenameEnv -> ConstrTerm -> RenameState ConstrTerm
-> renameConstrTerm env (LiteralPattern l) =
->   liftM LiteralPattern (renameLiteral env l)
-> renameConstrTerm env (NegativePattern op l) =
->   liftM (NegativePattern op) (renameLiteral env l)
-> renameConstrTerm env (VariablePattern x) =
->   liftM VariablePattern (renameVar env x)
-> renameConstrTerm env (ConstructorPattern c ts) =
->   liftM (ConstructorPattern c) (mapM (renameConstrTerm env) ts)
-> renameConstrTerm env (InfixPattern t1 op t2) =
->   liftM2 (flip InfixPattern op)
->          (renameConstrTerm env t1)
->          (renameConstrTerm env t2)
-> renameConstrTerm env (ParenPattern t) =
->   liftM ParenPattern (renameConstrTerm env t)
-> renameConstrTerm env (TuplePattern ts) =
->   liftM TuplePattern (mapM (renameConstrTerm env) ts)
-> renameConstrTerm env (ListPattern ts) =
->   liftM ListPattern (mapM (renameConstrTerm env) ts)
-> renameConstrTerm env (AsPattern x t) =
->   liftM2 AsPattern (renameVar env x) (renameConstrTerm env t)
-> renameConstrTerm env (LazyPattern t) =
->   liftM LazyPattern (renameConstrTerm env t)
+> renameConstrTerm :: RenameEnv -> RenameEnv -> ConstrTerm a
+>                  -> RenameState (ConstrTerm a)
+> renameConstrTerm _ _ (LiteralPattern a l) = return (LiteralPattern a l)
+> renameConstrTerm _ _ (NegativePattern a l) = return (NegativePattern a l)
+> renameConstrTerm _ env' (VariablePattern a x) =
+>   liftM (VariablePattern a) (renameVar env' x)
+> renameConstrTerm env env' (ConstructorPattern a c ts) =
+>   liftM (ConstructorPattern a c) (mapM (renameConstrTerm env env') ts)
+> renameConstrTerm env env' (FunctionPattern a f ts) =
+>   liftM2 (FunctionPattern a)
+>          (renameQual env f)
+>          (mapM (renameConstrTerm env env') ts)
+> renameConstrTerm env env' (InfixPattern a t1 op t2) =
+>   liftM3 (InfixPattern a)
+>          (renameConstrTerm env env' t1)
+>          (renameOp env op)
+>          (renameConstrTerm env env' t2)
+> renameConstrTerm env env' (ParenPattern t) =
+>   liftM ParenPattern (renameConstrTerm env env' t)
+> renameConstrTerm env env' (RecordPattern a c fs) =
+>   liftM (RecordPattern a c)
+>         (mapM (renameField (renameConstrTerm env env')) fs)
+> renameConstrTerm env env' (TuplePattern ts) =
+>   liftM TuplePattern (mapM (renameConstrTerm env env') ts)
+> renameConstrTerm env env' (ListPattern a ts) =
+>   liftM (ListPattern a) (mapM (renameConstrTerm env env') ts)
+> renameConstrTerm env env' (AsPattern x t) =
+>   liftM2 AsPattern (renameVar env' x) (renameConstrTerm env env' t)
+> renameConstrTerm env env' (LazyPattern t) =
+>   liftM LazyPattern (renameConstrTerm env env' t)
 
-> renameCondExpr :: RenameEnv -> CondExpr -> RenameState CondExpr
+> renameCondExpr :: RenameEnv -> CondExpr a -> RenameState (CondExpr a)
 > renameCondExpr env (CondExpr p g e) =
 >   liftM2 (CondExpr p) (renameExpr env g) (renameExpr env e)
 
-> renameExpr :: RenameEnv -> Expression -> RenameState Expression
-> renameExpr env (Literal l) = liftM Literal (renameLiteral env l)
-> renameExpr env (Variable x) = liftM Variable (renameQual env x)
-> renameExpr _ (Constructor c) = return (Constructor c)
+> renameExpr :: RenameEnv -> Expression a -> RenameState (Expression a)
+> renameExpr _ (Literal a l) = return (Literal a l)
+> renameExpr env (Variable a x) = liftM (Variable a) (renameQual env x)
+> renameExpr _ (Constructor a c) = return (Constructor a c)
 > renameExpr env (Paren e) = liftM Paren (renameExpr env e)
 > renameExpr env (Typed e ty) =
->   liftM2 Typed (renameExpr env e) (renameTypeSig ty)
+>   liftM2 Typed (renameExpr env e) (renameTypeSig emptyEnv ty)
+> renameExpr env (Record a c fs) =
+>   liftM (Record a c) (mapM (renameField (renameExpr env)) fs)
+> renameExpr env (RecordUpdate e fs) =
+>   liftM2 RecordUpdate
+>          (renameExpr env e)
+>          (mapM (renameField (renameExpr env)) fs)
 > renameExpr env (Tuple es) = liftM Tuple (mapM (renameExpr env) es)
-> renameExpr env (List es) = liftM List (mapM (renameExpr env) es)
+> renameExpr env (List a es) = liftM (List a) (mapM (renameExpr env) es)
 > renameExpr env (ListCompr e qs) =
 >   do
 >     (env',qs') <- mapAccumM renameStmt env qs
@@ -269,7 +380,7 @@
 >          (renameExpr env e1)
 >          (renameExpr env e2)
 >          (renameExpr env e3)
-> renameExpr env (UnaryMinus op e) = liftM (UnaryMinus op) (renameExpr env e)
+> renameExpr env (UnaryMinus e) = liftM UnaryMinus (renameExpr env e)
 > renameExpr env (Apply e1 e2) =
 >   liftM2 Apply (renameExpr env e1) (renameExpr env e2)
 > renameExpr env (InfixApply e1 op e2) =
@@ -278,10 +389,12 @@
 >   liftM2 LeftSection (renameExpr env e) (renameOp env op)
 > renameExpr env (RightSection op e) =
 >   liftM2 RightSection (renameOp env op) (renameExpr env e)
-> renameExpr env (Lambda ts e) =
+> renameExpr env (Lambda p ts e) =
 >   do
 >     env' <- bindVars env (bv ts)
->     liftM2 Lambda (mapM (renameConstrTerm env') ts) (renameExpr env' e)
+>     liftM2 (Lambda p)
+>            (mapM (renameConstrTerm env env') ts)
+>            (renameExpr env' e)
 > renameExpr env (Let ds e) =
 >   do
 >     env' <- bindVars env (bv ds)
@@ -298,32 +411,37 @@
 >          (renameExpr env e3)
 > renameExpr env (Case e as) =
 >   liftM2 Case (renameExpr env e) (mapM (renameAlt env) as)
+> renameExpr env (Fcase e as) =
+>   liftM2 Fcase (renameExpr env e) (mapM (renameAlt env) as)
 
-> renameOp :: RenameEnv -> InfixOp -> RenameState InfixOp
-> renameOp env (InfixOp op) = liftM InfixOp (renameQual env op)
-> renameOp _ (InfixConstr op) = return (InfixConstr op)
+> renameOp :: RenameEnv -> InfixOp a -> RenameState (InfixOp a)
+> renameOp env (InfixOp a op) = liftM (InfixOp a) (renameQual env op)
+> renameOp _ (InfixConstr a op) = return (InfixConstr a op)
 
-> renameStmt :: RenameEnv -> Statement -> RenameState (RenameEnv,Statement)
+> renameStmt :: RenameEnv -> Statement a -> RenameState (RenameEnv,Statement a)
 > renameStmt env (StmtExpr e) =
 >   do
 >     e' <- renameExpr env e
 >     return (env,StmtExpr e')
+> renameStmt env (StmtBind p t e) =
+>   do
+>     e' <- renameExpr env e
+>     env' <- bindVars env (bv t)
+>     t' <- renameConstrTerm env env' t
+>     return (env',StmtBind p t' e')
 > renameStmt env (StmtDecl ds) =
 >   do
 >     env' <- bindVars env (bv ds)
 >     ds' <- mapM (renameDecl env') ds
 >     return (env',StmtDecl ds')
-> renameStmt env (StmtBind t e) =
->   do
->     e' <- renameExpr env e
->     env' <- bindVars env (bv t)
->     t' <- renameConstrTerm env' t
->     return (env',StmtBind t' e')
 
-> renameAlt :: RenameEnv -> Alt -> RenameState Alt
+> renameAlt :: RenameEnv -> Alt a -> RenameState (Alt a)
 > renameAlt env (Alt p t rhs) =
 >   do
 >     env' <- bindVars env (bv t)
->     liftM2 (Alt p) (renameConstrTerm env' t) (renameRhs env' rhs)
+>     liftM2 (Alt p) (renameConstrTerm env env' t) (renameRhs env' rhs)
+
+> renameField :: (a -> RenameState a) -> Field a -> RenameState (Field a)
+> renameField rename (Field l x) = liftM (Field l) (rename x)
 
 \end{verbatim}
Sottodirectory in comune: curry-0.9.11/runtime e curry-0.9.11-classful/runtime
Solo in curry-0.9.11-classful/: runtime.htm
diff -u curry-0.9.11/Set.lhs curry-0.9.11-classful/Set.lhs
--- curry-0.9.11/Set.lhs	2007-06-15 14:16:36.000000000 +0200
+++ curry-0.9.11-classful/Set.lhs	2007-08-27 08:51:43.000000000 +0200
@@ -1,7 +1,7 @@
 % -*- LaTeX -*-
-% $Id: Set.lhs 1744 2005-08-23 16:17:12Z wlux $
+% $Id: Set.lhs 2454 2007-08-23 23:06:53Z wlux $
 %
-% Copyright (c) 2002, Wolfgang Lux
+% Copyright (c) 2002-2007, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{Set.lhs}
@@ -10,7 +10,10 @@
 maps.
 \begin{verbatim}
 
-> module Set where
+> module Set(Set, nullSet, zeroSet, unitSet, addToSet, deleteFromSet,
+>            elemSet, notElemSet, subsetSet, fromListSet, toListSet,
+>            unionSet, unionSets, intersectionSet, diffSet, symDiffSet,
+>            mapSet, domainFM) where
 > import List
 > import Map
 > import Maybe
diff -u curry-0.9.11/ShadowCheck.lhs curry-0.9.11-classful/ShadowCheck.lhs
--- curry-0.9.11/ShadowCheck.lhs	2007-06-15 14:16:34.000000000 +0200
+++ curry-0.9.11-classful/ShadowCheck.lhs	2011-10-08 12:42:57.000000000 +0200
@@ -1,7 +1,7 @@
 % -*- LaTeX -*-
-% $Id: ShadowCheck.lhs 2101 2007-02-21 16:25:07Z wlux $
+% $Id: ShadowCheck.lhs 3056 2011-10-07 16:27:03Z wlux $
 %
-% Copyright (c) 2005-2007, Wolfgang Lux
+% Copyright (c) 2005-2011, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{ShadowCheck.lhs}
@@ -9,33 +9,50 @@
 Besides unused variables, the compiler can also report local
 definitions which shadow a declaration from an outer scope.
 
-\ToDo{Take imported definitions into account.}
+\ToDo{Report warnings for local type definitions that shadow imported
+  type declarations and for type variables in type declarations that
+  shadow type constructors.}
 \begin{verbatim}
 
 > module ShadowCheck(shadowCheck, shadowCheckGoal) where
 > import Base
+> import Curry
+> import Interfaces
+> import List
+> import Map
+> import Maybe
 > import Options
-> import Set
+> import Position
 
 > infixl 1 &&&, >>>
 
-> shadowCheck :: [Warn] -> Module -> [String]
-> shadowCheck v (Module m _ _ ds) =
->   report v $ shadow noPosition [d | BlockDecl d <- ds] (const []) zeroSet
+> shadowCheck :: [Warn] -> ModuleEnv -> Module a -> [String]
+> shadowCheck v mEnv (Module m _ is ds) =
+>   report v $ shadow noPosition ds (const []) (imports mEnv is)
 >   where noPosition = error "noPosition"
 
-> shadowCheckGoal :: [Warn] -> Goal -> [String]
-> shadowCheckGoal v (Goal p e ds) =
->   report v $ shadow p (SimpleRhs p e ds) (const []) zeroSet
+> shadowCheckGoal :: [Warn] -> ModuleEnv -> [ImportDecl] -> Goal a -> [String]
+> shadowCheckGoal v mEnv is (Goal p e ds) =
+>   report v $ shadow p (SimpleRhs p e ds) (const []) (imports mEnv is)
 
-> report :: [Warn] -> [P Ident] -> [String]
+> report :: [Warn] -> [P (Ident,D)] -> [String]
 > report ws
 >   | WarnShadow `elem` ws = map format
 >   | otherwise = const []
 
-> format :: P Ident -> String
-> format (P p x) =
->   atP p ("Warning: " ++ name x ++ " shadows non-local definition")
+> format :: P (Ident,D) -> String
+> format (P p (x,d)) = atP p ("Warning: " ++ name x ++ " shadows " ++ formatD d)
+
+> formatD :: D -> String
+> formatD (I ms) =
+>   case nub ms of
+>     [m] -> "import from module " ++ show m
+>     [m1,m2] -> "imports from modules " ++ show m1 ++ " and " ++ show m2
+>     ms' ->
+>       "imports from modules " ++
+>       concat (intersperse ", " (map show (init ms'))) ++ ", and " ++
+>       show (last ms')
+> formatD (L p') = "definition at " ++ show (p'{ file = "" })
 
 \end{verbatim}
 Since shadowing can be checked efficiently only with unrenamed
@@ -50,13 +67,13 @@
 set of defined variables.
 \begin{verbatim}
 
-> type S = Set Ident -> [P Ident]
+> data D = I [ModuleIdent] | L Position
+> type S = FM Ident D -> [P (Ident,D)]
 
-> bindVars :: [P Ident] -> S -> S
-> bindVars bvs k vs =
->   filter (\(P _ x) -> x `elemSet` vs) bvs' ++
->   k (foldr addToSet vs [x | P _ x <- bvs'])
->   where bvs' = map (fmap unRenameIdent) bvs
+> bindEnts :: [P Ident] -> S -> S
+> bindEnts bvs k vs =
+>   catMaybes [fmap (\d -> P p (x,d)) (lookupFM x vs) | P p x <- bvs] ++
+>   k (foldr (uncurry addToFM) vs [(x,L p) | P p x <- bvs])
 
 > (>>>), (&&&) :: (S -> S) -> (S -> S) -> S -> S
 > f1 >>> f2 = \f gvs -> f1 (f2 f) gvs
@@ -64,7 +81,10 @@
 
 \end{verbatim}
 Collecting shadowing identifiers is implemented by just another
-traversal of the syntax tree.
+traversal of the syntax tree. Note that method implementations in type
+class and instance declarations do not define a new name and therefore
+shadowing warnings are to be reported only for the right hand sides of
+those method definitions.
 \begin{verbatim}
 
 > class SyntaxTree a where
@@ -75,83 +95,165 @@
 > instance SyntaxTree a => SyntaxTree [a] where
 >   shadow p = shadowGroup p
 
-> instance SyntaxTree Decl where
->   shadow _ (FunctionDecl p _ eqs) = shadow p eqs
+> instance SyntaxTree (TopDecl a) where
+>   shadow _ (DataDecl _ _ _ _ _ _) = id
+>   shadow _ (NewtypeDecl _ _ _ _ _ _) = id
+>   shadow _ (TypeDecl _ _ _ _) = id
+>   shadow _ (ClassDecl p _ _ _ ds) =
+>     foldr (&&&) id [shadow p eqs | FunctionDecl p _ _ eqs <- ds]
+>   shadow _ (InstanceDecl p _ _ _ ds) =
+>     foldr (&&&) id [shadow p eqs | FunctionDecl p _ _ eqs <- ds]
+>   shadow _ (DefaultDecl _ _) = id
+>   shadow p (BlockDecl d) = shadow p d
+
+>   shadowGroup p ds =
+>     bindEnts (concatMap topEnts ds) >>> foldr ((&&&) . shadow p) id ds
+
+> instance SyntaxTree (Decl a) where
+>   shadow _ (InfixDecl _ _ _ _) = id
+>   shadow _ (TypeSig _ _ _) = id
+>   shadow _ (FunctionDecl p _ _ eqs) = shadow p eqs
+>   shadow _ (ForeignDecl _ _ _ _ _) = id
 >   shadow _ (PatternDecl p _ rhs) = shadow p rhs
->   shadow _ _ = id
+>   shadow _ (FreeDecl _ _) = id
+>   shadow _ (TrustAnnot _ _ _) = id
 >
 >   shadowGroup p ds =
->     bindVars (concatMap vars ds) >>> foldr ((&&&) . shadow p) id ds
+>     bindEnts (concatMap vars ds) >>> foldr ((&&&) . shadow p) id ds
 
-> instance SyntaxTree Equation where
+> instance SyntaxTree (Equation a) where
 >   shadow _ (Equation p lhs rhs) = shadow p lhs >>> shadow p rhs
 
-> instance SyntaxTree Lhs where
->   shadow p lhs = bindVars (map (P p) (filter (not . isAnonId) (bv lhs)))
+> instance SyntaxTree (Lhs a) where
+>   shadow p lhs = bindEnts (map (P p) (bv lhs))
 
-> instance SyntaxTree ConstrTerm where
->   shadow p t = bindVars (map (P p) (filter (not . isAnonId) (bv t)))
+> instance SyntaxTree (ConstrTerm a) where
+>   shadow p t = bindEnts (map (P p) (bv t))
 
-> instance SyntaxTree Rhs where
+> instance SyntaxTree (Rhs a) where
 >   shadow _ (SimpleRhs p e ds) = shadow p ds >>> shadow p e
 >   shadow p (GuardedRhs es ds) = shadow p ds >>> shadow p es
 
-> instance SyntaxTree CondExpr where
+> instance SyntaxTree (CondExpr a) where
 >   shadow _ (CondExpr p g e) = shadow p g &&& shadow p e
 
-> instance SyntaxTree Expression where
->   shadow _ (Literal _) = id
->   shadow _ (Variable _) = id
->   shadow _ (Constructor _) = id
+> instance SyntaxTree (Expression a) where
+>   shadow _ (Literal _ _) = id
+>   shadow _ (Variable _ _) = id
+>   shadow _ (Constructor _ _) = id
 >   shadow p (Paren e) = shadow p e
 >   shadow p (Typed e _) = shadow p e
+>   shadow p (Record _ _ fs) = shadow p fs
+>   shadow p (RecordUpdate e fs) = shadow p e . shadow p fs
 >   shadow p (Tuple es) = shadow p es
->   shadow p (List es) = shadow p es
+>   shadow p (List _ es) = shadow p es
 >   shadow p (ListCompr e qs) = shadow p qs >>> shadow p e
 >   shadow p (EnumFrom e) = shadow p e
 >   shadow p (EnumFromThen e1 e2) = shadow p e1 &&& shadow p e2
 >   shadow p (EnumFromTo e1 e2) = shadow p e1 &&& shadow p e2
 >   shadow p (EnumFromThenTo e1 e2 e3) =
 >     shadow p e1 &&& shadow p e2 &&& shadow p e3
->   shadow p (UnaryMinus _ e) = shadow p e
+>   shadow p (UnaryMinus e) = shadow p e
 >   shadow p (Apply e1 e2) = shadow p e1 &&& shadow p e2
 >   shadow p (InfixApply e1 _ e2) = shadow p e1 &&& shadow p e2
 >   shadow p (LeftSection e _) = shadow p e
 >   shadow p (RightSection _ e) = shadow p e
->   shadow p (Lambda ts e) = shadow p ts >>> shadow p e
+>   shadow _ (Lambda p ts e) = shadow p ts >>> shadow p e
 >   shadow p (Let ds e) = shadow p ds >>> shadow p e
 >   shadow p (Do sts e) = shadow p sts >>> shadow p e
 >   shadow p (IfThenElse e1 e2 e3) =
 >     shadow p e1 &&& shadow p e2 &&& shadow p e3
 >   shadow p (Case e as) = shadow p e &&& shadow p as
+>   shadow p (Fcase e as) = shadow p e &&& shadow p as
 
-> instance SyntaxTree Statement where
+> instance SyntaxTree (Statement a) where
 >   shadow p (StmtExpr e) = shadow p e
->   shadow p (StmtBind t e) = shadow p e &&& shadow p t
+>   shadow _ (StmtBind p t e) = shadow p e &&& shadow p t
 >   shadow p (StmtDecl ds) = shadow p ds
 
 >   shadowGroup p = foldr ((>>>) . shadow p) id
 
-> instance SyntaxTree Alt where
+> instance SyntaxTree (Alt a) where
 >   shadow _ (Alt p t rhs) = shadow p t >>> shadow p rhs
 
+> instance SyntaxTree a => SyntaxTree (Field a) where
+>   shadow p (Field _ x) = shadow p x
+
 \end{verbatim}
-The function \texttt{vars} returns the bound variables of a list of
-declarations together with their positions.
+The functions \texttt{topEnts} and \texttt{vars} return the names of
+the entities defined by a (top-level) declaration together with their
+positions.
 \begin{verbatim}
 
-> vars :: Decl -> [P Ident]
-> vars (FunctionDecl p f _) = [P p f]
-> vars (PatternDecl p t _) = map (P p) (filter (not . isAnonId) (bv t))
-> vars (ForeignDecl p _ _ _ f _) = [P p f]
-> vars (FreeDecl p vs) = map (P p) vs
-> vars _ = []
+> topEnts :: TopDecl a -> [P Ident]
+> topEnts (DataDecl _ _ _ _ cs _) = nub (concatMap ents cs)
+>   where ents (ConstrDecl p _ _ c _) = [P p c]
+>         ents (ConOpDecl p _ _ _ op _) = [P p op]
+>         ents (RecordDecl p _ _ c fs) =
+>           P p c : [P p l | FieldDecl p ls _ <- fs, l <- ls]
+> topEnts (NewtypeDecl _ _ _ _ nc _) = ents nc
+>   where ents (NewConstrDecl p c _) = [P p c]
+>         ents (NewRecordDecl p c l _) = [P p c,P p l]
+> topEnts (TypeDecl _ _ _ _) = []
+> topEnts (ClassDecl _ _ _ _ ds) = [P p f | TypeSig p fs _ <- ds, f <- fs]
+> topEnts (InstanceDecl _ _ _ _ _) = []
+> topEnts (DefaultDecl _ _) = []
+> topEnts (BlockDecl d) = vars d
+
+> vars :: Decl a -> [P Ident]
+> vars (InfixDecl _ _ _ _) = []
+> vars (TypeSig _ _ _) = []
+> vars (FunctionDecl p _ f _) = [P p f]
+> vars (ForeignDecl p _ _ f _) = [P p f]
+> vars (PatternDecl p t _) = map (P p) (bv t)
+> vars (FreeDecl p vs) = map (P p) (bv vs)
+> vars (TrustAnnot _ _ _) = []
 
 \end{verbatim}
-Anonymous identifiers in patterns are always ignored.
+In order to report imported definitions that are shadowed by top-level
+or local declarations, we process the import declarations of the
+module. Since we consider only unqualified identifiers for shadowing
+warnings we can ignore all qualified imports. Note that we collect the
+import paths under which identifier is available, not the original
+names of the imported entities.
 \begin{verbatim}
 
-> isAnonId :: Ident -> Bool
-> isAnonId x = unRenameIdent x == anonId
+> imports :: ModuleEnv -> [ImportDecl] -> FM Ident D
+> imports mEnv is = foldr importModule zeroFM is
+>   where importModule (ImportDecl _ m q _ is) xs =
+>           foldr (importEnt m) xs (visible q is xs')
+>           where xs' = ents (moduleInterface m mEnv)
+>         importEnt m x xs =
+>           addToFM x (I (m : maybe [] (\(I ms) -> ms) (lookupFM x xs))) xs
+>         ents (Interface _ _ ds) = concatMap intfEnts ds
+
+> visible :: Bool -> Maybe ImportSpec -> [Ident] -> [Ident]
+> visible True _ = const []
+> visible False Nothing = id
+> visible False (Just (Importing _ is)) = const (foldr impEnts [] is)
+> visible False (Just (Hiding _ is)) = filter (`notElem` foldr impEnts [] is)
+
+> impEnts :: Import -> [Ident] -> [Ident]
+> impEnts (Import x) = (x:)
+> impEnts (ImportTypeWith _ xs) = (xs ++)
+
+> intfEnts :: IDecl -> [Ident]
+> intfEnts (IInfixDecl _ _ _ _) = []
+> intfEnts (HidingDataDecl _ _ _ _) = []
+> intfEnts (IDataDecl _ _ _ _ _ cs xs) =
+>   filter (`notElem` xs) (concatMap ents cs)
+>   where ents (ConstrDecl _ _ _ c _) = [c]
+>         ents (ConOpDecl _ _ _ _ op _) = [op]
+>         ents (RecordDecl _ _ _ c fs) =
+>           c : [l | FieldDecl _ ls _ <- fs, l <- ls]
+> intfEnts (INewtypeDecl _ _ _ _ _ nc xs) = filter (`notElem` xs) (ents nc)
+>   where ents (NewConstrDecl _ c _) = [c]
+>         ents (NewRecordDecl _ c l _) = [c,l]
+> intfEnts (ITypeDecl _ _ _ _ _) = []
+> intfEnts (HidingClassDecl _ _ _ _ _) = []
+> intfEnts (IClassDecl _ _ _ _ _ ds fs) = filter (`notElem` fs) (map mthd ds)
+>   where mthd (IMethodDecl _ f _ _) = f
+> intfEnts (IInstanceDecl _ _ _ _ _ _) = []
+> intfEnts (IFunctionDecl _ f _ _) = [unqualify f]
 
 \end{verbatim}
diff -u curry-0.9.11/Simplify.lhs curry-0.9.11-classful/Simplify.lhs
--- curry-0.9.11/Simplify.lhs	2007-06-15 14:16:34.000000000 +0200
+++ curry-0.9.11-classful/Simplify.lhs	2012-06-19 15:22:45.000000000 +0200
@@ -1,16 +1,14 @@
 % -*- LaTeX -*-
-% $Id: Simplify.lhs 2158 2007-04-20 07:59:38Z wlux $
+% $Id: Simplify.lhs 3079 2012-06-19 13:21:05Z wlux $
 %
-% Copyright (c) 2003-2007, Wolfgang Lux
+% Copyright (c) 2003-2011, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{Simplify.lhs}
 \section{Optimizing the Desugared Code}\label{sec:simplify}
-After desugaring the source code, but before lifting local
-declarations, the compiler performs a few simple optimizations to
-improve the efficiency of the generated code. In addition, the
-optimizer replaces pattern bindings with simple variable bindings and
-selector functions.
+After desugaring source code and making pattern matching explicit, but
+before lifting local declarations, the compiler performs a few simple
+optimizations to improve efficiency of the generated code.
 
 Currently, the following optimizations are implemented:
 \begin{itemize}
@@ -25,60 +23,120 @@
 > module Simplify(simplify) where
 > import Base
 > import Combined
+> import Curry
+> import CurryUtils
 > import Env
+> import List
 > import Monad
+> import PredefIdent
+> import PredefTypes
 > import SCC
-> import TopEnv
-> import TypeSubst
+> import TrustInfo
+> import Types
+> import TypeInfo
 > import Typing
 > import Utils
+> import ValueInfo
 
-> type SimplifyState a =
->   StateT ValueEnv (ReaderT NewtypeEnv (ReaderT TrustEnv (StateT Int Id))) a
-> type InlineEnv = Env Ident Expression
-
-> simplify :: ValueEnv -> TrustEnv -> Module -> (Module,ValueEnv)
-> simplify tyEnv trEnv m =
->   runSt (callRt (callRt (callSt (simplifyModule m) tyEnv) nEnv) trEnv) 1
->   where nEnv = newtypeEnv tyEnv
-
-> simplifyModule :: Module -> SimplifyState (Module,ValueEnv)
-> simplifyModule (Module m es is ds) =
->   do
->     ds' <- mapM (simplifyTopDecl m) ds
->     tyEnv <- fetchSt
->     return (Module m es is ds',tyEnv)
-
-> simplifyTopDecl :: ModuleIdent -> TopDecl -> SimplifyState TopDecl
-> simplifyTopDecl m (BlockDecl d) = liftM BlockDecl (simplifyDecl m emptyEnv d)
-> simplifyTopDecl _ d = return d
-
-> simplifyDecl :: ModuleIdent -> InlineEnv -> Decl -> SimplifyState Decl
-> simplifyDecl m env (FunctionDecl p f eqs) =
->   liftM (FunctionDecl p f)
->         (mapM (simplifyEquation m env) eqs >>= etaExpand m >>= inlineBodies m)
-> simplifyDecl m env (PatternDecl p t rhs) =
->   liftM (PatternDecl p t) (simplifyRhs m env rhs)
-> simplifyDecl _ _ d = return d
-
-> simplifyEquation :: ModuleIdent -> InlineEnv -> Equation
->                  -> SimplifyState Equation
-> simplifyEquation m env (Equation p lhs rhs) =
->   liftM (Equation p lhs) (simplifyRhs m env rhs)
+> type SimplifyState a = ReaderT TCEnv (ReaderT TrustEnv (StateT Int Id)) a
+> type InlineEnv = Env Ident (Expression QualType)
 
-> simplifyRhs :: ModuleIdent -> InlineEnv -> Rhs -> SimplifyState Rhs
-> simplifyRhs m env (SimpleRhs p e _) =
+> simplify :: TCEnv -> ValueEnv -> TrustEnv -> Module QualType
+>          -> (ValueEnv,Module QualType)
+> simplify tcEnv tyEnv trEnv m =
+>   runSt (callRt (callRt (simplifyModule tyEnv m) tcEnv) trEnv) 1
+
+> simplifyModule :: ValueEnv -> Module QualType
+>                -> SimplifyState (ValueEnv,Module QualType)
+> simplifyModule tyEnv (Module m es is ds) =
+>   do
+>     (tyEnv',dss') <- mapAccumM (simplifyTopDecl m) tyEnv ds
+>     return (tyEnv',Module m es is (concat dss'))
+
+> simplifyTopDecl :: ModuleIdent -> ValueEnv -> TopDecl QualType
+>                 -> SimplifyState (ValueEnv,[TopDecl QualType])
+> simplifyTopDecl _ tyEnv (DataDecl p cx tc tvs cs clss) =
+>   return (tyEnv,[DataDecl p cx tc tvs cs clss])
+> simplifyTopDecl _ tyEnv (NewtypeDecl p cx tc tvs nc clss) =
+>   return (tyEnv,[NewtypeDecl p cx tc tvs nc clss])
+> simplifyTopDecl _ tyEnv (TypeDecl p tc tvs ty) =
+>   return (tyEnv,[TypeDecl p tc tvs ty])
+> simplifyTopDecl m tyEnv (ClassDecl p cx cls tv ds) =
+>   do
+>     dss' <- mapM (simplifyDecl m (bindDecls ds tyEnv) emptyEnv) vds
+>     return (tyEnv,[ClassDecl p cx cls tv (tds ++ concatMap snd dss')])
+>   where (tds,vds) = partition isTypeSig ds
+> simplifyTopDecl m tyEnv (InstanceDecl p cx cls ty ds) =
+>   do
+>     dss' <- mapM (simplifyDecl m (bindDecls ds tyEnv) emptyEnv) ds
+>     return (tyEnv,[InstanceDecl p cx cls ty (concatMap snd dss')])
+> simplifyTopDecl _ tyEnv (DefaultDecl p tys) =
+>   return (tyEnv,[DefaultDecl p tys])
+> simplifyTopDecl m tyEnv (BlockDecl d) =
+>   do
+>     (tyEnv',ds') <- simplifyDecl m tyEnv emptyEnv d
+>     return (tyEnv',map BlockDecl ds')
+
+> simplifyDecl :: ModuleIdent -> ValueEnv -> InlineEnv -> Decl QualType
+>              -> SimplifyState (ValueEnv,[Decl QualType])
+> simplifyDecl m tyEnv env (FunctionDecl p ty f eqs) =
+>   do
+>     (tyEnv',eqs') <- mapAccumM (flip (simplifyEquation m) env) tyEnv eqs
+>     return (tyEnv',[FunctionDecl p ty f eqs'])
+> simplifyDecl _ tyEnv _ (ForeignDecl p fi ty f ty') =
+>   return (tyEnv,[ForeignDecl p fi ty f ty'])
+> simplifyDecl m tyEnv env (PatternDecl p t rhs) =
+>   do
+>     rhs' <- simplifyRhs m tyEnv env rhs >>= etaExpandRhs tyEnv
+>     case (t,rhs') of
+>       (VariablePattern ty f,SimpleRhs _ (Lambda _ ts e) _) ->
+>         return (changeArity m f (length ts) tyEnv,[funDecl p ty f ts e])
+>       (TuplePattern ts,SimpleRhs p' e _) -> return (tyEnv,match p' e)
+>         where match _ (Variable _ v) =
+>                 [patDecl p t (Variable (qualType (typeOf t)) v) | t <- ts]
+>               match _ (Tuple es) = zipWith (patDecl p) ts es
+>               match p' (Let ds e) = ds ++ match p' e
+>               match p' e@(Case _ _) = [PatternDecl p t (SimpleRhs p' e [])]
+>               match p' e@(Fcase _ _) = [PatternDecl p t (SimpleRhs p' e [])]
+>       _ -> return (tyEnv,[PatternDecl p t rhs'])
+> simplifyDecl _ tyEnv _ (FreeDecl p vs) = return (tyEnv,[FreeDecl p vs])
+
+> simplifyEquation :: ModuleIdent -> ValueEnv -> InlineEnv -> Equation QualType
+>                  -> SimplifyState (ValueEnv,Equation QualType)
+> simplifyEquation m tyEnv env (Equation p lhs rhs) =
+>   do
+>     rhs' <- simplifyRhs m tyEnv' env rhs >>= etaExpandRhs tyEnv'
+>     case (simplifyLhs (qfv m rhs') lhs,rhs') of
+>       (FunLhs f ts,SimpleRhs p' (Lambda _ ts' e') _) ->
+>         return (changeArity m f (length ts + length ts') tyEnv,
+>                 Equation p (FunLhs f (ts ++ ts')) (SimpleRhs p' e' []))
+>       (lhs',_) -> return (tyEnv,Equation p lhs' rhs')
+>   where tyEnv' = bindLhs lhs tyEnv
+
+> simplifyLhs :: [Ident] -> Lhs a -> Lhs a
+> simplifyLhs fvs (FunLhs f ts) = FunLhs f (map (simplifyPattern fvs) ts)
+
+> simplifyRhs :: ModuleIdent -> ValueEnv -> InlineEnv -> Rhs QualType
+>             -> SimplifyState (Rhs QualType)
+> simplifyRhs m tyEnv env (SimpleRhs p e _) =
 >   do
->     e' <- simplifyApp m p e [] >>= simplifyExpr m env
+>     e' <- simplifyAppExpr m tyEnv p env e
 >     return (SimpleRhs p e' [])
 
+> simplifyAppExpr :: ModuleIdent -> ValueEnv -> Position -> InlineEnv
+>                 -> Expression QualType -> SimplifyState (Expression QualType)
+> simplifyAppExpr m tyEnv p env e =
+>   simplifyApp p e [] >>= simplifyExpr m tyEnv p env
+
 \end{verbatim}
 \label{eta-expansion}
-After transforming the bodies of each equation defining a function,
-the compiler tries to $\eta$-expand the definition. Using
-$\eta$-expanded definitions has the advantage that the compiler can
-avoid intermediate lazy applications. For instance, if the
-\texttt{map} function were defined as follows
+After transforming the right hand side of a variable declaration and
+the body of a function equation\footnote{Recall that after making
+  pattern matching explicit each function is defined by exactly one
+  equation.}, respectively, the compiler tries to $\eta$-expand the
+definition. Using $\eta$-expanded definitions has the advantage that
+the compiler can avoid intermediate lazy applications. For instance,
+if the \texttt{map} function were defined as follows
 \begin{verbatim}
   map f = foldr (\x -> (f x :)) []
 \end{verbatim}
@@ -110,300 +168,284 @@
   $f\,x_1\dots x_n$)} and \texttt{let a = $f\,x_1\dots x_n$ in (a,a)}
 are equivalent. In order to find a safe approximation of definitions
 for which this property holds, the distinction between expansive and
-non-expansive expressions is useful again, which was introduced in
-order to identify let-bound variables for which polymorphic
-generalization is safe (see p.~\pageref{non-expansive} in
-Sect.~\ref{non-expansive}). An expression is non-expansive if it is
-either
+non-expansive expressions is useful again, which was introduced to
+identify let-bound variables for which polymorphic generalization is
+safe (see p.~\pageref{non-expansive} in Sect.~\ref{non-expansive}). An
+expression is non-expansive if it is either
 \begin{itemize}
 \item a literal,
 \item a variable,
 \item an application of a constructor with arity $n$ to at most $n$
   non-expansive expressions,
-\item an application of a function with arity $n$ to at most $n-1$
-  non-expansive expressions, or
+\item an application of a function or $\lambda$-abstraction with arity
+  $n$ to at most $n-1$ non-expansive expressions,
+\item an application of a $\lambda$-abstraction with arity $n$ to $n$
+  or more non-expansive expressions and the application of the
+  $\lambda$-abstraction's body to the excess arguments is
+  non-expansive, or
 \item a let expression whose body is a non-expansive expression and
   whose local declarations are either function declarations or
   variable declarations of the form \texttt{$x$=$e$} where $e$ is a
   non-expansive expression.
 \end{itemize}
-A function definition then can be $\eta$-expanded safely if it has
-only a single equation whose body is a non-expansive expression and
-whose arguments are all plain variables. The latter restriction is
-necessary in order to ensure that no arguments need to be evaluated in
-order to compute the equation's body.
-
-We perform $\eta$-expansion even across newtypes, so that, for
-instance, \texttt{doneST} and \texttt{returnST} in the program
-fragment 
+A function or variable definition can be $\eta$-expanded safely if its
+body is a non-expansive expression.
 \begin{verbatim}
-  newtype ST s a = ST (s -> (a,s))
-  doneST     = returnST ()
-  returnST x = ST (\s -> (x,s))
-\end{verbatim}
-are expanded into functions with arity one and two, respectively. In
-order to determine the types of the variables added by
-$\eta$-expansion in such cases, the compiler must expand the types as
-well. To this end, the compiler uses a simple environment that maps
-newtype identifiers onto the argument type of their newtype
-constructor. This environment is derived from the value type
-environment in function \texttt{newtypeEnv} below. The compiler does
-not expand functions across newtypes that cannot be expanded
-themselves, which happens for newtypes that are exported abstractly.
-In order to support $\eta$-expansion of functions with type
-\texttt{IO}, we consider the type \texttt{IO} to be defined as a
-newtype as well.
-\begin{verbatim}
-
-> type NewtypeEnv = Env QualIdent Type
-
-> newtypeEnv :: ValueEnv -> NewtypeEnv
-> newtypeEnv tyEnv = foldr bindNewtype initNewtypeEnv (allEntities tyEnv)
->   where initNewtypeEnv = bindEnv qIOId ioType' emptyEnv
->         ioType' = TypeArrow worldType (tupleType [TypeVariable 0,worldType])
->         qWorldId = qualify (mkIdent "World")
->         worldType = TypeConstructor qWorldId []
->         bindNewtype (DataConstructor _ _ _) = id
->         bindNewtype (NewtypeConstructor _ (ForAll _ ty)) = bindEnv tc ty1
->           where TypeArrow ty1 (TypeConstructor tc _) = ty
->         bindNewtype (Value _ _ _) = id
-
-> etaExpand :: ModuleIdent -> [Equation] -> SimplifyState [Equation]
-> etaExpand m [eq] =
->   do
->     tyEnv <- fetchSt
->     nEnv <- liftSt envRt
->     etaEquation m tyEnv nEnv eq
-> etaExpand m eqs = return eqs
-
-> etaEquation :: ModuleIdent -> ValueEnv -> NewtypeEnv -> Equation
->             -> SimplifyState [Equation]
-> etaEquation m tyEnv nEnv (Equation p1 (FunLhs f ts) (SimpleRhs p2 e _))
->   | all isVariablePattern ts && isNonExpansive tyEnv 0 e && not (null tys) =
+
+> etaExpandRhs :: ValueEnv -> Rhs QualType -> SimplifyState (Rhs QualType)
+> etaExpandRhs tyEnv rhs@(SimpleRhs p e _) =
+>   do
+>     (ts',e') <- etaExpand tyEnv e
+>     return (if null ts' then rhs else SimpleRhs p (Lambda p ts' e') [])
+
+> etaExpand :: ValueEnv -> Expression QualType
+>           -> SimplifyState ([ConstrTerm QualType],Expression QualType)
+> etaExpand tyEnv e =
+>   do
+>     tcEnv <- envRt
+>     etaExpr tcEnv tyEnv e
+
+> etaExpr :: TCEnv -> ValueEnv -> Expression QualType
+>         -> SimplifyState ([ConstrTerm QualType],Expression QualType)
+> etaExpr _ _ (Lambda _ ts e) = return (ts,e)
+> etaExpr tcEnv tyEnv e
+>   | isNonExpansive tyEnv 0 e && not (null tys) =
 >       do
->         vs <- mapM (freshIdent m etaId 0 . monoType) tys
->         updateSt_ (changeArity m f (n + length tys))
->         return [Equation p1 (FunLhs f (ts ++ map VariablePattern vs))
->                          (SimpleRhs p2 (etaApply e (map mkVar vs)) [])]
->   | otherwise = return [Equation p1 (FunLhs f ts) (SimpleRhs p2 e [])]
->   where n = length ts
->         ty = etaType nEnv (rawType (varType f tyEnv))
->         tys = take (exprArity tyEnv e) (drop n (arrowArgs ty))
->         etaId n = mkIdent ("_#eta" ++ show n)
->         etaApply (Let ds e) es = Let ds (etaApply e es)
->         etaApply e es = apply e es
-
-> isNonExpansive :: ValueEnv -> Int -> Expression -> Bool
-> isNonExpansive _ _ (Literal _) = True
-> isNonExpansive tyEnv n (Variable x)
+>         vs <- mapM (freshVar "_#eta") tys
+>         return (map (uncurry VariablePattern) vs,
+>                 etaApply e' (map (uncurry mkVar) vs))
+>   | otherwise = return ([],e)
+>   where n = exprArity tyEnv e
+>         (ty',e') = expandTypeAnnot tcEnv n e
+>         tys = take n (arrowArgs ty')
+>         etaApply e es =
+>           case e of
+>             Let ds e -> Let ds (etaApply e es)
+>             _ -> apply e es
+
+> isNonExpansive :: ValueEnv -> Int -> Expression QualType -> Bool
+> isNonExpansive _ _ (Literal _ _) = True
+> isNonExpansive tyEnv n (Variable _ x)
 >   | not (isQualified x) = n == 0 || n < arity x tyEnv
 >   | otherwise = n < arity x tyEnv
-> isNonExpansive _ _ (Constructor _) = True
+> isNonExpansive _ _ (Constructor _ _) = True
+> isNonExpansive tyEnv n (Tuple es) = n == 0 && all (isNonExpansive tyEnv 0) es
 > isNonExpansive tyEnv n (Apply e1 e2) =
 >   isNonExpansive tyEnv (n + 1) e1 && isNonExpansive tyEnv 0 e2
+> isNonExpansive tyEnv n (Lambda _ ts e) =
+>   n' < 0 || isNonExpansive (bindTerms ts tyEnv) n' e
+>   where n' = n - length ts
 > isNonExpansive tyEnv n (Let ds e) =
->   all (isNonExpansiveDecl tyEnv) ds && isNonExpansive tyEnv n e
-> isNonExpansive tyEnv n (Case _ _) = False
-
-> isNonExpansiveDecl :: ValueEnv -> Decl -> Bool
-> isNonExpansiveDecl _ (FunctionDecl _ _ _) = True
-> isNonExpansiveDecl _ (ForeignDecl _ _ _ _ _ _) = True
+>   all (isNonExpansiveDecl tyEnv') ds && isNonExpansive tyEnv' n e
+>   where tyEnv' = bindDecls ds tyEnv
+> isNonExpansive _ _ (Case _ _) = False
+> isNonExpansive _ _ (Fcase _ _) = False
+
+> isNonExpansiveDecl :: ValueEnv -> Decl QualType -> Bool
+> isNonExpansiveDecl _ (FunctionDecl _ _ _ _) = True
+> isNonExpansiveDecl _ (ForeignDecl _ _ _ _ _) = True
 > isNonExpansiveDecl tyEnv (PatternDecl _ _ (SimpleRhs _ e _)) =
 >   isNonExpansive tyEnv 0 e
 > isNonExpansiveDecl _ (FreeDecl _ _) = False
 
-> exprArity :: ValueEnv -> Expression -> Int
-> exprArity _ (Literal _) = 0
-> exprArity tyEnv (Variable x) = arity x tyEnv
-> exprArity tyEnv (Constructor c) = arity c tyEnv
+> exprArity :: ValueEnv -> Expression QualType -> Int
+> exprArity _ (Literal _ _) = 0
+> exprArity tyEnv (Variable _ x) = arity x tyEnv
+> exprArity tyEnv (Constructor _ c) = arity c tyEnv
+> exprArity _ (Tuple _) = 0
 > exprArity tyEnv (Apply e _) = exprArity tyEnv e - 1
-> exprArity tyEnv (Let _ e) = exprArity tyEnv e
+> exprArity _ (Lambda _ ts _) = length ts
+> exprArity tyEnv (Let ds e) = exprArity (bindDecls ds tyEnv) e
 > exprArity _ (Case _ _) = 0
+> exprArity _ (Fcase _ _) = 0
 
-> etaType :: NewtypeEnv -> Type -> Type
-> etaType nEnv (TypeArrow ty1 ty2) = TypeArrow ty1 (etaType nEnv ty2)
-> etaType nEnv (TypeConstructor tc tys) =
->   case lookupEnv tc nEnv of
->     Just ty -> etaType nEnv (expandAliasType tys ty)
->     Nothing -> TypeConstructor tc tys
-> etaType _ ty = ty
-
-\end{verbatim}
-After simplifying the right hand sides of all equations of a function
-and $\eta$-expanding the definition if possible, the compiler finally
-transforms declarations of the form
-\begin{quote}\tt
-  $f\;t_1\dots t_{k}\;x_{k+1}\dots x_{n}$ =
-    let $g\;t_{k+1}\dots t_{n}$ = $e$ in
-    $g\;x_{k+1}\dots x_{n}$
-\end{quote}
-into the equivalent definition
-\begin{quote}\tt
-  $f\;t_1\dots t_{k}\;(x_{k+1}$@$t_{k+1})\dots(x_n$@$t_{n})$ = $e$
-\end{quote}
-where the arities of $f$ and $g$ are $n$ and $n-k$, respectively,
-and $x_{k+1},\dots,x_{n}$ are variables. This optimization was
-introduced in order to avoid an auxiliary function being generated for
-definitions whose right-hand side is a $\lambda$-expression, e.g.,
-\verb|f . g = \x -> f (g x)|. This declaration is transformed into
-\verb|(.) f g x = let lambda x = f (g x) in lambda x| by desugaring
-and in turn is optimized into \verb|(.) f g x = f (g x)|, here. The
-transformation can obviously be generalized to the case where $g$ is
-defined by more than one equation.
-
-We have to be careful with this optimization in conjunction with
-newtype constructors. It is possible that the local function is
-applied only partially, e.g., for
+\end{verbatim}
+Since newtype constructors have been removed already, the compiler may
+perform $\eta$-expansion even across newtypes. For instance, given the
+source definitions
 \begin{verbatim}
   newtype ST s a = ST (s -> (a,s))
+  doneST     = returnST ()
   returnST x = ST (\s -> (x,s))
 \end{verbatim}
-the desugared code is equivalent to
-\begin{verbatim}
-  returnST x = let lambda1 s = (x,s) in lambda1
-\end{verbatim}
-We must not ``optimize'' this into \texttt{returnST x s = (x,s)}
-because the compiler assumes that \texttt{returnST} is a unary
-function.
-
-Note that this transformation is not strictly semantic preserving as
-the evaluation order of arguments can be changed. This happens if $f$
-is defined by more than one rule with overlapping patterns and the
-local functions of each rule have disjoint patterns. As an example,
-consider the function
-\begin{verbatim}
-  f (Just x) _ = let g (Left z)  = x + z in g
-  f _ (Just y) = let h (Right z) = y + z in h
-\end{verbatim}
-The definition of \texttt{f} is non-deterministic because of the
-overlapping patterns in the first and second argument. However, the
-optimized definition
-\begin{verbatim}
-  f (Just x) _ (Left z)  = x + z
-  f _ (Just y) (Right z) = y + z
-\end{verbatim}
-is deterministic. It will evaluate and match the third argument first,
-whereas the original definition is going to evaluate the first or the
-second argument first, depending on the non-deterministic branch
-chosen. As such definitions are presumably rare, and the optimization
-avoids a non-deterministic split of the computation, we put up with
-the change of evaluation order.
-
-This transformation is actually just a special case of inlining a
-(local) function definition. We are unable to handle the general case
-because it would require representing pattern matching code explicitly
-in Curry expressions.
-\begin{verbatim}
-
-> inlineBodies :: ModuleIdent -> [Equation] -> SimplifyState [Equation]
-> inlineBodies m eqs =
->   do
->     tyEnv <- fetchSt
->     trEnv <- liftSt (liftRt envRt)
->     return (concatMap (inlineBody m tyEnv trEnv) eqs)
-
-> inlineBody :: ModuleIdent -> ValueEnv -> TrustEnv -> Equation -> [Equation]
-> inlineBody m tyEnv trEnv
->     (Equation p (FunLhs f ts) (SimpleRhs _ (Let [FunctionDecl _ g eqs'] e) _))
->   | g `notElem` qfv m eqs' && e' == Variable (qualify g) &&
->     n == arity (qualify g) tyEnv && trustedFun trEnv g =
->     map (merge p f ts' vs') eqs'
->   where n :: Int                      -- type signature necessary for nhc
->         (n,vs',ts',e') = etaReduce 0 [] (reverse ts) e
->         merge p f ts vs (Equation _ (FunLhs _ ts') rhs) =
->           Equation p (FunLhs f (ts ++ zipWith AsPattern vs ts')) rhs
->         etaReduce n vs (VariablePattern v : ts) (Apply e (Variable v'))
->           | qualify v == v' = etaReduce (n+1) (v:vs) ts e
->         etaReduce n vs ts e = (n,vs,reverse ts,e)
-> inlineBody _ _ _ eq = [eq]
+the functions \texttt{doneST} and \texttt{returnST} are expanded into
+functions with arity one and two, respectively. In order to determine
+the types of the variables added by $\eta$-expansion in such cases,
+the compiler must expand the type annotations as well. In the example,
+the type annotation of function \texttt{returnST} in the definition of
+\texttt{doneST} is changed from $() \rightarrow
+\texttt{ST}\,\alpha_1\,()$ to $() \rightarrow \alpha_1 \rightarrow
+((),\alpha_1)$. This is implemented in function
+\texttt{expandTypeAnnot}, which tries to expand the type annotations
+of $e$'s root such that the expression has (at least) arity $n$. Note
+that this may fail when the newtype's definition is not visible in the
+current module.
+\begin{verbatim}
+
+> expandTypeAnnot :: TCEnv -> Int -> Expression QualType
+>                 -> (Type,Expression QualType)
+> expandTypeAnnot tcEnv n e
+>   | n <= arrowArity ty = (ty,e)
+>   | otherwise = (ty',fixType ty' e)
+>   where ty = typeOf e
+>         ty' = etaType tcEnv n ty
+
+> fixType :: Type -> Expression QualType -> Expression QualType
+> fixType ty (Literal _ l) = Literal (qualType ty) l
+> fixType ty (Variable _ v) = Variable (qualType ty) v
+> fixType ty (Constructor _ c) = Constructor (qualType ty) c
+> fixType _ (Tuple es) = Tuple es
+> fixType ty (Apply e1 e2) = Apply (fixType (TypeArrow (typeOf e2) ty) e1) e2
+> fixType ty (Lambda p ts e) = Lambda p ts (fixType (foldr match ty ts) e)
+>   where match _ (TypeArrow _ ty) = ty
+> fixType ty (Let ds e) = Let ds (fixType ty e)
+> fixType ty (Case e as) = Case e (map (fixTypeAlt ty) as)
+> fixType ty (Fcase e as) = Fcase e (map (fixTypeAlt ty) as)
+
+> fixTypeAlt :: Type -> Alt QualType -> Alt QualType
+> fixTypeAlt ty (Alt p t rhs) = Alt p t (fixTypeRhs ty rhs)
+
+> fixTypeRhs :: Type -> Rhs QualType -> Rhs QualType
+> fixTypeRhs ty (SimpleRhs p e _) = SimpleRhs p (fixType ty e) []
 
 \end{verbatim}
 Before other optimizations are applied to expressions, the simplifier
-first transforms applications of let and case expressions by pushing
-the application down into the body of let expressions and into the
-alternatives of case expressions, respectively. In order to avoid code
-duplication, arguments that are pushed into the alternatives of a case
-expression by this transformation are bound to local variables (unless
-there is only one alternative). If these arguments are just simple
-variables or constant literals, the optimizations performed in
-\texttt{simplifyExpr} below will substitute these values and the let
-declarations will be removed.
-\begin{verbatim}
-
-> simplifyApp :: ModuleIdent -> Position -> Expression -> [Expression]
->             -> SimplifyState Expression
-> simplifyApp _ _ (Literal l) _ = return (Literal l)
-> simplifyApp _ _ (Variable v) es = return (apply (Variable v) es)
-> simplifyApp _ _ (Constructor c) es = return (apply (Constructor c) es)
-> simplifyApp m p (Apply e1 e2) es =
->   do
->     e2' <- simplifyApp m p e2 []
->     simplifyApp m p e1 (e2':es)
-> simplifyApp m p (Let ds e) es = liftM (Let ds) (simplifyApp m p e es)
-> simplifyApp m p (Case e as) es =
->   do
->     e' <- simplifyApp m p e []
->     mkCase e' es as
->   where argId n = mkIdent ("_#arg" ++ show n)
->         mkCase e es as
->           | length as == 1 = return (Case e (map (applyToAlt es) as))
->           | otherwise =
->               do
->                 vs <- mapM (freshVar m argId) es
->                 return (foldr2 mkLet
->                                (Case e (map (applyToAlt (map mkVar vs)) as))
->                                vs es)
->         applyToAlt es (Alt p t rhs) = Alt p t (applyToRhs es rhs)
+first transforms applications of let and (f)case expressions by
+pushing the application down into the body of let expressions and into
+the alternatives of (f)case expressions, respectively. In order to
+avoid code duplication, arguments that are pushed into the
+alternatives of a (f)case expression by this transformation are bound
+to local variables (unless there is only one alternative). If these
+arguments are just simple variables or literal constants, the
+optimizations performed in \texttt{simplifyExpr} below will substitute
+these values and the let declarations will be removed. In addition,
+beta-reduction is applied to saturated applications of
+$\lambda$-abstractions, changing \texttt{(\bs$x_1 \dots\, x_m$ -> $e$)
+  $e_1 \dots\, e_m \; e_{m+1} \dots\, e_n$} into \texttt{let $x_1$ =
+  $e_1$ in \dots\ let $x_m$ = $e_m$ in $e$ $e_{m+1} \dots\, e_n$}.
+Note that this transformation is correct because the renaming phase
+ensures that $x_1,\dots,x_m$ are not free in $e_1,\dots,e_n$.
+\begin{verbatim}
+
+> simplifyApp :: Position -> Expression QualType -> [Expression QualType]
+>             -> SimplifyState (Expression QualType)
+> simplifyApp _ (Literal ty l) _ = return (Literal ty l)
+> simplifyApp _ (Variable ty v) es = return (apply (Variable ty v) es)
+> simplifyApp _ (Constructor ty c) es = return (apply (Constructor ty c) es)
+> simplifyApp _ (Tuple es) _ = return (Tuple es)
+> simplifyApp p (Apply e1 e2) es = simplifyApp p e1 (e2:es)
+> simplifyApp p (Lambda p' ts e) es
+>   | n <= length es = simplifyApp p (foldr2 (match p') e ts es1) es2
+>   | otherwise = return (apply (Lambda p' ts e) es)
+>   where n = length ts
+>         (es1,es2) = splitAt n es
+>         match p (VariablePattern ty v) e1 e2 = Let [varDecl p ty v e1] e2
+> simplifyApp p (Let ds e) es = liftM (Let ds) (simplifyApp p e es)
+> simplifyApp p (Case e as) es = mkCase p (Case e) es as
+> simplifyApp p (Fcase e as) es = mkCase p (Fcase e) es as
+
+> mkCase :: Position -> ([Alt QualType] -> Expression QualType)
+>        -> [Expression QualType] -> [Alt QualType]
+>        -> SimplifyState (Expression QualType)
+> mkCase p f es as
+>   | length as == 1 = return (f (map (applyToAlt es) as))
+>   | otherwise =
+>       do
+>         vs <- mapM (freshVar "_#arg" . typeOf) es
+>         let es' = map (uncurry mkVar) vs
+>         return (foldr2 mkLet (f (map (applyToAlt es') as)) vs es)
+>   where applyToAlt es (Alt p t rhs) = Alt p t (applyToRhs es rhs)
 >         applyToRhs es (SimpleRhs p e _) = SimpleRhs p (apply e es) []
->         mkLet v e1 e2 = Let [varDecl p v e1] e2
+>         mkLet (ty,v) e1 e2 = Let [varDecl p ty v e1] e2
 
 \end{verbatim}
 Variables that are bound to (simple) constants and aliases to other
 variables are substituted. In terms of conventional compiler
-technology these optimizations correspond to constant folding and copy
-propagation, respectively. The transformation is applied recursively
-to a substituted variable in order to handle chains of variable
-definitions.
-
-The bindings of a let expression are sorted topologically in
-order to split them into minimal binding groups. In addition,
-local declarations occurring on the right hand side of a pattern
-declaration are lifted into the enclosing binding group using the
-equivalence (modulo $\alpha$-conversion) of \texttt{let}
-$x$~=~\texttt{let} \emph{decls} \texttt{in} $e_1$ \texttt{in} $e_2$
-and \texttt{let} \emph{decls}\texttt{;} $x$~=~$e_1$ \texttt{in} $e_2$.
-This transformation avoids the creation of some redundant lifted
-functions in later phases of the compiler.
-\begin{verbatim}
-
-> simplifyExpr :: ModuleIdent -> InlineEnv -> Expression
->              -> SimplifyState Expression
-> simplifyExpr _ _ (Literal l) = return (Literal l)
-> simplifyExpr m env (Variable v)
->   | isQualified v = return (Variable v)
->   | otherwise = maybe (return (Variable v)) (simplifyExpr m env)
->                       (lookupEnv (unqualify v) env)
-> simplifyExpr _ _ (Constructor c) = return (Constructor c)
-> simplifyExpr m env (Apply e1 e2) =
+technology, these optimizations correspond to constant folding and
+copy propagation, respectively. The transformation is applied
+recursively to a substituted variable in order to handle chains of
+variable definitions. Note that the compiler carefully updates the
+type annotations of the inlined expression. This is necessary to
+preserve soundness of the annotations when inlining a variable with a
+polymorphic type because in that case each use of the variable is
+annotated with fresh type variables that are unrelated to the type
+variables used on the right hand side of the variable's definition. In
+addition, newtype constructors in the result of the substituted
+expression's type are expanded as far as necessary to ensure that the
+annotated type has the same arity before and after the substitution.
+
+\ToDo{Apply the type substitution only when necessary, i.e., when the
+  inlined variable has a polymorphic type.}
+
+The bindings of a let expression are sorted topologically to split
+them into minimal binding groups. In addition, local declarations
+occurring on the right hand side of variable and pattern declarations
+are lifted into the enclosing binding group using the equivalence
+(modulo $\alpha$-conversion) of \texttt{let} $x$~=~\texttt{let}
+\emph{decls} \texttt{in} $e_1$ \texttt{in} $e_2$ and \texttt{let}
+\emph{decls}\texttt{;} $x$~=~$e_1$ \texttt{in} $e_2$.  This
+transformation avoids the creation of some redundant lifted functions
+in later phases of the compiler.
+\begin{verbatim}
+
+> simplifyExpr :: ModuleIdent -> ValueEnv -> Position -> InlineEnv
+>              -> Expression QualType -> SimplifyState (Expression QualType)
+> simplifyExpr _ _ _ _ (Literal ty l) = return (Literal ty l)
+> simplifyExpr m tyEnv p env (Variable ty v)
+>   | isQualified v = return (Variable ty v)
+>   | otherwise =
+>       do
+>         tcEnv <- envRt
+>         maybe (return (Variable ty v))
+>               (simplifyExpr m tyEnv p env . substExpr tcEnv (unqualType ty))
+>               (lookupEnv (unqualify v) env)
+>   where substExpr tcEnv ty =
+>           snd . expandTypeAnnot tcEnv (arrowArity ty) . withType tcEnv ty
+> simplifyExpr _ _ _ _ (Constructor ty c) = return (Constructor ty c)
+> simplifyExpr m tyEnv p env (Tuple es) =
+>   liftM Tuple (mapM (simplifyAppExpr m tyEnv p env) es)
+> simplifyExpr m tyEnv p env (Apply e1 e2) =
 >   do
->     e1' <- simplifyExpr m env e1
->     e2' <- simplifyExpr m env e2
+>     e1' <- simplifyExpr m tyEnv p env e1
+>     e2' <- simplifyAppExpr m tyEnv p env e2
 >     return (Apply e1' e2')
-> simplifyExpr m env (Let ds e) =
->   do
->     dss' <- mapM (sharePatternRhs m) ds
->     simplifyLet m env (scc bv (qfv m) (foldr hoistDecls [] (concat dss'))) e
-> simplifyExpr m env (Case e alts) =
+> simplifyExpr m tyEnv _ env (Lambda p ts e) =
 >   do
->     e' <- simplifyExpr m env e
->     maybe (liftM (Case e') (mapM (simplifyAlt m env) alts))
->           (simplifyExpr m env)
->           (simplifyMatch e' alts)
+>     (ts',e') <- simplifyAppExpr m tyEnv' p env e >>= etaExpand tyEnv'
+>     let ts'' = map (simplifyPattern (qfv m (Lambda p ts' e'))) ts ++ ts'
+>     return (etaReduce m (bindTerms ts' tyEnv') p ts'' e')
+>   where tyEnv' = bindTerms ts tyEnv
+> simplifyExpr m tyEnv p env (Let ds e) =
+>   simplifyLet m tyEnv p env (scc bv (qfv m) (foldr hoistDecls [] ds)) e
+> simplifyExpr m tyEnv p env (Case e as) =
+>   do
+>     e' <- simplifyAppExpr m tyEnv p env e
+>     maybe (liftM (Case e') (mapM (simplifyAlt m tyEnv env) as))
+>           (simplifyExpr m tyEnv p env)
+>           (simplifyMatch e' as)
+> simplifyExpr m tyEnv p env (Fcase e as) =
+>   do
+>     e' <- simplifyAppExpr m tyEnv p env e
+>     maybe (liftM (Fcase e') (mapM (simplifyAlt m tyEnv env) as))
+>           (simplifyExpr m tyEnv p env)
+>           (simplifyMatch e' as)
+
+> simplifyAlt :: ModuleIdent -> ValueEnv -> InlineEnv -> Alt QualType
+>             -> SimplifyState (Alt QualType)
+> simplifyAlt m tyEnv env (Alt p t rhs) =
+>   do
+>     rhs' <- simplifyRhs m (bindTerm t tyEnv) env rhs
+>     return (Alt p (simplifyPattern (qfv m rhs') t) rhs')
+
+> simplifyPattern :: [Ident] -> ConstrTerm a -> ConstrTerm a
+> simplifyPattern _ (LiteralPattern a l) = LiteralPattern a l
+> simplifyPattern _ (VariablePattern a v) = VariablePattern a v
+> simplifyPattern fvs (ConstructorPattern a c ts) =
+>   ConstructorPattern a c (map (simplifyPattern fvs) ts)
+> simplifyPattern fvs (AsPattern v t) =
+>   (if v `elem` fvs then AsPattern v else id) (simplifyPattern fvs t)
 
-> simplifyAlt :: ModuleIdent -> InlineEnv -> Alt -> SimplifyState Alt
-> simplifyAlt m env (Alt p t rhs) = liftM (Alt p t) (simplifyRhs m env rhs)
-
-> hoistDecls :: Decl -> [Decl] -> [Decl]
+> hoistDecls :: Decl a -> [Decl a] -> [Decl a]
 > hoistDecls (PatternDecl p t (SimpleRhs p' (Let ds e) _)) ds' =
 >   foldr hoistDecls ds' (PatternDecl p t (SimpleRhs p' e []) : ds)
 > hoistDecls d ds = d : ds
@@ -412,67 +454,129 @@
 The declaration groups of a let expression are first processed from
 outside to inside, simplifying the right hand sides and collecting
 inlineable expressions on the fly. At present, only simple constants
-and aliases to other variables are inlined. A constant is considered
-simple if it is either a literal, a constructor, or a non-nullary
-function. Note that it is not possible to define nullary functions in
-local declarations in Curry. Thus, an unqualified name always refers
-to either a variable or a non-nullary function.  Applications of
-constructors and partial applications of functions to at least one
-argument are not inlined because the compiler has to allocate space
-for them, anyway. In order to prevent non-termination, recursive
-binding groups are not processed.
+and aliases to other variables are inlined. In addition, for function
+definitions of the form $f\,x_{m+1}\dots x_n = g\,e_1\dots
+e_m\,x_{m+1} \dots x_n$ where $g$ is a function or constructor whose
+arity is greater than or equal to $n$ and where $e_1,\dots,e_m$ are
+either simple constants or free variables of $f$, the application
+$g\,e_1\dots e_m$ is inlined in place of $f$.
+
+A constant is considered simple if it is either a literal, a
+constructor, or a non-nullary function. Since it is not possible to
+define nullary functions in a local declaration groups in Curry, an
+unqualified name here always refers to either a variable or a
+non-nullary function. Applications of constructors and partial
+applications of functions to at least one argument are not inlined to
+avoid code duplication (for the allocation of the terms). In order to
+prevent non-termination, no inlining is performed for entities defined
+in recursive binding groups.
 
 With the list of inlineable expressions, the body of the let is
 simplified and then the declaration groups are processed from inside
 to outside to construct the simplified, nested let expression. In
-doing so unused bindings are discarded. In addition, all pattern
-bindings are replaced by simple variable declarations using selector
-functions to access the pattern variables.
-\begin{verbatim}
-
-> simplifyLet :: ModuleIdent -> InlineEnv -> [[Decl]] -> Expression
->             -> SimplifyState Expression
-> simplifyLet m env [] e = simplifyExpr m env e
-> simplifyLet m env (ds:dss) e =
->   do
->     ds' <- mapM (simplifyDecl m env) ds
->     tyEnv <- fetchSt
->     e' <- simplifyLet m (inlineVars tyEnv ds' env) dss e
->     dss'' <- mapM (expandPatternBindings m tyEnv (qfv m ds' ++ qfv m e')) ds'
->     return (mkLet m (concat dss'') e')
-
-> inlineVars :: ValueEnv -> [Decl] -> InlineEnv -> InlineEnv
-> inlineVars tyEnv [PatternDecl _ (VariablePattern v) (SimpleRhs _ e _)] env
->   | canInline e = bindEnv v e env
->   where canInline (Literal _) = True
->         canInline (Constructor _) = True
->         canInline (Variable v')
->           | isQualified v' = arity v' tyEnv > 0
->           | otherwise = v /= unqualify v'
->         canInline _ = False
-> inlineVars _ _ env = env
-
-> mkLet :: ModuleIdent -> [Decl] -> Expression -> Expression
-> mkLet m [FreeDecl p vs] e
->   | null vs' = e
->   | otherwise = Let [FreeDecl p vs'] e
->   where vs' = filter (`elem` qfv m e) vs
-> mkLet m [PatternDecl _ (VariablePattern v) (SimpleRhs _ e _)] (Variable v')
->   | v' == qualify v && v `notElem` qfv m e = e
-> mkLet m ds e
->   | null (filter (`elem` qfv m e) (bv ds)) = e
->   | otherwise = Let ds e
-
-\end{verbatim}
-When the scrutinized expression in a case expression is a literal or a
-constructor application, the compiler can perform the pattern matching
-already at compile time and simplify the case expression to the right
-hand side of the matching alternative or to \texttt{Prelude.failed} if
-no alternative matches. When a case expression collapses to a matching
-alternative, the pattern variables are bound to the matching
-(sub)terms of the scrutinized expression. We have to be careful with
-as-patterns in order to avoid losing sharing by code duplication. For
-instance, the expression
+doing so unused bindings are discarded and pattern bindings are
+restricted to those variables actually used in the scope of the
+declaration. In addition, minimal binding groups are recomputed in
+case compile time matching of pattern bindings did introduce new
+variable declarations (see \texttt{simplifyDecl} above).
+\begin{verbatim}
+
+> simplifyLet :: ModuleIdent -> ValueEnv -> Position -> InlineEnv
+>             -> [[Decl QualType]] -> Expression QualType
+>             -> SimplifyState (Expression QualType)
+> simplifyLet m tyEnv p env [] e = simplifyExpr m tyEnv p env e
+> simplifyLet m tyEnv p env (ds:dss) e =
+>   do
+>     (tyEnv',dss') <-
+>       mapAccumM (flip (simplifyDecl m) env) (bindDecls ds tyEnv) ds
+>     tcEnv <- envRt
+>     trEnv <- liftRt envRt
+>     let dss'' = scc bv (qfv m) (concat dss')
+>         env' = foldr (inlineVars m tyEnv' trEnv) env dss''
+>     e' <- simplifyLet m tyEnv' p env' dss e
+>     return (snd (foldr (mkSimplLet m tcEnv) (qfv m e',e') dss''))
+
+> inlineVars :: ModuleIdent -> ValueEnv -> TrustEnv -> [Decl QualType]
+>            -> InlineEnv -> InlineEnv
+> inlineVars m tyEnv trEnv
+>            [FunctionDecl _ _ f [Equation p (FunLhs _ ts) (SimpleRhs _ e _)]]
+>            env
+>   | f `notElem` qfv m e && trustedFun trEnv f =
+>       case etaReduce m (bindTerms ts tyEnv) p ts e of
+>         Lambda _ _ _ -> env
+>         e' -> bindEnv f e' env
+> inlineVars m tyEnv _
+>            [PatternDecl _ (VariablePattern _ v) (SimpleRhs _ e _)]
+>            env
+>   | canInline tyEnv e && v `notElem` qfv m e = bindEnv v e env
+> inlineVars _ _ _ _ env = env
+
+> etaReduce :: ModuleIdent -> ValueEnv -> Position -> [ConstrTerm QualType]
+>           -> Expression QualType -> Expression QualType
+> etaReduce m tyEnv p ts e
+>   | all isVarPattern ts && funArity e' >= n && length ts <= n &&
+>     all (canInline tyEnv) es' && map (uncurry mkVar) vs == es'' &&
+>     all ((`notElem` qfv m e'') . snd) vs = e''
+>   | otherwise = Lambda p ts e
+>   where n = length es
+>         vs = [(ty,v) | VariablePattern ty v <- ts]
+>         (e',es) = unapply e []
+>         (es',es'') = splitAt (n - length ts) es
+>         e'' = apply e' es'
+>         funArity (Variable _ v) = arity v tyEnv
+>         funArity (Constructor _ c) = arity c tyEnv
+>         funArity _ = -1
+
+> canInline :: ValueEnv -> Expression a -> Bool
+> canInline _ (Literal _ _) = True
+> canInline _ (Constructor _ _) = True
+> canInline tyEnv (Variable _ v) = not (isQualified v) || arity v tyEnv > 0
+> canInline _ _ = False
+
+> mkSimplLet :: ModuleIdent -> TCEnv -> [Decl QualType]
+>            -> ([Ident],Expression QualType) -> ([Ident],Expression QualType)
+> mkSimplLet m _ [FreeDecl p vs] (fvs,e)
+>   | null vs' = (fvs,e)
+>   | otherwise = (fvs',Let [FreeDecl p vs'] e)
+>   where vs' = [FreeVar ty v | FreeVar ty v <- vs, v `elem` fvs]
+>         fvs' = filter (`notElem` bv vs) fvs
+> mkSimplLet m tcEnv [PatternDecl _ (VariablePattern _ v) (SimpleRhs _ e _)]
+>       (_,Variable ty' v')
+>   | v' == qualify v && v `notElem` fvs =
+>       (fvs,withType tcEnv (unqualType ty') e)
+>   where fvs = qfv m e
+> mkSimplLet m _ ds (fvs,e)
+>   | null (filter (`elem` fvs) bvs) = (fvs,e)
+>   | otherwise =
+>       (filter (`notElem` bvs) fvs',Let (map (simplifyPatternDecl fvs') ds) e)
+>   where fvs' = qfv m ds ++ fvs
+>         bvs = bv ds
+
+> simplifyPatternDecl :: [Ident] -> Decl QualType -> Decl QualType
+> simplifyPatternDecl fvs (PatternDecl p (TuplePattern ts) rhs) =
+>   PatternDecl p (tuplePattern (filterUsed ts)) (filterRhs rhs)
+>   where bs = [v `elem` fvs | VariablePattern ty v <- ts]
+>         filterUsed xs = [x | (b,x) <- zip bs xs, b]
+>         filterRhs (SimpleRhs p e _) = SimpleRhs p (filterBody e) []
+>         filterBody (Variable _ v) =
+>           tupleExpr (filterUsed [Variable ty v | VariablePattern ty _ <- ts])
+>         filterBody (Tuple es) = tupleExpr (filterUsed es)
+>         filterBody (Case e [Alt p t rhs]) = Case e [Alt p t (filterRhs rhs)]
+>         filterBody (Fcase e [Alt p t rhs]) =
+>           Fcase e [Alt p t (filterRhs rhs)]
+>         filterBody (Let ds e) = Let ds (filterBody e)
+> simplifyPatternDecl _ d = d
+
+\end{verbatim}
+When the scrutinized expression of a $($f$)$case expression is a
+literal or a constructor application, the compiler can perform the
+pattern matching already at compile time and simplify the case
+expression to the right hand side of the matching alternative or to
+\texttt{Prelude.failed} if no alternative matches. When a case
+expression collapses to a matching alternative, the pattern variables
+are bound to the matching (sub)terms of the scrutinized expression. We
+have to be careful with as-patterns to avoid losing sharing by code
+duplication. For instance, the expression
 \begin{verbatim}
   case (0?1) : undefined of
     l@(x:_) -> (x,l)
@@ -489,185 +593,100 @@
 duplication is also the reason why the compiler currently does not
 inline variables bound to constructor applications. This would be safe
 in general only when the program were transformed into a normalized
-form where all arguments of applications are variables.
+form where the arguments of all applications would be variables.
 \begin{verbatim}
 
-> simplifyMatch :: Expression -> [Alt] -> Maybe Expression
+> simplifyMatch :: Expression QualType -> [Alt QualType]
+>               -> Maybe (Expression QualType)
+> simplifyMatch (Let ds e) = fmap (Let ds) . simplifyMatch e
 > simplifyMatch e =
 >   case unapply e [] of
->     (dss,Literal l,_) -> Just . match dss (Left l)
->     (dss,Constructor c,es) -> Just . match dss (Right (c,es))
->     (_,_,_) -> const Nothing
-
-> unapply :: Expression -> [Expression] -> ([[Decl]],Expression,[Expression])
-> unapply (Literal l) es = ([],Literal l,es)
-> unapply (Variable v) es = ([],Variable v,es)
-> unapply (Constructor c) es = ([],Constructor c,es)
+>     (Literal ty l,_) -> Just . match (Left (ty,l))
+>     (Constructor ty c,es) -> Just . match (Right (ty,c,es))
+>     (_,_) -> const Nothing
+
+> unapply :: Expression a -> [Expression a] -> (Expression a,[Expression a])
+> unapply (Literal ty l) es = (Literal ty l,es)
+> unapply (Variable ty v) es = (Variable ty v,es)
+> unapply (Constructor ty c) es = (Constructor ty c,es)
+> unapply (Tuple es') es = (Tuple es',es)
 > unapply (Apply e1 e2) es = unapply e1 (e2:es)
-> unapply (Let ds e) es = (ds:dss',e',es')
->   where (dss',e',es') = unapply e es
-> unapply (Case e alts) es = ([],Case e alts,es)
-
-> match :: [[Decl]] -> Either Literal (QualIdent,[Expression]) -> [Alt]
->       -> Expression
-> match dss e alts =
->   head ([expr p t rhs | Alt p t rhs <- alts, t `matches` e] ++ [prelFailed])
->   where expr p t (SimpleRhs _ e' _) = foldr Let e' (dss ++ bindPattern p e t)
-
-> matches :: ConstrTerm -> Either Literal (QualIdent,[Expression]) -> Bool
-> matches (LiteralPattern l1) (Left l2) = sameLiteral l1 l2
->   where sameLiteral (Int _ i1) (Int _ i2) = i1 == i2
->         sameLiteral l1 l2 = l1 == l2
-> matches (ConstructorPattern c1 _) (Right (c2,_)) = c1 == c2
-> matches (VariablePattern _) _ = True
+> unapply (Lambda p ts e) es = (Lambda p ts e,es)
+> unapply (Let ds e) es = (Let ds e,es)
+> unapply (Case e as) es = (Case e as,es)
+> unapply (Fcase e as) es = (Fcase e as,es)
+
+> match :: Either (QualType,Literal) (QualType,QualIdent,[Expression QualType])
+>       -> [Alt QualType] -> Expression QualType
+> match e as =
+>   head ([expr p t rhs | Alt p t rhs <- as, t `matches` e] ++
+>         [prelFailed (qualType (typeOf (Case (matchExpr e) as)))])
+>   where expr p t (SimpleRhs _ e' _) = bindPattern p e t e'
+
+> matches :: ConstrTerm a -> Either (a,Literal) (a,QualIdent,[Expression a])
+>         -> Bool
+> matches (LiteralPattern _ l1) (Left (_,l2)) = l1 == l2
+> matches (ConstructorPattern _ c1 _) (Right (_,c2,_)) = c1 == c2
+> matches (VariablePattern _ _) _ = True
 > matches (AsPattern _ t) e = matches t e
 
-> bindPattern :: Position -> Either Literal (QualIdent,[Expression])
->             -> ConstrTerm -> [[Decl]]
-> bindPattern _ (Left _) (LiteralPattern _) = []
-> bindPattern p (Right (c,es)) (ConstructorPattern _ ts) =
->   [zipWith (\(VariablePattern v) e -> varDecl p v e) ts es]
-> bindPattern p e (VariablePattern v) =
->   [[varDecl p v (either Literal (uncurry (apply . Constructor)) e)]]
-> bindPattern p e (AsPattern v t) = bindPattern p e t ++ [[bindAs p v t]]
-
-> bindAs :: Position -> Ident -> ConstrTerm -> Decl
-> bindAs p v (LiteralPattern l) = varDecl p v (Literal l)
-> bindAs p v (VariablePattern v') = varDecl p v (mkVar v')
-> bindAs p v (ConstructorPattern c ts) = varDecl p v e'
->   where e' = apply (Constructor c) [mkVar v | VariablePattern v <- ts]
-> bindAs p v (AsPattern v' _) = varDecl p v (mkVar v')
-
-> prelFailed :: Expression
-> prelFailed = Variable (qualifyWith preludeMIdent (mkIdent "failed"))
-
-\end{verbatim}
-\label{pattern-binding}
-In order to implement lazy pattern matching in local declarations,
-pattern declarations $t$~\texttt{=}~$e$ where $t$ is not a variable
-are transformed into a list of declarations
-$v_0$~\texttt{=}~$e$\texttt{;} $v_1$~\texttt{=}~$f_1$~$v_0$\texttt{;}
-\dots{} $v_n$~\texttt{=}~$f_n$~$v_0$ where $v_0$ is a fresh variable,
-$v_1,\dots,v_n$ are the variables occurring in $t$ and the auxiliary
-functions $f_i$ are defined by $f_i$~$t$~\texttt{=}~$v_i$ (see also
-appendix D.8 of the Curry report~\cite{Hanus:Report}). The bindings
-$v_0$~\texttt{=}~$e$ are introduced before splitting the declaration
-groups of the enclosing let expression (cf. the \texttt{Let} case in
-\texttt{simplifyExpr} above) so that they are placed in their own
-declaration group whenever possible. In particular, this ensures that
-the new binding is discarded when the expression $e$ is itself a
-variable.
-
-Unfortunately, this transformation introduces a well-known space
-leak~\cite{Wadler87:Leaks,Sparud93:Leaks} because the matched
-expression cannot be garbage collected until all of the matched
-variables have been evaluated. Consider the following function:
-\begin{verbatim}
-  f x | all (' ' ==) cs = c where (c:cs) = x
-\end{verbatim}
-One might expect the call \verb|f (replicate 10000 ' ')| to execute in
-constant space because (the tail of) the long list of blanks is
-consumed and discarded immediately by \texttt{all}. However, the
-application of the selector function that extracts the head of the
-list is not evaluated until after the guard has succeeded and thus
-prevents the list from being garbage collected.
-
-In order to avoid this space leak we use the approach
-from~\cite{Sparud93:Leaks} and update all pattern variables when one
-of the selector functions has been evaluated. Therefore all pattern
-variables except for the matched one are passed as additional
-arguments to each of the selector functions. Thus, each of these
-variables occurs twice in the argument list of a selector function,
-once in the first argument and also as one of the remaining arguments.
-This duplication of names is used by the compiler to insert the code
-that updates the variables when generating abstract machine code.
-
-We will add only those pattern variables as additional arguments which
-are actually used in the code. This reduces the number of auxiliary
-variables and can prevent the introduction of a recursive binding
-group when only a single variable is used. It is also the reason for
-performing this transformation here instead of in the \texttt{Desugar}
-module. The selector functions are defined in a local declaration on
-the right hand side of a projection declaration so that there is
-exactly one declaration for each used variable.
-\begin{verbatim}
-
-> sharePatternRhs :: ModuleIdent -> Decl -> SimplifyState [Decl]
-> sharePatternRhs m (PatternDecl p t rhs) =
->   case t of
->     VariablePattern _ -> return [PatternDecl p t rhs]
->     _ -> 
->       do
->         v <- freshVar m patternId t
->         return [PatternDecl p t (SimpleRhs p (mkVar v) []),
->                 PatternDecl p (VariablePattern v) rhs]
->   where patternId n = mkIdent ("_#pat" ++ show n)
-> sharePatternRhs _ d = return [d]
-
-> expandPatternBindings :: ModuleIdent -> ValueEnv -> [Ident] -> Decl
->                       -> SimplifyState [Decl]
-> expandPatternBindings m tyEnv fvs (PatternDecl p t (SimpleRhs p' e _)) =
->   case t of
->     VariablePattern _ -> return [PatternDecl p t (SimpleRhs p' e [])]
->     _ ->
->       do
->         fs <- mapM (freshIdent m selectorId n . selectorType ty) (shuffle tys)
->         return (zipWith (projectionDecl p t e) fs (shuffle vs))
->       where n = length vs
->             vs = filter (`elem` fvs) (bv t)
->             ty = typeOf tyEnv t
->             tys = map (typeOf tyEnv) vs
->             selectorType ty0 (ty:tys) =
->               polyType (foldr TypeArrow ty (ty0:tys))
->             selectorDecl p f t (v:vs) =
->               funDecl p f (t:map VariablePattern vs) (mkVar v)
->             projectionDecl p t e f (v:vs) =
->               varDecl p v (Let [selectorDecl p f t (v:vs)]
->                                (apply (mkVar f) (e : map mkVar vs)))
-> expandPatternBindings _ _ _ d = return [d]
-
-\end{verbatim}
-Auxiliary functions
-\begin{verbatim}
-
-> trustedFun :: TrustEnv -> Ident -> Bool
-> trustedFun trEnv f = maybe True (Trust ==) (lookupEnv f trEnv)
-
-> freshIdent :: ModuleIdent -> (Int -> Ident) -> Int -> TypeScheme
->            -> SimplifyState Ident
-> freshIdent m f n ty =
->   do
->     x <- liftM f (liftSt (liftRt (liftRt (updateSt (1 +)))))
->     updateSt_ (bindFun m x n ty)
->     return x
-
-> freshVar :: Typeable a => ModuleIdent -> (Int -> Ident) -> a
->          -> SimplifyState Ident
-> freshVar m f x =
->   do
->     tyEnv <- fetchSt
->     freshIdent m f 0 (monoType (typeOf tyEnv x))
-
-> shuffle :: [a] -> [[a]]
-> shuffle xs = shuffle id xs
->   where shuffle _ [] = []
->         shuffle f (x:xs) = (x : f xs) : shuffle (f . (x:)) xs
-
-> apply :: Expression -> [Expression] -> Expression
-> apply = foldl Apply
-
-> mkVar :: Ident -> Expression
-> mkVar = Variable . qualify
-
-> varDecl :: Position -> Ident -> Expression -> Decl
-> varDecl p v e = PatternDecl p (VariablePattern v) (SimpleRhs p e [])
-
-> funDecl :: Position -> Ident -> [ConstrTerm] -> Expression -> Decl
-> funDecl p f ts e =
->   FunctionDecl p f [Equation p (FunLhs f ts) (SimpleRhs p e [])]
-
-> isVariablePattern :: ConstrTerm -> Bool
-> isVariablePattern (VariablePattern _) = True
-> isVariablePattern _ = False
+> matchExpr :: Either (a,Literal) (a,QualIdent,[Expression a]) -> Expression a
+> matchExpr (Left (ty,l)) = Literal ty l
+> matchExpr (Right (ty,c,es)) = apply (Constructor ty c) es
+
+> bindPattern :: Position
+>             -> Either (QualType,Literal)
+>                       (QualType,QualIdent,[Expression QualType])
+>             -> ConstrTerm QualType -> Expression QualType
+>             -> Expression QualType
+> bindPattern _ (Left _) (LiteralPattern _ _) e' = e'
+> bindPattern p (Right (_,_,es)) (ConstructorPattern _ _ ts) e' =
+>   foldr Let e' [zipWith (patDecl p) ts es]
+> bindPattern p e (VariablePattern ty v) e' =
+>   Let [varDecl p ty v (matchExpr e)] e'
+> bindPattern p e (AsPattern v t) e' = bindPattern p e t (Let [bindAs p v t] e')
+
+> bindAs :: Position -> Ident -> ConstrTerm QualType -> Decl QualType
+> bindAs p v (LiteralPattern ty l) = varDecl p ty v (Literal ty l)
+> bindAs p v (VariablePattern ty v') = varDecl p ty v (mkVar ty v')
+> bindAs p v (ConstructorPattern ty c ts) =
+>   varDecl p ty v (apply (Constructor (toExprType ty ts) c) (map toExpr ts))
+>   where toExpr (VariablePattern ty v) = mkVar ty v
+>         toExprType ty ts =
+>           qualType (foldr (TypeArrow . typeOf) (unqualType ty) ts)
+> bindAs p v (AsPattern v' t') = varDecl p ty v (mkVar ty v')
+>   where ty = qualType (typeOf t')
+
+> prelFailed :: a -> Expression a
+> prelFailed ty = Variable ty (qualifyWith preludeMIdent (mkIdent "failed"))
+
+\end{verbatim}
+Generation of fresh names.
+\begin{verbatim}
+
+> freshVar :: String -> Type -> SimplifyState (QualType,Ident)
+> freshVar prefix ty =
+>   do
+>     v <- liftM mkName (liftRt (liftRt (updateSt (1 +))))
+>     return (qualType ty,v)
+>   where mkName n = renameIdent (mkIdent (prefix ++ show n)) n
+
+\end{verbatim}
+Auxiliary functions.
+\begin{verbatim}
+
+> tuplePattern :: [ConstrTerm QualType] -> ConstrTerm QualType
+> tuplePattern ts =
+>   case ts of
+>     [] -> ConstructorPattern qualUnitType qUnitId []
+>     [t] -> t
+>     _ -> TuplePattern ts
+
+> tupleExpr :: [Expression QualType] -> Expression QualType
+> tupleExpr es =
+>   case es of
+>     [] -> Constructor qualUnitType qUnitId
+>     [e] -> e
+>     _ -> Tuple es
 
 \end{verbatim}
Solo in curry-0.9.11-classful/: SplitModule.lhs
diff -u curry-0.9.11/Subst.lhs curry-0.9.11-classful/Subst.lhs
--- curry-0.9.11/Subst.lhs	2007-06-15 14:16:35.000000000 +0200
+++ curry-0.9.11-classful/Subst.lhs	2007-08-27 08:51:43.000000000 +0200
@@ -1,7 +1,7 @@
 % -*- LaTeX -*-
-% $Id: Subst.lhs 1744 2005-08-23 16:17:12Z wlux $
+% $Id: Subst.lhs 2454 2007-08-23 23:06:53Z wlux $
 %
-% Copyright (c) 2002, Wolfgang Lux
+% Copyright (c) 2002-2007, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{Subst.lhs}
@@ -15,7 +15,8 @@
 substitutions are marked with a boolean flag (see below).
 \begin{verbatim}
 
-> module Subst where
+> module Subst(Subst, idSubst, bindSubst, unbindSubst, compose, substToList,
+>              substVar', IntSubst(..), isubstVar, restrictSubstTo) where
 > import Map
 > import Utils
 
diff -u curry-0.9.11/SyntaxCheck.lhs curry-0.9.11-classful/SyntaxCheck.lhs
--- curry-0.9.11/SyntaxCheck.lhs	2007-06-15 14:16:34.000000000 +0200
+++ curry-0.9.11-classful/SyntaxCheck.lhs	2011-10-08 12:42:57.000000000 +0200
@@ -1,7 +1,7 @@
 % -*- LaTeX -*-
-% $Id: SyntaxCheck.lhs 2146 2007-04-02 08:01:20Z wlux $
+% $Id: SyntaxCheck.lhs 3056 2011-10-07 16:27:03Z wlux $
 %
-% Copyright (c) 1999-2007, Wolfgang Lux
+% Copyright (c) 1999-2011, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{SyntaxCheck.lhs}
@@ -11,82 +11,221 @@
 nullary data constructors and variables, which cannot be done in the
 parser because Curry -- in contrast to many other declarative
 languages -- lacks a capitalization convention. In addition, this pass
-checks for undefined as well as ambiguous variables and constructors.
-Finally, all (adjacent) equations of a function are merged into a
-single definition.
+checks for undefined as well as ambiguous value identifiers. Finally,
+all (adjacent) equations of a function are merged into a single
+definition.
 \begin{verbatim}
 
 > module SyntaxCheck(syntaxCheck,syntaxCheckGoal) where
 > import Base
 > import Char
+> import Curry
 > import CurryPP
+> import CurryUtils
 > import Error
+> import IdentInfo
 > import List
 > import Maybe
 > import Monad
+> import TopEnv
 > import NestEnv
+> import Position
 > import Pretty
 > import Utils
 
 \end{verbatim}
-Syntax checking proceeds as follows. First, the compiler extracts
-information about all imported values and data constructors from the
-imported (type) environments. Next, the data constructors defined in
-the current module are entered into this environment. Finally, all
-declarations are checked within the resulting environment.
-\begin{verbatim}
-
-> syntaxCheck :: ModuleIdent -> ValueEnv -> [TopDecl]
->             -> Error (FunEnv,[TopDecl])
-> syntaxCheck m tyEnv ds =
+In order to check patterns and expressions, the compiler maintains an
+environment that records all known functions, data, and newtype
+constructors. For each nested declaration group in the source code, a
+new scope is opened in this environment. The functions
+\texttt{syntaxCheck} and \texttt{syntaxCheckGoal} expect an
+environment that is already initialized with the imported functions
+and data and newtype constructors. First, the data and newtype
+constructors defined in the current module are added to this
+environment. Then, all declarations are checked within the resulting
+environment and the declared functions and variables are added to
+their respective scopes in the environment. The final top-level
+environment is returned from \texttt{syntaxCheck} in order to be used
+later for checking the optional export list of the current module.
+\begin{verbatim}
+
+> syntaxCheck :: ModuleIdent -> TypeEnv -> FunEnv -> [TopDecl a]
+>             -> Error (FunEnv,[TopDecl a])
+> syntaxCheck m tEnv env ds =
 >   do
 >     reportDuplicates duplicateData repeatedData cs
->     (env',ds') <- checkTopDecls m cs env ds
->     return (toplevelEnv env',ds')
->   where env = foldr (bindConstr m) (globalEnv (fmap valueKind tyEnv)) cs
+>     (env'',ds') <- checkTopDecls m tEnv cs ls env' ds
+>     return (toplevelEnv env'',ds')
+>   where env' = foldr (bindConstr m) (globalEnv env) cs
 >         cs = concatMap constrs ds
+>         ls = concatMap fieldLabels ds
 
-> syntaxCheckGoal :: ValueEnv -> Goal -> Error Goal
-> syntaxCheckGoal tyEnv g = checkGoal (globalEnv (fmap valueKind tyEnv)) g
+> syntaxCheckGoal :: FunEnv -> Goal a -> Error (Goal a)
+> syntaxCheckGoal env g = checkGoal (globalEnv env) g
 
 > bindConstr :: ModuleIdent -> P Ident -> VarEnv -> VarEnv
 > bindConstr m (P _ c) = globalBindNestEnv m c (Constr (qualifyWith m c))
 
+> bindLabel :: ModuleIdent -> (P Ident,[Ident]) -> VarEnv -> VarEnv
+> bindLabel m (P _ l,cs) =
+>   globalBindNestEnv m l (Var (qualifyWith m l) (map (qualifyWith m) cs))
+
 > bindFunc :: ModuleIdent -> P Ident -> VarEnv -> VarEnv
-> bindFunc m (P _ f) = globalBindNestEnv m f (Var (qualifyWith m f))
+> bindFunc m (P _ f) = globalBindNestEnv m f (Var (qualifyWith m f) [])
 
 > bindVar :: P Ident -> VarEnv -> VarEnv
-> bindVar (P _ v) = localBindNestEnv v (Var (qualify v))
+> bindVar (P _ v) = localBindNestEnv v (Var (qualify v) [])
 
 \end{verbatim}
-When a module's global declaration group is checked, the compiler must
-preserve the order of type and value declarations. This is necessary
-in order to detect the error in the following code fragment.
+In each declaration group, the compiler must first disambiguate
+variable and data constructor identifiers on the left hand side so
+that it can distinguish function and pattern declarations. For
+instance, the declaration \texttt{Just x = Nothing} is syntactically
+both a valid function declaration defining the function \texttt{Just}
+and a pattern declaration matching the pattern \texttt{Just x} against
+the expression \texttt{Nothing}. Since no pattern declarations are
+allowed at the top-level of a module, the declaration is unambiguous
+in the global scope. In a local declaration group, we always consider
+the declaration a pattern declaration provided that the Prelude's
+definition of data constructor \texttt{Just} is in scope.
+
+The ambiguity is getting more subtle when infix operator declarations
+and infix patterns are taken into account.\footnote{Infix constructors
+  are an extension supported for compatibility with Haskell. The Curry
+  report~\cite{Hanus:Report} knows only a single infix data
+  constructor, the list constructor \texttt{:}.} Consider a
+declaration \texttt{$t_1$ `op$_1$` $t_2$ $\dots$ $t_n$ `op$_n$` $t_n$
+  = $e$}. If all operators $\texttt{op}_1, \dots, \texttt{op}_n$
+except for a single operator $op_i$ denote a data constructor, this
+declaration is considered a function declaration of \texttt{op$_i$}.
+If more than one operator does not denote a data constructor, the
+declaration is invalid and we arbitrarily choose the leftmost operator
+as root of the left hand side. If all operators denote a data
+constructor, the declaration is considered a pattern declaration, but
+only in a local declaration group. At the top-level, we arbitrarily
+choose the leftmost unqualified operator (if one exists) and consider
+the declaration a function declaration of that operator. Ideally, the
+choice of the left hand side's root operator should be based on the
+relative precedences of the operators, but unfortunately these
+precedences are not known during syntax checking\footnote{Note that
+  this is a principal limitation. Since fixities are associated with
+  entities and not identifiers, the fixity of an operator cannot be
+  known before the compiler knows where the identifier is defined.}.
+For some contrived examples our heuristics means that the compiler may
+choose the wrong root, e.g.,
+\begin{verbatim}
+module A where { infixl 7 :/; data Rat a = a :/ a }
+module M where
+  import A
+  infixl 1 :/; infix 4 :=
+  data Assoc a b = a := b
+  a := _ :/ b = a := b
+\end{verbatim}
+The last line of module \texttt{M} is supposed to define the operator
+\verb|:/| and, in fact, the compiler would accept this declaration if
+the import of module A where omitted. Unfortunately, the import
+declaration brings a data constructor definition for \verb|:/| into
+scope, which means that the compiler will -- wrongly -- consider the
+leftmost unqualified operator, i.e., \verb|:=| the root of the left
+hand side and therefore complain about the redefinition of that
+operator. To avoid this error, the user has to add redundant
+parentheses around the argument term \verb|a := _| or use the
+qualified name \texttt{M.:=} for the first operator.
+
+After disambiguating variable and data constructor identifiers, the
+compiler merges adjacent equations for the same function into a single
+definition. When a module's global declaration group is checked, the
+compiler must be careful to preserve the order of type and value
+declarations; otherwise it would fail to detect the error in the
+following code fragment.
 \begin{verbatim}
   f = 0
   data T = C
   f = 1
 \end{verbatim}
-This error would go by unnoticed if the compiler would partition
-top-level declarations into type and value declarations.
-Unfortunately, this means that we cannot use \texttt{checkLocalDecls}
-in order to check the global declaration group.
-\begin{verbatim}
-
-> checkTopDecls :: ModuleIdent -> [P Ident] -> VarEnv -> [TopDecl]
->               -> Error (VarEnv,[TopDecl])
-> checkTopDecls m cs env ds =
->   do
->     ds' <- liftE joinTopEquations (mapE (checkTopDeclLhs env) ds)
->     env' <- checkDeclVars (bindFunc m) cs env [d | BlockDecl d <- ds']
->     ds'' <- mapE (checkTopDeclRhs env') ds'
->     return (env',ds'')
-
-> checkTopDeclLhs :: VarEnv -> TopDecl -> Error TopDecl
-> checkTopDeclLhs env (BlockDecl d) = liftE BlockDecl (checkDeclLhs True env d)
-> checkTopDeclLhs _ d = return d
+Next, the compiler checks that there is a corresponding value
+definition for every fixity declaration, type signature, and trust
+annotation in this group and that there are no duplicate definitions.
+Finally, each declaration of the group is checked.
+
+Without function patterns it would be safe to report undefined data
+constructors already during disambiguation because data constructors
+can be defined only in top-level declarations and pattern declarations
+are valid only in local declaration groups. However, a function
+pattern in a pattern declaration might use a function defined in the
+same declaration group, e.g.\ \texttt{let dup x = (x,x); (dup z) = e
+  in z}.\footnote{The parentheses around \texttt{(dup z)} are
+  necessary to make the declaration a pattern declaration.}
+Therefore, we can report undefined identifiers only after determining
+the bound identifiers of the current declaration group.
+
+Note that fixity declarations for class methods can occur either at
+the top-level of a module or in the class declaration itself
+(cf.\ Sect.~4.4.2 of the revised Haskell'98
+report~\cite{PeytonJones03:Haskell}). In order to detect duplicate
+fixity declarations for class methods, the relevant top-level fixity
+declarations are passed to \texttt{checkMethodDecls}.
+\begin{verbatim}
+
+> checkTopDecls :: ModuleIdent -> TypeEnv -> [P Ident] -> [(P Ident,[Ident])]
+>               -> VarEnv -> [TopDecl a] -> Error (VarEnv,[TopDecl a])
+> checkTopDecls m tEnv cs ls env ds =
+>   do
+>     ds' <- liftE joinTopEquations (mapE (disambTopDecl env) ds)
+>     env'' <- checkDeclVars (bindFunc m) xs (concatMap mthds ds') env'
+>                            [d | BlockDecl d <- ds']
+>     ds'' <- mapE (checkTopDecl tEnv env'' ops) ds'
+>     return (env'',ds'')
+>   where ops = [P p op | BlockDecl (InfixDecl p _ _ ops) <- ds, op <- ops]
+>         env' = foldr (bindLabel m) env ls
+>         xs = mergeBy comparePos cs (map fst ls)
+
+> disambTopDecl :: VarEnv -> TopDecl a -> Error (TopDecl a)
+> disambTopDecl _ (DataDecl p cx tc tvs cs clss) =
+>   return (DataDecl p cx tc tvs cs clss)
+> disambTopDecl _ (NewtypeDecl p cx tc tvs nc clss) =
+>   return (NewtypeDecl p cx tc tvs nc clss)
+> disambTopDecl _ (TypeDecl p tc tvs ty) = return (TypeDecl p tc tvs ty)
+> disambTopDecl _ (ClassDecl p cx cls tv ds) = return (ClassDecl p cx cls tv ds)
+> disambTopDecl _ (InstanceDecl p cx cls ty ds) =
+>   return (InstanceDecl p cx cls ty ds)
+> disambTopDecl _ (DefaultDecl p tys) = return (DefaultDecl p tys)
+> disambTopDecl env (BlockDecl d) = liftE BlockDecl (disambBlockDecl env d)
+
+> disambBlockDecl :: VarEnv -> Decl a -> Error (Decl a)
+> disambBlockDecl _ (InfixDecl p fix pr ops) = return (InfixDecl p fix pr ops)
+> disambBlockDecl _ (TypeSig p vs ty) = return (TypeSig p vs ty)
+> disambBlockDecl env (FunctionDecl p a _ [Equation p' lhs rhs]) =
+>   case disambLhs env a lhs of
+>     Left (a',f',lhs') -> return (funDecl a' f' lhs')
+>     Right t' ->
+>       case msum (map toFunLhs (terms t')) of
+>         Just (f',lhs') -> return (funDecl a f' lhs')
+>         Nothing -> errorAt p noToplevelPattern
+>   where funDecl a f lhs = FunctionDecl p a f [Equation p' lhs rhs]
+> disambBlockDecl _ (ForeignDecl p fi a f ty) = return (ForeignDecl p fi a f ty)
+> --disambBlockDecl _ (PatternDecl p _ _) = errorAt p noToplevelPattern
+> --disambBlockDecl _ (FreeDecl p _) = errorAt p noToplevelFree
+> disambBlockDecl _ (TrustAnnot p t fs) = return (TrustAnnot p t fs)
+
+> terms :: ConstrTerm a -> [ConstrTerm a]
+> terms t = t :
+>   case t of
+>     InfixPattern a1 t1 op1 (InfixPattern a2 t2 op2 t3) ->
+>       terms (InfixPattern a2 (InfixPattern a1 t1 op1 t2) op2 t3)
+>     _ -> []
+
+> toFunLhs :: ConstrTerm a -> Maybe (Ident,Lhs a)
+> toFunLhs t =
+>   case t of
+>     VariablePattern _ v -> Just (v,FunLhs v [])
+>     ConstructorPattern _ c ts -> funLhs (\f -> FunLhs f ts) c
+>     InfixPattern _ t1 (InfixConstr _ op) t2 -> funLhs (\f -> OpLhs t1 f t2) op
+>     _ -> Nothing
+>   where funLhs lhs c = maybe (Just (f,lhs f)) (const Nothing) m
+>           where (m,f) = splitQualIdent c
 
-> joinTopEquations :: [TopDecl] -> [TopDecl]
+> joinTopEquations :: [TopDecl a] -> [TopDecl a]
 > joinTopEquations [] = []
 > joinTopEquations (d : ds)
 >   | isBlockDecl d =
@@ -95,9 +234,41 @@
 >   | otherwise = d : joinTopEquations ds
 >   where (ds',ds'') = span isBlockDecl ds
 
-> checkTopDeclRhs :: VarEnv -> TopDecl -> Error TopDecl
-> checkTopDeclRhs env (BlockDecl d) = liftE BlockDecl (checkDeclRhs env d)
-> checkTopDeclRhs _ d = return d
+> checkTopDecl :: TypeEnv -> VarEnv -> [P Ident] -> TopDecl a
+>                 -> Error (TopDecl a)
+> checkTopDecl _ _ _ (DataDecl p cx tc tvs cs clss) =
+>   mapE_ checkDeclLabels cs >> return (DataDecl p cx tc tvs cs clss)
+> checkTopDecl _ _ _ (NewtypeDecl p cx tc tvs nc clss) =
+>   return (NewtypeDecl p cx tc tvs nc clss)
+> checkTopDecl _ _ _ (TypeDecl p tc tvs ty) = return (TypeDecl p tc tvs ty)
+> checkTopDecl _ env ops (ClassDecl p cx cls tv ds) =
+>   liftE (ClassDecl p cx cls tv)
+>         (checkMethodDecls env (qualify cls) (filter (`elem` fs) ops) fs ds)
+>   where fs = mthds (ClassDecl p cx cls tv ds)
+> checkTopDecl tEnv env _ (InstanceDecl p cx cls ty ds) =
+>   liftE (InstanceDecl p cx cls ty) (checkMethodDecls env cls [] fs ds)
+>   where fs = map (P p) (classMthds cls tEnv)
+> checkTopDecl _ _ _ (DefaultDecl p tys) = return (DefaultDecl p tys)
+> checkTopDecl _ env _ (BlockDecl d) = liftE BlockDecl (checkDecl env d)
+
+\end{verbatim}
+The compiler checks field labels in data type declarations twice
+because field labels must be globally unique and also must be unique
+for each constructor declaration, but the same label may be used in
+different constructors of the same data type. Global uniqueness is
+checked in function \texttt{checkDeclVars}, which also ensures that
+there are no conflicts between field labels and global functions,
+whereas the function \texttt{checkDeclLabels} below checks that each
+field label occurs at most once in a particular data constructor
+declaration.
+\begin{verbatim}
+
+> checkDeclLabels :: ConstrDecl -> Error ()
+> checkDeclLabels (ConstrDecl _ _ _ _ _) = return ()
+> checkDeclLabels (ConOpDecl _ _ _ _ _ _) = return ()
+> checkDeclLabels (RecordDecl p evs cx c fs) =
+>   mapE_ (errorAt p . duplicateLabel "declaration" . fst)
+>         (duplicates (labels (RecordDecl p evs cx c fs)))
 
 \end{verbatim}
 A goal is checked like the right hand side of a pattern declaration.
@@ -105,119 +276,102 @@
 declarations. The final environment can be discarded.
 \begin{verbatim}
 
-> checkGoal :: VarEnv -> Goal -> Error Goal
+> checkGoal :: VarEnv -> Goal a -> Error (Goal a)
 > checkGoal env (Goal p e ds) =
 >   do
 >     (env',ds') <- checkLocalDecls env ds
 >     e' <- checkExpr p env' e
 >     return (Goal p e' ds')
 
-\end{verbatim}
-In each declaration group, first the left hand sides of all
-declarations are checked and adjacent equations for the same function
-are merged into a single definition. Next, the compiler checks that
-there is a corresponding value definition for every fixity
-declaration, type signature, and trust annotation in this group and
-that there are no duplicate definitions. Finally, the right hand sides
-are checked.
-
-The function \texttt{checkDeclLhs} also handles the case where a
-pattern declaration is recognized as a function declaration by the
-parser. This happens, e.g., for the declaration \verb|Just x = y|
-because the parser cannot distinguish nullary constructors and
-functions. Note that pattern declarations are not allowed on the
-top-level.
-\begin{verbatim}
-
-> checkLocalDecls :: VarEnv -> [Decl] -> Error (VarEnv,[Decl])
+> checkLocalDecls :: VarEnv -> [Decl a] -> Error (VarEnv,[Decl a])
 > checkLocalDecls env ds =
 >   do
->     ds' <- liftE joinEquations (mapE (checkDeclLhs False env') ds)
->     env'' <- checkDeclVars bindVar [] env' ds'
->     ds'' <- mapE (checkDeclRhs env'') ds'
->     return (env'',ds'')
->   where env' = nestEnv env
+>     env' <- checkDeclVars bindVar [] [] (nestEnv env) ds'
+>     ds'' <- mapE (checkDecl env') ds'
+>     return (env',ds'')
+>   where ds' = joinEquations (map (disambDecl env) ds)
 
-> checkDeclLhs :: Bool -> VarEnv -> Decl -> Error Decl
-> checkDeclLhs _ _ (InfixDecl p fix pr ops) = return (InfixDecl p fix pr ops)
-> checkDeclLhs _ env (TypeSig p vs ty) =
->   do
->     checkVars "type signature" p env vs
->     return (TypeSig p vs ty)
-> checkDeclLhs top env (FunctionDecl p _ eqs) = checkEquationLhs top env p eqs
-> checkDeclLhs _ env (ForeignDecl p cc s ie f ty) =
->   do
->     checkVars "foreign declaration" p env [f]
->     return (ForeignDecl p cc s ie f ty)
-> checkDeclLhs top env (PatternDecl p t rhs)
->   | top = internalError "checkDeclLhs"
->   | otherwise = liftE (flip (PatternDecl p) rhs) (checkConstrTerm p env t)
-> checkDeclLhs top env (FreeDecl p vs)
->   | top = internalError "checkDeclLhs"
->   | otherwise =
->       do
->         checkVars "free variables declaration" p env vs
->         return (FreeDecl p vs)
-> checkDeclLhs top env (TrustAnnot p t fs) =
->   do
->     maybe (return ()) (checkVars "trust annotation" p env) fs
->     return (TrustAnnot p t fs)
-
-> checkEquationLhs :: Bool -> VarEnv -> Position -> [Equation] -> Error Decl
-> checkEquationLhs top env p [Equation p' lhs rhs] =
->   either funDecl patDecl (checkEqLhs env p' lhs)
->   where funDecl (f,lhs)
->           | isDataConstr env f =
->               errorAt p (nonVariable "curried definition" f)
->           | otherwise = return (FunctionDecl p f [Equation p' lhs rhs])
->         patDecl t
->           | top = errorAt p noToplevelPattern
->           | otherwise = checkDeclLhs top env (PatternDecl p' t rhs)
-> checkEquationLhs _ _ _ _ = internalError "checkEquationLhs"
-
-> checkEqLhs :: VarEnv -> Position -> Lhs -> Either (Ident,Lhs) ConstrTerm
-> checkEqLhs env _ (FunLhs f ts)
->   | isDataConstr env f = Right (ConstructorPattern (qualify f) ts)
->   | otherwise = Left (f,FunLhs f ts)
-> checkEqLhs env _ (OpLhs t1 op t2)
->   | isDataConstr env op = checkOpLhs env (infixPattern t1 (qualify op)) t2
->   | otherwise = Left (op,OpLhs t1 op t2)
->   where infixPattern (InfixPattern t1 op1 t2) op2 t3 =
->           InfixPattern t1 op1 (infixPattern t2 op2 t3)
->         infixPattern t1 op t2 = InfixPattern t1 op t2
-> checkEqLhs env p (ApLhs lhs ts) =
->   case checkEqLhs env p lhs of
->     Left (f',lhs') -> Left (f',ApLhs lhs' ts)
->     Right _ -> Left (f,ApLhs lhs ts)
+> disambDecl :: VarEnv -> Decl a -> Decl a
+> disambDecl _ (InfixDecl p fix pr ops) = InfixDecl p fix pr ops
+> disambDecl _ (TypeSig p vs ty) = TypeSig p vs ty
+> disambDecl env (FunctionDecl p a _ [Equation p' lhs rhs]) =
+>   case disambLhs env a lhs of
+>     Left (a',f',lhs') -> FunctionDecl p a' f' [Equation p' lhs' rhs]
+>     Right t' -> PatternDecl p' (disambTerm env t') rhs
+> disambDecl _ (ForeignDecl p fi a f ty) = ForeignDecl p fi a f ty
+> disambDecl env (PatternDecl p t rhs) = PatternDecl p (disambTerm env t) rhs
+> disambDecl _ (FreeDecl p vs) = FreeDecl p vs
+> disambDecl _ (TrustAnnot p t fs) = TrustAnnot p t fs
+
+> disambLhs :: VarEnv -> a -> Lhs a -> Either (a,Ident,Lhs a) (ConstrTerm a)
+> disambLhs env a (FunLhs f ts)
+>   | isDataConstr env f = Right (ConstructorPattern a (qualify f) ts)
+>   | otherwise = Left (a,f,FunLhs f ts)
+> disambLhs env a (OpLhs t1 op t2)
+>   | isDataConstr env op =
+>       disambOpLhs env (infixPattern t1 (InfixConstr () (qualify op))) t2
+>   | otherwise = Left (a,op,OpLhs t1 op t2)
+>   where infixPattern (InfixPattern a t1 op1 t2) op2 t3 =
+>           InfixPattern a t1 op1 (infixPattern t2 op2 t3)
+>         infixPattern t1 op t2 = InfixPattern a t1 op t2
+> disambLhs env a (ApLhs lhs ts) =
+>   case disambLhs env a lhs of
+>     Left (a',f',lhs') -> Left (a',f',ApLhs lhs' ts)
+>     Right _ -> Left (a,f,ApLhs lhs ts)
 >   where (f,_) = flatLhs lhs
 
-> checkOpLhs :: VarEnv -> (ConstrTerm -> ConstrTerm) -> ConstrTerm
->            -> Either (Ident,Lhs) ConstrTerm
-> checkOpLhs env f (InfixPattern t1 op t2)
+> disambOpLhs :: VarEnv -> (ConstrTerm a -> ConstrTerm a) -> ConstrTerm a
+>             -> Either (a,Ident,Lhs a) (ConstrTerm a)
+> disambOpLhs env f (InfixPattern a t1 op t2)
 >   | isJust m || isDataConstr env op' =
->       checkOpLhs env (f . InfixPattern t1 op) t2
->   | otherwise = Left (op',OpLhs (f t1) op' t2)
->   where (m,op') = splitQualIdent op
-> checkOpLhs _ f t = Right (f t)
-
-> checkVars :: String -> Position -> VarEnv -> [Ident] -> Error ()
-> checkVars what p env vs =
->   mapE_ (errorAt p . nonVariable what) (nub (filter (isDataConstr env) vs))
-
-> checkDeclVars :: (P Ident -> VarEnv -> VarEnv) -> [P Ident] -> VarEnv
->               -> [Decl] -> Error VarEnv
-> checkDeclVars bindVar cs env ds =
+>       disambOpLhs env (f . InfixPattern a t1 op) t2
+>   | otherwise = Left (a,op',OpLhs (f t1) op' t2)
+>   where (m,op') = splitQualIdent (opName op)
+> disambOpLhs _ f t = Right (f t)
+
+> disambTerm :: VarEnv -> ConstrTerm a -> ConstrTerm a
+> disambTerm _ (LiteralPattern a l) = LiteralPattern a l
+> disambTerm _ (NegativePattern a l) = NegativePattern a l
+> disambTerm env (VariablePattern a v)
+>   | v == anonId = VariablePattern a v
+>   | otherwise = disambTerm env (ConstructorPattern a (qualify v) [])
+> disambTerm env (ConstructorPattern a c ts)
+>   | any isConstr (qualLookupNestEnv c env) = ConstructorPattern a c ts'
+>   | not (isQualified c) && null ts = VariablePattern a (unqualify c)
+>   | otherwise = FunctionPattern a c ts'
+>   where ts' = map (disambTerm env) ts
+> disambTerm env (FunctionPattern a f ts) =
+>   disambTerm env (ConstructorPattern a f ts)
+> disambTerm env (InfixPattern a t1 op t2) =
+>   InfixPattern a t1' (disambOp env (opName op)) t2'
+>   where t1' = disambTerm env t1
+>         t2' = disambTerm env t2
+>         disambOp env op
+>           | any isConstr (qualLookupNestEnv op env) = InfixConstr () op
+>           | otherwise = InfixOp () op
+> disambTerm env (ParenPattern t) = ParenPattern (disambTerm env t)
+> disambTerm env (RecordPattern a c fs) =
+>   RecordPattern a c [Field l (disambTerm env t) | Field l t <- fs]
+> disambTerm env (TuplePattern ts) = TuplePattern (map (disambTerm env) ts)
+> disambTerm env (ListPattern a ts) = ListPattern a (map (disambTerm env) ts)
+> disambTerm env (AsPattern v t) = AsPattern v (disambTerm env t)
+> disambTerm env (LazyPattern t) = LazyPattern (disambTerm env t)
+
+> checkDeclVars :: (P Ident -> VarEnv -> VarEnv) -> [P Ident] -> [P Ident]
+>               -> VarEnv -> [Decl a] -> Error VarEnv
+> checkDeclVars bindVar xs fs env ds =
 >   reportDuplicates duplicatePrecedence repeatedPrecedence ops &&>
->   reportDuplicates duplicateDefinition repeatedDefinition bvs &&>
+>   reportDuplicates duplicateDefinition repeatedDefinition
+>                    (mergeBy comparePos xs (mergeBy comparePos fs bvs)) &&>
 >   reportDuplicates duplicateTypeSig repeatedTypeSig tys &&>
 >   reportDuplicates (const duplicateDefaultTrustAnnot)
 >                    (const repeatedDefaultTrustAnnot)
->                    [P p () | TrustAnnot p _ Nothing <- ds] &&>
+>                    [P p () | TrustAnnot p _ [] <- ds] &&>
 >   reportDuplicates duplicateTrustAnnot repeatedTrustAnnot trs &&>
 >   mapE_ (\(P p v) -> errorAt p (noBody v))
->         (filter (`notElem` cs ++ bvs) ops ++
+>         (filter (`notElem` xs ++ fs ++ bvs) ops ++
 >          filter (`notElem` bvs) (tys ++ trs)) &&>
->   return (foldr bindVar env (nub bvs))
+>   return (foldr bindVar env (fs ++ bvs))
 >   where bvs = concatMap vars (filter isValueDecl ds)
 >         tys = concatMap vars (filter isTypeSig ds)
 >         trs = concatMap vars (filter isTrustAnnot ds)
@@ -229,26 +383,32 @@
   foreign functions.}
 \begin{verbatim}
 
-> checkDeclRhs :: VarEnv -> Decl -> Error Decl
-> checkDeclRhs env (FunctionDecl p f eqs) =
->   unless (sameArity eqs) (errorAt p (differentArity f)) &&>
->   liftE (FunctionDecl p f) (mapE (checkEquation env) eqs)
+> checkDecl :: VarEnv -> Decl a -> Error (Decl a)
+> checkDecl _ (InfixDecl p fix pr ops) = return (InfixDecl p fix pr ops)
+> checkDecl _ (TypeSig p fs ty) = return (TypeSig p fs ty)
+> checkDecl env (FunctionDecl p a f eqs) =
+>   checkArity p f eqs &&>
+>   liftE (FunctionDecl p a f) (mapE (checkEquation env) eqs)
+> checkDecl _ (ForeignDecl p fi a f ty) =
+>   do
+>     fi' <- checkForeign p f fi
+>     return (ForeignDecl p fi' a f ty)
+> checkDecl env (PatternDecl p t rhs) =
+>   liftE2 (PatternDecl p) (checkConstrTerm p env t) (checkRhs env rhs)
+> checkDecl _ (FreeDecl p vs) = return (FreeDecl p vs)
+> checkDecl _ (TrustAnnot p tr fs) = return (TrustAnnot p tr fs)
+
+> checkArity :: Position -> Ident -> [Equation a] -> Error ()
+> checkArity p f eqs = unless (sameArity eqs) (errorAt p (differentArity f))
 >   where sameArity = null . tail . nub . map eqnArity
-> checkDeclRhs env (PatternDecl p t rhs) =
->   liftE (PatternDecl p t) (checkRhs env rhs)
-> checkDeclRhs _ (ForeignDecl p cc s ie f ty) =
->   do
->     ie' <- checkForeign p f cc ie
->     return (ForeignDecl p cc s ie' f ty)
-> checkDeclRhs _ d = return d
 
-> joinEquations :: [Decl] -> [Decl]
+> joinEquations :: [Decl a] -> [Decl a]
 > joinEquations [] = []
-> joinEquations (FunctionDecl p f eqs : FunctionDecl p' f' [eq] : ds)
->   | f == f' = joinEquations (FunctionDecl p f (eqs ++ [eq]) : ds)
+> joinEquations (FunctionDecl p a f eqs : FunctionDecl p' _ f' [eq] : ds)
+>   | f == f' = joinEquations (FunctionDecl p a f (eqs ++ [eq]) : ds)
 > joinEquations (d : ds) = d : joinEquations ds
 
-> checkEquation :: VarEnv -> Equation -> Error Equation
+> checkEquation :: VarEnv -> Equation a -> Error (Equation a)
 > checkEquation env (Equation p lhs rhs) =
 >   do
 >     (env',lhs') <- checkLhs p env lhs
@@ -256,6 +416,41 @@
 >     return (Equation p lhs' rhs')
 
 \end{verbatim}
+The method declarations in an instance declaration and also the
+default method declarations in a class declaration are checked like
+any other declaration group except that the declared methods are not
+added to the variable name environment. Instead, the compiler checks
+that the declared methods are members of the specified class. Note
+that in an instance declaration the method names are required to be in
+scope, but the name under which a method is in scope is immaterial
+(cf.\ Sect.~4.3.2 of the revised Haskell'98
+report~\cite{PeytonJones03:Haskell}).
+\begin{verbatim}
+
+> checkMethodDecls :: VarEnv -> QualIdent -> [P Ident] -> [P Ident] -> [Decl a]
+>                  -> Error [Decl a]
+> checkMethodDecls env cls ops fs ds =
+>   do
+>     ds' <- liftE joinEquations (mapE (disambBlockDecl env) ds)
+>     checkMethods cls ops fs ds'
+>     mapE (checkDecl env) ds'
+
+> checkMethods :: QualIdent -> [P Ident] -> [P Ident] -> [Decl a] -> Error ()
+> checkMethods cls ops fs ds =
+>   reportDuplicates duplicatePrecedence repeatedPrecedence (ops ++ ops') &&>
+>   reportDuplicates duplicateDefinition repeatedDefinition fs' &&>
+>   reportDuplicates (const duplicateDefaultTrustAnnot)
+>                    (const repeatedDefaultTrustAnnot)
+>                    [P p () | TrustAnnot p _ [] <- ds] &&>
+>   reportDuplicates duplicateTrustAnnot repeatedTrustAnnot trs &&>
+>   mapE_ (\(P p f) -> errorAt p (undefinedMethod cls f))
+>         (filter (`notElem` fs) (ops' ++ fs')) &&>
+>     mapE_ (\(P p f) -> errorAt p (noBody f)) (filter (`notElem` fs') trs)
+>   where fs' = [P p f | FunctionDecl p _ f _ <- ds]
+>         ops' = concatMap vars (filter isInfixDecl ds)
+>         trs = concatMap vars (filter isTrustAnnot ds)
+
+\end{verbatim}
 The syntax checker examines the optional import specification of
 foreign function declarations. For functions using the \texttt{ccall}
 and \texttt{rawcall} calling conventions, the syntax from the Haskell
@@ -265,17 +460,16 @@
 runtime system.
 \begin{verbatim}
 
-> checkForeign :: Position -> Ident -> CallConv -> Maybe String
->              -> Error (Maybe String)
-> checkForeign p f cc ie
->   | cc == CallConvPrimitive = return ie
+> checkForeign :: Position -> Ident -> ForeignImport -> Error ForeignImport
+> checkForeign p f (cc,s,ie)
+>   | cc == CallConvPrimitive = return (cc,s,ie)
 >   | otherwise =
->       maybe (checkFunName f >> return Nothing)
->             (impEnt . words . join . break ('&' ==))
+>       maybe (checkFunName f >> return (cc,s,Nothing))
+>             (impEnt cc s . words . join . break ('&' ==))
 >             ie
 >   where join (cs,[]) = cs
 >         join (cs,c':cs') = cs ++ [' ',c',' '] ++ cs'
->         impEnt ie = kind ie >> return (Just (unwords ie))
+>         impEnt cc s ie = kind ie >> return (cc,s,Just (unwords ie))
 >         kind [] = ident []
 >         kind (x:xs)
 >           | x == "static" = header xs
@@ -307,14 +501,14 @@
 >         isLetNum c = isLetter c || isDigit c
 >         isHeaderChar c = isLetNum c || c `elem` "!#$%*+./<=>?@\\^|-~"
 
-> checkLhs :: Position -> VarEnv -> Lhs -> Error (VarEnv,Lhs)
+> checkLhs :: Position -> VarEnv -> Lhs a -> Error (VarEnv,Lhs a)
 > checkLhs p env lhs =
 >   do
 >     lhs' <- checkLhsTerm p env lhs
 >     env' <- checkBoundVars p env lhs'
 >     return (env',lhs')
 
-> checkLhsTerm :: Position -> VarEnv -> Lhs -> Error Lhs
+> checkLhsTerm :: Position -> VarEnv -> Lhs a -> Error (Lhs a)
 > checkLhsTerm p env (FunLhs f ts) =
 >   liftE (FunLhs f) (mapE (checkConstrTerm p env) ts)
 > checkLhsTerm p env (OpLhs t1 op t2) =
@@ -322,14 +516,15 @@
 > checkLhsTerm p env (ApLhs lhs ts) =
 >   liftE2 ApLhs (checkLhsTerm p env lhs) (mapE (checkConstrTerm p env) ts)
 
-> checkArg :: Position -> VarEnv -> ConstrTerm -> Error (VarEnv,ConstrTerm)
+> checkArg :: Position -> VarEnv -> ConstrTerm a -> Error (VarEnv,ConstrTerm a)
 > checkArg p env t =
 >   do
 >     t' <- checkConstrTerm p env t
 >     env' <- checkBoundVars p env t'
 >     return (env',t')
 
-> checkArgs :: Position -> VarEnv -> [ConstrTerm] -> Error (VarEnv,[ConstrTerm])
+> checkArgs :: Position -> VarEnv -> [ConstrTerm a]
+>           -> Error (VarEnv,[ConstrTerm a])
 > checkArgs p env ts =
 >   do
 >     ts' <- mapE (checkConstrTerm p env) ts
@@ -343,44 +538,66 @@
 >     return (foldr (bindVar . P p) (nestEnv env) bvs)
 >   where bvs = bv ts
 
-> checkConstrTerm :: Position -> VarEnv -> ConstrTerm -> Error ConstrTerm
-> checkConstrTerm _ _ (LiteralPattern l) = return (LiteralPattern l)
-> checkConstrTerm _ _ (NegativePattern op l) = return (NegativePattern op l)
-> checkConstrTerm p env (VariablePattern v)
->   | v == anonId = return (VariablePattern v)
->   | otherwise = checkConstrTerm p env (ConstructorPattern (qualify v) [])
-> checkConstrTerm p env (ConstructorPattern c ts) =
->   liftE2 ($)
->          (case qualLookupNestEnv c env of
->             [Constr _] -> return (ConstructorPattern c)
->             rs
->               | any isConstr rs -> errorAt p (ambiguousData rs c)
->               | not (isQualified c) && null ts ->
->                   return (const (VariablePattern (unqualify c)))
->               | otherwise -> errorAt p (undefinedData c))
->          (mapE (checkConstrTerm p env) ts)
-> checkConstrTerm p env (InfixPattern t1 op t2) =
->   liftE3 ($)
->          (case qualLookupNestEnv op env of
->             [Constr _] -> return (flip InfixPattern op)
->             rs
->               | any isConstr rs -> errorAt p (ambiguousData rs op)
->               | otherwise -> errorAt p (undefinedData op))
+> checkConstrTerm :: Position -> VarEnv -> ConstrTerm a -> Error (ConstrTerm a)
+> checkConstrTerm _ _ (LiteralPattern a l) = return (LiteralPattern a l)
+> checkConstrTerm _ _ (NegativePattern a l) = return (NegativePattern a l)
+> checkConstrTerm p env (VariablePattern a v)
+>   | v == anonId = return (VariablePattern a v)
+>   | otherwise = checkConstrTerm p env (ConstructorPattern a (qualify v) [])
+> checkConstrTerm p env (ConstructorPattern a c ts)
+>   | not (isQualified c) && null ts =
+>       case qualLookupNestEnv c env of
+>         [Constr _] -> return (ConstructorPattern a c [])
+>         rs
+>           | any isConstr rs -> errorAt p (ambiguousData rs c)
+>           | otherwise -> return (VariablePattern a (unqualify c))
+>   | otherwise =
+>       liftE2 ($)
+>              (case qualLookupNestEnv c env of
+>                 [] -> errorAt p (undefinedData c)
+>                 [Constr _] -> return (ConstructorPattern a c)
+>                 [Var _ _] -> return (FunctionPattern a c)
+>                 rs
+>                   | any isConstr rs -> errorAt p (ambiguousData rs c)
+>                   | otherwise -> errorAt p (ambiguousFunction rs c))
+>              (mapE (checkConstrTerm p env) ts)
+> checkConstrTerm p env (FunctionPattern a f ts) =
+>   checkConstrTerm p env (ConstructorPattern a f ts)
+> checkConstrTerm p env (InfixPattern a t1 op t2) =
+>   liftE3 (InfixPattern a)
 >          (checkConstrTerm p env t1)
+>          (case qualLookupNestEnv op' env of
+>             [] -> errorAt p (undefinedData op')
+>             [Constr _] -> return (InfixConstr () op')
+>             [Var _ _] -> return (InfixOp () op')
+>             rs
+>               | any isConstr rs -> errorAt p (ambiguousData rs op')
+>               | otherwise -> errorAt p (ambiguousFunction rs op'))
 >          (checkConstrTerm p env t2)
+>   where op' = opName op
 > checkConstrTerm p env (ParenPattern t) =
 >   liftE ParenPattern (checkConstrTerm p env t)
+> checkConstrTerm p env (RecordPattern a c fs) =
+>   do
+>     fs' <-
+>       (case qualLookupNestEnv c env of
+>          [Constr _] -> return ()
+>          rs
+>            | any isConstr rs -> errorAt p (ambiguousData rs c)
+>            | otherwise -> errorAt p (undefinedData c)) &&>
+>       mapE (checkField (checkConstrTerm p env)) fs
+>     checkFieldLabels "pattern" p env (Just c) fs'
+>     return (RecordPattern a c fs')
 > checkConstrTerm p env (TuplePattern ts) =
 >   liftE TuplePattern (mapE (checkConstrTerm p env) ts)
-> checkConstrTerm p env (ListPattern ts) =
->   liftE ListPattern (mapE (checkConstrTerm p env) ts)
+> checkConstrTerm p env (ListPattern a ts) =
+>   liftE (ListPattern a) (mapE (checkConstrTerm p env) ts)
 > checkConstrTerm p env (AsPattern v t) =
->   checkVars "@ pattern" p env [v] &&>
 >   liftE (AsPattern v) (checkConstrTerm p env t)
 > checkConstrTerm p env (LazyPattern t) =
 >   liftE LazyPattern (checkConstrTerm p env t)
 
-> checkRhs :: VarEnv -> Rhs -> Error Rhs
+> checkRhs :: VarEnv -> Rhs a -> Error (Rhs a)
 > checkRhs env (SimpleRhs p e ds) =
 >   do
 >     (env',ds') <- checkLocalDecls env ds
@@ -392,26 +609,49 @@
 >     es' <- mapE (checkCondExpr env') es
 >     return (GuardedRhs es' ds')
 
-> checkCondExpr :: VarEnv -> CondExpr -> Error CondExpr
+> checkCondExpr :: VarEnv -> CondExpr a -> Error (CondExpr a)
 > checkCondExpr env (CondExpr p g e) =
 >   liftE2 (CondExpr p) (checkExpr p env g) (checkExpr p env e)
 
-> checkExpr :: Position -> VarEnv -> Expression -> Error Expression
-> checkExpr _ _ (Literal l) = return (Literal l)
-> checkExpr p env (Variable v) =
->   case qualLookupNestEnv v env of
->     [] -> errorAt p (undefinedVariable v)
->     [Constr _] -> return (Constructor v)
->     [Var _] -> return (Variable v)
->     rs -> errorAt p (ambiguousIdent rs v)
-> checkExpr p env (Constructor c) = checkExpr p env (Variable c)
+> checkExpr :: Position -> VarEnv -> Expression a -> Error (Expression a)
+> checkExpr _ _ (Literal a l) = return (Literal a l)
+> checkExpr p env (Variable a v)
+>   | unqualify v == anonId = return (Variable a v)
+>   | otherwise =
+>       case qualLookupNestEnv v env of
+>         [] -> errorAt p (undefinedVariable v)
+>         [Constr _] -> return (Constructor a v)
+>         [Var _ _] -> return (Variable a v)
+>         rs -> errorAt p (ambiguousIdent rs v)
+> checkExpr p env (Constructor a c) = checkExpr p env (Variable a c)
 > checkExpr p env (Paren e) = liftE Paren (checkExpr p env e)
 > checkExpr p env (Typed e ty) = liftE (flip Typed ty) (checkExpr p env e)
+> checkExpr p env (Record a c fs)
+>   | null fs =
+>       case qualLookupNestEnv c env of
+>         [Constr _] -> return (Record a c [])
+>         rs
+>           | any isConstr rs -> errorAt p (ambiguousData rs c)
+>           | otherwise -> errorAt p (undefinedData c)
+>   | otherwise = checkExpr p env (RecordUpdate (Constructor a c) fs)
+> checkExpr p env (RecordUpdate e fs) =
+>   do
+>     (e',fs') <-
+>       liftE (,) (checkExpr p env e) &&& mapE (checkField (checkExpr p env)) fs
+>     case e' of
+>       Constructor a c ->
+>         do
+>           checkFieldLabels "construction" p env (Just c) fs'
+>           return (Record a c fs')
+>       _ ->
+>         do
+>           checkFieldLabels "update" p env Nothing fs'
+>           return (RecordUpdate e' fs')
 > checkExpr p env (Tuple es) = liftE Tuple (mapE (checkExpr p env) es)
-> checkExpr p env (List es) = liftE List (mapE (checkExpr p env) es)
+> checkExpr p env (List a es) = liftE (List a) (mapE (checkExpr p env) es)
 > checkExpr p env (ListCompr e qs) =
 >   do
->     (env',qs') <- mapAccumM (checkStatement p) env qs
+>     (env',qs') <- mapAccumM (checkStmt p) env qs
 >     e' <- checkExpr p env' e
 >     return (ListCompr e' qs')
 > checkExpr p env (EnumFrom e) = liftE EnumFrom (checkExpr p env e)
@@ -424,7 +664,7 @@
 >          (checkExpr p env e1)
 >          (checkExpr p env e2)
 >          (checkExpr p env e3)
-> checkExpr p env (UnaryMinus op e) = liftE (UnaryMinus op) (checkExpr p env e)
+> checkExpr p env (UnaryMinus e) = liftE UnaryMinus (checkExpr p env e)
 > checkExpr p env (Apply e1 e2) =
 >   liftE2 Apply (checkExpr p env e1) (checkExpr p env e2)
 > checkExpr p env (InfixApply e1 op e2) =
@@ -436,11 +676,11 @@
 >   liftE2 LeftSection (checkExpr p env e) (checkOp p env op)
 > checkExpr p env (RightSection op e) =
 >   liftE2 RightSection (checkOp p env op) (checkExpr p env e)
-> checkExpr p env (Lambda ts e) =
+> checkExpr _ env (Lambda p ts e) =
 >   do
 >     (env',ts') <- checkArgs p env ts
 >     e' <- checkExpr p env' e
->     return (Lambda ts' e')
+>     return (Lambda p ts' e')
 > checkExpr p env (Let ds e) =
 >   do
 >     (env',ds') <- checkLocalDecls env ds
@@ -448,7 +688,7 @@
 >     return (Let ds' e')
 > checkExpr p env (Do sts e) =
 >   do
->     (env',sts') <- mapAccumM (checkStatement p) env sts
+>     (env',sts') <- mapAccumM (checkStmt p) env sts
 >     e' <- checkExpr p env' e
 >     return (Do sts' e')
 > checkExpr p env (IfThenElse e1 e2 e3) =
@@ -458,84 +698,192 @@
 >          (checkExpr p env e3)
 > checkExpr p env (Case e alts) =
 >   liftE2 Case (checkExpr p env e) (mapE (checkAlt env) alts)
+> checkExpr p env (Fcase e alts) =
+>   liftE2 Fcase (checkExpr p env e) (mapE (checkAlt env) alts)
 
-> checkStatement :: Position -> VarEnv -> Statement -> Error (VarEnv,Statement)
-> checkStatement p env (StmtExpr e) =
+> checkStmt :: Position -> VarEnv -> Statement a -> Error (VarEnv,Statement a)
+> checkStmt p env (StmtExpr e) =
 >   do
 >     e' <- checkExpr p env e
 >     return (env,StmtExpr e')
-> checkStatement p env (StmtBind t e) =
+> checkStmt _ env (StmtBind p t e) =
 >   do
 >     e' <- checkExpr p env e
 >     (env',t') <- checkArg p env t
->     return (env',StmtBind t' e')
-> checkStatement p env (StmtDecl ds) =
+>     return (env',StmtBind p t' e')
+> checkStmt _ env (StmtDecl ds) =
 >   do
 >     (env',ds') <- checkLocalDecls env ds
 >     return (env',StmtDecl ds')
 
-> checkAlt :: VarEnv -> Alt -> Error Alt
+> checkAlt :: VarEnv -> Alt a -> Error (Alt a)
 > checkAlt env (Alt p t rhs) =
 >   do
 >     (env',t') <- checkArg p env t
 >     rhs' <- checkRhs env' rhs
 >     return (Alt p t' rhs')
 
-> checkOp :: Position -> VarEnv -> InfixOp -> Error InfixOp
+> checkOp :: Position -> VarEnv -> InfixOp a -> Error (InfixOp a)
 > checkOp p env op =
 >   case qualLookupNestEnv v env of
 >     [] -> errorAt p (undefinedVariable v)
->     [Constr _] -> return (InfixConstr v)
->     [Var _] -> return (InfixOp v)
+>     [Constr _] -> return (InfixConstr (attr op) v)
+>     [Var _ _] -> return (InfixOp (attr op) v)
 >     rs -> errorAt p (ambiguousIdent rs v)
 >   where v = opName op
+>         attr (InfixOp a _) = a
+>         attr (InfixConstr a _) = a
+
+\end{verbatim}
+For record patterns and expressions the compiler checks that all field
+labels belong to the pattern or expression's constructor. For record
+update expressions, the compiler checks that there is at least one
+constructor which has all the specified field labels. In addition, the
+compiler always checks that no field label occurs twice. Field labels
+are always looked up in the global environment since they cannot be
+shadowed by local variables (cf.\ Sect.~3.15.1 of the revised
+Haskell'98 report~\cite{PeytonJones03:Haskell}).
+\begin{verbatim}
+
+> checkFieldLabels :: String -> Position -> VarEnv -> Maybe QualIdent
+>                  -> [Field a] -> Error ()
+> checkFieldLabels what p env c fs =
+>   do
+>     mapE (checkFieldLabel p env) ls' >>= checkLabels p env c ls'
+>     mapE_ (errorAt p . duplicateLabel what . fst)
+>           (duplicates (map unqualify ls))
+>   where ls = [l | Field l _ <- fs]
+>         ls' = nub ls
+
+> checkFieldLabel :: Position -> VarEnv -> QualIdent -> Error [QualIdent]
+> checkFieldLabel p env l =
+>   case qualLookupNestEnv l (globalEnv (toplevelEnv env)) of
+>     [Var _ cs]
+>       | null cs -> errorAt p (undefinedLabel l)
+>       | otherwise -> return cs
+>     rs
+>       | any isLabel rs -> errorAt p (ambiguousLabel rs l)
+>       | otherwise -> errorAt p (undefinedLabel l)
+
+> checkLabels :: Position -> VarEnv -> Maybe QualIdent -> [QualIdent]
+>             -> [[QualIdent]] -> Error ()
+> checkLabels p env (Just c) ls css =
+>   mapE_ (errorAt p . noLabel c) [l | (l,cs) <- zip ls css, c' `notElem` cs]
+>   where c' = origName (head (qualLookupNestEnv c env))
+> checkLabels p _ Nothing ls css =
+>   when (null (foldr1 intersect css)) (errorAt p (noCommonConstr ls))
+
+> checkField :: (a -> Error a) -> Field a -> Error (Field a)
+> checkField check (Field l x) = liftE (Field l) (check x)
 
 \end{verbatim}
 Auxiliary definitions.
 \begin{verbatim}
 
-> constrs :: TopDecl -> [P Ident]
-> constrs (DataDecl _ _ _ cs) = map constr cs
->   where constr (ConstrDecl p _ c _) = P p c
->         constr (ConOpDecl p _ _ op _) = P p op
-> constrs (NewtypeDecl _ _ _ (NewConstrDecl p c _)) = [P p c]
+> constrs :: TopDecl a -> [P Ident]
+> constrs (DataDecl _ _ _ _ cs _) = map constr cs
+>   where constr (ConstrDecl p _ _ c _) = P p c
+>         constr (ConOpDecl p _ _ _ op _) = P p op
+>         constr (RecordDecl p _ _ c _) = P p c
+> constrs (NewtypeDecl _ _ _ _ nc _) = [nconstr nc]
+>   where nconstr (NewConstrDecl p c _) = P p c
+>         nconstr (NewRecordDecl p c _ _) = P p c
 > constrs (TypeDecl _ _ _ _) = []
+> constrs (ClassDecl _ _ _ _ _) = []
+> constrs (InstanceDecl _ _ _ _ _) = []
+> constrs (DefaultDecl _ _) = []
 > constrs (BlockDecl _) = []
 
-> vars :: Decl -> [P Ident]
+> fieldLabels :: TopDecl a -> [(P Ident,[Ident])]
+> fieldLabels (DataDecl _ _ _ _ cs _) =
+>   [(l,constrs cs l) | l <- nub (concatMap labels cs)]
+>   where constrs cs l = [constr c | c <- cs, l `elem` labels c]
+>         labels (ConstrDecl _ _ _ _ _) = []
+>         labels (ConOpDecl _ _ _ _ _ _) = []
+>         labels (RecordDecl _ _ _ _ fs) =
+>           [P p l | FieldDecl p ls _ <- fs, l <- ls]
+> fieldLabels (NewtypeDecl _ _ _ _ nc _) = nlabel nc
+>   where nlabel (NewConstrDecl _ _ _) = []
+>         nlabel (NewRecordDecl p c l _) = [(P p l,[c])]
+> fieldLabels (TypeDecl _ _ _ _) = []
+> fieldLabels (ClassDecl _ _ _ _ _) = []
+> fieldLabels (InstanceDecl _ _ _ _ _) = []
+> fieldLabels (DefaultDecl _ _) = []
+> fieldLabels (BlockDecl _) = []
+
+> mthds :: TopDecl a -> [P Ident]
+> mthds (DataDecl _ _ _ _ _ _) = []
+> mthds (NewtypeDecl _ _ _ _ _ _) = []
+> mthds (TypeDecl _ _ _ _) = []
+> mthds (ClassDecl _ _ _ _ ds) = [P p f | TypeSig p fs _ <- ds, f <- fs]
+> mthds (InstanceDecl _ _ _ _ _) = []
+> mthds (DefaultDecl _ _) = []
+> mthds (BlockDecl _) = []
+
+> vars :: Decl a -> [P Ident]
 > vars (InfixDecl p _ _ ops) = map (P p) ops
 > vars (TypeSig p fs _) = map (P p) fs
-> vars (FunctionDecl p f _) = [P p f]
-> vars (ForeignDecl p _ _ _ f _) = [P p f]
+> vars (FunctionDecl p _ f _) = [P p f]
+> vars (ForeignDecl p _ _ f _) = [P p f]
 > vars (PatternDecl p t _) = map (P p) (bv t)
-> vars (FreeDecl p vs) = map (P p) vs
-> vars (TrustAnnot p _ fs) = maybe [] (map (P p)) fs
+> vars (FreeDecl p vs) = map (P p) (bv vs)
+> vars (TrustAnnot p _ fs) = map (P p) fs
 
 \end{verbatim}
 Due to the lack of a capitalization convention in Curry, it is
 possible that an identifier may ambiguously refer to a data
 constructor and a function provided that both are imported from some
-other module. When checking whether an identifier denotes a
-constructor there are two options with regard to ambiguous
-identifiers:
-\begin{enumerate}
-\item Handle the identifier as a data constructor if at least one of
-  the imported names is a data constructor.
-\item Handle the identifier as a data constructor only if all imported
-  entities are data constructors.
-\end{enumerate}
-We have chosen the first option because otherwise a redefinition of a
-constructor can become possible by importing a function with the same
-name.
+other module. For the purpose of disambiguating the left hand sides of
+operator declarations, we consider an identifier to denote a data
+constructor only if it does so unambiguously.
 \begin{verbatim}
 
 > isDataConstr :: VarEnv -> Ident -> Bool
 > isDataConstr env v =
->   any isConstr (lookupNestEnv v (globalEnv (toplevelEnv env)))
+>   case lookupNestEnv v env of
+>     [Constr _] -> True
+>     _ -> False
 
 > isConstr :: ValueKind -> Bool
 > isConstr (Constr _) = True
-> isConstr (Var _) = False
+> isConstr (Var _ _) = False
+
+> isLabel :: ValueKind -> Bool
+> isLabel (Constr _) = False
+> isLabel (Var _ cs) = not (null cs)
+
+> classMthds :: QualIdent -> TypeEnv -> [Ident]
+> classMthds cls tEnv =
+>   case qualLookupTopEnv cls tEnv of
+>     [Class _ fs] -> fs
+>     _ -> internalError "classMthds"
+
+\end{verbatim}
+Auxiliary functions.
+\begin{verbatim}
+
+> comparePos :: P a -> P a -> Ordering
+> comparePos (P p1 _) (P p2 _) = compare p1 p2
+
+\end{verbatim}
+The functions \texttt{merge} and \texttt{mergeBy} merge two already
+sorted lists.
+
+\ToDo{The function \texttt{merge} is commented out because it
+  conflicts with a method of the \texttt{Entity} class and thus
+  prevents compilation with hbc.}
+\begin{verbatim}
+
+merge :: Ord a => [a] -> [a] -> [a]
+merge = mergeBy compare
+
+> mergeBy :: (a -> a -> Ordering) -> [a] -> [a] -> [a]
+> mergeBy _ [] ys = ys
+> mergeBy _ (x:xs) [] = x:xs
+> mergeBy cmp (x:xs) (y:ys) =
+>   case cmp x y of
+>     GT -> y : mergeBy cmp (x:xs) ys
+>     _ -> x : mergeBy cmp xs (y:ys)
 
 \end{verbatim}
 Error messages.
@@ -553,6 +901,12 @@
 > undefinedData :: QualIdent -> String
 > undefinedData c = "Undefined data constructor " ++ qualName c
 
+> undefinedLabel :: QualIdent -> String
+> undefinedLabel l = "Undefined field label " ++ qualName l
+
+> undefinedMethod :: QualIdent -> Ident -> String
+> undefinedMethod cls f = name f ++ " is not a method of class " ++ qualName cls
+
 > ambiguousIdent :: [ValueKind] -> QualIdent -> String
 > ambiguousIdent rs
 >   | any isConstr rs = ambiguousData rs
@@ -561,9 +915,15 @@
 > ambiguousVariable :: [ValueKind] -> QualIdent -> String
 > ambiguousVariable = ambiguous "variable"
 
+> ambiguousFunction :: [ValueKind] -> QualIdent -> String
+> ambiguousFunction = ambiguous "function"
+
 > ambiguousData :: [ValueKind] -> QualIdent -> String
 > ambiguousData = ambiguous "data constructor"
 
+> ambiguousLabel :: [ValueKind] -> QualIdent -> String
+> ambiguousLabel = ambiguous "field label"
+
 > ambiguous :: String -> [ValueKind] -> QualIdent -> String
 > ambiguous what rs x = show $
 >   text "Ambiguous" <+> text what <+> ppQIdent x $$
@@ -576,6 +936,10 @@
 > repeatedDefinition :: Ident -> String
 > repeatedDefinition v = "Redefinition of " ++ name v
 
+> duplicateLabel :: String -> Ident -> String
+> duplicateLabel what l =
+>   "Field label " ++ name l ++ " occurs more than once in record " ++ what
+
 > duplicateVariable :: Ident -> String
 > duplicateVariable v = name v ++ " occurs more than once in pattern"
 
@@ -610,12 +974,17 @@
 > repeatedTrustAnnot :: Ident -> String
 > repeatedTrustAnnot f = "Repeated trust annotation for " ++ name f
 
-> nonVariable :: String -> Ident -> String
-> nonVariable what c =
->   "Data constructor " ++ name c ++ " used in left hand side of " ++ what
+> noLabel :: QualIdent -> QualIdent -> String
+> noLabel c l =
+>   qualName l ++ " is not a field label of constructor " ++ show c
+
+> noCommonConstr :: [QualIdent] -> String
+> noCommonConstr ls =
+>   "No constructor has all of these fields: " ++
+>   concat (intersperse ", " (map qualName ls))
 
 > noBody :: Ident -> String
-> noBody v = name v ++ " is undefined in this scope"
+> noBody v = name v ++ " is not defined in this scope"
 
 > noToplevelPattern :: String
 > noToplevelPattern = "Pattern declaration not allowed at top-level"
diff -u curry-0.9.11/TopEnv.lhs curry-0.9.11-classful/TopEnv.lhs
--- curry-0.9.11/TopEnv.lhs	2007-06-15 14:16:35.000000000 +0200
+++ curry-0.9.11-classful/TopEnv.lhs	2009-08-25 10:02:57.000000000 +0200
@@ -1,76 +1,55 @@
 % -*- LaTeX -*-
-% $Id: TopEnv.lhs 2153 2007-04-12 09:14:47Z wlux $
+% $Id: TopEnv.lhs 2902 2009-08-24 15:15:03Z wlux $
 %
-% Copyright (c) 1999-2007, Wolfgang Lux
+% Copyright (c) 1999-2009, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{TopEnv.lhs}
 \subsection{Top-Level Environments}\label{sec:toplevel-env}
 The module \texttt{TopEnv} implements environments for qualified and
 possibly ambiguous identifiers. An identifier is ambiguous if two
-different entities are imported under the same name or if a local
-definition uses the same name as an imported entity. Following an idea
-presented in \cite{DiatchkiJonesHallgren02:ModuleSystem}, an
-identifier is associated with a list of entities in order to handle
-ambiguous names properly.
-
-Tuple constructors must be treated specially because there is a
-potentially unlimited number of them. Instead of inserting tuple
-constructors into the environment, the compiler can optionally supply
-an infinite list with information about tuple constructors when a new
-environment is constructed with \texttt{emptyEnv}. Given a tuple
-constructor with arity $n$, whose binding is not found in the
-environment, the functions \texttt{lookupTopEnv} and
-\texttt{qualLookupTopEnv} will return the element at index $n-2$ from
-this list. Since the list is infinite, \texttt{TopEnv}'s \texttt{Show}
-instance shows only the head of the list.
+different entities are imported under the same name. Local definitions
+shadow imported entities. Following an idea presented in
+\cite{DiatchkiJonesHallgren02:ModuleSystem}, an imported identifier is
+associated with a list of entities in order to handle ambiguous names
+properly.
 
 The code in this module ensures that the list of entities returned by
 the functions \texttt{lookupTopEnv} and \texttt{qualLookupTopEnv}
 contains exactly one element for each imported entity regardless of
 how many times and from which modules it was imported. Thus, the
-result of these function is a list with exactly one element if and
-only if the identifier is unambiguous. The module names associated
-with an imported entity identify the modules from which the entity was
-imported.
+result of these functions is a list with exactly one element if and
+only if the identifier is unambiguous.
 \begin{verbatim}
 
-> module TopEnv(TopEnv, Entity(..), emptyTopEnv, predefTopEnv,
->               importTopEnv, qualImportTopEnv,
+> module TopEnv(TopEnv, Entity(..), emptyTopEnv, importTopEnv, qualImportTopEnv,
 >               bindTopEnv, globalBindTopEnv, localBindTopEnv, qualBindTopEnv,
 >               rebindTopEnv, globalRebindTopEnv, localRebindTopEnv,
->               qualRebindTopEnv, localUnbindTopEnv,
+>               qualRebindTopEnv, localUnimportTopEnv, localUnbindTopEnv,
 >               lookupTopEnv, qualLookupTopEnv, allEntities,
->               allImports, moduleImports, localBindings) where
+>               allImports, localBindings, moduleBindings) where
 > import Env
 > import Ident
 > import Maybe
-> import Utils
 
-> data TopEnv a = TopEnv (Maybe [a]) (Env QualIdent [(Source,a)])
-> data Source = Local | Import [ModuleIdent] deriving (Eq,Show)
-
-> instance Show a => Show (TopEnv a) where
->   showsPrec p (TopEnv tup env) =
->     showParen (p > 10)
->               (showString "TopEnv " . showsPrec 11 (fmap head tup) .
->                showChar ' ' . showsPrec 11 env)
+> newtype TopEnv a = TopEnv (Env QualIdent (Entities a)) deriving Show
+> data Entities a = Local a | Imported [a] deriving (Eq,Show)
 
 > instance Functor TopEnv where
->   fmap f (TopEnv tup env) =
->     TopEnv (fmap (map f) tup) (fmap (map (apSnd f)) env)
-
-> entities :: QualIdent -> Env QualIdent [(Source,a)] -> [(Source,a)]
-> entities x env = fromMaybe [] (lookupEnv x env)
+>   fmap f (TopEnv env) = TopEnv (fmap (fmap f) env)
+> instance Functor Entities where
+>   fmap f (Local x) = Local (f x)
+>   fmap f (Imported xs) = Imported (map f xs)
+
+> entityList :: Entities a -> [a]
+> entityList (Local x) = [x]
+> entityList (Imported xs) = xs
 
-> emptyTopEnv :: Maybe [a] -> TopEnv a
-> emptyTopEnv tup = TopEnv tup emptyEnv
+> entities :: QualIdent -> Env QualIdent (Entities a) -> Entities a
+> entities x env = fromMaybe (Imported []) (lookupEnv x env)
 
-> predefTopEnv :: Entity a => QualIdent -> a -> TopEnv a -> TopEnv a
-> predefTopEnv x y (TopEnv tup env) =
->   case lookupEnv x env of
->     Just _ -> error "internal error: predefTopEnv"
->     Nothing -> TopEnv tup (bindEnv x [(Import [],y)] env)
+> emptyTopEnv :: TopEnv a
+> emptyTopEnv = TopEnv emptyEnv
 
 \end{verbatim}
 In general, two entities are considered equal if the names of their
@@ -100,28 +79,23 @@
 > importTopEnv :: Entity a => Bool -> ModuleIdent -> Ident -> a
 >              -> TopEnv a -> TopEnv a
 > importTopEnv qual
->   | qual = qualImportTopEnv
->   | otherwise = \m x y -> unqualImportTopEnv m x y . qualImportTopEnv m x y
-
-> unqualImportTopEnv :: Entity a => ModuleIdent -> Ident -> a
->                    -> TopEnv a -> TopEnv a
-> unqualImportTopEnv m x y (TopEnv tup env) =
->   TopEnv tup (bindEnv x' (mergeImport m y (entities x' env)) env)
->   where x' = qualify x
-
-> qualImportTopEnv :: Entity a => ModuleIdent -> Ident -> a -> TopEnv a
->                  -> TopEnv a
-> qualImportTopEnv m x y (TopEnv tup env) =
->   TopEnv tup (bindEnv x' (mergeImport m y (entities x' env)) env)
->   where x' = qualifyWith m x
-
-> mergeImport :: Entity a => ModuleIdent -> a -> [(Source,a)] -> [(Source,a)]
-> mergeImport m x [] = [(Import [m],x)]
-> mergeImport m x ((Local,x') : xs) = (Local,x') : mergeImport m x xs
-> mergeImport m x ((Import ms,x') : xs) =
->   case merge x x' of
->     Just x'' -> (Import (m:ms),x'') : xs
->     Nothing -> (Import ms,x') : mergeImport m x xs
+>   | qual = qualImport
+>   | otherwise = \m x y -> unqualImport x y . qualImport m x y
+>   where unqualImport x = qualImportTopEnv (qualify x)
+>         qualImport m x = qualImportTopEnv (qualifyWith m x)
+
+> qualImportTopEnv :: Entity a => QualIdent -> a -> TopEnv a -> TopEnv a
+> qualImportTopEnv x y (TopEnv env) =
+>   TopEnv (bindEnv x (mergeImport y (entities x env)) env)
+
+> mergeImport :: Entity a => a -> Entities a -> Entities a
+> mergeImport _ (Local _) = wrong "qualImportTopEnv"
+> mergeImport y (Imported ys) = Imported (mergeImports y ys)
+>   where mergeImports x [] = [x]
+>         mergeImports x (x':xs) =
+>           case merge x x' of
+>             Just x'' -> x'' : xs
+>             Nothing ->  x' : mergeImports x xs
 
 \end{verbatim}
 The function \texttt{globalBindTopEnv} introduces a binding for a
@@ -147,11 +121,9 @@
 > localBindTopEnv = qualBindTopEnv . qualify
 
 > qualBindTopEnv :: QualIdent -> a -> TopEnv a -> TopEnv a
-> qualBindTopEnv x y (TopEnv tup env) =
->   TopEnv tup (bindEnv x (bindLocal y (entities x env)) env)
->   where bindLocal x xs
->           | null [x' | (Local,x') <- xs] = (Local,x) : xs
->           | otherwise = error "internal error: qualBindTopEnv"
+> qualBindTopEnv x y (TopEnv env) = TopEnv (bindLocal x y (entities x env) env)
+>   where bindLocal _ _ (Local _) = wrong "qualBindTopEnv"
+>         bindLocal x y (Imported _) = bindEnv x (Local y)
 
 > rebindTopEnv :: ModuleIdent -> Ident -> a -> TopEnv a -> TopEnv a
 > rebindTopEnv m x
@@ -166,58 +138,76 @@
 > localRebindTopEnv = qualRebindTopEnv . qualify
 
 > qualRebindTopEnv :: QualIdent -> a -> TopEnv a -> TopEnv a
-> qualRebindTopEnv x y (TopEnv tup env) =
->   TopEnv tup (bindEnv x (rebindLocal (entities x env)) env)
->   where rebindLocal [] = error "internal error: qualRebindTopEnv"
->         rebindLocal ((Local,_) : ys) = (Local,y) : ys
->         rebindLocal ((Import ms,y) : ys) = (Import ms,y) : rebindLocal ys
+> qualRebindTopEnv x y (TopEnv env) =
+>   TopEnv (rebindLocal x y (entities x env) env)
+>   where rebindLocal x y (Local _) = bindEnv x (Local y)
+>         rebindLocal _ _ (Imported _) = wrong "qualRebindTopEnv"
+
+> localUnimportTopEnv :: Ident -> TopEnv a -> TopEnv a
+> localUnimportTopEnv x (TopEnv env) =
+>   TopEnv (unbindImport x' (entities x' env) env)
+>   where x' = qualify x
+>         unbindImport _ (Local _) = id
+>         unbindImport x (Imported _) = unbindEnv x
 
 > localUnbindTopEnv :: Ident -> TopEnv a -> TopEnv a
-> localUnbindTopEnv x (TopEnv tup env) =
->   TopEnv tup (bindEnv x' (unbindLocal (entities x' env)) env)
+> localUnbindTopEnv x (TopEnv env) =
+>   TopEnv (unbindLocal x' (entities x' env) env)
 >   where x' = qualify x
->         unbindLocal [] = error "internal error: unbindTopEnv"
->         unbindLocal ((Local,_) : ys) = ys
->         unbindLocal ((Import ms,y) : ys) = (Import ms,y) : unbindLocal ys
+>         unbindLocal x (Local _) = unbindEnv x
+>         unbindLocal _ (Imported _) = wrong "unbindTopEnv"
 
 > lookupTopEnv :: Ident -> TopEnv a -> [a]
 > lookupTopEnv = qualLookupTopEnv . qualify
 
 > qualLookupTopEnv :: QualIdent -> TopEnv a -> [a]
-> qualLookupTopEnv x (TopEnv tup env) =
->   map snd (entities x env) ++!
->   maybe [] (\ys -> [ys !! (qTupleArity x - 2) | isQTupleId x]) tup
+> qualLookupTopEnv x (TopEnv env) = entityList (entities x env)
 
 \end{verbatim}
 The function \texttt{allEntities} returns a list of all entities bound
 in an environment. The function \texttt{allImports} returns a list of
 the names and values of all entities in an environment that were
-imported from another module. The functions \texttt{localBindings} and
-\texttt{moduleImports} return the list of entities defined in the
-current module and imported from a particular module, respectively.
-Since a name can be defined only once at the top-level of a module and
-imports of the same entity are merged, the result lists of both
-functions will contain no duplicates.
+imported from another module. The function \texttt{localBindings}
+returns the list of all entities defined in the current module, and
+the function \texttt{moduleBindings} returns the list of all entities
+which are in scope with both an unqualified name $x$ and a qualified
+name $M.x$. Since a name can be defined only once at the top-level of
+a module and imports of the same entity are merged, the result lists
+of both functions will contain no duplicates. Note that both functions
+(actually, their helper function \texttt{unqualBindings}) make use of
+the fact that the list returned by \texttt{envToList} is sorted
+according to the qualified names of the entities and qualified
+identifiers are ordered first by their module qualifier.
 \begin{verbatim}
 
 > allEntities :: TopEnv a -> [a]
-> allEntities (TopEnv _ env) =
->   [y | (x,ys) <- envToList env, isQualified x, (_,y) <- ys]
+> allEntities (TopEnv env) =
+>   [y' | (x,y) <- envToList env, isQualified x, y' <- entityList y]
 
 > allImports :: TopEnv a -> [(QualIdent,a)]
-> allImports (TopEnv _ env) =
->   [(x,y) | (x,ys) <- envToList env, (Import _,y) <- ys]
+> allImports (TopEnv env) =
+>   [(x,y) | (x,Imported ys) <- envToList env, y <- ys]
 
-> unqualBindings :: TopEnv a -> [(Ident,(Source,a))]
-> unqualBindings (TopEnv _ env) =
->   [(x',y) | (x,ys) <- takeWhile (not . isQualified . fst) (envToList env),
->             let x' = unqualify x, y <- ys]
-
-> moduleImports :: ModuleIdent -> TopEnv a -> [(Ident,a)]
-> moduleImports m env =
->   [(x,y) | (x,(Import ms,y)) <- unqualBindings env, m `elem` ms]
+> unqualBindings :: Maybe ModuleIdent -> TopEnv a -> [(Ident,Entities a)]
+> unqualBindings m (TopEnv env) =
+>   [(x',y) | (x,y) <- takeWhile p (dropWhile (not . p) (envToList env)),
+>             let x' = unqualify x]
+>   where p = (m ==) . fst . splitQualIdent . fst
 
 > localBindings :: TopEnv a -> [(Ident,a)]
-> localBindings env = [(x,y) | (x,(Local,y)) <- unqualBindings env]
+> localBindings env =
+>   [(x,y) | (x,Local y) <- unqualBindings Nothing env]
+
+> moduleBindings :: Entity a => ModuleIdent -> TopEnv a -> [(Ident,a)]
+> moduleBindings m env =
+>   [(x,y') | (x,y) <- unqualBindings (Just m) env, y' <- entityList y,
+>             origName y' `elem` map origName (lookupTopEnv x env)]
+
+\end{verbatim}
+Auxiliary functions.
+\begin{verbatim}
+
+> wrong :: String -> a
+> wrong what = error ("internal error: " ++ what)
 
 \end{verbatim}
Solo in curry-0.9.11-classful/: TrustInfo.lhs
diff -u curry-0.9.11/Trust.lhs curry-0.9.11-classful/Trust.lhs
--- curry-0.9.11/Trust.lhs	2007-06-15 14:16:34.000000000 +0200
+++ curry-0.9.11-classful/Trust.lhs	2010-06-28 10:54:16.000000000 +0200
@@ -1,23 +1,21 @@
 % -*- LaTeX -*-
-% $Id: Trust.lhs 2184 2007-04-30 10:25:49Z wlux $
+% $Id: Trust.lhs 2968 2010-06-24 14:39:50Z wlux $
 %
-% Copyright (c) 2006-2007, Wolfgang Lux
+% Copyright (c) 2006-2010, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{Trust.lhs}
 \section{Collecting Trust Annotations}
 The module \texttt{Trust} computes the trust annotation environment.
-It is applied to the desugared source code in order to allow providing
-trust annotations for anonymous lambda abstractions. Since lambda
-abstractions have no name and the desugarer does not change scopes, a
-lambda abstraction is trusted if its enclosing function is trusted.
 There is no need to check the annotations because this happens already
 while checking the definitions of the module.
 \begin{verbatim}
 
 > module Trust(trustEnv) where
-> import Base
+> import Curry
 > import Env
+> import PredefIdent
+> import TrustInfo
 
 \end{verbatim}
 The function \texttt{trustEnv} collects the trust attributes from all
@@ -43,8 +41,8 @@
 \texttt{g} is not.
 \begin{verbatim}
 
-> trustEnv :: Trust -> Module -> TrustEnv
-> trustEnv tr (Module _ _ _ ds) = trust tr [d | BlockDecl d <- ds] emptyEnv
+> trustEnv :: Trust -> Module a -> TrustEnv
+> trustEnv tr (Module _ _ _ ds) = trust tr ds emptyEnv
 
 > class SyntaxTree a where
 >   trust :: Trust -> a -> TrustEnv -> TrustEnv
@@ -55,35 +53,83 @@
 > instance SyntaxTree a => SyntaxTree [a] where
 >   trust = trustList
 
-> instance SyntaxTree Decl where
->   trust tr (FunctionDecl _ f eqs) env =
+> instance SyntaxTree (TopDecl a) where
+>   trust tr (ClassDecl _ _ _ _ ds) = trust tr ds
+>   trust tr (InstanceDecl _ _ _ _ ds) = trust tr ds
+>   trust tr (BlockDecl d) = trust tr d
+>   trust _ _ = id
+
+>   trustList tr ds = trustDeclGroup tr [d | BlockDecl d <- ds] ds
+
+> instance SyntaxTree (Decl a) where
+>   trust tr (FunctionDecl _ _ f eqs) env =
 >     case lookupEnv f env of
 >       Just tr' -> trust tr' eqs env
 >       Nothing -> trust tr eqs (bindEnv f tr env)
->   trust tr (PatternDecl _ _ rhs) env = trust tr rhs env
+>   trust tr (PatternDecl _ t rhs) env =
+>     case t of
+>       VariablePattern _ v ->
+>         case lookupEnv v env of
+>           Just tr' -> trust tr' rhs env
+>           Nothing -> trust tr rhs (bindEnv v tr env)
+>       _ -> trust tr rhs env
 >   trust _ _ env = env
 
->   trustList tr ds env = foldr (trust tr') env' ds
->     where tr' = head $ [tr | TrustAnnot _ tr Nothing <- ds] ++ [tr]
->           env' =
->             foldr ($) env
->                   [bindEnv f tr | TrustAnnot _ tr (Just fs) <- ds, f <- fs]
+>   trustList tr ds = trustDeclGroup tr ds ds
+
+> trustDeclGroup :: SyntaxTree d => Trust -> [Decl a] -> [d] -> TrustEnv
+>                -> TrustEnv
+> trustDeclGroup tr ds ds' env = foldr (trust tr') env' ds'
+>   where tr' = head ([tr | TrustAnnot _ tr [] <- ds] ++ [tr])
+>         env' =
+>           foldr ($) env [bindEnv f tr | TrustAnnot _ tr fs <- ds, f <- fs]
 
-> instance SyntaxTree Equation where
+> instance SyntaxTree (Equation a) where
 >   trust tr (Equation _ _ rhs) = trust tr rhs
 
-> instance SyntaxTree Rhs where
+> instance SyntaxTree (Rhs a) where
 >   trust tr (SimpleRhs _ e ds) = trust tr e . trust tr ds
+>   trust tr (GuardedRhs es ds) = trust tr es . trust tr ds
 
-> instance SyntaxTree Expression where
->   trust _ (Literal _) = id
->   trust _ (Variable _) = id
->   trust _ (Constructor _) = id
+> instance SyntaxTree (CondExpr a) where
+>   trust tr (CondExpr _ g e) = trust tr g . trust tr e
+
+> instance SyntaxTree (Expression a) where
+>   trust _ (Literal _ _) = id
+>   trust _ (Variable _ _) = id
+>   trust _ (Constructor _ _) = id
+>   trust tr (Paren e) = trust tr e
+>   trust tr (Typed e _) = trust tr e
+>   trust tr (Record _ _ fs) = trust tr fs
+>   trust tr (RecordUpdate e fs) = trust tr e . trust tr fs
+>   trust tr (Tuple es) = trust tr es
+>   trust tr (List _ es) = trust tr es
+>   trust tr (ListCompr e qs) = trust tr e . trust tr qs
+>   trust tr (EnumFrom e) = trust tr e
+>   trust tr (EnumFromThen e1 e2) = trust tr e1 . trust tr e2
+>   trust tr (EnumFromTo e1 e2) = trust tr e1 . trust tr e2
+>   trust tr (EnumFromThenTo e1 e2 e3) = trust tr e1 . trust tr e2 . trust tr e3
+>   trust tr (UnaryMinus e) = trust tr e
 >   trust tr (Apply e1 e2) = trust tr e1 . trust tr e2
+>   trust tr (InfixApply e1 _ e2) = trust tr e1 . trust tr e2
+>   trust tr (LeftSection e _) = trust tr e
+>   trust tr (RightSection _ e) = trust tr e
+>   trust tr (Lambda p _ e) = bindEnv (lambdaId p) tr . trust tr e
 >   trust tr (Let ds e) = trust tr ds . trust tr e
+>   trust tr (Do sts e) = trust tr sts . trust tr e
+>   trust tr (IfThenElse e1 e2 e3) = trust tr e1 . trust tr e2 . trust tr e3
 >   trust tr (Case e as) = trust tr e . trust tr as
+>   trust tr (Fcase e as) = trust tr e . trust tr as
+
+> instance SyntaxTree (Statement a) where
+>   trust tr (StmtExpr e) = trust tr e
+>   trust tr (StmtBind _ _ e) = trust tr e
+>   trust tr (StmtDecl ds) = trust tr ds
 
-> instance SyntaxTree Alt where
+> instance SyntaxTree (Alt a) where
 >   trust tr (Alt _ _ rhs) = trust tr rhs
 
+> instance SyntaxTree a => SyntaxTree (Field a) where
+>   trust tr (Field _ e) = trust tr e
+
 \end{verbatim}
diff -u curry-0.9.11/TypeCheck.lhs curry-0.9.11-classful/TypeCheck.lhs
--- curry-0.9.11/TypeCheck.lhs	2007-06-15 14:16:34.000000000 +0200
+++ curry-0.9.11-classful/TypeCheck.lhs	2013-04-15 09:31:31.000000000 +0200
@@ -1,7 +1,7 @@
 % -*- LaTeX -*-
-% $Id: TypeCheck.lhs 2176 2007-04-26 20:35:57Z wlux $
+% $Id: TypeCheck.lhs 3130 2013-04-13 17:03:51Z wlux $
 %
-% Copyright (c) 1999-2007, Wolfgang Lux
+% Copyright (c) 1999-2013, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{TypeCheck.lhs}
@@ -10,108 +10,243 @@
 type checker is invoked after the syntactic correctness of the program
 has been verified and kind checking has been applied to all type
 expressions. Local variables have been renamed already. Therefore, the
-compiler can maintain a flat type environment (which is necessary in
-order to pass the type information to later phases of the compiler).
-The type checker now checks the correct typing of all expressions and
-also verifies that the type signatures given by the user match the
-inferred types. The type checker uses algorithm
-W~\cite{DamasMilner82:Principal} for inferring the types of
-unannotated declarations, but allows for polymorphic recursion when a
-type annotation is present.
+compiler can maintain a flat type environment. The type checker now
+checks the correct typing of all expressions and also verifies that
+the type signatures given by the user match the inferred types. The
+type checker uses algorithm W~\cite{DamasMilner82:Principal} for
+inferring the types of unannotated declarations, but allows for
+polymorphic recursion when a type annotation is present.
+
+The result of type checking is a (flat) top-level environment
+containing the types of all constructors, variables, and functions
+defined at the top level of a module. In addition, a type annotated
+source module or goal is returned. Note that type annotations on the
+left hand side of a declaration hold the function or variable's
+generalized type with the type scheme's for all qualifier left
+implicit. Type annotations on the right hand side of a declaration
+hold the particular instance at which a polymorphic function or
+variable is used.
 \begin{verbatim}
 
 > module TypeCheck(typeCheck,typeCheckGoal) where
 > import Base
-> import Pretty
+> import Combined
+> import Curry
 > import CurryPP
+> import CurryUtils
 > import Env
-> import TopEnv
-> import TypeSubst
-> import TypeTrans
-> import Combined
 > import Error
+> import InstInfo
 > import List
+> import Maybe
 > import Monad
+> import Position
+> import PredefIdent
+> import PredefTypes
+> import Pretty
 > import SCC
 > import Set
+> import TopEnv
+> import Types
+> import TypeInfo
+> import TypeSubst
+> import TypeTrans
 > import Utils
+> import ValueInfo
 
 > infixl 5 $-$
+> infixl 1 >>-, >>=-
 
 > ($-$) :: Doc -> Doc -> Doc
 > x $-$ y = x $$ space $$ y
 
+> (>>-) :: Monad m => m (a,b,c) -> (a -> b -> m a) -> m (a,c)
+> m >>- f =
+>   do
+>     (u,x,y) <- m
+>     u' <- f u x
+>     return (u',y)
+
+> (>>=-) :: Monad m => m (a,b,d) -> (b -> m c) -> m (a,c,d)
+> m >>=- f =
+>   do
+>     (u,x,z) <- m
+>     y <- f x
+>     return (u,y,z)
+
 \end{verbatim}
 Before checking the function declarations of a module, the compiler
 adds the types of all data and newtype constructors defined in the
 current module to the type environment.
 \begin{verbatim}
 
-> typeCheck :: ModuleIdent -> TCEnv -> ValueEnv -> [TopDecl] -> Error ValueEnv
-> typeCheck m tcEnv tyEnv ds =
->   run (tcDecls m tcEnv [d | BlockDecl d <- vds] >>
->        liftSt fetchSt >>= \theta -> liftM (subst theta) fetchSt)
->       (foldr (bindConstrs m tcEnv) tyEnv tds)
->   where (tds,vds) = partition isTypeDecl ds
+> typeCheck :: ModuleIdent -> TCEnv -> InstEnv -> ValueEnv -> [TopDecl a]
+>           -> Error (ValueEnv,[TopDecl QualType])
+> typeCheck m tcEnv iEnv tyEnv ds =
+>   sequenceE [tcDataDecl tcEnv tvs cs | DataDecl _ _ _ tvs cs _ <- tds] >>
+>   run (do
+>          mapM_ (defaultTypes tcEnv) (filter isDefaultDecl tds)
+>          (tyEnv'',cx,vds') <- tcDecls m tcEnv tyEnv' [d | BlockDecl d <- vds]
+>          unless (null cx) (internalError ("typeCheck " ++ show cx))
+>          tds' <- mapM (tcTopDecl m tcEnv tyEnv'') tds
+>          theta <- fetchSt
+>          return (subst theta tyEnv'',
+>                  map (fmap (subst theta)) (tds' ++ map BlockDecl vds')))
+>       iEnv
+>   where (vds,tds) = partition isBlockDecl ds
+>         tyEnv' = foldr (bindTypeValues m tcEnv) tyEnv tds
 
 \end{verbatim}
 Type checking of a goal is simpler because there are no type
-declarations.
-\begin{verbatim}
-
-> typeCheckGoal :: ModuleIdent -> TCEnv -> ValueEnv -> Goal -> Error ValueEnv
-> typeCheckGoal m tcEnv tyEnv (Goal p e ds) =
->   run (tcRhs m tcEnv (SimpleRhs p e ds) >>=
->        checkSkolems p tcEnv (text "Goal:" <+> ppExpr 0 e) zeroSet >>
->        liftSt fetchSt >>= \theta -> liftM (subst theta) fetchSt)
->       tyEnv
+declarations. Depending on whether we only compute the type of a goal
+or a going to generate code for the goal, the compiler will allow a
+non-empty context for the goal's type or not.
+\begin{verbatim}
+
+> typeCheckGoal :: Bool -> ModuleIdent -> TCEnv -> InstEnv -> ValueEnv -> Goal a
+>               -> Error (Context,Goal QualType)
+> typeCheckGoal forEval m tcEnv iEnv tyEnv g =
+>   run (do
+>          (cx',g') <-
+>            tcGoal m tcEnv tyEnv g >>= uncurry3 (defaultGoalType forEval tcEnv)
+>          theta <- fetchSt
+>          return (cx',fmap (subst theta) g'))
+>       iEnv
+
+> defaultGoalType :: Bool -> TCEnv -> Context -> Type -> Goal a
+>                 -> TcState (Context,Goal a)
+> defaultGoalType forEval tcEnv cx ty (Goal p e ds) =
+>   do
+>     theta <- fetchSt
+>     let ty' = subst theta ty
+>         tvs = if forEval then zeroSet else fromListSet (typeVars ty')
+>     cx' <- applyDefaults p "goal" (ppExpr 0 e) tcEnv tvs cx ty'
+>     return (cx',Goal p e ds)
 
 \end{verbatim}
 The type checker makes use of nested state monads in order to maintain
-the type environment, the current substitution, and a counter, which
-is used for generating fresh type variables.
-\begin{verbatim}
-
-> type TcState a = StateT ValueEnv (StateT TypeSubst (StateT Int Error)) a
+the current substitution, the instance environment, and a counter,
+which is used for generating fresh type variables.
 
-> run :: TcState a -> ValueEnv -> Error a
-> run m tyEnv = callSt (callSt (callSt m tyEnv) idSubst) 1
-
-\end{verbatim}
-\paragraph{Defining Data Constructors}
-First, the types of all data and newtype constructors are entered into
-the type environment. All type synonyms occurring in their types are
-expanded. We cannot use \texttt{expandPolyType} for expanding the type
-of a data or newtype constructor in function \texttt{bindConstr}
-because of the different normalization scheme used for constructor
-types and also because the name of the type could be ambiguous.
-\begin{verbatim}
-
-> bindConstrs :: ModuleIdent -> TCEnv -> TopDecl -> ValueEnv -> ValueEnv
-> bindConstrs m tcEnv (DataDecl _ tc tvs cs) tyEnv = foldr bind tyEnv cs
->   where ty0 = constrType m tc tvs
->         bind (ConstrDecl _ _ c tys) =
->           bindConstr DataConstructor m tcEnv tvs c tys ty0
->         bind (ConOpDecl _ _ ty1 op ty2) =
->           bindConstr DataConstructor m tcEnv tvs op [ty1,ty2] ty0
-> bindConstrs m tcEnv (NewtypeDecl _ tc tvs nc) tyEnv = bind nc tyEnv
->   where ty0 = constrType m tc tvs
->         bind (NewConstrDecl _ c ty) =
->           bindConstr (const . NewtypeConstructor) m tcEnv tvs c [ty] ty0
-> bindConstrs _ _ (TypeDecl _ _ _ _) tyEnv = tyEnv
-> bindConstrs _ _ (BlockDecl _) tyEnv = tyEnv
-
-> bindConstr :: (QualIdent -> Int -> TypeScheme -> ValueInfo) -> ModuleIdent
->            -> TCEnv -> [Ident] -> Ident -> [TypeExpr] -> Type
->            -> ValueEnv -> ValueEnv
-> bindConstr f m tcEnv tvs c tys ty0 =
->   globalBindTopEnv m c (f (qualifyWith m c) (length tys) ty')
->   where ty' = polyType (normalize (length tvs) (foldr TypeArrow ty0 tys'))
->         tys' = expandMonoTypes tcEnv tvs tys
-
-> constrType :: ModuleIdent -> Ident -> [Ident] -> Type
-> constrType m tc tvs =
->   TypeConstructor (qualifyWith m tc) (map TypeVariable [0..length tvs-1])
+In order to handle the introduction of local instances when matching a
+data constructor with a non-empty right hand side context, the type
+checker uses an extended instance environment that is composed of the
+static top-level instance environment and a dynamic environment that
+maps each class on the instances which are in scope for it. The
+rationale behind using this representation is that it makes it easy to
+apply the current substitution to the dynamic part of the environment.
+
+For lack of a better place, we also include the list of default types
+in the extended instance environment.
+\begin{verbatim}
+
+> type TcState a = StateT TypeSubst (StateT InstEnv' (StateT Int Error)) a
+> type InstEnv' = ([Type],Env QualIdent [Type],InstEnv)
+
+> run :: TcState a -> InstEnv -> Error a
+> run m iEnv =
+>   callSt (callSt (callSt m idSubst) (defaultDefaultTypes,emptyEnv,iEnv)) 1
+
+\end{verbatim}
+The list of default types is given either by a default declaration in
+the source code or defaults to the predefined list of numeric data
+types, which at present includes the types \texttt{Integer} and
+\texttt{Float}. This list is always used when type checking goal
+expressions because a goal has no top-level declarations.
+
+Note that it is possible to declare polymorphic default types, e.g.,
+\texttt{default (T a)}. Since defaults are used only to disambiguate
+ambiguous type variables, i.e., type variables which the type
+inference algorithm cannot constrain to a more specific type, it is
+safe to use a single instance of a polymorphic default type for the
+whole module.
+
+\ToDo{Provide a way to set the default types for a goal, e.g. via
+  a command line switch.}
+\begin{verbatim}
+
+> defaultTypes :: TCEnv -> TopDecl a -> TcState ()
+> defaultTypes tcEnv (DefaultDecl _ tys) =
+>   do
+>     tys' <- mapM (liftM snd . inst . typeScheme . defaultType) tys
+>     liftSt (updateSt_ (apFst3 (const tys')))
+>   where defaultType = expandPolyType tcEnv . QualTypeExpr []
+
+> defaultDefaultTypes :: [Type]
+> defaultDefaultTypes = [integerType,floatType]
+
+\end{verbatim}
+\paragraph{Defining Data Constructors and Methods}
+First, the types of all data and newtype constructors as well as those
+of their field labels and the types of all type class methods are
+entered into the type environment. All type synonyms occurring in
+their types are expanded.
+\begin{verbatim}
+
+> bindTypeValues :: ModuleIdent -> TCEnv -> TopDecl a -> ValueEnv -> ValueEnv
+> bindTypeValues m tcEnv (DataDecl _ cxL tc tvs cs _) tyEnv =
+>   foldr bindCon (foldr (uncurry bindLab) tyEnv (nubBy sameLabel ls)) cs
+>   where ls = [(l,ty) | RecordDecl _ _ _ _ fs <- cs,
+>                        FieldDecl _ ls ty <- fs, l <- ls]
+>         bindCon (ConstrDecl _ _ cxR c tys) =
+>           bindConstr m tcEnv cxL tc tvs cxR c (zip (repeat anonId) tys)
+>         bindCon (ConOpDecl _ _ cxR ty1 op ty2) =
+>           bindConstr m tcEnv cxL tc tvs cxR op [(anonId,ty1),(anonId,ty2)]
+>         bindCon (RecordDecl _ _ cxR c fs) =
+>           bindConstr m tcEnv cxL tc tvs cxR c tys
+>           where tys = [(l,ty) | FieldDecl _ ls ty <- fs, l <- ls]
+>         bindLab = bindLabel m tcEnv cxL tc tvs
+>         sameLabel (l1,_) (l2,_) = l1 == l2
+> bindTypeValues m tcEnv (NewtypeDecl _ cx tc tvs nc _) tyEnv = bind nc tyEnv
+>   where bind (NewConstrDecl _ c ty) =
+>           bindNewConstr m tcEnv cx tc tvs c anonId ty
+>         bind (NewRecordDecl _ c l ty) =
+>           bindNewConstr m tcEnv cx tc tvs c l ty .
+>           bindLabel m tcEnv cx tc tvs l ty
+> bindTypeValues _ _ (TypeDecl _ _ _ _) tyEnv = tyEnv
+> bindTypeValues m tcEnv (ClassDecl _ _ cls tv ds) tyEnv = foldr bind tyEnv ds
+>   where cls' = qualifyWith m cls
+>         bind (InfixDecl _ _ _ _) = id
+>         bind (TypeSig _ fs ty) = bindMethods m tcEnv cls' tv fs ty
+>         bind (FunctionDecl _ _ _ _) = id
+>         bind (TrustAnnot _ _ _) = id
+> bindTypeValues _ _ (InstanceDecl _ _ _ _ _) tyEnv = tyEnv
+> bindTypeValues _ _ (DefaultDecl _ _) tyEnv = tyEnv
+> bindTypeValues _ _ (BlockDecl _) tyEnv = tyEnv
+
+> bindConstr :: ModuleIdent -> TCEnv -> [ClassAssert] -> Ident -> [Ident]
+>            -> [ClassAssert] -> Ident -> [(Ident,TypeExpr)] -> ValueEnv
+>            -> ValueEnv
+> bindConstr m tcEnv cxL tc tvs cxR c tys = globalBindTopEnv m c $
+>   DataConstructor (qualifyWith m c) ls ci (typeScheme ty)
+>   where (ci,ty) = expandConstrType tcEnv cxL (qualifyWith m tc) tvs cxR tys'
+>         (ls,tys') = unzip tys
+
+> bindNewConstr :: ModuleIdent -> TCEnv -> [ClassAssert] -> Ident -> [Ident]
+>               -> Ident -> Ident -> TypeExpr -> ValueEnv -> ValueEnv
+> bindNewConstr m tcEnv cx tc tvs c l ty = globalBindTopEnv m c $
+>   NewtypeConstructor (qualifyWith m c) l (typeScheme ty')
+>   where ty' = snd (expandConstrType tcEnv cx (qualifyWith m tc) tvs [] [ty])
+
+> bindLabel :: ModuleIdent -> TCEnv -> [ClassAssert] -> Ident -> [Ident]
+>           -> Ident -> TypeExpr -> ValueEnv -> ValueEnv
+> bindLabel m tcEnv cx tc tvs l ty =
+>   globalBindTopEnv m l (Value (qualifyWith m l) 1 (typeScheme ty'))
+>   where ty' = expandPolyType tcEnv (QualTypeExpr cx (ArrowType ty0 ty))
+>         ty0 = constrType (qualifyWith m tc) tvs
+
+> bindMethods :: ModuleIdent -> TCEnv -> QualIdent -> Ident -> [Ident]
+>             -> QualTypeExpr -> ValueEnv -> ValueEnv
+> bindMethods m tcEnv cls tv fs ty tyEnv =
+>   foldr (bindMethod m (typeScheme ty')) tyEnv fs
+>   where ty' = expandMethodType tcEnv cls tv ty
+
+> bindMethod :: ModuleIdent -> TypeScheme -> Ident -> ValueEnv -> ValueEnv
+> bindMethod m ty f = globalBindTopEnv m f (Value (qualifyWith m f) 0 ty)
+
+> constrType :: QualIdent -> [Ident] -> TypeExpr
+> constrType tc tvs =
+>   foldl ApplyType (ConstructorType tc) (map VariableType tvs)
 
 \end{verbatim}
 \paragraph{Type Signatures}
@@ -121,26 +256,72 @@
 the signature.
 \begin{verbatim}
 
-> type SigEnv = Env Ident TypeExpr
+> type SigEnv = Env Ident QualTypeExpr
 
 > noSigs :: SigEnv
 > noSigs = emptyEnv
 
-> bindTypeSigs :: Decl -> SigEnv -> SigEnv
+> bindTypeSigs :: Decl a -> SigEnv -> SigEnv
 > bindTypeSigs (TypeSig _ vs ty) env = foldr (flip bindEnv ty) env vs 
 > bindTypeSigs _ env = env
         
 \end{verbatim}
-\paragraph{Type Inference}
+\paragraph{Top-level Declarations}
+When a field label occurs in more than one constructor declaration of
+a data type, the compiler ensures that the label is defined
+consistently. In addition, the compiler ensures that no existentially
+quantified type variable occurs in the type of a field label because
+such type variables necessarily escape their scope with the type of
+the record selection function associated with the field label.
+\begin{verbatim}
+
+> tcDataDecl :: TCEnv -> [Ident] -> [ConstrDecl] -> Error ()
+> tcDataDecl tcEnv tvs cs =
+>   mapE (uncurry (tcFieldLabel tcEnv tvs)) ls >>=
+>   mapE_ (uncurry tcFieldLabels) . groupLabels
+>   where ls = [(P p l,ty) | RecordDecl _ _ _ _ fs <- cs,
+>                            FieldDecl p ls ty <- fs, l <- ls]
+
+> tcFieldLabel :: TCEnv -> [Ident] -> P Ident -> TypeExpr
+>              -> Error (P Ident,QualType)
+> tcFieldLabel tcEnv tvs (P p l) ty
+>   | n <= length tvs = return (P p l,ty')
+>   | otherwise = errorAt p (skolemFieldLabel l)
+>   where ForAll n ty' = polyType (expandMonoType tcEnv tvs ty)
+
+> tcFieldLabels :: P Ident -> [QualType] -> Error ()
+> tcFieldLabels (P p l) (ty:tys) =
+>   unless (all (ty ==) tys) (errorAt p (inconsistentFieldLabel l))
+
+> groupLabels :: Eq a => [(a,b)] -> [(a,[b])]
+> groupLabels [] = []
+> groupLabels ((x,y):xys) = (x,y:map snd xys') : groupLabels xys''
+>   where (xys',xys'') = partition ((x ==) . fst) xys
+
+\end{verbatim}
+\paragraph{Declaration Groups}
 Before type checking a group of declarations, a dependency analysis is
-performed and the declaration group is split into minimal, nested
+performed and the declaration group is split into minimal nested
 binding groups which are checked separately. Within each binding
 group, first the type environment is extended with new bindings for
-all variables and functions defined in the group. Next, each
-declaration is checked in the extended type environment. Finally, the
-types of all defined functions are generalized. The generalization
-step will also check that the type signatures given by the user match
-the inferred types.
+all variables and functions defined in the group. Next, types are
+inferred for all declarations without an explicit type signature and
+the inferred types are then generalized. Finally, the types of all
+explicitly typed declarations are checked.
+
+The idea of checking the explicitly typed declarations after the
+implicitly typed declarations is due to Mark P.\ Jones' ``Typing
+Haskell in Haskell'' paper~\cite{Jones99:THiH}. It has the advantage
+of inferring more general types. For instance, given the declarations
+\begin{verbatim}
+  f :: Eq a => a -> Bool
+  f x = (x==x) || g True
+  g y = (y<=y) || f True
+\end{verbatim}
+the compiler will infer type \texttt{Ord a => a -> Bool} for
+\texttt{g} if \texttt{f} is checked after inferring a type for
+\texttt{g}, but only type \texttt{Bool -> Bool} if both declarations
+are checked together.
 
 The presence of unbound logical variables necessitates a monomorphism
 restriction that prohibits unsound functions like
@@ -200,10 +381,31 @@
 Obviously, this generalization does not hold for Curry with
 \texttt{let x = unknown in x} being the canonical counter-example.
 
+\ToDo{Strictly speaking, numeric literals are not non-expansive since
+  they are just abbreviations for the saturated (in fact, over
+  applied) applications \texttt{Prelude.fromInt}~$i$ and
+  \texttt{Prelude.fromFloat}~$f$, respectively. Therefore, the
+  compiler should either consider all numeric literals expansive,
+  consider only numeric literals of some predefined types like
+  \texttt{Int}, \texttt{Float}, etc. non-expansive, or ensure that all
+  \texttt{fromInt} and \texttt{fromFloat} instance method
+  implementations are deterministic.}
+
+Note that we do not implement Haskell's monomorphism restriction
+(cf.\ Sect.~4.5.5 in~\cite{PeytonJones03:Haskell}), which prevents
+generalization of constrained type variables in the types of simple
+pattern bindings of the form $x=e$ without an explicit type signature.
+The motivation for this restriction is that sharing is lost for an
+overloaded declaration, which might cause an expensive computation to
+be repeated. However, this argument does not apply to Curry since
+generalization is allowed only when $e$ is a non-expansive expression,
+i.e., essentially a normal form.
+
 Within a group of mutually recursive declarations, all type variables
-that appear in the types of the variables defined in the group must
-not be generalized. Without this restriction, the compiler would
-accept the function
+that appear in the types of the variables defined in the group and
+whose type cannot be generalized must not be generalized in the other
+declarations of that group as well. Without this restriction, the
+compiler would accept the function
 \begin{verbatim}
   illTyped = x=:=1 &> f True "Hello"
     where (x:xs) = f True (repeat unknown)
@@ -213,134 +415,309 @@
 whose result is the ill-typed list \verb|['H',1,'l',1,'o']|,
 because \verb|f|'s type would incorrectly be generalized to
 $\forall\alpha.\texttt{Bool}\rightarrow[\alpha]\rightarrow[\alpha]$.
-\begin{verbatim}
 
-> tcDecls :: ModuleIdent -> TCEnv -> [Decl] -> TcState ()
-> tcDecls m tcEnv ds =
->   mapM_ (tcDeclGroup m tcEnv (foldr bindTypeSigs noSigs ods))
->         (scc bv (qfv m) vds)
+Note that \texttt{tcFunctionDecl} ignores the context of a function's
+type signature. This prevents spurious missing instance errors when
+the inferred type of a function is less general than the declared
+type. For instance, if the type signature's context were merged with
+the inferred context, the compiler would report a missing instance
+\texttt{Prelude.Eq (a -> a)} for the declaration
+\begin{verbatim}
+  f :: Eq a => a
+  f = id
+\end{verbatim}
+instead of reporting that the inferred type \texttt{a -> a} is less
+general than the type signature.
+\begin{verbatim}
+
+> tcDecls :: ModuleIdent -> TCEnv -> ValueEnv -> [Decl a]
+>         -> TcState (ValueEnv,Context,[Decl QualType])
+> tcDecls m tcEnv tyEnv ds =
+>   do
+>     ((tyEnv',cx),dss') <-
+>       mapAccumM (uncurry (tcDeclGroup m tcEnv sigs)) (tyEnv,[])
+>                 (scc bv (qfv m) vds)
+>     return (tyEnv',cx,map untyped ods ++ concat dss')
 >   where (vds,ods) = partition isValueDecl ds
+>         sigs = foldr bindTypeSigs noSigs ods
 
-> tcDeclGroup :: ModuleIdent -> TCEnv -> SigEnv -> [Decl] -> TcState ()
-> tcDeclGroup m tcEnv _ [ForeignDecl p cc _ ie f ty] =
->   tcForeignFunct m tcEnv p cc ie f ty
-> tcDeclGroup m tcEnv sigs [FreeDecl p vs] = bindDeclVars m tcEnv sigs p vs
-> tcDeclGroup m tcEnv sigs ds =
->   do
->     tyEnv0 <- fetchSt
->     mapM_ (bindDecl m tcEnv sigs) ds
->     tys <- mapM (tcDecl m tcEnv) ds
->     tyEnv <- fetchSt
->     theta <- liftSt fetchSt
->     let vs = [v | PatternDecl _ t rhs <- ds,
->                   not (isVariablePattern t && isNonExpansive tcEnv tyEnv rhs),
->                   v <- bv t]
->         tvss = map (typeVars . subst theta . flip varType tyEnv) vs
->         fvs = foldr addToSet (fvEnv (subst theta tyEnv0)) (concat tvss)
->     zipWithM_ (genDecl m tcEnv tyEnv sigs fvs . subst theta) tys ds
+> tcDeclGroup :: ModuleIdent -> TCEnv -> SigEnv -> ValueEnv -> Context
+>             -> [Decl a] -> TcState ((ValueEnv,Context),[Decl QualType])
+> tcDeclGroup m tcEnv _ tyEnv cx [ForeignDecl p fi _ f ty] =
+>   do
+>     (tyEnv',ty') <- tcForeignFunct m tcEnv tyEnv p fi f ty
+>     return ((tyEnv',cx),[ForeignDecl p fi (qualType ty') f ty])
+> tcDeclGroup m tcEnv sigs tyEnv cx [FreeDecl p vs] =
+>   do
+>     vs' <- mapM (tcDeclVar False tcEnv sigs p) (bv vs)
+>     return ((bindVars m tyEnv vs',cx),[FreeDecl p (map freeVar vs')])
+>   where freeVar (v,_,ForAll _ ty) = FreeVar ty v
+> tcDeclGroup m tcEnv sigs tyEnv cx ds =
+>   do
+>     vss <- mapM (tcDeclVars tcEnv sigs) ds
+>     let tyEnv' = bindVars m tyEnv (concat vss)
+>     (cx',impDs') <- mapAccumM (tcDecl m tcEnv tyEnv') cx impDs
+>     theta <- fetchSt
+>     let tvs =
+>           [tv | (ty,d) <- impDs', not (isNonExpansive tcEnv tyEnv' d),
+>                 tv <- typeVars (subst theta ty)]
+>         fvs = foldr addToSet (fvEnv (subst theta tyEnv)) tvs
+>         (gcx,lcx) = splitContext fvs cx'
+>     lcx' <- foldM (uncurry . dfltDecl tcEnv fvs) lcx impDs'
+>     theta <- fetchSt
+>     let impDs'' = map (uncurry (fixType . gen fvs lcx' . subst theta)) impDs'
+>         tyEnv'' = rebindVars m tyEnv' (concatMap declVars impDs'')
+>     (cx'',expDs') <-
+>       mapAccumM (uncurry . tcCheckDecl m tcEnv tyEnv'') gcx expDs
+>     return ((tyEnv'',cx''),impDs'' ++ expDs')
+>   where (impDs,expDs) = partDecls sigs ds
+
+> partDecls :: SigEnv -> [Decl a] -> ([Decl a],[(QualTypeExpr,Decl a)])
+> partDecls sigs =
+>   foldr (\d -> maybe (implicit d) (explicit d) (declTypeSig sigs d)) ([],[])
+>   where implicit d ~(impDs,expDs) = (d:impDs,expDs)
+>         explicit d ty ~(impDs,expDs) = (impDs,(ty,d):expDs)
+
+> declTypeSig :: SigEnv -> Decl a -> Maybe QualTypeExpr
+> declTypeSig sigs (FunctionDecl _ _ f _) = lookupEnv f sigs
+> declTypeSig sigs (PatternDecl _ t _) =
+>   case t of
+>     VariablePattern _ v -> lookupEnv v sigs
+>     _ -> Nothing
 
-> bindDecl :: ModuleIdent -> TCEnv -> SigEnv -> Decl -> TcState ()
-> bindDecl m tcEnv sigs (FunctionDecl p f eqs) =
+> bindVars :: ModuleIdent -> ValueEnv -> [(Ident,Int,TypeScheme)] -> ValueEnv
+> bindVars m = foldr (uncurry3 (bindFun m))
+
+> rebindVars :: ModuleIdent -> ValueEnv -> [(Ident,Int,TypeScheme)] -> ValueEnv
+> rebindVars m = foldr (uncurry3 (rebindFun m))
+
+> tcDeclVars :: TCEnv -> SigEnv -> Decl a -> TcState [(Ident,Int,TypeScheme)]
+> tcDeclVars tcEnv sigs (FunctionDecl _ _ f eqs) =
 >   case lookupEnv f sigs of
->     Just ty -> updateSt_ (bindFun m f n (expandPolyType tcEnv ty))
+>     Just ty -> return [(f,n,typeScheme (expandPolyType tcEnv ty))]
 >     Nothing ->
->       replicateM (n + 1) freshTypeVar >>=
->       updateSt_ . bindFun m f n . monoType . foldr1 TypeArrow
+>       do
+>         tys <- replicateM (n + 1) freshTypeVar
+>         return [(f,n,monoType (foldr1 TypeArrow tys))]
 >   where n = eqnArity (head eqs)
-> bindDecl m tcEnv sigs (PatternDecl p t _) =
+> tcDeclVars tcEnv sigs (PatternDecl p t _) =
 >   case t of
->     VariablePattern v -> bindDeclVar True m tcEnv sigs p v
->     _ -> bindDeclVars m tcEnv sigs p (bv t)
+>     VariablePattern _ v -> mapM (tcDeclVar True tcEnv sigs p) [v]
+>     _ -> mapM (tcDeclVar False tcEnv sigs p) (bv t)
 
-> bindDeclVars :: ModuleIdent -> TCEnv -> SigEnv -> Position -> [Ident]
->              -> TcState ()
-> bindDeclVars m tcEnv sigs p = mapM_ (bindDeclVar False m tcEnv sigs p)
-
-> bindDeclVar :: Bool -> ModuleIdent -> TCEnv -> SigEnv -> Position -> Ident
->             -> TcState ()
-> bindDeclVar poly m tcEnv sigs p v =
+> tcDeclVar :: Bool -> TCEnv -> SigEnv -> Position -> Ident
+>           -> TcState (Ident,Int,TypeScheme)
+> tcDeclVar poly tcEnv sigs p v =
 >   case lookupEnv v sigs of
 >     Just ty
 >       | poly || null (fv ty) ->
->           updateSt_ (bindFun m v 0 (expandPolyType tcEnv ty))
+>           return (v,0,typeScheme (expandPolyType tcEnv ty))
 >       | otherwise -> errorAt p (polymorphicVar v)
->     Nothing -> bindLambdaVar m v
+>     Nothing -> lambdaVar v
 
-> tcDecl :: ModuleIdent -> TCEnv -> Decl -> TcState Type
-> tcDecl m tcEnv (FunctionDecl _ f eqs) =
+> tcDecl :: ModuleIdent -> TCEnv -> ValueEnv -> Context -> Decl a
+>        -> TcState (Context,(Type,Decl QualType))
+> tcDecl m tcEnv tyEnv cx (FunctionDecl p _ f eqs) =
+>   tcFunctionDecl m tcEnv tyEnv cx (varType f tyEnv) p f eqs
+> tcDecl m tcEnv tyEnv cx d@(PatternDecl p t rhs) =
+>   do
+>     (cx',ty',t') <- tcConstrTerm False tcEnv tyEnv p t
+>     (cx'',rhs') <-
+>       tcRhs m tcEnv tyEnv rhs >>-
+>       unifyDecl p "pattern declaration" (ppDecl d) tcEnv tyEnv (cx++cx') ty'
+>     return (cx'',(ty',PatternDecl p t' rhs'))
+
+> tcFunctionDecl :: ModuleIdent -> TCEnv -> ValueEnv -> Context
+>                -> TypeScheme -> Position -> Ident -> [Equation a]
+>                -> TcState (Context,(Type,Decl QualType))
+> tcFunctionDecl m tcEnv tyEnv cx (ForAll n ty) p f eqs =
 >   do
->     tyEnv0 <- fetchSt
->     theta <- liftSt fetchSt
->     ty <- inst (varType f tyEnv0)
->     mapM_ (tcEquation m tcEnv (fsEnv (subst theta tyEnv0)) ty) eqs
->     return ty
-> tcDecl m tcEnv (PatternDecl p t rhs) =
->   do
->     ty <- tcConstrTerm m tcEnv p t
->     tcRhs m tcEnv rhs >>=
->       unify p "pattern binding" (ppConstrTerm 0 t) tcEnv ty
->     return ty
-
-> tcEquation :: ModuleIdent -> TCEnv -> Set Int -> Type -> Equation
->            -> TcState ()
-> tcEquation m tcEnv fs ty eq@(Equation p lhs rhs) =
->   do
->     tcEqn m tcEnv p ts rhs >>=
->       unify p "function declaration" (ppEquation eq) tcEnv ty
->     checkSkolems p tcEnv (text "Function:" <+> ppIdent f) fs ty
->   where (f,ts) = flatLhs lhs
-
-> tcEqn :: ModuleIdent -> TCEnv -> Position -> [ConstrTerm] -> Rhs
->       -> TcState Type
-> tcEqn m tcEnv p ts rhs =
->   do
->     bindLambdaVars m ts
->     tys <- mapM (tcConstrTerm m tcEnv p) ts
->     ty <- tcRhs m tcEnv rhs
->     return (foldr TypeArrow ty tys)
-
-> bindLambdaVars :: QuantExpr t => ModuleIdent -> t -> TcState ()
-> bindLambdaVars m t = mapM_ (bindLambdaVar m) (bv t)
-
-> bindLambdaVar :: ModuleIdent -> Ident -> TcState ()
-> bindLambdaVar m v = freshTypeVar >>= updateSt_ . bindFun m v 0 . monoType
-
-\end{verbatim}
-The code in \texttt{genDecl} below verifies that the inferred type of
-a function matches its declared type. Since the type inferred for the
-left hand side of a function or variable declaration is an instance of
-its declared type -- provided a type signature is given -- it can only
-be more specific. Therefore, if the inferred type does not match the
-type signature, the declared type must be too general. No check is
-necessary for the variables in variable and other pattern declarations
-because the types of variables must be monomorphic, which is checked
-in \texttt{bindDeclVar} above.
-\begin{verbatim}
-
-> genDecl :: ModuleIdent -> TCEnv -> ValueEnv -> SigEnv -> Set Int -> Type
->         -> Decl -> TcState ()
-> genDecl m tcEnv _ sigs fvs ty (FunctionDecl p f eqs) =
->   case lookupEnv f sigs of
->     Just sigTy
->       | sigma == expandPolyType tcEnv sigTy -> return ()
->       | otherwise -> errorAt p (typeSigTooGeneral tcEnv what sigTy sigma)
->     Nothing -> updateSt_ (rebindFun m f (eqnArity (head eqs)) sigma)
->   where what = text "Function:" <+> ppIdent f
->         sigma = gen fvs ty
-> genDecl m tcEnv tyEnv sigs fvs ty (PatternDecl p t rhs) =
+>     theta <- fetchSt
+>     (_,ty') <- inst (ForAll n ty)
+>     (cx',eqs') <-
+>       mapAccumM (tcEquation m tcEnv tyEnv (fsEnv (subst theta tyEnv)) ty' f)
+>                 cx eqs
+>     return (cx',(ty',FunctionDecl p ty f eqs'))
+
+> tcEquation :: ModuleIdent -> TCEnv -> ValueEnv -> Set Int -> Type -> Ident
+>            -> Context -> Equation a -> TcState (Context,Equation QualType)
+> tcEquation m tcEnv tyEnv fs ty f cx eq@(Equation p lhs rhs) =
+>   tcEqn m tcEnv tyEnv fs p lhs rhs >>-
+>   unifyDecl p "equation" (ppEquation eq) tcEnv tyEnv cx ty
+
+> tcEqn :: ModuleIdent -> TCEnv -> ValueEnv -> Set Int -> Position
+>       -> Lhs a -> Rhs a -> TcState (Context,Type,Equation QualType)
+> tcEqn m tcEnv tyEnv fs p lhs rhs =
+>   do
+>     tyEnv' <- bindLambdaVars m tyEnv lhs
+>     (cx,tys,lhs') <- tcLhs tcEnv tyEnv' p lhs
+>     (cx',ty,rhs') <- tcRhs m tcEnv tyEnv' rhs
+>     cx'' <-
+>       reduceContext p "equation" (ppEquation (Equation p lhs' rhs')) tcEnv
+>                     (cx ++ cx')
+>     checkSkolems p "Equation" ppEquation tcEnv tyEnv fs cx''
+>                  (foldr TypeArrow ty tys) (Equation p lhs' rhs')
+
+> bindLambdaVars :: QuantExpr t => ModuleIdent -> ValueEnv -> t
+>                -> TcState ValueEnv
+> bindLambdaVars m tyEnv t = liftM (bindVars m tyEnv) (mapM lambdaVar (bv t))
+
+> lambdaVar :: Ident -> TcState (Ident,Int,TypeScheme)
+> lambdaVar v = freshTypeVar >>= \ty -> return (v,0,monoType ty)
+
+> tcGoal :: ModuleIdent -> TCEnv -> ValueEnv -> Goal a
+>        -> TcState (Context,Type,Goal QualType)
+> tcGoal m tcEnv tyEnv (Goal p e ds) =
+>   do
+>     (tyEnv',cx,ds') <- tcDecls m tcEnv tyEnv ds
+>     (cx',ty,e') <- tcExpr m tcEnv tyEnv' p e
+>     cx'' <- reduceContext p "goal" (ppExpr 0 e') tcEnv (cx ++ cx')
+>     checkSkolems p "Goal" ppGoal tcEnv tyEnv zeroSet cx'' ty (Goal p e' ds')
+
+> unifyDecl :: Position -> String -> Doc -> TCEnv -> ValueEnv -> Context -> Type
+>           -> Context -> Type -> TcState Context
+> unifyDecl p what doc tcEnv tyEnv cxLhs tyLhs cxRhs tyRhs =
+>   do
+>     cx <- unify p what doc tcEnv cxLhs tyLhs cxRhs tyRhs
+>     theta <- fetchSt
+>     let ty = subst theta tyLhs
+>         fvs = foldr addToSet (fvEnv (subst theta tyEnv)) (typeVars ty)
+>     applyDefaults p what doc tcEnv fvs cx ty
+
+\end{verbatim}
+After inferring types for a group of mutually recursive declarations
+and computing the set of its constrained type variables, the compiler
+has to be prepared for some of the constrained type variables to not
+appear in some of the inferred types, i.e., there may be ambiguous
+types that have not been reported by \texttt{unifyDecl} above at the
+level of individual function equations and pattern declarations. For
+instance, given the two functions
+\begin{verbatim}
+  f1 [] = []
+  f1 (x:xs) = if x < 0 then f2 1 xs else x : f1 xs
+
+  f2 _ [] = []
+  f2 n (x:xs) = if x < 0 then f2 (n + 1) xs else x : f1 xs
+\end{verbatim}
+the compiler infers types $\alpha_1 \rightarrow \alpha_1$ and
+$\beta_1 \rightarrow \alpha_1 \rightarrow \alpha_1$ for \texttt{f1}
+and \texttt{f2}, respectively. In addition, the constraints
+$\texttt{Num}\,\alpha_1, \texttt{Ord}\,\alpha_1,
+\texttt{Num}\,\beta_1$ are inferred, which means that \texttt{f1}'s
+type is ambiguous because $\beta_1$ does not appear in its
+type. This is detected in function \texttt{dfltDecl} below, which
+fixes the type $\beta_1$ to the default numeric type (\texttt{Int} at
+present). Thus, the compiler finally infers types $\forall\alpha .
+(\texttt{Num}\,\alpha, \texttt{Ord}\,\alpha) \Rightarrow \alpha
+\rightarrow \alpha$ and $\forall\alpha . (\texttt{Num}\,\alpha,
+\texttt{Ord}\,\alpha) \Rightarrow \texttt{Int} \rightarrow \alpha
+\rightarrow \alpha$ for \texttt{f1} and \texttt{f2}, respectively.
+
+It would be possible to infer more general types for \texttt{f1} and
+\texttt{f2} by keeping the (generalized) $\texttt{Num}\,\beta_1$
+constraint in \texttt{f1}'s type despite the fact that it is
+ambiguous. In fact, this is what ghc, hbc, and nhc98, but not Hugs,
+implement. Note that the $\texttt{Num}\,\beta_1$ constraint is not
+really ambiguous for the application of \texttt{f1} in \texttt{f2} due
+to the fact that recursion is monomorphic without an explicit type
+signature and therefore \texttt{f1} and \texttt{f2} must be using the
+same instance dictionary for the $\texttt{Num}\,\beta_1$ constraint.
+Unfortunately, our dictionary transformation algorithm implemented in
+module \texttt{DictTrans} (see Sect.~\ref{sec:dict-trans}) is unable
+to make use of this fact.
+
+\ToDo{Change the dictionary transformation algorithm to handle
+  ambiguous constraints like $\texttt{Num}\,\beta_1$ above. On the
+  side of the type checker, this probably requires that all implicitly
+  typed declarations of a declaration group use exactly the same
+  context, i.e., contexts must not be sorted during generalization in
+  function \texttt{gen} below.}
+\begin{verbatim}
+
+> dfltDecl :: TCEnv -> Set Int -> Context -> Type -> Decl a -> TcState Context
+> dfltDecl tcEnv fvs cx ty (FunctionDecl p _ f _) =
+>   applyDefaultsDecl p ("function " ++ name f) tcEnv fvs cx ty
+> dfltDecl tcEnv fvs cx ty (PatternDecl p t _) =
+>   case t of
+>     VariablePattern _ v ->
+>       applyDefaultsDecl p ("variable " ++ name v) tcEnv fvs cx ty
+>     _ -> return cx
+
+> applyDefaultsDecl :: Position -> String -> TCEnv -> Set Int -> Context -> Type
+>                   -> TcState Context
+> applyDefaultsDecl p what tcEnv fvs cx ty =
+>   do
+>     theta <- fetchSt
+>     let ty' = subst theta ty
+>         fvs' = foldr addToSet fvs (typeVars ty')
+>     applyDefaults p what empty tcEnv fvs' cx ty'
+
+\end{verbatim}
+After \texttt{tcDeclGroup} has generalized the types of the implicitly
+typed declarations of a declaration group it must update their left
+hand side type annotations and the type environment accordingly.
+Recall that the compiler generalizes only the types of variable and
+function declarations.
+\begin{verbatim}
+
+> fixType :: TypeScheme -> Decl QualType -> Decl QualType
+> fixType ~(ForAll _ ty) (FunctionDecl p _ f eqs) = FunctionDecl p ty f eqs
+> fixType ty (PatternDecl p t rhs) = PatternDecl p (fixVarType ty t) rhs
+>   where fixVarType ~(ForAll _ ty) t =
+>           case t of
+>             VariablePattern _ v -> VariablePattern ty v
+>             _ -> t
+
+> declVars :: Decl QualType -> [(Ident,Int,TypeScheme)]
+> declVars (FunctionDecl _ ty f eqs) = [(f,eqnArity (head eqs),typeScheme ty)]
+> declVars (PatternDecl _ t _) =
 >   case t of
->     VariablePattern v ->
->       case lookupEnv v sigs of
->         Just sigTy
->           | sigma == expandPolyType tcEnv sigTy -> return ()
->           | otherwise -> errorAt p (typeSigTooGeneral tcEnv what sigTy sigma)
->         Nothing
->           | poly -> updateSt_ (rebindFun m v 0 sigma)
->           | otherwise -> return ()
->       where what = text "Variable: " <+> ppIdent v
->             poly = isNonExpansive tcEnv tyEnv rhs
->             sigma = if poly then gen fvs ty else monoType ty
->     _ -> return ()
+>     VariablePattern ty v -> [(v,0,typeScheme ty)]
+>     _ -> []
+
+\end{verbatim}
+The function \texttt{tcCheckDecl} checks the type of an explicitly
+typed function or variable declaration. After inferring a type for the
+declaration, the inferred type is compared with the type signature.
+Since the inferred type of an explicitly typed function or variable
+declaration is automatically an instance of its type signature (cf.\ 
+\texttt{tcDecl} above), the type signature is correct only if the
+inferred type matches the type signature exactly except for the
+inferred context, which may contain only a subset of the declared
+context because the context of a function's type signature is
+(deliberately) ignored in \texttt{tcFunctionDecl} above.
+\begin{verbatim}
+
+> tcCheckDecl :: ModuleIdent -> TCEnv -> ValueEnv -> Context -> QualTypeExpr
+>             -> Decl a -> TcState (Context,Decl QualType)
+> tcCheckDecl m tcEnv tyEnv cx sigTy d =
+>   do
+>     (cx',(ty,d')) <- tcDecl m tcEnv tyEnv cx d
+>     theta <- fetchSt
+>     let fvs = fvEnv (subst theta tyEnv)
+>         (gcx,lcx) = splitContext fvs cx'
+>         ty' = subst theta ty
+>         sigma = if poly then gen fvs lcx ty' else monoType ty'
+>     checkDeclSig tcEnv sigTy gcx sigma d'
+>   where poly = isNonExpansive tcEnv tyEnv d
+
+> checkDeclSig :: TCEnv -> QualTypeExpr -> Context -> TypeScheme
+>              -> Decl QualType -> TcState (Context,Decl QualType)
+> checkDeclSig tcEnv sigTy cx sigma (FunctionDecl p _ f eqs)
+>   | checkTypeSig tcEnv ty sigma = return (cx,FunctionDecl p ty f eqs)
+>   | otherwise = errorAt p (typeSigTooGeneral tcEnv what sigTy sigma)
+>   where what = text "Function:" <+> ppIdent f
+>         ty = expandPolyType tcEnv sigTy
+> checkDeclSig tcEnv sigTy cx sigma (PatternDecl p (VariablePattern _ v) rhs)
+>   | checkTypeSig tcEnv ty sigma =
+>       return (cx,PatternDecl p (VariablePattern ty v) rhs)
+>   | otherwise = errorAt p (typeSigTooGeneral tcEnv what sigTy sigma)
+>   where what = text "Variable:" <+> ppIdent v
+>         ty = expandPolyType tcEnv sigTy
+
+> checkTypeSig :: TCEnv -> QualType -> TypeScheme -> Bool
+> checkTypeSig tcEnv (QualType sigCx sigTy) (ForAll _ (QualType cx ty)) =
+>   ty == sigTy && all (`elem` maxContext tcEnv sigCx) cx
 
 > class Binding a where
 >   isNonExpansive :: TCEnv -> ValueEnv -> a -> Bool
@@ -348,53 +725,190 @@
 > instance Binding a => Binding [a] where
 >   isNonExpansive tcEnv tyEnv = all (isNonExpansive tcEnv tyEnv)
 
-> instance Binding Decl where
+> instance Binding (Decl a) where
 >   isNonExpansive _ _ (InfixDecl _ _ _ _) = True
 >   isNonExpansive _ _ (TypeSig _ _ _) = True
->   isNonExpansive _ _ (FunctionDecl _ _ (eq:eqs)) = eqnArity eq > 0
->   isNonExpansive tcEnv _ (ForeignDecl _ _ _ _ _ ty) =
->     foreignArity (expandPolyType tcEnv ty) > 0
+>   isNonExpansive _ _ (FunctionDecl _ _ _ _) = True
+>   isNonExpansive _ _ (ForeignDecl _ _ _ _ _) = True
 >   isNonExpansive tcEnv tyEnv (PatternDecl _ t rhs) =
 >     isVariablePattern t && isNonExpansive tcEnv tyEnv rhs
 >   isNonExpansive _ _ (FreeDecl _ _) = False
 >   isNonExpansive _ _ (TrustAnnot _ _ _) = True
 
-> instance Binding Rhs where
+> instance Binding (Rhs a) where
 >   isNonExpansive tcEnv tyEnv (SimpleRhs _ e ds) =
->     isNonExpansive tcEnv tyEnv ds && isNonExpansive tcEnv tyEnv e
+>     isNonExpansive tcEnv tyEnv' ds && isNonExpansive tcEnv tyEnv' e
+>     where tyEnv' = foldr (bindDeclArity tcEnv) tyEnv ds
 >   isNonExpansive _ _ (GuardedRhs _ _) = False
 
-> instance Binding Expression where
+> instance Binding (Expression a) where
 >   isNonExpansive tcEnv tyEnv = isNonExpansiveApp tcEnv tyEnv 0
 
-> isNonExpansiveApp :: TCEnv -> ValueEnv -> Int -> Expression -> Bool
-> isNonExpansiveApp _ _ _ (Literal _) = True
-> isNonExpansiveApp _ tyEnv n (Variable v)
+> instance Binding a => Binding (Field a) where
+>   isNonExpansive tcEnv tyEnv (Field _ e) = isNonExpansive tcEnv tyEnv e
+
+> isNonExpansiveApp :: TCEnv -> ValueEnv -> Int -> Expression a -> Bool
+> isNonExpansiveApp _ _ _ (Literal _ _) = True
+> isNonExpansiveApp _ tyEnv n (Variable _ v)
+>   | unqualify v == anonId = False
 >   | isRenamed (unqualify v) = n == 0 || n < arity v tyEnv
 >   | otherwise = n < arity v tyEnv
-> isNonExpansiveApp _ _ _ (Constructor _) = True
-> isNonExpansiveApp tcEnv tyEnv n (Paren e) =
->   isNonExpansiveApp tcEnv tyEnv n e
+> isNonExpansiveApp _ _ _ (Constructor _ _) = True
+> isNonExpansiveApp tcEnv tyEnv n (Paren e) = isNonExpansiveApp tcEnv tyEnv n e
 > isNonExpansiveApp tcEnv tyEnv n (Typed e _) =
 >   isNonExpansiveApp tcEnv tyEnv n e
-> isNonExpansiveApp tcEnv tyEnv _ (Tuple es) =
->   isNonExpansive tcEnv tyEnv es
-> isNonExpansiveApp tcEnv tyEnv _ (List es) =
->   isNonExpansive tcEnv tyEnv es
+> isNonExpansiveApp tcEnv tyEnv _ (Record _ _ fs) =
+>   isNonExpansive tcEnv tyEnv fs
+>   -- FIXME: stricly speaking a record construction is non-expansive
+>   -- only if *all* field labels are present; for instance, (:){}
+>   -- probably should be considered expansive
+> isNonExpansiveApp tcEnv tyEnv _ (Tuple es) = isNonExpansive tcEnv tyEnv es
+> isNonExpansiveApp tcEnv tyEnv _ (List _ es) = isNonExpansive tcEnv tyEnv es
 > isNonExpansiveApp tcEnv tyEnv n (Apply f e) =
->   isNonExpansive tcEnv tyEnv e && isNonExpansiveApp tcEnv tyEnv (n + 1) f
+>   isNonExpansiveApp tcEnv tyEnv (n + 1) f && isNonExpansive tcEnv tyEnv e
 > isNonExpansiveApp tcEnv tyEnv n (InfixApply e1 op e2) =
 >   isNonExpansiveApp tcEnv tyEnv (n + 2) (infixOp op) &&
 >   isNonExpansive tcEnv tyEnv e1 && isNonExpansive tcEnv tyEnv e2
 > isNonExpansiveApp tcEnv tyEnv n (LeftSection e op) =
 >   isNonExpansiveApp tcEnv tyEnv (n + 1) (infixOp op) &&
 >   isNonExpansive tcEnv tyEnv e
-> isNonExpansiveApp _ _ n (Lambda ts _) = n < length ts
+> isNonExpansiveApp tcEnv tyEnv n (Lambda _ ts e) =
+>   n < length ts ||
+>   all isVarPattern ts && isNonExpansiveApp tcEnv tyEnv' (n - length ts) e
+>   where tyEnv' = foldr bindVarArity tyEnv (bv ts)
 > isNonExpansiveApp tcEnv tyEnv n (Let ds e) =
->   isNonExpansive tcEnv tyEnv ds && isNonExpansiveApp tcEnv tyEnv n e
+>   isNonExpansive tcEnv tyEnv' ds && isNonExpansiveApp tcEnv tyEnv' n e
+>   where tyEnv' = foldr (bindDeclArity tcEnv) tyEnv ds
 > isNonExpansiveApp _ _ _ _ = False
 
+> bindDeclArity :: TCEnv -> Decl a -> ValueEnv -> ValueEnv
+> bindDeclArity _ (InfixDecl _ _ _ _) tyEnv = tyEnv
+> bindDeclArity _ (TypeSig _ _ _) tyEnv = tyEnv
+> bindDeclArity _ (FunctionDecl _ _ f eqs) tyEnv =
+>   bindArity f (eqnArity (head eqs)) tyEnv
+> bindDeclArity tcEnv (ForeignDecl _ _ _ f ty) tyEnv =
+>   bindArity f (foreignArity ty') tyEnv
+>   where ty' = unqualType (expandPolyType tcEnv (QualTypeExpr [] ty))
+> bindDeclArity _ (PatternDecl _ t _) tyEnv = foldr bindVarArity tyEnv (bv t)
+> bindDeclArity _ (FreeDecl _ vs) tyEnv = foldr bindVarArity tyEnv (bv vs)
+> bindDeclArity _ (TrustAnnot _ _ _) tyEnv = tyEnv
+
+> bindVarArity :: Ident -> ValueEnv -> ValueEnv
+> bindVarArity v tyEnv = bindArity v 0 tyEnv
+
+> bindArity :: Ident -> Int -> ValueEnv -> ValueEnv
+> bindArity v n tyEnv = localBindTopEnv v (Value (qualify v) n undefined) tyEnv
+
+\end{verbatim}
+\paragraph{Class and instance declarations}
+When checking method implementations in class and instance
+declarations, the compiler must check that the inferred type matches
+the method's declared type. This is straight forward in class
+declarations (the only difference with respect to an overloaded
+function with an explicit type signature is that a class method's type
+signature is composed of its declared type signature and the context
+from the class declaration), but a little bit more complicated for
+instance declarations because the instance type must be substituted
+for the type variable used in the type class declaration.
+
+When checking inferred method types against their expected types, we
+have to be careful because the class' type variable is always assigned
+index 0 in the method types recorded in the type environment. However,
+in the inferred type scheme returned from \texttt{tcMethodDecl}, type
+variables are assigned indices in the order of their occurrence. In
+order to avoid incorrectly reporting errors when the type class
+variable is not the first variable that appears in a method's type,
+\texttt{tcInstMethodDecl} normalizes the expected method type before
+applying \texttt{checkInstMethodType} to it and
+\texttt{checkClassMethodType} uses \texttt{expandPolyType} instead of
+\texttt{expandMethodType} in order to convert the method's type
+signature. Unfortunately, this also means that the compiler has to add
+the class type constraint explicitly to the type signature, which is
+done while collecting the type signatures in the \texttt{ClassDecl}
+case of \texttt{tcTopDecl}.
+\begin{verbatim}
+
+> tcTopDecl :: ModuleIdent -> TCEnv -> ValueEnv -> TopDecl a
+>           -> TcState (TopDecl QualType)
+> tcTopDecl _ _ _ (DataDecl p cx tc tvs cs clss) =
+>   return (DataDecl p cx tc tvs cs clss)
+> tcTopDecl _ _ _ (NewtypeDecl p cx tc tvs nc clss) =
+>   return (NewtypeDecl p cx tc tvs nc clss)
+> tcTopDecl _ _ _ (TypeDecl p tc tvs ty) = return (TypeDecl p tc tvs ty)
+> tcTopDecl m tcEnv tyEnv (ClassDecl p cx cls tv ds) =
+>   do
+>     vds' <- mapM (tcClassMethodDecl m tcEnv tyEnv (qualify cls) tv sigs) vds
+>     return (ClassDecl p cx cls tv (map untyped ods ++ vds'))
+>   where sigs = foldr bindTypeSigs noSigs ods
+>         (vds,ods) = partition isValueDecl ds
+> tcTopDecl m tcEnv tyEnv (InstanceDecl p cx cls ty ds) =
+>   do
+>     vds' <- mapM (tcInstMethodDecl m tcEnv tyEnv cls' ty') vds
+>     return (InstanceDecl p cx cls ty (map untyped ods ++ vds'))
+>   where cls' = origName (head (qualLookupTopEnv cls tcEnv))
+>         ty' = expandPolyType tcEnv (QualTypeExpr cx ty)
+>         (vds,ods) = partition isValueDecl ds
+> tcTopDecl _ _ _ (DefaultDecl p tys) = return (DefaultDecl p tys)
+> tcTopDecl _ _ _ (BlockDecl _) = internalError "tcTopDecl"
+
+> tcClassMethodDecl :: ModuleIdent -> TCEnv -> ValueEnv -> QualIdent -> Ident
+>                   -> SigEnv -> Decl a -> TcState (Decl QualType)
+> tcClassMethodDecl m tcEnv tyEnv cls tv sigs d =
+>   do
+>     (ty',d') <- tcMethodDecl m tcEnv tyEnv methTy d
+>     checkClassMethodType tcEnv (clsType cls tv (classMethodSig sigs d)) ty' d'
+>   where methTy = classMethodType (qualifyWith m) d tyEnv
+>         clsType cls tv (QualTypeExpr cx ty) =
+>           QualTypeExpr (ClassAssert cls (VariableType tv) : cx) ty
+
+> checkClassMethodType :: TCEnv -> QualTypeExpr -> TypeScheme -> Decl QualType
+>                      -> TcState (Decl QualType)
+> checkClassMethodType tcEnv sigTy sigma (FunctionDecl p ty f eqs)
+>   | checkTypeSig tcEnv (expandPolyType tcEnv sigTy) sigma =
+>       return (FunctionDecl p ty f eqs)
+>   | otherwise = errorAt p (typeSigTooGeneral tcEnv what sigTy sigma)
+>   where what = text "Method:" <+> ppIdent f
+
+> tcInstMethodDecl :: ModuleIdent -> TCEnv -> ValueEnv -> QualIdent -> QualType
+>                  -> Decl a -> TcState (Decl QualType)
+> tcInstMethodDecl m tcEnv tyEnv cls instTy d =
+>   do
+>     (ty',d') <- tcMethodDecl m tcEnv tyEnv (typeScheme methTy) d
+>     checkInstMethodType tcEnv (normalize 0 methTy) ty' d'
+>   where methTy = instMethodType (qualifyLike cls) instTy d tyEnv
+
+> checkInstMethodType :: TCEnv -> QualType -> TypeScheme -> Decl QualType
+>                     -> TcState (Decl QualType)
+> checkInstMethodType tcEnv methTy sigma (FunctionDecl p ty f eqs)
+>   | checkTypeSig tcEnv methTy sigma = return (FunctionDecl p ty f eqs)
+>   | otherwise = errorAt p (methodSigTooGeneral tcEnv what methTy sigma)
+>   where what = text "Method:" <+> ppIdent f
+
+> tcMethodDecl :: ModuleIdent -> TCEnv -> ValueEnv -> TypeScheme -> Decl a
+>              -> TcState (TypeScheme,Decl QualType)
+> tcMethodDecl m tcEnv tyEnv methTy (FunctionDecl p _ f eqs) =
+>   do
+>     (cx,(ty,d')) <- tcFunctionDecl m tcEnv tyEnv' [] methTy p f eqs
+>     theta <- fetchSt
+>     return (gen zeroSet cx (subst theta ty),d')
+>   where tyEnv' = bindFun m f (eqnArity (head eqs)) methTy tyEnv
+
+> classMethodSig :: SigEnv -> Decl a -> QualTypeExpr
+> classMethodSig sigs (FunctionDecl _ _ f _) =
+>   fromJust (lookupEnv (unRenameIdent f) sigs)
+
+> classMethodType :: (Ident -> QualIdent) -> Decl a -> ValueEnv -> TypeScheme
+> classMethodType qualify (FunctionDecl _ _ f _) tyEnv =
+>   funType (qualify (unRenameIdent f)) tyEnv
+
+> instMethodType :: (Ident -> QualIdent) -> QualType -> Decl a -> ValueEnv
+>                -> QualType
+> instMethodType qualify (QualType cx ty) d tyEnv =
+>   contextMap (cx ++) (instanceType ty (contextMap tail ty'))
+>   where ForAll _ ty' = classMethodType qualify d tyEnv
+
 \end{verbatim}
+\paragraph{Foreign Functions}
 Argument and result types of foreign functions using the
 \texttt{ccall} calling convention are restricted to the basic types
 \texttt{Bool}, \texttt{Char}, \texttt{Int}, \texttt{Float},
@@ -406,7 +920,7 @@
 allows arbitrary argument and result types. However, in contrast
 to the \texttt{ccall} calling convention, no marshaling takes place at
 all even for the basic types (cf.\ Sect.~\ref{sec:il-compile} with
-regard to marshalling). The type of a dynamic function wrapper is
+regard to marshaling). The type of a dynamic function wrapper is
 restricted further to be of the form $\texttt{FunPtr}\;t \rightarrow
 t$, where $t$ is a valid foreign function type, and the type of a
 foreign address must be either $\texttt{Ptr}\;a$ or
@@ -419,27 +933,20 @@
 equivalent to $\emph{World}\rightarrow(t,\emph{World})$.
 \begin{verbatim}
 
-> tcForeignFunct :: ModuleIdent -> TCEnv -> Position -> CallConv
->                -> Maybe String -> Ident -> TypeExpr -> TcState ()
-> tcForeignFunct m tcEnv p cc ie f ty =
->   do
->     checkForeignType cc (rawType ty')
->     updateSt_ (bindFun m f (foreignArity ty') ty')
->   where ty' = expandPolyType tcEnv ty
+> tcForeignFunct :: ModuleIdent -> TCEnv -> ValueEnv
+>                -> Position -> ForeignImport -> Ident -> TypeExpr
+>                -> TcState (ValueEnv,Type)
+> tcForeignFunct m tcEnv tyEnv p (cc,_,ie) f ty =
+>   do
+>     checkForeignType cc ty'
+>     return (bindFun m f (foreignArity ty') (polyType ty') tyEnv,ty')
+>   where ty' = unqualType (expandPolyType tcEnv (QualTypeExpr [] ty))
 >         checkForeignType cc ty
 >           | cc == CallConvPrimitive = return ()
 >           | ie == Just "dynamic" = checkCDynCallType tcEnv p cc ty
 >           | maybe False ('&' `elem`) ie = checkCAddrType tcEnv p ty
 >           | otherwise = checkCCallType tcEnv p cc ty
 
-> foreignArity :: TypeScheme -> Int
-> foreignArity (ForAll _ ty)
->   | isIO (arrowBase ty') = length tys + 1
->   | otherwise = length tys
->   where (tys,ty') = arrowUnapply ty
->         isIO (TypeConstructor tc [_]) = tc == qIOId
->         isIO _ = False
-
 > checkCCallType :: TCEnv -> Position -> CallConv -> Type -> TcState ()
 > checkCCallType tcEnv p CallConvCCall (TypeArrow ty1 ty2)
 >   | isCArgType ty1 = checkCCallType tcEnv p CallConvCCall ty2
@@ -450,7 +957,8 @@
 > checkCCallType _ _ CallConvRawCall _ = return ()
 
 > checkCDynCallType :: TCEnv -> Position -> CallConv -> Type -> TcState ()
-> checkCDynCallType tcEnv p cc (TypeArrow (TypeConstructor tc [ty1]) ty2)
+> checkCDynCallType tcEnv p cc
+>                   (TypeArrow (TypeApply (TypeConstructor tc) ty1) ty2)
 >   | tc == qFunPtrId && ty1 == ty2 = checkCCallType tcEnv p cc ty1
 > checkCDynCallType tcEnv p _ ty =
 >   errorAt p (invalidCType "dynamic function" tcEnv ty)
@@ -461,17 +969,18 @@
 >   | otherwise = errorAt p (invalidCType "static address" tcEnv ty)
 
 > isCArgType :: Type -> Bool
-> isCArgType (TypeConstructor tc []) = tc `elem` cBasicTypeId
-> isCArgType (TypeConstructor tc [_]) = tc `elem` qStablePtrId:cPointerTypeId
+> isCArgType (TypeConstructor tc) = tc `elem` cBasicTypeId
+> isCArgType (TypeApply (TypeConstructor tc) _) =
+>   tc `elem` qStablePtrId:cPointerTypeId
 > isCArgType _ = False
 
 > isCRetType :: Type -> Bool
-> isCRetType (TypeConstructor tc [ty])
+> isCRetType (TypeApply (TypeConstructor tc) ty)
 >   | tc == qIOId = ty == unitType || isCArgType ty
 > isCRetType ty = isCArgType ty
 
 > isCPtrType :: Type -> Bool
-> isCPtrType (TypeConstructor tc [_]) = tc `elem` cPointerTypeId
+> isCPtrType (TypeApply (TypeConstructor tc) _) = tc `elem` cPointerTypeId
 > isCPtrType _ = False
 
 > cBasicTypeId, cPointerTypeId :: [QualIdent]
@@ -480,275 +989,479 @@
 
 \end{verbatim}
 \paragraph{Patterns and Expressions}
-\begin{verbatim}
-
-> tcLiteral :: ModuleIdent -> Literal -> TcState Type
-> tcLiteral _ (Char _) = return charType
-> tcLiteral m (Int v _) =
->   do
->     ty <- freshConstrained [intType,floatType]
->     updateSt_ (bindFun m v 0 (monoType ty))
->     return ty
-> tcLiteral _ (Float _) = return floatType
-> tcLiteral _ (String _) = return stringType
-
-> tcConstrTerm :: ModuleIdent -> TCEnv -> Position -> ConstrTerm -> TcState Type
-> tcConstrTerm m _ _ (LiteralPattern l) = tcLiteral m l
-> tcConstrTerm m _ _ (NegativePattern _ l) = tcLiteral m l
-> tcConstrTerm _ _ _ (VariablePattern v) = fetchSt >>= inst . varType v
-> tcConstrTerm m tcEnv p t@(ConstructorPattern c ts) =
->   tcConstrApp m tcEnv p (ppConstrTerm 0 t) c ts
-> tcConstrTerm m tcEnv p t@(InfixPattern t1 op t2) =
->   tcConstrApp m tcEnv p (ppConstrTerm 0 t) op [t1,t2]
-> tcConstrTerm m tcEnv p (ParenPattern t) = tcConstrTerm m tcEnv p t
-> tcConstrTerm m tcEnv p (TuplePattern ts) =
->   liftM tupleType (mapM (tcConstrTerm m tcEnv p) ts)
-> tcConstrTerm m tcEnv p t@(ListPattern ts) =
+Note that the type attribute associated with a constructor or infix
+pattern is the type of the whole pattern and not the type of the
+constructor itself. Overloaded (numeric) literals are supported in
+expressions and patterns of case alternatives, but not in other
+patterns.
+
+\ToDo{The types admissible for numeric literals in patterns without
+  overloading should in some way acknowledge the set of types
+  specified in a default declaration if one is present.}
+
+When computing the type of a variable in a pattern, we ignore the
+context of the variable's type (which can only be due to a type
+signature in the same declaration group) for just the same reason as
+in \texttt{tcFunctionDecl} above.
+\begin{verbatim}
+
+> tcLiteral :: Bool -> Literal -> TcState (Context,Type)
+> tcLiteral _ (Char _) = return ([],charType)
+> tcLiteral poly (Integer _)
+>   | poly = freshNumType
+>   | otherwise = liftM ((,) []) (freshConstrained numTypes)
+> tcLiteral poly (Rational _)
+>   | poly = freshFracType
+>   | otherwise = liftM ((,) []) (freshConstrained fracTypes)
+> tcLiteral _ (String _) = return ([],stringType)
+
+> tcLhs :: TCEnv -> ValueEnv -> Position -> Lhs a
+>       -> TcState (Context,[Type],Lhs QualType)
+> tcLhs tcEnv tyEnv p (FunLhs f ts) =
+>   do
+>     (cxs,tys,ts') <- liftM unzip3 $ mapM (tcConstrTerm False tcEnv tyEnv p) ts
+>     return (concat cxs,tys,FunLhs f ts')
+> tcLhs tcEnv tyEnv p (OpLhs t1 op t2) =
+>   do
+>     (cx1,ty1,t1') <- tcConstrTerm False tcEnv tyEnv p t1
+>     (cx2,ty2,t2') <- tcConstrTerm False tcEnv tyEnv p t2
+>     return (cx1 ++ cx2,[ty1,ty2],OpLhs t1' op t2')
+> tcLhs tcEnv tyEnv p (ApLhs lhs ts) =
+>   do
+>     (cx,tys1,lhs') <- tcLhs tcEnv tyEnv p lhs
+>     (cxs,tys2,ts') <-
+>       liftM unzip3 $ mapM (tcConstrTerm False tcEnv tyEnv p) ts
+>     return (cx ++ concat cxs,tys1 ++ tys2,ApLhs lhs' ts')
+
+> tcConstrTerm :: Bool -> TCEnv -> ValueEnv -> Position -> ConstrTerm a
+>              -> TcState (Context,Type,ConstrTerm QualType)
+> tcConstrTerm poly _ _ _ (LiteralPattern _ l) =
+>   do
+>     (cx,ty) <- tcLiteral poly l
+>     return (cx,ty,LiteralPattern (qualType ty) l)
+> tcConstrTerm poly _ _ _ (NegativePattern _ l) =
+>   do
+>     (cx,ty) <- tcLiteral poly l
+>     return (cx,ty,NegativePattern (qualType ty) l)
+> tcConstrTerm _ _ tyEnv _ (VariablePattern _ v) =
+>   do
+>     (_,ty) <- inst (varType v tyEnv)
+>     return ([],ty,VariablePattern (qualType ty) v)
+> tcConstrTerm poly tcEnv tyEnv p t@(ConstructorPattern _ c ts) =
+>   do
+>     (cx,ty) <- skol tcEnv (conType c tyEnv)
+>     tcConstrApp poly tcEnv tyEnv p (ppConstrTerm 0 t) c cx ty ts
+> tcConstrTerm poly tcEnv tyEnv p t@(FunctionPattern _ f ts) =
+>   do
+>     (cx,ty) <- inst (funType f tyEnv)
+>     tcFunctPattern poly tcEnv tyEnv p (ppConstrTerm 0 t) f id cx ty ts
+> tcConstrTerm poly tcEnv tyEnv p t@(InfixPattern _ t1 op t2) =
+>   do
+>     (cx,ty) <- tcPatternOp tcEnv tyEnv p op
+>     (alpha,beta,gamma) <-
+>       tcBinary p "infix pattern" (doc $-$ text "Operator:" <+> ppOp op)
+>                tcEnv ty
+>     (cx',t1') <- tcConstrArg poly tcEnv tyEnv p "pattern" doc cx alpha t1
+>     (cx'',t2') <- tcConstrArg poly tcEnv tyEnv p "pattern" doc cx' beta t2
+>     return (cx'',gamma,InfixPattern (qualType gamma) t1' op t2')
+>   where doc = ppConstrTerm 0 t
+> tcConstrTerm poly tcEnv tyEnv p (ParenPattern t) =
+>   do
+>     (cx,ty,t') <- tcConstrTerm poly tcEnv tyEnv p t
+>     return (cx,ty,ParenPattern t')
+> tcConstrTerm poly tcEnv tyEnv p t@(RecordPattern _ c fs) =
+>   do
+>     (cx,ty) <- liftM (apSnd arrowBase) (skol tcEnv (conType c tyEnv))
+>     (cx',fs') <-
+>       mapAccumM (tcField (tcConstrTerm poly) "pattern" doc tcEnv tyEnv p ty)
+>                 cx fs
+>     return (cx',ty,RecordPattern (qualType ty) c fs')
+>   where doc t1 = ppConstrTerm 0 t $-$ text "Term:" <+> ppConstrTerm 0 t1
+> tcConstrTerm poly tcEnv tyEnv p (TuplePattern ts) =
+>   do
+>     (cxs,tys,ts') <- liftM unzip3 $ mapM (tcConstrTerm poly tcEnv tyEnv p) ts
+>     return (concat cxs,tupleType tys,TuplePattern ts')
+> tcConstrTerm poly tcEnv tyEnv p t@(ListPattern _ ts) =
 >   do
 >     ty <- freshTypeVar
->     mapM_ (tcElem (ppConstrTerm 0 t) ty) ts
->     return (listType ty)
->   where tcElem doc ty t =
->           tcConstrTerm m tcEnv p t >>=
->           unify p "pattern" (doc $-$ text "Term:" <+> ppConstrTerm 0 t)
->                 tcEnv ty
-> tcConstrTerm m tcEnv p t@(AsPattern v t') =
->   do
->     ty <- tcConstrTerm m tcEnv p (VariablePattern v)
->     tcConstrTerm m tcEnv p t' >>=
->       unify p "pattern" (ppConstrTerm 0 t) tcEnv ty
->     return ty
-> tcConstrTerm m tcEnv p (LazyPattern t) = tcConstrTerm m tcEnv p t
-
-> tcConstrApp :: ModuleIdent -> TCEnv -> Position -> Doc -> QualIdent
->             -> [ConstrTerm] -> TcState Type
-> tcConstrApp m tcEnv p doc c ts =
+>     (cx,ts') <-
+>       mapAccumM (flip (tcConstrArg poly tcEnv tyEnv p "pattern" doc) ty) [] ts
+>     return (cx,listType ty,ListPattern (qualType (listType ty)) ts')
+>   where doc = ppConstrTerm 0 t
+> tcConstrTerm poly tcEnv tyEnv p t@(AsPattern v t') =
+>   do
+>     (_,ty) <- inst (varType v tyEnv)
+>     (cx,t'') <-
+>       tcConstrTerm poly tcEnv tyEnv p t' >>-
+>       unify p "pattern" (ppConstrTerm 0 t) tcEnv [] ty
+>     return (cx,ty,AsPattern v t'')
+> tcConstrTerm _ tcEnv tyEnv p (LazyPattern t) =
+>   do
+>     (cx,ty,t') <- tcConstrTerm False tcEnv tyEnv p t
+>     return (cx,ty,LazyPattern t')
+
+> tcConstrApp :: Bool -> TCEnv -> ValueEnv -> Position -> Doc -> QualIdent
+>             -> Context -> Type -> [ConstrTerm a]
+>             -> TcState (Context,Type,ConstrTerm QualType)
+> tcConstrApp poly tcEnv tyEnv p doc c cx ty ts =
 >   do
->     tyEnv <- fetchSt
->     (tys,ty) <- liftM arrowUnapply (skol (conType c tyEnv))
 >     unless (length tys == n) (errorAt p (wrongArity c (length tys) n))
->     zipWithM_ (tcConstrArg m tcEnv p doc) ts tys
->     return ty
->   where n = length ts
-
-> tcConstrArg :: ModuleIdent -> TCEnv -> Position -> Doc -> ConstrTerm -> Type
->             -> TcState ()
-> tcConstrArg m tcEnv p doc t ty =
->   tcConstrTerm m tcEnv p t >>=
->   unify p "pattern" (doc $-$ text "Term:" <+> ppConstrTerm 0 t) tcEnv ty
-
-> tcRhs :: ModuleIdent -> TCEnv -> Rhs -> TcState Type
-> tcRhs m tcEnv (SimpleRhs p e ds) =
->   do
->     tcDecls m tcEnv ds
->     tcExpr m tcEnv p e
-> tcRhs m tcEnv (GuardedRhs es ds) =
+>     (cx',ts') <-
+>       mapAccumM (uncurry . tcConstrArg poly tcEnv tyEnv p "pattern" doc) cx
+>                 (zip tys ts)
+>     return (cx',ty',ConstructorPattern (qualType ty') c ts')
+>   where (tys,ty') = arrowUnapply ty
+>         n = length ts
+
+> tcFunctPattern :: Bool -> TCEnv -> ValueEnv -> Position -> Doc -> QualIdent
+>                -> ([ConstrTerm QualType] -> [ConstrTerm QualType])
+>                -> Context -> Type -> [ConstrTerm a]
+>                -> TcState (Context,Type,ConstrTerm QualType)
+> tcFunctPattern _ _ _ _ _ f ts cx ty [] =
+>   return (cx,ty,FunctionPattern (qualType ty) f (ts []))
+> tcFunctPattern poly tcEnv tyEnv p doc f ts cx ty (t':ts') =
+>   do
+>     (alpha,beta) <-
+>       tcArrow p "pattern" (doc $-$ text "Term:" <+> ppConstrTerm 0 t) tcEnv ty
+>     (cx',t'') <- tcConstrArg poly tcEnv tyEnv p "pattern" doc cx alpha t'
+>     tcFunctPattern poly tcEnv tyEnv p doc f (ts . (t'':)) cx' beta ts'
+>   where t = FunctionPattern (qualType ty) f (ts [])
+
+> tcConstrArg :: Bool -> TCEnv -> ValueEnv -> Position -> String -> Doc
+>             -> Context -> Type -> ConstrTerm a
+>             -> TcState (Context,ConstrTerm QualType)
+> tcConstrArg poly tcEnv tyEnv p what doc cx ty t =
+>   tcConstrTerm poly tcEnv tyEnv p t >>-
+>   unify p what (doc $-$ text "Term:" <+> ppConstrTerm 0 t) tcEnv cx ty
+
+> tcPatternOp :: TCEnv -> ValueEnv -> Position -> InfixOp a
+>             -> TcState (Context,Type)
+> tcPatternOp tcEnv tyEnv p (InfixConstr _ op) =
+>   do
+>     (cx,ty) <- skol tcEnv (conType op tyEnv)
+>     unless (arrowArity ty == 2) (errorAt p (wrongArity op (arrowArity ty) 2))
+>     return (cx,ty)
+> tcPatternOp _ tyEnv _ (InfixOp _ op) = inst (funType op tyEnv)
+
+> tcRhs :: ModuleIdent -> TCEnv -> ValueEnv -> Rhs a
+>       -> TcState (Context,Type,Rhs QualType)
+> tcRhs m tcEnv tyEnv (SimpleRhs p e ds) =
+>   do
+>     (tyEnv',cx,ds') <- tcDecls m tcEnv tyEnv ds
+>     (cx',ty,e') <- tcExpr m tcEnv tyEnv' p e
+>     cx'' <- reduceContext p "expression" (ppExpr 0 e') tcEnv (cx ++ cx')
+>     return (cx'',ty,SimpleRhs p e' ds')
+> tcRhs m tcEnv tyEnv (GuardedRhs es ds) =
 >   do
->     tcDecls m tcEnv ds
+>     (tyEnv',cx,ds') <- tcDecls m tcEnv tyEnv ds
 >     gty <- guardType es
 >     ty <- freshTypeVar
->     mapM_ (tcCondExpr m tcEnv gty ty) es
->     return ty
+>     (cx',es') <- mapAccumM (tcCondExpr m tcEnv tyEnv' gty ty) cx es
+>     return (cx',ty,GuardedRhs es' ds')
 >   where guardType es
 >           | length es > 1 = return boolType
->           | otherwise = freshConstrained [successType,boolType]
+>           | otherwise = freshConstrained guardTypes
 
-> tcCondExpr :: ModuleIdent -> TCEnv -> Type -> Type -> CondExpr -> TcState ()
-> tcCondExpr m tcEnv gty ty (CondExpr p g e) =
->   do
->     tcExpr m tcEnv p g >>= unify p "guard" (ppExpr 0 g) tcEnv gty
->     tcExpr m tcEnv p e >>= unify p "guarded expression" (ppExpr 0 e) tcEnv ty
-
-> tcExpr :: ModuleIdent -> TCEnv -> Position -> Expression -> TcState Type
-> tcExpr m _ _ (Literal l) = tcLiteral m l
-> tcExpr m tcEnv p (Variable v) = fetchSt >>= inst . funType v
-> tcExpr m tcEnv p (Constructor c) = fetchSt >>= inst . conType c
-> tcExpr m tcEnv p (Typed e sig) =
->   do
->     tyEnv0 <- fetchSt
->     ty <- inst sigma'
->     tcExpr m tcEnv p e >>=
->       unify p "explicitly typed expression" (ppExpr 0 e) tcEnv ty
->     theta <- liftSt fetchSt
->     let sigma = gen (fvEnv (subst theta tyEnv0)) (subst theta ty)
->     unless (sigma == sigma')
+> tcCondExpr :: ModuleIdent -> TCEnv -> ValueEnv -> Type -> Type -> Context
+>            -> CondExpr a -> TcState (Context,CondExpr QualType)
+> tcCondExpr m tcEnv tyEnv gty ty cx (CondExpr p g e) =
+>   do
+>     (cx',g') <-
+>       tcExpr m tcEnv tyEnv p g >>- unify p "guard" (ppExpr 0 g) tcEnv cx gty
+>     (cx'',e') <-
+>       tcExpr m tcEnv tyEnv p e >>-
+>       unify p "expression" (ppExpr 0 e) tcEnv cx' ty
+>     return (cx'',CondExpr p g' e')
+
+> tcExpr :: ModuleIdent -> TCEnv -> ValueEnv -> Position -> Expression a
+>        -> TcState (Context,Type,Expression QualType)
+> tcExpr _ _ _ _ (Literal _ l) =
+>   do
+>     (cx,ty) <- tcLiteral True l
+>     return (cx,ty,Literal (qualType ty) l)
+> tcExpr _ _ tyEnv _ (Variable _ v) =
+>   do
+>     (cx,ty) <-
+>       if unRenameIdent (unqualify v) == anonId then freshQualType []
+>       else inst (funType v tyEnv)
+>     return (cx,ty,Variable (qualType ty) v)
+> tcExpr _ _ tyEnv _ (Constructor _ c) =
+>   do
+>     (cx,ty) <- inst (thd3 (conType c tyEnv))
+>     return (cx,ty,Constructor (qualType ty) c)
+> tcExpr m tcEnv tyEnv p (Typed e sig) =
+>   do
+>     (cx,ty) <- inst (typeScheme sigTy)
+>     (cx',e') <-
+>       tcExpr m tcEnv tyEnv p e >>-
+>       unifyDecl p "explicitly typed expression" (ppExpr 0 e) tcEnv tyEnv [] ty
+>     theta <- fetchSt
+>     let fvs = fvEnv (subst theta tyEnv)
+>         (gcx,lcx) = splitContext fvs cx'
+>         sigma = gen fvs lcx (subst theta ty)
+>     unless (checkTypeSig tcEnv sigTy sigma)
 >       (errorAt p (typeSigTooGeneral tcEnv (text "Expression:" <+> ppExpr 0 e)
 >                                     sig sigma))
->     return ty
->   where sigma' = expandPolyType tcEnv sig
-> tcExpr m tcEnv p (Paren e) = tcExpr m tcEnv p e
-> tcExpr m tcEnv p (Tuple es) = liftM tupleType (mapM (tcExpr m tcEnv p) es)
-> tcExpr m tcEnv p e@(List es) =
+>     return (cx ++ gcx,ty,Typed e' sig)
+>   where sigTy = expandPolyType tcEnv sig
+> tcExpr m tcEnv tyEnv p (Paren e) =
+>   do
+>     (cx,ty,e') <- tcExpr m tcEnv tyEnv p e
+>     return (cx,ty,Paren e')
+> tcExpr m tcEnv tyEnv p e@(Record _ c fs) =
+>   do
+>     (cx,ty) <- liftM (apSnd arrowBase) (inst (thd3 (conType c tyEnv)))
+>     (cx',fs') <-
+>       mapAccumM (tcField (tcExpr m) "construction" doc tcEnv tyEnv p ty) cx fs
+>     return (cx',ty,Record (qualType ty) c fs')
+>   where doc e1 = ppExpr 0 e $-$ text "Term:" <+> ppExpr 0 e1
+> tcExpr m tcEnv tyEnv p e@(RecordUpdate e1 fs) =
+>   do
+>     (cx,ty,e1') <- tcExpr m tcEnv tyEnv p e1
+>     (cx',fs') <-
+>       mapAccumM (tcField (tcExpr m) "update" doc tcEnv tyEnv p ty) cx fs
+>     return (cx',ty,RecordUpdate e1' fs')
+>   where doc e1 = ppExpr 0 e $-$ text "Term:" <+> ppExpr 0 e1
+> tcExpr m tcEnv tyEnv p (Tuple es) =
+>   do
+>     (cxs,tys,es') <- liftM unzip3 $ mapM (tcExpr m tcEnv tyEnv p) es
+>     return (concat cxs,tupleType tys,Tuple es')
+> tcExpr m tcEnv tyEnv p e@(List _ es) =
 >   do
 >     ty <- freshTypeVar
->     mapM_ (tcElem (ppExpr 0 e) ty) es
->     return (listType ty)
->   where tcElem doc ty e =
->           tcExpr m tcEnv p e >>=
->           unify p "expression" (doc $-$ text "Term:" <+> ppExpr 0 e) tcEnv ty
-> tcExpr m tcEnv p (ListCompr e qs) =
->   do
->     mapM_ (tcQual m tcEnv p) qs
->     liftM listType (tcExpr m tcEnv p e)
-> tcExpr m tcEnv p e@(EnumFrom e1) =
->   do
->     tcExpr m tcEnv p e1 >>=
->       unify p "arithmetic sequence"
->             (ppExpr 0 e $-$ text "Term:" <+> ppExpr 0 e1) tcEnv intType
->     return (listType intType)
-> tcExpr m tcEnv p e@(EnumFromThen e1 e2) =
->   do
->     tcExpr m tcEnv p e1 >>=
->       unify p "arithmetic sequence"
->             (ppExpr 0 e $-$ text "Term:" <+> ppExpr 0 e1) tcEnv intType
->     tcExpr m tcEnv p e2 >>=
->       unify p "arithmetic sequence"
->             (ppExpr 0 e $-$ text "Term:" <+> ppExpr 0 e2) tcEnv intType
->     return (listType intType)
-> tcExpr m tcEnv p e@(EnumFromTo e1 e2) =
->   do
->     tcExpr m tcEnv p e1 >>=
->       unify p "arithmetic sequence"
->             (ppExpr 0 e $-$ text "Term:" <+> ppExpr 0 e1) tcEnv intType
->     tcExpr m tcEnv p e2 >>=
->       unify p "arithmetic sequence"
->             (ppExpr 0 e $-$ text "Term:" <+> ppExpr 0 e2) tcEnv intType
->     return (listType intType)
-> tcExpr m tcEnv p e@(EnumFromThenTo e1 e2 e3) =
->   do
->     tcExpr m tcEnv p e1 >>=
->       unify p "arithmetic sequence"
->             (ppExpr 0 e $-$ text "Term:" <+> ppExpr 0 e1) tcEnv intType
->     tcExpr m tcEnv p e2 >>=
->       unify p "arithmetic sequence"
->             (ppExpr 0 e $-$ text "Term:" <+> ppExpr 0 e2) tcEnv intType
->     tcExpr m tcEnv p e3 >>=
->       unify p "arithmetic sequence"
->             (ppExpr 0 e $-$ text "Term:" <+> ppExpr 0 e3) tcEnv intType
->     return (listType intType)
-> tcExpr m tcEnv p e@(UnaryMinus op e1) =
->   do
->     ty <- opType op
->     tcExpr m tcEnv p e1 >>=
->       unify p "unary negation" (ppExpr 0 e $-$ text "Term:" <+> ppExpr 0 e1)
->             tcEnv ty
->     return ty
->   where opType op
->           | op == minusId = freshConstrained [intType,floatType]
->           | op == fminusId = return floatType
->           | otherwise = internalError ("tcExpr unary " ++ name op)
-> tcExpr m tcEnv p e@(Apply e1 e2) =
+>     (cx,es') <-
+>       mapAccumM (flip (tcArg m tcEnv tyEnv p "expression" doc) ty) [] es
+>     return (cx,listType ty,List (qualType (listType ty)) es')
+>   where doc = ppExpr 0 e
+> tcExpr m tcEnv tyEnv p (ListCompr e qs) =
+>   do
+>     fs <- liftM (fsEnv . flip subst tyEnv) fetchSt
+>     ((tyEnv',cx),qs') <-
+>       mapAccumM (uncurry (flip (tcQual m tcEnv) p)) (tyEnv,[]) qs
+>     (cx',ty,e') <- tcExpr m tcEnv tyEnv' p e
+>     cx'' <- reduceContext p "expression" (ppExpr 0 e') tcEnv (cx ++ cx')
+>     checkSkolems p "Expression" (ppExpr 0) tcEnv tyEnv fs cx'' (listType ty)
+>                  (ListCompr e' qs')
+> tcExpr m tcEnv tyEnv p e@(EnumFrom e1) =
+>   do
+>     (cx,ty) <- freshEnumType
+>     (cx',e1') <-
+>       tcArg m tcEnv tyEnv p "arithmetic sequence" (ppExpr 0 e) cx ty e1
+>     return (cx',listType ty,EnumFrom e1')
+> tcExpr m tcEnv tyEnv p e@(EnumFromThen e1 e2) =
+>   do
+>     (cx,ty) <- freshEnumType
+>     (cx',e1') <-
+>       tcArg m tcEnv tyEnv p "arithmetic sequence" (ppExpr 0 e) cx ty e1
+>     (cx'',e2') <-
+>       tcArg m tcEnv tyEnv p "arithmetic sequence" (ppExpr 0 e) cx' ty e2
+>     return (cx'',listType ty,EnumFromThen e1' e2')
+> tcExpr m tcEnv tyEnv p e@(EnumFromTo e1 e2) =
+>   do
+>     (cx,ty) <- freshEnumType
+>     (cx',e1') <-
+>       tcArg m tcEnv tyEnv p "arithmetic sequence" (ppExpr 0 e) cx ty e1
+>     (cx'',e2') <-
+>       tcArg m tcEnv tyEnv p "arithmetic sequence" (ppExpr 0 e) cx' ty e2
+>     return (cx'',listType ty,EnumFromTo e1' e2')
+> tcExpr m tcEnv tyEnv p e@(EnumFromThenTo e1 e2 e3) =
+>   do
+>     (cx,ty) <- freshEnumType
+>     (cx',e1') <-
+>       tcArg m tcEnv tyEnv p "arithmetic sequence" (ppExpr 0 e) cx ty e1
+>     (cx'',e2') <-
+>       tcArg m tcEnv tyEnv p "arithmetic sequence" (ppExpr 0 e) cx' ty e2
+>     (cx''',e3') <-
+>       tcArg m tcEnv tyEnv p "arithmetic sequence" (ppExpr 0 e) cx'' ty e3
+>     return (cx''',listType ty,EnumFromThenTo e1' e2' e3')
+> tcExpr m tcEnv tyEnv p e@(UnaryMinus e1) =
+>   do
+>     (cx,ty) <- freshNumType
+>     (cx',e1') <- tcArg m tcEnv tyEnv p "unary negation" (ppExpr 0 e) cx ty e1
+>     return (cx',ty,UnaryMinus e1')
+> tcExpr m tcEnv tyEnv p e@(Apply e1 e2) =
 >   do
->     (alpha,beta) <-
->       tcExpr m tcEnv p e1 >>=
+>     (cx,(alpha,beta),e1') <-
+>       tcExpr m tcEnv tyEnv p e1 >>=-
 >       tcArrow p "application" (ppExpr 0 e $-$ text "Term:" <+> ppExpr 0 e1)
 >               tcEnv
->     tcExpr m tcEnv p e2 >>=
->       unify p "application" (ppExpr 0 e $-$ text "Term:" <+> ppExpr 0 e2)
->             tcEnv alpha
->     return beta
-> tcExpr m tcEnv p e@(InfixApply e1 op e2) =
+>     (cx',e2') <- tcArg m tcEnv tyEnv p "application" (ppExpr 0 e) cx alpha e2
+>     return (cx',beta,Apply e1' e2')
+> tcExpr m tcEnv tyEnv p e@(InfixApply e1 op e2) =
 >   do
->     (alpha,beta,gamma) <-
->       tcExpr m tcEnv p (infixOp op) >>=
+>     (cx,(alpha,beta,gamma),op') <-
+>       tcInfixOp tyEnv op >>=-
 >       tcBinary p "infix application"
 >                (ppExpr 0 e $-$ text "Operator:" <+> ppOp op) tcEnv
->     tcExpr m tcEnv p e1 >>=
->       unify p "infix application"
->             (ppExpr 0 e $-$ text "Term:" <+> ppExpr 0 e1) tcEnv alpha
->     tcExpr m tcEnv p e2 >>=
->       unify p "infix application"
->             (ppExpr 0 e $-$ text "Term:" <+> ppExpr 0 e2) tcEnv beta
->     return gamma
-> tcExpr m tcEnv p e@(LeftSection e1 op) =
+>     (cx',e1') <-
+>       tcArg m tcEnv tyEnv p "infix application" (ppExpr 0 e) cx alpha e1
+>     (cx'',e2') <-
+>       tcArg m tcEnv tyEnv p "infix application" (ppExpr 0 e) cx' beta e2
+>     return (cx'',gamma,InfixApply e1' op' e2')
+> tcExpr m tcEnv tyEnv p e@(LeftSection e1 op) =
 >   do
->     (alpha,beta) <-
->       tcExpr m tcEnv p (infixOp op) >>=
+>     (cx,(alpha,beta),op') <-
+>       tcInfixOp tyEnv op >>=-
 >       tcArrow p "left section" (ppExpr 0 e $-$ text "Operator:" <+> ppOp op)
 >               tcEnv
->     tcExpr m tcEnv p e1 >>=
->       unify p "left section" (ppExpr 0 e $-$ text "Term:" <+> ppExpr 0 e1)
->             tcEnv alpha
->     return beta
-> tcExpr m tcEnv p e@(RightSection op e1) =
+>     (cx',e1') <- tcArg m tcEnv tyEnv p "left section" (ppExpr 0 e) cx alpha e1
+>     return (cx',beta,LeftSection e1' op')
+> tcExpr m tcEnv tyEnv p e@(RightSection op e1) =
 >   do
->     (alpha,beta,gamma) <-
->       tcExpr m tcEnv p (infixOp op) >>=
+>     (cx,(alpha,beta,gamma),op') <-
+>       tcInfixOp tyEnv op >>=-
 >       tcBinary p "right section"
 >                (ppExpr 0 e $-$ text "Operator:" <+> ppOp op) tcEnv
->     tcExpr m tcEnv p e1 >>=
->       unify p "right section" (ppExpr 0 e $-$ text "Term:" <+> ppExpr 0 e1)
->             tcEnv beta
->     return (TypeArrow alpha gamma)
-> tcExpr m tcEnv p (Lambda ts e) =
->   do
->     bindLambdaVars m ts
->     tys <- mapM (tcConstrTerm m tcEnv p) ts
->     ty <- tcExpr m tcEnv p e
->     return (foldr TypeArrow ty tys)
-> tcExpr m tcEnv p (Let ds e) =
->   do
->     tcDecls m tcEnv ds
->     tcExpr m tcEnv p e
-> tcExpr m tcEnv p (Do sts e) =
->   do
->     mapM_ (tcStmt m tcEnv p) sts
->     ty <- liftM ioType freshTypeVar
->     tcExpr m tcEnv p e >>= unify p "statement" (ppExpr 0 e) tcEnv ty
->     return ty
-> tcExpr m tcEnv p e@(IfThenElse e1 e2 e3) =
->   do
->     tcExpr m tcEnv p e1 >>=
->       unify p "expression" (ppExpr 0 e $-$ text "Term:" <+> ppExpr 0 e1)
->             tcEnv boolType
->     ty <- tcExpr m tcEnv p e2
->     tcExpr m tcEnv p e3 >>=
->       unify p "expression" (ppExpr 0 e $-$ text "Term:" <+> ppExpr 0 e3)
->             tcEnv ty
->     return ty
-> tcExpr m tcEnv p (Case e alts) =
+>     (cx',e1') <- tcArg m tcEnv tyEnv p "right section" (ppExpr 0 e) cx beta e1
+>     return (cx',TypeArrow alpha gamma,RightSection op' e1')
+> tcExpr m tcEnv tyEnv _ (Lambda p ts e) =
+>   do
+>     fs <- liftM (fsEnv . flip subst tyEnv) fetchSt
+>     tyEnv' <- bindLambdaVars m tyEnv ts
+>     (cxs,tys,ts') <-
+>       liftM unzip3 $ mapM (tcConstrTerm False tcEnv tyEnv' p) ts
+>     (cx,ty,e') <- tcExpr m tcEnv tyEnv' p e
+>     cx' <- reduceContext p "expression" (ppExpr 0 e') tcEnv (concat cxs ++ cx)
+>     checkSkolems p "Expression" (ppExpr 0) tcEnv tyEnv fs cx'
+>                  (foldr TypeArrow ty tys) (Lambda p ts' e')
+> tcExpr m tcEnv tyEnv p (Let ds e) =
+>   do
+>     fs <- liftM (fsEnv . flip subst tyEnv) fetchSt
+>     (tyEnv',cx,ds') <- tcDecls m tcEnv tyEnv ds
+>     (cx',ty,e') <- tcExpr m tcEnv tyEnv' p e
+>     cx'' <- reduceContext p "expression" (ppExpr 0 e') tcEnv (cx ++ cx')
+>     checkSkolems p "Expression" (ppExpr 0) tcEnv tyEnv fs cx'' ty (Let ds' e')
+> tcExpr m tcEnv tyEnv p (Do sts e) =
+>   do
+>     fs <- liftM (fsEnv . flip subst tyEnv) fetchSt
+>     ((tyEnv',cx,mTy),sts') <-
+>       mapAccumM (uncurry3 (flip (tcStmt m tcEnv) p)) (tyEnv,[],Nothing) sts
+>     ty <- liftM (maybe id TypeApply mTy) freshTypeVar
+>     (cx',e') <-
+>       tcExpr m tcEnv tyEnv' p e >>-
+>       unify p "statement" (ppExpr 0 e) tcEnv cx ty
+>     checkSkolems p "Expression" (ppExpr 0) tcEnv tyEnv fs cx' ty (Do sts' e')
+> tcExpr m tcEnv tyEnv p e@(IfThenElse e1 e2 e3) =
+>   do
+>     (cx,e1') <- tcArg m tcEnv tyEnv p "expression" (ppExpr 0 e) [] boolType e1
+>     (cx',ty,e2') <- tcExpr m tcEnv tyEnv p e2
+>     (cx'',e3') <-
+>       tcArg m tcEnv tyEnv p "expression" (ppExpr 0 e) (cx ++ cx') ty e3
+>     return (cx'',ty,IfThenElse e1' e2' e3')
+> tcExpr m tcEnv tyEnv p (Case e as) =
 >   do
->     tyLhs <- tcExpr m tcEnv p e
+>     (cx,tyLhs,e') <- tcExpr m tcEnv tyEnv p e
 >     tyRhs <- freshTypeVar
->     mapM_ (tcAlt m tcEnv tyLhs tyRhs) alts
->     return tyRhs
-
-> tcAlt :: ModuleIdent -> TCEnv -> Type -> Type -> Alt -> TcState ()
-> tcAlt m tcEnv tyLhs tyRhs a@(Alt p t rhs) =
+>     fs <- liftM (fsEnv . flip subst tyEnv) fetchSt
+>     (cx',as') <- mapAccumM (tcAlt True m tcEnv tyEnv fs tyLhs tyRhs) cx as
+>     return (cx',tyRhs,Case e' as')
+> tcExpr m tcEnv tyEnv p (Fcase e as) =
 >   do
->     bindLambdaVars m t
->     tcConstrTerm m tcEnv p t >>=
->       unify p "case pattern" (doc $-$ text "Term:" <+> ppConstrTerm 0 t)
->             tcEnv tyLhs
->     tcRhs m tcEnv rhs >>= unify p "case branch" doc tcEnv tyRhs
->   where doc = ppAlt a
-
-> tcQual :: ModuleIdent -> TCEnv -> Position -> Statement -> TcState ()
-> tcQual m tcEnv p (StmtExpr e) =
->   tcExpr m tcEnv p e >>= unify p "guard" (ppExpr 0 e) tcEnv boolType
-> tcQual m tcEnv p q@(StmtBind t e) =
->   do
->     bindLambdaVars m t
->     ty <- tcConstrTerm m tcEnv p t
->     tcExpr m tcEnv p e >>=
->       unify p "generator" (ppStmt q $-$ text "Term:" <+> ppExpr 0 e)
->             tcEnv (listType ty)
-> tcQual m tcEnv p (StmtDecl ds) = tcDecls m tcEnv ds
-
-> tcStmt :: ModuleIdent -> TCEnv -> Position -> Statement -> TcState ()
-> tcStmt m tcEnv p (StmtExpr e) =
+>     (cx,tyLhs,e') <- tcExpr m tcEnv tyEnv p e
+>     tyRhs <- freshTypeVar
+>     fs <- liftM (fsEnv . flip subst tyEnv) fetchSt
+>     (cx',as') <- mapAccumM (tcAlt False m tcEnv tyEnv fs tyLhs tyRhs) cx as
+>     return (cx',tyRhs,Fcase e' as')
+
+> tcArg :: ModuleIdent -> TCEnv -> ValueEnv -> Position -> String -> Doc
+>       -> Context -> Type -> Expression a
+>       -> TcState (Context,Expression QualType)
+> tcArg m tcEnv tyEnv p what doc cx ty e =
+>   tcExpr m tcEnv tyEnv p e >>-
+>   unify p what (doc $-$ text "Term:" <+> ppExpr 0 e) tcEnv cx ty
+
+> tcAlt :: Bool -> ModuleIdent -> TCEnv -> ValueEnv -> Set Int -> Type -> Type
+>       -> Context -> Alt a -> TcState (Context,Alt QualType)
+> tcAlt poly m tcEnv tyEnv fs tyLhs tyRhs cx a@(Alt p t rhs) =
+>   tcAltern poly m tcEnv tyEnv fs tyLhs tyRhs p t rhs >>- 
+>   unify p "case alternative" (ppAlt a) tcEnv cx tyRhs
+
+> tcAltern :: Bool -> ModuleIdent -> TCEnv -> ValueEnv -> Set Int
+>          -> Type -> Type -> Position -> ConstrTerm a -> Rhs a
+>          -> TcState (Context,Type,Alt QualType)
+> tcAltern poly m tcEnv tyEnv fs tyLhs tyRhs p t rhs =
+>   do
+>     tyEnv' <- bindLambdaVars m tyEnv t
+>     (cx,t') <- tcConstrArg poly tcEnv tyEnv' p "case pattern" doc [] tyLhs t
+>     (cx',ty',rhs') <- tcRhs m tcEnv tyEnv' rhs
+>     cx'' <-
+>       reduceContext p "alternative" (ppAlt (Alt p t' rhs')) tcEnv (cx ++ cx')
+>     checkSkolems p "Alternative" ppAlt tcEnv tyEnv fs cx'' ty' (Alt p t' rhs')
+>   where doc = ppAlt (Alt p t rhs)
+
+> tcQual :: ModuleIdent -> TCEnv -> ValueEnv -> Position -> Context
+>        -> Statement a -> TcState ((ValueEnv,Context),Statement QualType)
+> tcQual m tcEnv tyEnv p cx (StmtExpr e) =
+>   do
+>     (cx',e') <-
+>       tcExpr m tcEnv tyEnv p e >>-
+>       unify p "guard" (ppExpr 0 e) tcEnv cx boolType
+>     return ((tyEnv,cx'),StmtExpr e')
+> tcQual m tcEnv tyEnv _ cx q@(StmtBind p t e) =
+>   do
+>     alpha <- freshTypeVar
+>     (cx',e') <-
+>       tcArg m tcEnv tyEnv p "generator" (ppStmt q) cx (listType alpha) e
+>     tyEnv' <- bindLambdaVars m tyEnv t
+>     (cx'',t') <-
+>       tcConstrArg False tcEnv tyEnv' p "generator" (ppStmt q) cx' alpha t
+>     return ((tyEnv',cx''),StmtBind p t' e')
+> tcQual m tcEnv tyEnv _ cx (StmtDecl ds) =
+>   do
+>     (tyEnv',cx',ds') <- tcDecls m tcEnv tyEnv ds
+>     return ((tyEnv',cx ++ cx'),StmtDecl ds')
+
+> tcStmt :: ModuleIdent -> TCEnv -> ValueEnv -> Position
+>        -> Context -> Maybe Type -> Statement a
+>        -> TcState ((ValueEnv,Context,Maybe Type),Statement QualType)
+> tcStmt m tcEnv tyEnv p cx mTy (StmtExpr e) =
 >   do
+>     (cx',ty) <- maybe freshMonadType (return . (,) []) mTy
 >     alpha <- freshTypeVar
->     tcExpr m tcEnv p e >>=
->       unify p "statement" (ppExpr 0 e) tcEnv (ioType alpha)
-> tcStmt m tcEnv p st@(StmtBind t e) =
->   do
->     bindLambdaVars m t
->     ty <- tcConstrTerm m tcEnv p t
->     tcExpr m tcEnv p e >>=
->       unify p "statement" (ppStmt st $-$ text "Term:" <+> ppExpr 0 e)
->             tcEnv (ioType ty)
-> tcStmt m tcEnv p (StmtDecl ds) = tcDecls m tcEnv ds
+>     (cx'',e') <-
+>       tcExpr m tcEnv tyEnv p e >>-
+>       unify p "statement" (ppExpr 0 e) tcEnv (cx ++ cx') (TypeApply ty alpha)
+>     return ((tyEnv,cx'',Just ty),StmtExpr e')
+> tcStmt m tcEnv tyEnv _ cx mTy st@(StmtBind p t e) =
+>   do
+>     (cx',ty) <- maybe freshMonadType (return . (,) []) mTy
+>     alpha <- freshTypeVar
+>     (cx'',e') <-
+>       tcArg m tcEnv tyEnv p "statement" (ppStmt st) (cx ++ cx')
+>             (TypeApply ty alpha) e
+>     tyEnv' <- bindLambdaVars m tyEnv t
+>     (cx''',t') <-
+>       tcConstrArg False tcEnv tyEnv' p "statement" (ppStmt st) cx'' alpha t
+>     return ((tyEnv',cx''',Just ty),StmtBind p t' e')
+> tcStmt m tcEnv tyEnv _ cx mTy (StmtDecl ds) =
+>   do
+>     (tyEnv',cx',ds') <- tcDecls m tcEnv tyEnv ds
+>     return ((tyEnv',cx ++ cx',mTy),StmtDecl ds')
+
+> tcInfixOp :: ValueEnv -> InfixOp a -> TcState (Context,Type,InfixOp QualType)
+> tcInfixOp tyEnv (InfixOp _ op) =
+>   do
+>     (cx,ty) <- inst (funType op tyEnv)
+>     return (cx,ty,InfixOp (qualType ty) op)
+> tcInfixOp tyEnv (InfixConstr a op) =
+>   do
+>     (cx,ty) <- inst (thd3 (conType op tyEnv))
+>     return (cx,ty,InfixConstr (qualType ty) op)
+
+> tcField :: (TCEnv -> ValueEnv -> Position -> a b
+>             -> TcState (Context,Type,a QualType))
+>         -> String -> (a b -> Doc) -> TCEnv -> ValueEnv -> Position -> Type
+>         -> Context -> Field (a b) -> TcState (Context,Field (a QualType))
+> tcField tc what doc tcEnv tyEnv p ty cx (Field l x) =
+>   do
+>     (cx',TypeArrow ty1 ty2) <- inst (funType l tyEnv)
+>     -- NB the following unification cannot fail; it serves only for
+>     --    instantiating the type variables in the field label's type
+>     unify p "field label" empty tcEnv [] ty [] ty1
+>     (cx'',x') <-
+>       tc tcEnv tyEnv p x >>-
+>       unify p ("record " ++ what) (doc x) tcEnv (cx ++ cx') ty2
+>     return (cx'',Field l x')
 
 \end{verbatim}
 The function \texttt{tcArrow} checks that its argument can be used as
@@ -759,33 +1472,31 @@
 $(\alpha,\beta,\gamma)$.
 \begin{verbatim}
 
-> tcArrow :: Position -> String -> Doc -> TCEnv -> Type
->         -> TcState (Type,Type)
+> tcArrow :: Position -> String -> Doc -> TCEnv -> Type -> TcState (Type,Type)
 > tcArrow p what doc tcEnv ty =
 >   do
->     theta <- liftSt fetchSt
+>     theta <- fetchSt
 >     unaryArrow (subst theta ty)
 >   where unaryArrow (TypeArrow ty1 ty2) = return (ty1,ty2)
 >         unaryArrow (TypeVariable tv) =
 >           do
 >             alpha <- freshTypeVar
 >             beta <- freshTypeVar
->             liftSt (updateSt_ (bindVar tv (TypeArrow alpha beta)))
+>             updateSt_ (bindVar tv (TypeArrow alpha beta))
 >             return (alpha,beta)
 >         unaryArrow ty = errorAt p (nonFunctionType what doc tcEnv ty)
 
 > tcBinary :: Position -> String -> Doc -> TCEnv -> Type
 >          -> TcState (Type,Type,Type)
-> tcBinary p what doc tcEnv ty =
->   tcArrow p what doc tcEnv ty >>= uncurry binaryArrow
->   where binaryArrow ty1 (TypeArrow ty2 ty3) = return (ty1,ty2,ty3)
->         binaryArrow ty1 (TypeVariable tv) =
+> tcBinary p what doc tcEnv ty = tcArrow p what doc tcEnv ty >>= binaryArrow
+>   where binaryArrow (ty1,TypeArrow ty2 ty3) = return (ty1,ty2,ty3)
+>         binaryArrow (ty1,TypeVariable tv) =
 >           do
 >             beta <- freshTypeVar
 >             gamma <- freshTypeVar
->             liftSt (updateSt_ (bindVar tv (TypeArrow beta gamma)))
+>             updateSt_ (bindVar tv (TypeArrow beta gamma))
 >             return (ty1,beta,gamma)
->         binaryArrow ty1 ty2 =
+>         binaryArrow (ty1,ty2) =
 >           errorAt p (nonBinaryOp what doc tcEnv (TypeArrow ty1 ty2))
 
 \end{verbatim}
@@ -794,10 +1505,9 @@
 of~\cite{PeytonJones87:Book}).
 \begin{verbatim}
 
-> unify :: Position -> String -> Doc -> TCEnv -> Type -> Type
->       -> TcState ()
-> unify p what doc tcEnv ty1 ty2 =
->   liftSt $ {-$-}
+> unify :: Position -> String -> Doc -> TCEnv -> Context -> Type
+>       -> Context -> Type -> TcState Context
+> unify p what doc tcEnv cx1 ty1 cx2 ty2 =
 >   do
 >     theta <- fetchSt
 >     let ty1' = subst theta ty1
@@ -805,6 +1515,7 @@
 >     either (errorAt p . typeMismatch what doc tcEnv ty1' ty2')
 >            (updateSt_ . compose)
 >            (unifyTypes tcEnv ty1' ty2')
+>     reduceContext p what doc tcEnv (cx1 ++ cx2)
 
 > unifyTypes :: TCEnv -> Type -> Type -> Either Doc TypeSubst
 > unifyTypes _ (TypeVariable tv1) (TypeVariable tv2)
@@ -831,36 +1542,219 @@
 >         tys
 >   where choose (Left _) theta' = theta'
 >         choose (Right theta) _ = Right (bindSubst tv ty theta)
-> unifyTypes tcEnv (TypeConstructor tc1 tys1) (TypeConstructor tc2 tys2)
->   | tc1 == tc2 = unifyTypeLists tcEnv tys1 tys2
-> unifyTypes tcEnv (TypeArrow ty11 ty12) (TypeArrow ty21 ty22) =
->   unifyTypeLists tcEnv [ty11,ty12] [ty21,ty22]
+> unifyTypes _ (TypeConstructor tc1) (TypeConstructor tc2)
+>   | tc1 == tc2 = Right idSubst
 > unifyTypes _ (TypeSkolem k1) (TypeSkolem k2)
 >   | k1 == k2 = Right idSubst
+> unifyTypes tcEnv (TypeApply ty11 ty12) (TypeApply ty21 ty22) =
+>   case unifyTypes tcEnv ty11 ty21 of
+>     Right theta ->
+>       case unifyTypes tcEnv (subst theta ty12) (subst theta ty22) of
+>         Right theta' -> Right (compose theta' theta)
+>         Left msg -> Left msg
+>     Left msg -> Left msg
+> unifyTypes tcEnv (TypeArrow ty11 ty12) (TypeArrow ty21 ty22) =
+>   case unifyTypes tcEnv ty11 ty21 of
+>     Right theta ->
+>       case unifyTypes tcEnv (subst theta ty12) (subst theta ty22) of
+>         Right theta' -> Right (compose theta' theta)
+>         Left msg -> Left msg
+>     Left msg -> Left msg
+> unifyTypes tcEnv (TypeApply ty11 ty12) (TypeArrow ty21 ty22) =
+>   case unifyTypes tcEnv ty11 (TypeApply (TypeConstructor qArrowId) ty21) of
+>     Right theta ->
+>       case unifyTypes tcEnv (subst theta ty12) (subst theta ty22) of
+>         Right theta' -> Right (compose theta' theta)
+>         Left msg -> Left msg
+>     Left msg -> Left msg
+> unifyTypes tcEnv (TypeArrow ty11 ty12) (TypeApply ty21 ty22) =
+>   case unifyTypes tcEnv (TypeApply (TypeConstructor qArrowId) ty11) ty21 of
+>     Right theta ->
+>       case unifyTypes tcEnv (subst theta ty12) (subst theta ty22) of
+>         Right theta' -> Right (compose theta' theta)
+>         Left msg -> Left msg
+>     Left msg -> Left msg
 > unifyTypes tcEnv ty1 ty2 = Left (incompatibleTypes tcEnv ty1 ty2)
 
-> unifyTypeLists :: TCEnv -> [Type] -> [Type] -> Either Doc TypeSubst
-> unifyTypeLists _ [] _ = Right idSubst
-> unifyTypeLists _ _ [] = Right idSubst
-> unifyTypeLists tcEnv (ty1:tys1) (ty2:tys2) =
->   either Left (unifyTypesTheta tcEnv ty1 ty2) (unifyTypeLists tcEnv tys1 tys2)
->   where unifyTypesTheta tcEnv ty1 ty2 theta =
->           either Left (Right . flip compose theta)
->                  (unifyTypes tcEnv (subst theta ty1) (subst theta ty2))
-
-\end{verbatim}
-For each function declaration, the type checker ensures that no skolem
-type escapes its scope. This is slightly more general than the
-algorithm in~\cite{LauferOdersky94:AbstractTypes}, which checks for
-escaping skolems at every let binding, but is still sound.
-\begin{verbatim}
-
-> checkSkolems :: Position -> TCEnv -> Doc -> Set Int -> Type -> TcState ()
-> checkSkolems p tcEnv what fs ty =
->   do
->     ty' <- liftM (flip subst ty) (liftSt fetchSt)
->     unless (all (`elemSet` fs) (typeSkolems ty'))
->            (errorAt p (skolemEscapingScope tcEnv what ty'))
+\end{verbatim}
+After performing a unification, the resulting substitution is applied
+to the current context and the resulting context is subject to a
+context reduction. This context reduction retains all predicates whose
+types are simple variables and which are not implied but other
+predicates in the context. For all other predicates, the compiler
+checks whether an instance exists and replaces them by applying the
+instances' contexts to the respective types. A minor complication
+arises due to constrained types, which at present are used to
+implement overloading of guard expressions and of numeric literals in
+patterns. The set of admissible types of a constrained type may be
+restricted by the current context after the context reduction and thus
+may cause a further extension of the current substitution.
+\begin{verbatim}
+
+> reduceContext :: Position -> String -> Doc -> TCEnv -> Context
+>               -> TcState Context
+> reduceContext p what doc tcEnv cx =
+>   do
+>     theta <- fetchSt
+>     iEnv <- liftM (apSnd3 (fmap (subst theta))) (liftSt fetchSt)
+>     let cx' = subst theta cx
+>         (cx1,cx2) =
+>           partitionContext (minContext tcEnv (reduceTypePreds iEnv cx'))
+>     theta' <- foldM (reportMissingInstance p what doc tcEnv iEnv) idSubst cx2
+>     updateSt_ (compose theta')
+>     return cx1
+
+> reduceTypePreds :: InstEnv' -> Context -> Context
+> reduceTypePreds iEnv = concatMap (reduceTypePred iEnv)
+
+> reduceTypePred :: InstEnv' -> TypePred -> Context
+> reduceTypePred iEnv (TypePred cls ty) =
+>   maybe [TypePred cls ty] (reduceTypePreds iEnv) (instContext iEnv cls ty)
+
+> instContext :: InstEnv' -> QualIdent -> Type -> Maybe Context
+> instContext (_,dEnv,iEnv) cls ty =
+>   case lookupEnv cls dEnv of
+>     Just tys | ty `elem` tys -> Just []
+>     _ ->
+>       case unapplyType False ty of
+>         (TypeConstructor tc,tys) ->
+>           fmap (map (expandAliasType tys) . snd3) (lookupEnv (CT cls tc) iEnv)
+>         _ -> Nothing
+
+> partitionContext :: Context -> (Context,Context)
+> partitionContext cx = partition (\(TypePred _ ty) -> isTypeVar ty) cx
+>   where isTypeVar (TypeConstructor _) = False
+>         isTypeVar (TypeVariable _) = True
+>         isTypeVar (TypeConstrained _ _) = False
+>         isTypeVar (TypeSkolem _) = False
+>         isTypeVar (TypeApply ty _) = isTypeVar ty
+>         isTypeVar (TypeArrow _ _) = False
+
+> reportMissingInstance :: Position -> String -> Doc -> TCEnv -> InstEnv'
+>                       -> TypeSubst -> TypePred -> TcState TypeSubst
+> reportMissingInstance p what doc tcEnv iEnv theta (TypePred cls ty) =
+>   case subst theta ty of
+>     TypeConstrained tys tv ->
+>       case filter (hasInstance iEnv cls) tys of
+>         [] ->
+>           errorAt p (noInstance what doc tcEnv cls (TypeConstrained tys tv))
+>         [ty'] -> return (bindSubst tv ty' theta)
+>         tys'
+>           | length tys == length tys' -> return theta
+>           | otherwise ->
+>               liftM (flip (bindSubst tv) theta) (freshConstrained tys')
+>     ty'
+>       | hasInstance iEnv cls ty' -> return theta
+>       | otherwise -> errorAt p (noInstance what doc tcEnv cls ty')
+
+> hasInstance :: InstEnv' -> QualIdent -> Type -> Bool
+> hasInstance iEnv cls ty = isJust (instContext iEnv cls ty)
+
+\end{verbatim}
+When a constrained type variable that is not free in the type
+environment disappears from the current type, the type becomes
+ambiguous. For instance, the type of the expression
+\begin{verbatim}
+  let x = read "" in show x
+\end{verbatim}
+is ambiguous assuming that \texttt{read} and \texttt{show} have types
+\begin{verbatim}
+  read :: Read a => String -> a
+  show :: Show a => a -> String
+\end{verbatim}
+because the compiler cannot determine which \texttt{Read} and
+\texttt{Show} instances to use.
+
+In the case of expressions with an ambiguous numeric type, i.e., a
+type that must be an instance of \texttt{Num} or one of its
+subclasses, the compiler tries to resolve the ambiguity by choosing
+the first type from the list of default types that satisfies all
+constraints for the ambiguous type variable. An error is reported if
+no such type exists.
+
+At present, we do not implement two restrictions mandated by the
+revised Haskell'98 report~\cite{PeytonJones03:Haskell} (cf.\ 
+Sect.~4.3.4). In particular, in Haskell an ambiguous type variable $v$
+is resolved only if it appears only in constraints of the form $C\,v$
+and all of these classes are defined in the Prelude or a standard
+library.
+
+\ToDo{Adopt Haskell's restrictions?}
+\begin{verbatim}
+
+> applyDefaults :: Position -> String -> Doc -> TCEnv -> Set Int -> Context
+>               -> Type -> TcState Context
+> applyDefaults p what doc tcEnv fvs cx ty =
+>   do
+>     iEnv <- liftSt fetchSt
+>     let theta =
+>           foldr (bindDefault tcEnv iEnv cx) idSubst
+>                 (nub [tv | TypePred cls (TypeVariable tv) <- cx,
+>                            tv `notElemSet` fvs, isNumClass tcEnv cls])
+>         cx' = fst (partitionContext (subst theta cx))
+>         ty' = subst theta ty
+>         tvs' = nub (filter (`notElemSet` fvs) (typeVars cx'))
+>     unless (null tvs') (errorAt p (ambiguousType what doc tcEnv tvs' cx' ty'))
+>     updateSt_ (compose theta)
+>     return cx'
+
+> bindDefault :: TCEnv -> InstEnv' -> [TypePred] -> Int -> TypeSubst
+>             -> TypeSubst
+> bindDefault tcEnv iEnv cx tv =
+>   case foldr (defaultType tcEnv iEnv tv) (fst3 iEnv) cx of
+>     [] -> id
+>     ty:_ -> bindSubst tv ty
+
+> defaultType :: TCEnv -> InstEnv' -> Int -> TypePred -> [Type] -> [Type]
+> defaultType tcEnv iEnv tv (TypePred cls (TypeVariable tv'))
+>   | tv == tv' = filter (hasInstance iEnv cls)
+>   | otherwise = id
+> defaultType _ _ _ _ = id
+
+> isNumClass :: TCEnv -> QualIdent -> Bool
+> isNumClass tcEnv cls = qNumId `elem` allSuperClasses cls tcEnv
+
+\end{verbatim}
+The function \texttt{splitContext} splits a context
+$\overline{C_n\,t_n}$ into a pair of contexts
+$(\overline{C_{n_1}\,t_{n_1}}, \overline{C_{n_2}\,t_{n_2}})$ such that
+all type variables that appear in the types $\overline{t_{n_1}}$ are
+elements of a given set of type variables.
+\begin{verbatim}
+
+> splitContext :: Set Int -> Context -> (Context,Context)
+> splitContext fvs = partition (all (`elemSet` fvs) . typeVars)
+
+\end{verbatim}
+Whenever type inference succeeds for a function equation, $($f$)$case
+alternative, etc., which may open an existentially quantified data
+type and thus bring fresh skolem constants into scope the compiler
+checks that none of those skolem constants escape their scope through
+the result type or the type environment. E.g., for the sample program
+\begin{verbatim}
+  data Key a = forall b. b (b -> a)
+  f (Key x _) = x 
+  g k x = fcase k of { Key _ f -> f x }
+\end{verbatim}
+a skolem constant escapes in the (result) type of \texttt{f} and in
+the type of the environment variable \texttt{x} for the fcase
+expression in the definition of \texttt{g}
+(cf.~\cite{LauferOdersky94:AbstractTypes}).
+\begin{verbatim}
+
+> checkSkolems :: Position -> String -> (a -> Doc) -> TCEnv -> ValueEnv
+>              -> Set Int -> Context -> Type -> a -> TcState (Context,Type,a)
+> checkSkolems p what pp tcEnv tyEnv fs cx ty x =
+>   do
+>     theta <- fetchSt
+>     let esc = filter escape $
+>           [(v,subst theta ty) | (v,ty) <- (empty,QualType cx ty) : tys]
+>     unless (null esc) (errorAt p (skolemEscapingScope tcEnv what (pp x) esc))
+>     return (cx,ty,x)
+>   where tys =
+>           [(var v,ty) | (v,Value _ _ (ForAll _ ty)) <- localBindings tyEnv]
+>         escape = any (`notElemSet` fs) . typeSkolems . snd
+>         var v = text "Variable:" <+> ppIdent v
 
 \end{verbatim}
 \paragraph{Instantiation and Generalization}
@@ -876,39 +1770,67 @@
 > freshTypeVar :: TcState Type
 > freshTypeVar = freshVar TypeVariable
 
+> freshQualType :: [QualIdent] -> TcState (Context,Type)
+> freshQualType clss =
+>   do
+>     tv <- freshTypeVar
+>     return ([TypePred cls tv | cls <- clss],tv)
+
+> freshEnumType, freshNumType, freshFracType :: TcState (Context,Type)
+> freshEnumType = freshQualType [qEnumId]
+> freshNumType = freshQualType [qNumId]
+> freshFracType = freshQualType [qFractionalId]
+> freshMonadType = freshQualType [qMonadId]
+
 > freshConstrained :: [Type] -> TcState Type
 > freshConstrained tys = freshVar (TypeConstrained tys)
 
 > freshSkolem :: TcState Type
 > freshSkolem = fresh TypeSkolem
 
-> inst :: TypeScheme -> TcState Type
-> inst (ForAll n ty) =
+> inst :: TypeScheme -> TcState (Context,Type)
+> inst (ForAll n (QualType cx ty)) =
 >   do
 >     tys <- replicateM n freshTypeVar
->     return (expandAliasType tys ty)
+>     return (map (expandAliasType tys) cx,expandAliasType tys ty)
 
 \end{verbatim}
 The function \texttt{skol} instantiates the type of data and newtype
 constructors in patterns. All universally quantified type variables
 are instantiated with fresh type variables and all existentially
 quantified type variables are instantiated with fresh skolem types.
-\begin{verbatim}
-
-> skol :: TypeScheme -> TcState Type
-> skol (ForAll n ty) =
->   do
->     tys <- replicateM m freshTypeVar
->     tys' <- replicateM (n - m) freshSkolem
->     return (expandAliasType (tys ++ tys') ty)
->   where m = arity (arrowBase ty)
->         arity (TypeConstructor _ tys) = length tys
-
-> gen :: Set Int -> Type -> TypeScheme
-> gen gvs ty =
->   ForAll (length tvs) (subst (foldr2 bindSubst idSubst tvs tvs') ty)
->   where tvs = [tv | tv <- nub (typeVars ty), tv `notElemSet` gvs]
->         tvs' = map TypeVariable [0..]
+All constraints that appear on the right hand side of the
+constructor's declaration are added to the dynamic instance
+environment.
+\begin{verbatim}
+
+> skol :: TCEnv -> ([Ident],ConstrInfo,TypeScheme) -> TcState (Context,Type)
+> skol tcEnv (_,ConstrInfo m cxR,ForAll n (QualType cx ty)) =
+>   do
+>     tys <- replicateM (n - m) freshTypeVar
+>     tys' <- replicateM m freshSkolem
+>     let tys'' = tys ++ tys'
+>     liftSt (updateSt_ (apSnd3 (bindSkolemInsts tys'')))
+>     return (map (expandAliasType tys) cxL,expandAliasType tys'' ty)
+>   where cxL = filter (`notElem` cxR) cx
+>         bindSkolemInsts tys dEnv =
+>           foldr bindSkolemInst dEnv
+>                 (map (expandAliasType tys) (maxContext tcEnv cxR))
+>         bindSkolemInst (TypePred cls ty) dEnv =
+>           bindEnv cls (ty : fromMaybe [] (lookupEnv cls dEnv)) dEnv
+
+\end{verbatim}
+The function \texttt{gen} generalizes a context \emph{cx} and a type
+$\tau$ into a type scheme $\forall\overline{\alpha} . \emph{cx}
+\Rightarrow \tau$ by universally quantifying all type variables that
+are free in $\tau$ and not fixed by the environment. The set of the
+latter is given by \texttt{gen}'s first argument.
+\begin{verbatim}
+
+> gen :: Set Int -> Context -> Type -> TypeScheme
+> gen fvs cx ty = ForAll (length tvs) (canonType (subst theta (QualType cx ty)))
+>   where tvs = [tv | tv <- nub (typeVars ty), tv `notElemSet` fvs]
+>         theta = foldr2 bindSubst idSubst tvs (map TypeVariable [0..])
 
 > replicateM :: Monad m => Int -> m a -> m [a]
 > replicateM n = sequence . replicate n
@@ -917,8 +1839,8 @@
 \paragraph{Auxiliary Functions}
 \begin{verbatim}
 
-> isVariablePattern :: ConstrTerm -> Bool
-> isVariablePattern (VariablePattern _) = True
+> isVariablePattern :: ConstrTerm a -> Bool
+> isVariablePattern (VariablePattern _ _) = True
 > isVariablePattern _ = False
 
 \end{verbatim}
@@ -929,26 +1851,46 @@
 \begin{verbatim}
 
 > fvEnv :: ValueEnv -> Set Int
-> fvEnv tyEnv = fromListSet (concatMap typeVars (localTypes tyEnv))
+> fvEnv tyEnv = fromListSet (typeVars (localTypes tyEnv))
 
 > fsEnv :: ValueEnv -> Set Int
-> fsEnv tyEnv = fromListSet (concatMap typeSkolems (localTypes tyEnv))
+> fsEnv tyEnv = fromListSet (typeSkolems (localTypes tyEnv))
 
 > localTypes :: ValueEnv -> [TypeScheme]
 > localTypes tyEnv = [ty | (_,Value _ _ ty) <- localBindings tyEnv]
 
 \end{verbatim}
+The function \texttt{untyped} is used when transforming annotated
+syntax tree nodes into typed syntax tree nodes without adding type
+information. This is useful for nodes which contain no attributes
+themselves, e.g., operator fixity declarations.
+\begin{verbatim}
+
+> untyped :: Functor f => f a -> f QualType
+> untyped = fmap (internalError "untyped")
+
+\end{verbatim}
 Error functions.
 \begin{verbatim}
 
+> inconsistentFieldLabel :: Ident -> String
+> inconsistentFieldLabel l =
+>   "Types for field label " ++ name l ++ " do not agree"
+
 > polymorphicVar :: Ident -> String
 > polymorphicVar v = "Variable " ++ name v ++ " cannot have polymorphic type"
 
-> typeSigTooGeneral :: TCEnv -> Doc -> TypeExpr -> TypeScheme -> String
+> typeSigTooGeneral :: TCEnv -> Doc -> QualTypeExpr -> TypeScheme -> String
 > typeSigTooGeneral tcEnv what ty sigma = show $
 >   vcat [text "Type signature too general", what,
 >         text "Inferred type:" <+> ppTypeScheme tcEnv sigma,
->         text "Type signature:" <+> ppTypeExpr 0 ty]
+>         text "Type signature:" <+> ppQualTypeExpr ty]
+
+> methodSigTooGeneral :: TCEnv -> Doc -> QualType -> TypeScheme -> String
+> methodSigTooGeneral tcEnv what ty sigma = show $
+>   vcat [text "Method type not general enough", what,
+>         text "Inferred type:" <+> ppTypeScheme tcEnv sigma,
+>         text "Expected type:" <+> ppQualType tcEnv ty]
 
 > wrongArity :: QualIdent -> Int -> Int -> String
 > wrongArity c arity argc = show $
@@ -976,10 +1918,15 @@
 >         text "Expected type:" <+> ppType tcEnv ty1,
 >         reason]
 
-> skolemEscapingScope :: TCEnv -> Doc -> Type -> String
-> skolemEscapingScope tcEnv what ty = show $
->   vcat [text "Existential type escapes out of its scope", what,
->         text "Type:" <+> ppType tcEnv ty]
+> skolemFieldLabel :: Ident -> String
+> skolemFieldLabel l =
+>   "Existential type escapes with type of record selector " ++ name l
+
+> skolemEscapingScope :: TCEnv -> String -> Doc -> [(Doc,QualType)] -> String
+> skolemEscapingScope tcEnv what doc esc = show $ vcat $
+>   text "Existential type escapes out of its scope" :
+>   sep [text what <> colon,indent doc] :
+>   [whence $$ text "Type:" <+> ppQualType tcEnv ty | (whence,ty) <- esc]
 
 > invalidCType :: String -> TCEnv -> Type -> String
 > invalidCType what tcEnv ty = show $
@@ -995,4 +1942,23 @@
 >        nest 2 (text "and" <+> ppType tcEnv ty2),
 >        text "are incompatible"]
 
+> ambiguousType :: String -> Doc -> TCEnv -> [Int] -> Context -> Type
+>               -> String
+> ambiguousType what doc tcEnv tvs cx ty = show $
+>   vcat [text "Ambiguous type variable" <> plural tvs <+>
+>           list (map (ppType tcEnv . TypeVariable) tvs) <+> text "in type",
+>         ppQualType tcEnv (canonType (QualType cx ty)),
+>         text "inferred for" <+> text what, doc]
+>   where plural (_:xs) = if null xs then empty else char 's'
+>         list [x] = x
+>         list [x1,x2] = x1 <+> text "and" <+> x2
+>         list xs = hsep (map (<> comma) (init xs)) <+> text "and" <+> last xs
+
+> noInstance :: String -> Doc -> TCEnv -> QualIdent -> Type -> String
+> noInstance what doc tcEnv cls ty = show $
+>   vcat [text "Missing" <+> ppInstance tcEnv tp <+> text "instance",
+>         text "in" <+> text what,
+>         doc]
+>   where tp = TypePred cls ty
+
 \end{verbatim}
Solo in curry-0.9.11-classful/: type-classes.htm
Solo in curry-0.9.11-classful/: TypeInfo.lhs
diff -u curry-0.9.11/Types.lhs curry-0.9.11-classful/Types.lhs
--- curry-0.9.11/Types.lhs	2007-06-15 14:16:34.000000000 +0200
+++ curry-0.9.11-classful/Types.lhs	2008-05-09 09:39:17.000000000 +0200
@@ -1,7 +1,7 @@
 % -*- LaTeX -*-
-% $Id: Types.lhs 2144 2007-04-01 13:26:29Z wlux $
+% $Id: Types.lhs 2690 2008-05-01 20:40:17Z wlux $
 %
-% Copyright (c) 2002-2007, Wolfgang Lux
+% Copyright (c) 2002-2008, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{Types.lhs}
@@ -12,20 +12,25 @@
 
 > module Types where
 > import Ident
+> import PredefIdent
 > import List
 
 \end{verbatim}
-A type is either a type variable, an application of a type constructor
-to a list of arguments, or an arrow type. The \texttt{TypeConstrained}
-case is used for representing type variables that are restricted to a
-particular set of types. At present, this is used for typing guard
-expressions, which are restricted to be either of type \texttt{Bool}
-or of type \texttt{Success}, and integer literals, which are
-restricted to types \texttt{Int} and \texttt{Float}. If the type is
-not restricted, it defaults to the first type from the constraint
-list. The case \texttt{TypeSkolem} is used for handling skolem types,
-which result from matching data constructors with existentially
-quantified types.
+A type is either a type constructor, a type variable, or an
+application of a type to another type. The \texttt{TypeConstrained}
+and \texttt{TypeSkolem} constructors represent two special cases of
+type variables. A \texttt{TypeConstrained} variable represents a type
+variable that is restricted to a particular set of types. At present,
+this is used for typing guard expressions, which are restricted to be
+either of type \texttt{Bool} or of type \texttt{Success}, and integer
+literals in patterns, which are restricted to types \texttt{Int} and
+\texttt{Float}. If the type is not restricted, it defaults to the
+first type from the constraint list. A \texttt{TypeSkolem} variable is
+used for handling skolem types, which result from matching data
+constructors with existentially quantified types. Since arrow types
+are used so frequently, we use \texttt{TypeArrow} $t_1$ $t_2$
+consistently as a shorthand for the application of the arrow type
+constructor \texttt{(->)} to the two types $t_1$ and $t_2$.
 
 Type variables are represented with deBruijn style indices. Universally
 quantified type variables are assigned indices in the order of their
@@ -35,25 +40,69 @@
 
 Note that even though \texttt{TypeConstrained} variables use indices
 as well, these variables must never be quantified.
+
+\ToDo{Use \texttt{TypeApply .\ TypeApply qArrowId} instead of
+  \texttt{TypeArrow}?}
 \begin{verbatim}
 
 > data Type =
->     TypeConstructor QualIdent [Type]
+>     TypeConstructor QualIdent
 >   | TypeVariable Int
 >   | TypeConstrained [Type] Int
->   | TypeArrow Type Type
 >   | TypeSkolem Int
->   deriving (Eq,Show)
+>   | TypeApply Type Type
+>   | TypeArrow Type Type
+>   deriving (Eq,Ord,Show)
 
 \end{verbatim}
-The function \texttt{isArrowType} checks whether a type
-$t = t_1 \rightarrow t_2 \rightarrow \dots \rightarrow t_{n+1}$
+The function \texttt{applyType} applies a type to a list of argument
+types. Note that it carefully converts an application of the arrow
+type constructor to two argument types into an arrow type. The
+function \texttt{unapplyType} decomposes a type into a root type and a
+list of argument types such that the root type is either a type
+constructor, a type variable, or a skolem type. If the \texttt{dflt}
+argument of \texttt{unapplyType} is \texttt{True}, constrained type
+variables are fixed to their first alternative, otherwise they are
+handled like type variables. The function \texttt{rootOfType} returns
+the name of the type constructor at the root of a type. This function
+must not be applied to a type whose root is a type variable or a
+skolem type.
+\begin{verbatim}
+
+> applyType :: Type -> [Type] -> Type
+> applyType (TypeConstructor tc) tys
+>   | tc == qArrowId && length tys == 2 = TypeArrow (tys!!0) (tys!!1)
+> applyType (TypeApply (TypeConstructor tc) ty) tys
+>   | tc == qArrowId && length tys == 1 = TypeArrow ty (head tys)
+> applyType ty tys = foldl TypeApply ty tys
+
+> unapplyType :: Bool -> Type -> (Type,[Type])
+> unapplyType dflt ty = unapply ty []
+>   where unapply (TypeConstructor tc) tys = (TypeConstructor tc,tys)
+>         unapply (TypeVariable tv) tys = (TypeVariable tv,tys)
+>         unapply (TypeConstrained tys tv) tys'
+>           | dflt = unapply (head tys) tys'
+>           | otherwise = (TypeConstrained tys tv,tys')
+>         unapply (TypeSkolem k) tys = (TypeSkolem k,tys)
+>         unapply (TypeApply ty1 ty2) tys = unapply ty1 (ty2:tys)
+>         unapply (TypeArrow ty1 ty2) tys =
+>           (TypeConstructor qArrowId,ty1:ty2:tys)
+
+> rootOfType :: Type -> QualIdent
+> rootOfType ty =
+>   case fst (unapplyType True ty) of
+>     TypeConstructor tc -> tc
+>     _ -> error "internal error: rootOfType"
+
+\end{verbatim}
+The function \texttt{isArrowType} checks whether a type $\tau = \tau_1
+\rightarrow \dots \rightarrow \tau_n \rightarrow \tau_{n+1}$
 ($n\geq0$) is a function type, i.e., whether $n > 0$ . The function
 \texttt{arrowArity} returns the arity $n$ of a function type, the
 function \texttt{arrowArgs} returns the list of types
-\texttt{[$t_1$,$\dots$,$t_{n}$]}, \texttt{arrowBase} returns the
-type $t_{n+1}$, and \texttt{arrowUnapply} combines \texttt{arrowArgs}
-and \texttt{arrowBase} in one call.
+\texttt{[$\tau_1$,$\dots$,$\tau_{n}$]}, \texttt{arrowBase} returns the
+type $\tau_{n+1}$, and \texttt{arrowUnapply} combines
+\texttt{arrowArgs} and \texttt{arrowBase} in one call.
 \begin{verbatim}
 
 > isArrowType :: Type -> Bool
@@ -76,7 +125,7 @@
 
 \end{verbatim}
 The methods \texttt{typeVars} and \texttt{typeSkolems} return a list
-of all type variables and skolem types occurring in a type $t$,
+of all type variables and skolem types occurring in a type $\tau$,
 respectively. Note that \texttt{TypeConstrained} variables are not
 included in the set of type variables because they cannot be
 generalized.
@@ -86,27 +135,99 @@
 >   typeVars :: t -> [Int]
 >   typeSkolems :: t -> [Int]
 
+> instance IsType a => IsType [a] where
+>   typeVars = concatMap typeVars
+>   typeSkolems = concatMap typeSkolems
+
 > instance IsType Type where
 >   typeVars ty = vars ty []
->     where vars (TypeConstructor _ tys) tvs = foldr vars tvs tys
+>     where vars (TypeConstructor _) tvs = tvs
 >           vars (TypeVariable tv) tvs = tv : tvs
 >           vars (TypeConstrained _ _) tvs = tvs
->           vars (TypeArrow ty1 ty2) tvs = vars ty1 (vars ty2 tvs)
 >           vars (TypeSkolem _) tvs = tvs
+>           vars (TypeApply ty1 ty2) tvs = vars ty1 (vars ty2 tvs)
+>           vars (TypeArrow ty1 ty2) tvs = vars ty1 (vars ty2 tvs)
 >   typeSkolems ty = skolems ty []
->     where skolems (TypeConstructor _ tys) sks = foldr skolems sks tys
+>     where skolems (TypeConstructor _) sks = sks
 >           skolems (TypeVariable _) sks = sks
 >           skolems (TypeConstrained _ _) sks = sks
->           skolems (TypeArrow ty1 ty2) sks = skolems ty1 (skolems ty2 sks)
 >           skolems (TypeSkolem k) sks = k : sks
+>           skolems (TypeApply ty1 ty2) sks = skolems ty1 (skolems ty2 sks)
+>           skolems (TypeArrow ty1 ty2) sks = skolems ty1 (skolems ty2 sks)
 
 \end{verbatim}
-Type schemes $\forall\overline{\alpha} . \tau(\overline{\alpha})$
-introduce (universal) quantification of type variables in types. The
-universally quantified type variables in a type are assigned
-increasing indices starting at 0. Therefore, it is sufficient to
-record only the number of quantified type variables in the
-\texttt{ForAll} constructor.
+Qualified types represent types with class membership constraints. A
+qualified type $\emph{cx}\Rightarrow\tau$ consists of a plain type
+$\tau$ and a context \emph{cx}, which is a list of type predicates
+$C_i\,\tau_i$ that must be satisfied. A type predicate $C_i\,\tau_i$
+is satisfied if the type $\tau_i$ is an instance of class $C_i$.
+Normally, each type $\tau_i$ has the form $\alpha\,\tau_1,\dots\tau_k$
+($k\geq0$), where $\alpha$ is a type variable and $\tau_1,\dots\tau_k$
+are types. Type predicates where $\tau_i$ has a different form may
+occur in intermediate contexts computed during type inference.
+However, such predicates can be proved to be either satisfied or not,
+or they can be transformed into simpler predicates where all types are
+of the form $\alpha\,\tau_1,\dots\tau_k$.
+
+The order of predicates in a qualified type does not matter. In order
+to define a canonical representation for qualified types, the compiler
+sorts the predicates in the contexts of function types. The
+non-standard \texttt{Ord} instance for type predicates sorts them
+according to their type (variable) first so that constraints that
+apply to the same type variable are grouped together.
+
+\ToDo{Consider using true sets for the contexts of qualified types.}
+\begin{verbatim}
+
+> data QualType = QualType Context Type deriving (Eq,Show)
+> type Context = [TypePred]
+> data TypePred = TypePred QualIdent Type deriving (Eq,Show)
+
+> instance Ord TypePred where
+>   TypePred cls1 ty1 `compare` TypePred cls2 ty2 =
+>     case ty1 `compare` ty2 of
+>       LT -> LT
+>       EQ -> cls1 `compare` cls2
+>       GT -> GT
+
+> qualType :: Type -> QualType
+> qualType ty = QualType [] ty
+
+> unqualType :: QualType -> Type
+> unqualType (QualType _ ty) = ty
+
+> canonType :: QualType -> QualType
+> canonType = contextMap sort
+
+> contextMap :: (Context -> Context) -> QualType -> QualType
+> contextMap f (QualType cx ty) = QualType (f cx) ty
+
+\end{verbatim}
+Usually, the free and skolem variables of the context of a qualified
+type are free in the plain type itself, but this is not necessarily
+the case.
+\begin{verbatim}
+
+> instance IsType QualType where
+>   typeVars (QualType cx ty) = typeVars ty ++ typeVars cx
+>   typeSkolems (QualType cx ty) = typeSkolems ty ++ typeSkolems cx
+
+> instance IsType TypePred where
+>   typeVars (TypePred _ ty) = typeVars ty
+>   typeSkolems (TypePred _ ty) = typeSkolems ty
+
+\end{verbatim}
+Type schemes $\forall\overline{\alpha} . \emph{cx} \Rightarrow \tau$
+introduce (universal) quantification of type variables in qualified
+types. The universally quantified type variables in a type are
+assigned increasing indices starting at 0. Therefore, it is sufficient
+to record only the number of quantified type variables in the
+\texttt{ForAll} constructor. The context \emph{cx} of a type scheme
+must contain only predicates of the form
+$C\,(\alpha\,\tau_1\dots\tau_k)$ ($k\geq0$) where the type variable
+$\alpha$ and the free variables of the types $\tau_1,\dots,\tau_k$ are
+either free in the plain type $\tau$ or are monomorphic type variables
+that are bound in the type environment.
 
 In general, type variables are assigned indices from left to right in
 the order of their occurrence in a type. However, a slightly different
@@ -132,7 +253,10 @@
 m-1$ are existentially quantified.
 \begin{verbatim}
 
-> data TypeScheme = ForAll Int Type deriving (Eq,Show)
+> data TypeScheme = ForAll Int QualType deriving (Eq,Show)
+
+> tmap :: (QualType -> QualType) -> TypeScheme -> TypeScheme
+> tmap f (ForAll n ty) = ForAll n (f ty)
 
 > instance IsType TypeScheme where
 >   typeVars (ForAll _ ty) = [tv | tv <- typeVars ty, tv < 0]
@@ -141,49 +265,30 @@
 \end{verbatim}
 The functions \texttt{monoType} and \texttt{polyType} translate a type
 $\tau$ into a monomorphic type scheme $\forall.\tau$ and a polymorphic
-type scheme $\forall\overline{\alpha}.\tau$ where $\overline{\alpha} =
-\emph{vars}(\tau)$, respectively. Note that \texttt{polyType} does not
-renumber the type variables in its argument type.
+type scheme $\forall\overline{\alpha}.\tau$, respectively, where
+$\overline{\alpha} = \emph{vars}(\tau)$. The function
+\texttt{typeScheme} translates a qualified type $\emph{cx} \Rightarrow
+\tau$ into a polymorphic type scheme $\forall\overline{\alpha}.
+\emph{cx} \Rightarrow \tau$. Note that neither \texttt{polyType} nor
+\texttt{typeScheme} renumber the type variables in their argument
+types.
 \begin{verbatim}
 
-> monoType, polyType :: Type -> TypeScheme
-> monoType ty = ForAll 0 ty
-> polyType ty = ForAll (maximum (-1 : typeVars ty) + 1) ty
+> monoType :: Type -> TypeScheme
+> monoType ty = ForAll 0 (qualType ty)
 
-\end{verbatim}
-The function \texttt{rawType} strips the quantifier from a type
-scheme.
-\begin{verbatim}
+> polyType :: Type -> TypeScheme
+> polyType ty = typeScheme (qualType ty)
 
-> rawType :: TypeScheme -> Type
-> rawType (ForAll _ ty) = ty
+> typeScheme :: QualType -> TypeScheme
+> typeScheme ty = ForAll (maximum (-1 : typeVars ty) + 1) ty
 
 \end{verbatim}
-There are a few predefined types. Note that the identifiers of the
-primitive types \texttt{()}, \texttt{[a]}, and the tuple types must
-never be qualified with a module prefix.
+The function \texttt{rawType} strips the quantifier and context from a
+type scheme.
 \begin{verbatim}
 
-> isPrimTypeId :: QualIdent -> Bool
-> isPrimTypeId tc = tc `elem` [qUnitId,qListId] || isQTupleId tc
-
-> unitType,boolType,charType,intType,floatType,stringType,successType :: Type
-> unitType = TypeConstructor qUnitId []
-> boolType = TypeConstructor qBoolId []
-> charType = TypeConstructor qCharId []
-> intType = TypeConstructor qIntId []
-> floatType = TypeConstructor qFloatId []
-> stringType = listType charType
-> successType = TypeConstructor qSuccessId []
-
-> listType,ioType :: Type -> Type
-> listType ty = TypeConstructor qListId [ty]
-> ioType ty = TypeConstructor qIOId [ty]
-
-> tupleType :: [Type] -> Type
-> tupleType tys = TypeConstructor (qTupleId (length tys)) tys
-
-> typeVar :: Int -> Type
-> typeVar = TypeVariable
+> rawType :: TypeScheme -> Type
+> rawType (ForAll _ (QualType _ ty)) = ty
 
 \end{verbatim}
diff -u curry-0.9.11/TypeSubst.lhs curry-0.9.11-classful/TypeSubst.lhs
--- curry-0.9.11/TypeSubst.lhs	2007-06-15 14:16:34.000000000 +0200
+++ curry-0.9.11-classful/TypeSubst.lhs	2007-10-25 09:55:24.000000000 +0200
@@ -1,5 +1,5 @@
 % -*- LaTeX -*-
-% $Id: TypeSubst.lhs 2146 2007-04-02 08:01:20Z wlux $
+% $Id: TypeSubst.lhs 2527 2007-10-22 13:49:27Z wlux $
 %
 % Copyright (c) 2003-2007, Wolfgang Lux
 % See LICENSE for the full license.
@@ -9,12 +9,15 @@
 This module implements substitutions on types.
 \begin{verbatim}
 
-> module TypeSubst(module TypeSubst, idSubst,bindSubst,compose) where
-> import Base
-> import TopEnv
-> import Maybe
+> module TypeSubst(TypeSubst, SubstType(..), bindVar, substVar,
+>                  ExpandAliasType(..), normalize, instanceType,
+>                  idSubst, bindSubst, compose) where
 > import List
+> import Maybe
 > import Subst
+> import TopEnv
+> import Types
+> import ValueInfo
 
 > type TypeSubst = Subst Int Type
 
@@ -27,56 +30,101 @@
 > substVar :: TypeSubst -> Int -> Type
 > substVar = substVar' TypeVariable subst
 
+> instance SubstType a => SubstType [a] where
+>   subst sigma = map (subst sigma)
+
 > instance SubstType Type where
->   subst sigma (TypeConstructor tc tys) =
->     TypeConstructor tc (map (subst sigma) tys)
->   subst sigma (TypeVariable tv) = substVar sigma tv
->   subst sigma (TypeConstrained tys tv) =
->     case substVar sigma tv of
->       TypeVariable tv -> TypeConstrained tys tv
->       ty -> ty
->   subst sigma (TypeArrow ty1 ty2) =
->     TypeArrow (subst sigma ty1) (subst sigma ty2)
->   subst sigma (TypeSkolem k) = TypeSkolem k
+>   subst sigma ty = substTypeApp sigma ty []
+
+> substTypeApp :: TypeSubst -> Type -> [Type] -> Type
+> substTypeApp _ (TypeConstructor tc) = foldl TypeApply (TypeConstructor tc)
+> substTypeApp sigma (TypeVariable tv) = applyType (substVar sigma tv)
+> substTypeApp sigma (TypeConstrained tys tv) =
+>   case substVar sigma tv of
+>     TypeVariable tv -> foldl TypeApply (TypeConstrained tys tv)
+>     ty -> foldl TypeApply ty
+> substTypeApp _ (TypeSkolem k) = foldl TypeApply (TypeSkolem k)
+> substTypeApp sigma (TypeApply ty1 ty2) =
+>   substTypeApp sigma ty1 . (subst sigma ty2 :)
+> substTypeApp sigma (TypeArrow ty1 ty2) =
+>   foldl TypeApply (TypeArrow (subst sigma ty1) (subst sigma ty2))
+
+> instance SubstType TypePred where
+>   subst sigma (TypePred cls ty) = TypePred cls (subst sigma ty)
+
+> instance SubstType QualType where
+>   subst sigma (QualType cx ty) = QualType (subst sigma cx) (subst sigma ty)
 
 > instance SubstType TypeScheme where
->   subst sigma (ForAll n ty) =
->     ForAll n (subst (foldr unbindSubst sigma [0..n-1]) ty)
+>   subst sigma (ForAll n ty) = ForAll n (subst sigma' ty)
+>     where sigma' = foldr unbindSubst sigma [0..n-1]
 
 > instance SubstType ValueInfo where
->   subst theta (DataConstructor c n ty) = DataConstructor c n ty
->   subst theta (NewtypeConstructor c ty) = NewtypeConstructor c ty
->   subst theta (Value v n ty) = Value v n (subst theta ty)
+>   subst _ (DataConstructor c ls ci ty) = DataConstructor c ls ci ty
+>   subst _ (NewtypeConstructor c l ty) = NewtypeConstructor c l ty
+>   subst sigma (Value v n ty) = Value v n (subst sigma ty)
 
 > instance SubstType a => SubstType (TopEnv a) where
 >   subst = fmap . subst
 
 \end{verbatim}
-The function \texttt{expandAliasType} expands all occurrences of a
-type synonym in a type. After the expansion we have to reassign the
-type indices for all type variables. Otherwise, expanding a type
-synonym like \verb|type Pair' a b = (b,a)| could break the invariant
-that the universally quantified type variables are assigned indices in
-the order of their occurrence. This is handled by function
+The class method \texttt{expandAliasType} expands all occurrences of a
+type synonym in its (second) argument. After the expansion we have to
+reassign the type indices of all type variables. Otherwise, expanding
+a type synonym like \verb|type Pair' a b = (b,a)| could break the
+invariant that the universally quantified type variables are assigned
+indices in the order of their occurrence. This is handled by function
 \texttt{normalize}. The function has a threshold parameter that allows
 preserving the indices of type variables bound on the left hand side
-of a type declaration.
+of a type declaration and in the head of a type class declaration,
+respectively.
 \begin{verbatim}
 
-> expandAliasType :: [Type] -> Type -> Type
-> expandAliasType tys (TypeConstructor tc tys') =
->   TypeConstructor tc (map (expandAliasType tys) tys')
-> expandAliasType tys (TypeVariable n)
->   | n >= 0 = tys !! n
->   | otherwise = TypeVariable n
-> expandAliasType _ (TypeConstrained tys n) = TypeConstrained tys n
-> expandAliasType tys (TypeArrow ty1 ty2) =
->   TypeArrow (expandAliasType tys ty1) (expandAliasType tys ty2)
-> expandAliasType _ (TypeSkolem k) = TypeSkolem k
+> class ExpandAliasType t where
+>   expandAliasType :: [Type] -> t -> t
+
+> instance ExpandAliasType Type where
+>   expandAliasType tys ty = expandTypeApp tys ty []
 
-> normalize :: Int -> Type -> Type
-> normalize n ty = expandAliasType [TypeVariable (occur tv) | tv <- [0..]] ty
+> expandTypeApp :: [Type] -> Type -> [Type] -> Type
+> expandTypeApp _ (TypeConstructor tc) = foldl TypeApply (TypeConstructor tc)
+> expandTypeApp tys (TypeVariable n)
+>   | n >= 0 = applyType (tys !! n)
+>   | otherwise = foldl TypeApply (TypeVariable n)
+> expandTypeApp _ (TypeConstrained tys n) =
+>   foldl TypeApply (TypeConstrained tys n)
+> expandTypeApp _ (TypeSkolem k) = foldl TypeApply (TypeSkolem k)
+> expandTypeApp tys (TypeApply ty1 ty2) =
+>   expandTypeApp tys ty1 . (expandAliasType tys ty2 :)
+> expandTypeApp tys (TypeArrow ty1 ty2) =
+>   foldl TypeApply
+>         (TypeArrow (expandAliasType tys ty1) (expandAliasType tys ty2))
+
+> instance ExpandAliasType TypePred where
+>   expandAliasType tys (TypePred cls ty) =
+>     TypePred cls (expandAliasType tys ty)
+
+> instance ExpandAliasType QualType where
+>   expandAliasType tys (QualType cx ty) =
+>     QualType (map (expandAliasType tys) cx) (expandAliasType tys ty)
+
+> normalize :: Int -> QualType -> QualType
+> normalize n ty =
+>   canonType (expandAliasType [TypeVariable (occur tv) | tv <- [0..]] ty)
 >   where tvs' = zip (nub (filter (>= n) (typeVars ty))) [n..]
 >         occur tv = fromMaybe tv (lookup tv tvs')
 
 \end{verbatim}
+The function \texttt{instanceType} computes an instance of a
+polymorphic type by substituting the first type argument for all
+occurrences of the type variable with index 0 in the second argument.
+The function carefully assigns new indices to all other type variables
+of the second argument so that they do not conflict with the type
+variables of the first argument.
+\begin{verbatim}
+
+> instanceType :: ExpandAliasType a => Type -> a -> a
+> instanceType ty = expandAliasType (ty : map TypeVariable [n..])
+>   where ForAll n _ = polyType ty
+
+\end{verbatim}
diff -u curry-0.9.11/TypeSyntaxCheck.lhs curry-0.9.11-classful/TypeSyntaxCheck.lhs
--- curry-0.9.11/TypeSyntaxCheck.lhs	2007-06-15 14:16:34.000000000 +0200
+++ curry-0.9.11-classful/TypeSyntaxCheck.lhs	2011-10-08 12:42:57.000000000 +0200
@@ -1,7 +1,7 @@
 % -*- LaTeX -*-
-% $Id: TypeSyntaxCheck.lhs 2101 2007-02-21 16:25:07Z wlux $
+% $Id: TypeSyntaxCheck.lhs 3056 2011-10-07 16:27:03Z wlux $
 %
-% Copyright (c) 1999-2007, Wolfgang Lux
+% Copyright (c) 1999-2011, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{TypeSyntaxCheck.lhs}
@@ -16,45 +16,58 @@
 
 > module TypeSyntaxCheck(typeSyntaxCheck,typeSyntaxCheckGoal) where
 > import Base
+> import Curry
 > import CurryPP
+> import CurryUtils
 > import Error
+> import IdentInfo
 > import List
+> import Monad
+> import Position
 > import Pretty
+> import Set
 > import TopEnv
 
 \end{verbatim}
 In order to check type constructor applications, the compiler
-maintains an environment, which records all known type constructors.
-The function \texttt{typeSyntaxCheck} first initializes this
-environment from the imported type constructor environment. Next, the
-all locally defined type constructors are inserted into the
-environment, and, finally, the declarations are checked within this
-environment. The final environment is returned in order to be used
-later for checking the optional export list of the current module.
+maintains an environment that records all known type constructors and
+type classes. The functions \texttt{typeSyntaxCheck} and
+\texttt{typeSyntaxCheckGoal} expect a type identifier environment that
+is already initialized with the imported type constructors and
+classes. All locally defined type constructors and classes are added
+to this environment and then the declarations are checked within this
+environment. The environment is returned in order to be used later for
+checking the optional export list of the current module.
 \begin{verbatim}
 
-> typeSyntaxCheck :: ModuleIdent -> TCEnv -> [TopDecl]
->                 -> Error (TypeEnv,[TopDecl])
-> typeSyntaxCheck m tcEnv ds =
->   do
->     reportDuplicates duplicateType repeatedType (map tconstr tds)
->     ds' <- mapE (checkTopDecl env) ds
->     return (env,ds')
->   where tds = filter isTypeDecl ds
->         env = foldr (bindType m) (fmap typeKind tcEnv) tds
-
-> typeSyntaxCheckGoal :: TCEnv -> Goal -> Error Goal
-> typeSyntaxCheckGoal tcEnv (Goal p e ds) =
->   liftE2 (Goal p) (checkExpr env p e) (mapE (checkDecl env) ds)
->   where env = fmap typeKind tcEnv
-
-> bindType :: ModuleIdent -> TopDecl -> TypeEnv -> TypeEnv
-> bindType m (DataDecl _ tc _ cs) =
->   globalBindTopEnv m tc (Data (qualifyWith m tc) (map constr cs))
-> bindType m (NewtypeDecl _ tc _ nc) =
->   globalBindTopEnv m tc (Data (qualifyWith m tc) [nconstr nc])
+> typeSyntaxCheck :: ModuleIdent -> TypeEnv -> InstSet -> [TopDecl a]
+>                 -> Error (TypeEnv,[TopDecl a])
+> typeSyntaxCheck m env iEnv ds =
+>   do
+>     reportDuplicates (const duplicateDefault) (const repeatedDefault)
+>                      [P p () | DefaultDecl p _ <- ods] &&>
+>       reportDuplicates duplicateType repeatedType (map tident tds)
+>     ds' <- mapE (checkTopDecl env') ds
+>     checkInstances env' iEnv ds'
+>     return (env',ds')
+>   where (tds,ods) = partition isTypeDecl ds
+>         env' = foldr (bindType m) env tds
+
+> typeSyntaxCheckGoal :: TypeEnv -> Goal a -> Error (Goal a)
+> typeSyntaxCheckGoal env g = checkGoal env g
+
+> bindType :: ModuleIdent -> TopDecl a -> TypeEnv -> TypeEnv
+> bindType m (DataDecl _ _ tc _ cs _) =
+>   globalBindTopEnv m tc (Data (qualifyWith m tc) xs)
+>   where xs = map constr cs ++ nub (concatMap labels cs)
+> bindType m (NewtypeDecl _ _ tc _ nc _) =
+>   globalBindTopEnv m tc (Data (qualifyWith m tc) (nconstr nc : nlabel nc))
 > bindType m (TypeDecl _ tc _ _) =
 >   globalBindTopEnv m tc (Alias (qualifyWith m tc))
+> bindType m (ClassDecl _ _ cls _ ds) =
+>   globalBindTopEnv m cls (Class (qualifyWith m cls) (concatMap methods ds))
+> bindType m (InstanceDecl _ _ _ _ _) = id
+> bindType _ (DefaultDecl _ _) = id
 > bindType _ (BlockDecl _) = id
 
 \end{verbatim}
@@ -64,82 +77,168 @@
 signatures.
 \begin{verbatim}
 
-> checkTopDecl :: TypeEnv -> TopDecl -> Error TopDecl
-> checkTopDecl env (DataDecl p tc tvs cs) =
->   checkTypeLhs env p tvs &&>
->   liftE (DataDecl p tc tvs) (mapE (checkConstrDecl env tvs) cs)
-> checkTopDecl env (NewtypeDecl p tc tvs nc) =
->   checkTypeLhs env p tvs &&>
->   liftE (NewtypeDecl p tc tvs) (checkNewConstrDecl env tvs nc)
+> checkTopDecl :: TypeEnv -> TopDecl a -> Error (TopDecl a)
+> checkTopDecl env (DataDecl p cx tc tvs cs clss) =
+>   do
+>     cx' <- checkTypeLhs env p cx tvs
+>     checkClosedContext p cx' tvs
+>     cs' <-
+>       liftE const (mapE (checkConstrDecl env tvs) cs) &&&
+>       mapE_ (checkDClass env tvs) clss
+>     return (DataDecl p cx' tc tvs cs' clss)
+> checkTopDecl env (NewtypeDecl p cx tc tvs nc clss) =
+>   do
+>     cx' <- checkTypeLhs env p cx tvs
+>     checkClosedContext p cx' tvs
+>     nc' <-
+>       liftE const (checkNewConstrDecl env tvs nc) &&&
+>       mapE_ (checkDClass env tvs) clss
+>     return (NewtypeDecl p cx' tc tvs nc' clss)
 > checkTopDecl env (TypeDecl p tc tvs ty) =
->   checkTypeLhs env p tvs &&>
->   liftE (TypeDecl p tc tvs) (checkClosedType env p tvs ty)
+>   do
+>     checkTypeLhs env p [] tvs
+>     ty' <- checkClosedType env p tvs ty
+>     return (TypeDecl p tc tvs ty')
+> checkTopDecl env (ClassDecl p cx cls tv ds) =
+>   do
+>     cx' <- checkTypeLhs env p cx [tv]
+>     checkClosedContext p cx' [tv]
+>     ds' <-
+>       mapE_ (checkSimpleConstraint "class" doc p) cx' &&>
+>       mapE (checkDecl env) ds
+>     sequenceE_ [checkMethodType tv p ty | TypeSig p _ ty <- ds']
+>     return (ClassDecl p cx' cls tv ds')
+>   where doc = ppIdent cls <+> ppIdent tv
+> checkTopDecl env (InstanceDecl p cx cls ty ds) =
+>   do
+>     (cx',ty') <- checkClass env p [] cls &&> checkInstType env p cx ty
+>     ds' <-
+>       mapE_ (checkSimpleConstraint "instance" doc p) cx' &&>
+>       mapE (checkDecl env) ds
+>     return (InstanceDecl p cx' cls ty' ds')
+>   where doc = ppQIdent cls <+> ppTypeExpr 2 ty
+> checkTopDecl env (DefaultDecl p tys) =
+>   liftE (DefaultDecl p) (mapE (checkType env p []) tys)
 > checkTopDecl env (BlockDecl d) = liftE BlockDecl (checkDecl env d)
 
-> checkDecl :: TypeEnv -> Decl -> Error Decl
+> checkDClass :: TypeEnv -> [Ident] -> DClass -> Error ()
+> checkDClass env tvs (DClass p cls) = checkClass env p tvs cls
+
+> checkGoal :: TypeEnv -> Goal a -> Error (Goal a)
+> checkGoal env (Goal p e ds) =
+>   liftE2 (Goal p) (checkExpr env p e) (mapE (checkDecl env) ds)
+
+\end{verbatim}
+Method type signatures have to obey a few additional restrictions.
+The class type variable must appear in the method's type (otherwise,
+the type would be inherently ambiguous), and the method's context must
+not contain any additional constraints for that type variable
+(cf.\ Sect.~4.3.1 of the Haskell report).
+\begin{verbatim}
+
+> checkMethodType :: Ident -> Position -> QualTypeExpr -> Error ()
+> checkMethodType tv p ty =
+>   do
+>     unless (tv `elem` fv ty) (errorAt p (ambiguousType tv))
+>     when (tv `elem` cvars ty) (errorAt p (constrainedClassType tv))
+>   where cvars (QualTypeExpr cx _) = [cvar ty | ClassAssert _ ty <- cx]
+>         cvar (VariableType tv) = tv
+>         cvar (ApplyType ty _) = cvar ty
+
+> checkDecl :: TypeEnv -> Decl a -> Error (Decl a)
+> checkDecl _ (InfixDecl p fix pr ops) = return (InfixDecl p fix pr ops)
 > checkDecl env (TypeSig p vs ty) =
->   liftE (TypeSig p vs) (checkType env p ty)
-> checkDecl env (FunctionDecl p f eqs) =
->   liftE (FunctionDecl p f) (mapE (checkEquation env) eqs)
+>   liftE (TypeSig p vs) (checkQualType env p ty)
+> checkDecl env (FunctionDecl p a f eqs) =
+>   liftE (FunctionDecl p a f) (mapE (checkEquation env) eqs)
+> checkDecl env (ForeignDecl p fi a f ty) =
+>   liftE (ForeignDecl p fi a f) (checkType env p [] ty)
 > checkDecl env (PatternDecl p t rhs) =
 >   liftE (PatternDecl p t) (checkRhs env rhs)
-> checkDecl env (ForeignDecl p cc s ie f ty) =
->   liftE (ForeignDecl p cc s ie f) (checkType env p ty)
-> checkDecl _ d = return d
-
-> checkTypeLhs :: TypeEnv -> Position -> [Ident] -> Error ()
-> checkTypeLhs env p tvs =
->   mapE_ (errorAt p . noVariable) (nub tcs) &&>
->   mapE_ (errorAt p . nonLinear . fst) (duplicates (filter (anonId /=) tvs'))
->   where (tcs,tvs') = partition isTypeConstr tvs
->         isTypeConstr tv = not (null (lookupTopEnv tv env))
+> checkDecl _ (FreeDecl p vs) = return (FreeDecl p vs)
+> checkDecl _ (TrustAnnot p tr fs) = return (TrustAnnot p tr fs)
+
+> checkTypeLhs :: TypeEnv -> Position -> [ClassAssert] -> [Ident]
+>              -> Error [ClassAssert]
+> checkTypeLhs env p cx tvs =
+>   mapE_ (errorAt p . nonLinear "left hand side of type declaration" . fst)
+>         (duplicates (filter (anonId /=) tvs)) &&>
+>   mapE (checkClassAssert env p tvs) cx
+
+> checkSimpleConstraint :: String -> Doc -> Position -> ClassAssert -> Error ()
+> checkSimpleConstraint what doc p (ClassAssert cls ty) =
+>   unless (isVariableType ty)
+>          (errorAt p (invalidSimpleConstraint what doc (ClassAssert cls ty)))
 
 > checkConstrDecl :: TypeEnv -> [Ident] -> ConstrDecl -> Error ConstrDecl
-> checkConstrDecl env tvs (ConstrDecl p evs c tys) =
->   checkTypeLhs env p evs &&>
->   liftE (ConstrDecl p evs c) (mapE (checkClosedType env p tvs') tys)
+> checkConstrDecl env tvs (ConstrDecl p evs cx c tys) =
+>   do
+>     cx' <- checkTypeLhs env p cx evs
+>     checkClosedContext p cx' tvs'
+>     tys' <- mapE (checkClosedType env p tvs') tys
+>     return (ConstrDecl p evs cx' c tys')
 >   where tvs' = evs ++ tvs
-> checkConstrDecl env tvs (ConOpDecl p evs ty1 op ty2) =
->   checkTypeLhs env p evs &&>
->   liftE2 (flip (ConOpDecl p evs) op)
->          (checkClosedType env p tvs' ty1)
->          (checkClosedType env p tvs' ty2)
+> checkConstrDecl env tvs (ConOpDecl p evs cx ty1 op ty2) =
+>   do
+>     cx' <- checkTypeLhs env p cx evs
+>     checkClosedContext p cx' tvs'
+>     (ty1',ty2') <-
+>       liftE (,) (checkClosedType env p tvs' ty1) &&&
+>       checkClosedType env p tvs' ty2
+>     return (ConOpDecl p evs cx' ty1' op ty2')
 >   where tvs' = evs ++ tvs
+> checkConstrDecl env tvs (RecordDecl p evs cx c fs) =
+>   do
+>     cx' <- checkTypeLhs env p cx evs
+>     checkClosedContext p cx' tvs'
+>     fs' <- mapE (checkFieldDecl env tvs') fs
+>     return (RecordDecl p evs cx' c fs')
+>   where tvs' = evs ++ tvs
+
+> checkFieldDecl :: TypeEnv -> [Ident] -> FieldDecl -> Error FieldDecl
+> checkFieldDecl env tvs (FieldDecl p ls ty) =
+>   liftE (FieldDecl p ls) (checkClosedType env p tvs ty)
 
 > checkNewConstrDecl :: TypeEnv -> [Ident] -> NewConstrDecl
 >                    -> Error NewConstrDecl
 > checkNewConstrDecl env tvs (NewConstrDecl p c ty) =
 >   liftE (NewConstrDecl p c) (checkClosedType env p tvs ty)
+> checkNewConstrDecl env tvs (NewRecordDecl p c l ty) =
+>   liftE (NewRecordDecl p c l) (checkClosedType env p tvs ty)
 
 \end{verbatim}
-Checking expressions is rather straight forward. The compiler must
-only traverse the structure of expressions in order to find local
+Checking expressions is rather straightforward. The compiler must only
+traverse the structure of expressions in order to find local
 declaration groups.
 \begin{verbatim}
 
-> checkEquation :: TypeEnv -> Equation -> Error Equation
+> checkEquation :: TypeEnv -> Equation a -> Error (Equation a)
 > checkEquation env (Equation p lhs rhs) =
 >   liftE (Equation p lhs) (checkRhs env rhs)
 
-> checkRhs :: TypeEnv -> Rhs -> Error Rhs
+> checkRhs :: TypeEnv -> Rhs a -> Error (Rhs a)
 > checkRhs env (SimpleRhs p e ds) =
 >   liftE2 (SimpleRhs p) (checkExpr env p e) (mapE (checkDecl env) ds)
 > checkRhs env (GuardedRhs es ds) =
 >   liftE2 GuardedRhs (mapE (checkCondExpr env) es) (mapE (checkDecl env) ds)
 
-> checkCondExpr :: TypeEnv -> CondExpr -> Error CondExpr
+> checkCondExpr :: TypeEnv -> CondExpr a -> Error (CondExpr a)
 > checkCondExpr env (CondExpr p g e) =
 >   liftE2 (CondExpr p) (checkExpr env p g) (checkExpr env p e)
 
-> checkExpr :: TypeEnv -> Position -> Expression -> Error Expression
-> checkExpr _ _ (Literal l) = return (Literal l)
-> checkExpr _ _ (Variable v) = return (Variable v)
-> checkExpr _ _ (Constructor c) = return (Constructor c)
+> checkExpr :: TypeEnv -> Position -> Expression a -> Error (Expression a)
+> checkExpr _ _ (Literal a l) = return (Literal a l)
+> checkExpr _ _ (Variable a v) = return (Variable a v)
+> checkExpr _ _ (Constructor a c) = return (Constructor a c)
 > checkExpr env p (Paren e) = liftE Paren (checkExpr env p e)
 > checkExpr env p (Typed e ty) =
->   liftE2 Typed (checkExpr env p e) (checkType env p ty)
+>   liftE2 Typed (checkExpr env p e) (checkQualType env p ty)
+> checkExpr env p (Record a c fs) =
+>   liftE (Record a c) (mapE (checkField env p) fs)
+> checkExpr env p (RecordUpdate e fs) =
+>   liftE2 RecordUpdate (checkExpr env p e) (mapE (checkField env p) fs)
 > checkExpr env p (Tuple es) = liftE Tuple (mapE (checkExpr env p) es)
-> checkExpr env p (List es) = liftE List (mapE (checkExpr env p) es)
+> checkExpr env p (List a es) = liftE (List a) (mapE (checkExpr env p) es)
 > checkExpr env p (ListCompr e qs) =
 >   liftE2 ListCompr (checkExpr env p e) (mapE (checkStmt env p) qs)
 > checkExpr env p (EnumFrom e) = liftE EnumFrom (checkExpr env p e)
@@ -152,7 +251,7 @@
 >          (checkExpr env p e1)
 >          (checkExpr env p e2)
 >          (checkExpr env p e3)
-> checkExpr env p (UnaryMinus op e) = liftE (UnaryMinus op) (checkExpr env p e)
+> checkExpr env p (UnaryMinus e) = liftE UnaryMinus (checkExpr env p e)
 > checkExpr env p (Apply e1 e2) =
 >   liftE2 Apply (checkExpr env p e1) (checkExpr env p e2)
 > checkExpr env p (InfixApply e1 op e2) =
@@ -161,7 +260,7 @@
 >   liftE (flip LeftSection op) (checkExpr env p e)
 > checkExpr env p (RightSection op e) =
 >   liftE (RightSection op) (checkExpr env p e)
-> checkExpr env p (Lambda ts e) = liftE (Lambda ts) (checkExpr env p e)
+> checkExpr env _ (Lambda p ts e) = liftE (Lambda p ts) (checkExpr env p e)
 > checkExpr env p (Let ds e) =
 >   liftE2 Let (mapE (checkDecl env) ds) (checkExpr env p e)
 > checkExpr env p (Do sts e) =
@@ -173,61 +272,174 @@
 >          (checkExpr env p e3)
 > checkExpr env p (Case e alts) =
 >   liftE2 Case (checkExpr env p e) (mapE (checkAlt env) alts)
+> checkExpr env p (Fcase e alts) =
+>   liftE2 Fcase (checkExpr env p e) (mapE (checkAlt env) alts)
 
-> checkStmt :: TypeEnv -> Position -> Statement -> Error Statement
+> checkStmt :: TypeEnv -> Position -> Statement a -> Error (Statement a)
 > checkStmt env p (StmtExpr e) = liftE StmtExpr (checkExpr env p e)
-> checkStmt env p (StmtBind t e) = liftE (StmtBind t) (checkExpr env p e)
-> checkStmt env p (StmtDecl ds) = liftE StmtDecl (mapE (checkDecl env) ds)
+> checkStmt env _ (StmtBind p t e) = liftE (StmtBind p t) (checkExpr env p e)
+> checkStmt env _ (StmtDecl ds) = liftE StmtDecl (mapE (checkDecl env) ds)
 
-> checkAlt :: TypeEnv -> Alt -> Error Alt
+> checkAlt :: TypeEnv -> Alt a -> Error (Alt a)
 > checkAlt env (Alt p t rhs) = liftE (Alt p t) (checkRhs env rhs)
 
+> checkField :: TypeEnv -> Position -> Field (Expression a)
+>            -> Error (Field (Expression a))
+> checkField env p (Field l e) = liftE (Field l) (checkExpr env p e)
+
 \end{verbatim}
 The parser cannot distinguish unqualified nullary type constructors
 and type variables. Therefore, if the compiler finds an unbound
 identifier in a position where a type variable is admissible, it will
-interpret the identifier as such.
+interpret the identifier as such. In type declarations, type variables
+on the left hand side of a declaration can shadow type constructors
+with the same name.
 \begin{verbatim}
 
 > checkClosedType :: TypeEnv -> Position -> [Ident] -> TypeExpr
 >                 -> Error TypeExpr
 > checkClosedType env p tvs ty =
 >   do
->     ty' <- checkType env p ty
+>     ty' <- checkType env p tvs ty
 >     mapE_ (errorAt p . unboundVariable)
 >           (nub (filter (\tv -> tv == anonId || tv `notElem` tvs) (fv ty')))
 >     return ty'
 
-> checkType :: TypeEnv -> Position -> TypeExpr -> Error TypeExpr
-> checkType env p (ConstructorType tc tys) =
->   liftE2 ($)
->          (case qualLookupTopEnv tc env of
->             []
->               | not (isQualified tc) && null tys ->
->                   return (const (VariableType (unqualify tc)))
->               | otherwise -> errorAt p (undefinedType tc)
->             [_] -> return (ConstructorType tc)
->             rs -> errorAt p (ambiguousType rs tc))
->          (mapE (checkType env p) tys)
-> checkType env p (VariableType tv)
->   | tv == anonId = return (VariableType tv)
->   | otherwise = checkType env p (ConstructorType (qualify tv) [])
-> checkType env p (TupleType tys) =
->   liftE TupleType (mapE (checkType env p) tys)
-> checkType env p (ListType ty) =
->   liftE ListType (checkType env p ty)
-> checkType env p (ArrowType ty1 ty2) =
->   liftE2 ArrowType (checkType env p ty1) (checkType env p ty2)
+> checkInstType :: TypeEnv -> Position -> [ClassAssert] -> TypeExpr
+>               -> Error ([ClassAssert],TypeExpr)
+> checkInstType env p cx ty =
+>   do
+>     QualTypeExpr cx' ty' <- checkQualType env p (QualTypeExpr cx ty)
+>     unless (isSimpleType ty' && not (isTypeSynonym env (typeConstr ty')) &&
+>             null (duplicates (filter (anonId /=) (fv ty'))))
+>            (errorAt p (notSimpleType ty'))
+>     return (cx',ty')
+
+> checkQualType :: TypeEnv -> Position -> QualTypeExpr -> Error QualTypeExpr
+> checkQualType env p (QualTypeExpr cx ty) =
+>   do
+>     (cx',ty') <-
+>       liftE (,) (mapE (checkClassAssert env p []) cx) &&&
+>       checkType env p [] ty
+>     checkClosedContext p cx' (fv ty')
+>     return (QualTypeExpr cx' ty')
+
+> checkClassAssert :: TypeEnv -> Position -> [Ident] -> ClassAssert
+>                  -> Error ClassAssert
+> checkClassAssert env p tvs (ClassAssert cls ty) =
+>   do
+>     ty' <- checkClass env p tvs cls &&> checkType env p tvs ty
+>     unless (isVariableType (root ty'))
+>            (errorAt p (invalidConstraint (ClassAssert cls ty')))
+>     return (ClassAssert cls ty')
+>   where root (ApplyType ty _) = root ty
+>         root ty = ty
+
+> checkClosedContext :: Position -> [ClassAssert] -> [Ident] -> Error ()
+> checkClosedContext p cx tvs =
+>   mapE_ (errorAt p . unboundVariable) (nub (filter (`notElem` tvs) (fv cx)))
+
+> checkType :: TypeEnv -> Position -> [Ident] -> TypeExpr -> Error TypeExpr
+> checkType env p tvs (ConstructorType tc)
+>   | tc `elem` map qualify tvs = return (VariableType (unqualify tc))
+>   | otherwise =
+>       case qualLookupTopEnv tc env of
+>         []
+>           | isQualified tc -> errorAt p (undefinedType tc)
+>           | otherwise -> return (VariableType (unqualify tc))
+>         [Data _ _] -> return (ConstructorType tc)
+>         [Alias _] -> return (ConstructorType tc)
+>         [Class _ _] -> errorAt p (undefinedType tc)
+>         rs -> errorAt p (ambiguousIdent rs tc)
+> checkType env p tvs (VariableType tv)
+>   | tv `elem` anonId:tvs = return (VariableType tv)
+>   | otherwise = checkType env p tvs (ConstructorType (qualify tv))
+> checkType env p tvs (TupleType tys) =
+>   liftE TupleType (mapE (checkType env p tvs) tys)
+> checkType env p tvs (ListType ty) =
+>   liftE ListType (checkType env p tvs ty)
+> checkType env p tvs (ArrowType ty1 ty2) =
+>   liftE2 ArrowType (checkType env p tvs ty1) (checkType env p tvs ty2)
+> checkType env p tvs (ApplyType ty1 ty2) =
+>   liftE2 ApplyType (checkType env p tvs ty1) (checkType env p tvs ty2)
+
+> checkClass :: TypeEnv -> Position -> [Ident] -> QualIdent -> Error ()
+> checkClass env p tvs cls
+>   | cls `elem` map qualify tvs = errorAt p (undefinedClass cls)
+>   | otherwise =
+>       case qualLookupTopEnv cls env of
+>         [] -> errorAt p (undefinedClass cls)
+>         [Data _ _] -> errorAt p (undefinedClass cls)
+>         [Alias _] -> errorAt p (undefinedClass cls)
+>         [Class _ _] -> return ()
+>         rs -> errorAt p (ambiguousIdent rs cls)
+
+\end{verbatim}
+The compiler reports an error when more than one instance is defined
+for a particular pair of a type class and type constructor. This
+includes duplicate instances defined in the current module as well as
+conflicts between locally defined instances and imported instances.
+\begin{verbatim}
+
+> checkInstances :: TypeEnv -> InstSet -> [TopDecl a] -> Error ()
+> checkInstances tEnv iEnv ds =
+>   do
+>     sequenceE_ [errorAt p (duplicateInstance (unqualCT tEnv inst))
+>                | P p inst <- unique cts, inst `elemSet` iEnv] &&>
+>       reportDuplicates (duplicateInstance . unqualCT tEnv)
+>                        (repeatedInstance . unqualCT tEnv) cts
+>     return ()
+>   where cts = map (fmap (qualCT tEnv)) (concatMap instances ds)
+>         unique [] = []
+>         unique (x:xs)
+>           | x `elem` xs = unique (filter (x /=) xs)
+>           | otherwise = x : unique xs
+
+> bindInstance :: P CT -> InstSet -> InstSet
+> bindInstance (P _ inst) iEnv = addToSet inst iEnv
+
+> qualCT :: TypeEnv -> CT -> CT
+> qualCT env (CT cls tc) = CT (qual env cls) (qual env tc)
+>   where qual env x = origName (head (qualLookupTopEnv x env))
+
+> unqualCT :: TypeEnv -> CT -> CT
+> unqualCT env (CT cls tc) = CT (unqual env cls) (unqual env tc)
+>   where unqual env x =
+>           case lookupTopEnv x' env of
+>             [y] | origName y == x -> qualify x'
+>             _ -> x
+>           where x' = unqualify x
 
 \end{verbatim}
 Auxiliary definitions.
 \begin{verbatim}
 
-> tconstr :: TopDecl -> P Ident
-> tconstr (DataDecl p tc _ _) = P p tc
-> tconstr (NewtypeDecl p tc _ _) = P p tc
-> tconstr (TypeDecl p tc _ _) = P p tc
-> tconstr (BlockDecl _) = internalError "tconstr"
+> tident :: TopDecl a -> P Ident
+> tident (DataDecl p _ tc _ _ _) = P p tc
+> tident (NewtypeDecl p _ tc _ _ _) = P p tc
+> tident (TypeDecl p tc _ _) = P p tc
+> tident (ClassDecl p _ cls _ _) = P p cls
+> tident (InstanceDecl _ _ _ _ _) = internalError "tident"
+> tident (DefaultDecl _ _) = internalError "tident"
+> tident (BlockDecl _) = internalError "tident"
+
+> instances :: TopDecl a -> [P CT]
+> instances (DataDecl _ _ tc _ _ clss) =
+>   [P p (CT cls (qualify tc)) | DClass p cls <- clss]
+> instances (NewtypeDecl _ _ tc _ _ clss) =
+>   [P p (CT cls (qualify tc)) | DClass p cls <- clss]
+> instances (TypeDecl _ _ _ _) = []
+> instances (ClassDecl _ _ _ _ _) = []
+> instances (InstanceDecl p _ cls ty _) = [P p (CT cls (typeConstr ty))]
+> instances (DefaultDecl _ _) = []
+> instances (BlockDecl _) = []
+
+> isTypeSynonym :: TypeEnv -> QualIdent -> Bool
+> isTypeSynonym env tc =
+>   case qualLookupTopEnv tc env of
+>     [Data _ _] -> False
+>     [Alias _] -> True
+>     _ -> internalError "isTypeSynonym"
 
 \end{verbatim}
 Error messages.
@@ -242,29 +454,69 @@
 > undefinedType :: QualIdent -> String
 > undefinedType tc = "Undefined type " ++ qualName tc
 
-> ambiguousType :: [TypeKind] -> QualIdent -> String
-> ambiguousType rs tc = show $
->   text "Ambiguous type" <+> ppQIdent tc $$
+> undefinedClass :: QualIdent -> String
+> undefinedClass cls = "Undefined type class " ++ qualName cls
+
+> ambiguousIdent :: [TypeKind] -> QualIdent -> String
+> ambiguousIdent rs x = show $
+>   text "Ambiguous identifier" <+> ppQIdent x $$
 >   fsep (text "Could refer to:" :
 >               punctuate comma (map (ppQIdent . origName) rs))
 
 > duplicateType :: Ident -> String
-> duplicateType tc = "Type " ++ name tc ++ " defined more than once"
+> duplicateType x = name x ++ " defined more than once"
 
 > repeatedType :: Ident -> String
-> repeatedType tc = "Redefinition of type " ++ name tc
+> repeatedType x = "Redefinition of " ++ name x
 
-> nonLinear :: Ident -> String
-> nonLinear tv =
->   "Type variable " ++ name tv ++
->   " occurs more than once in left hand side of type declaration"
-
-> noVariable :: Ident -> String
-> noVariable tv =
->   "Type constructor " ++ name tv ++
->   " used in left hand side of type declaration"
+> duplicateInstance :: CT -> String
+> duplicateInstance (CT cls tc) =
+>   "More than one " ++ qualName cls ++ " " ++ qualName tc ++
+>   " instance declaration"
+
+> repeatedInstance :: CT -> String
+> repeatedInstance (CT cls tc) =
+>   "Repeated " ++ qualName cls ++ " " ++ qualName tc ++ " instance declaration"
+
+> duplicateDefault :: String
+> duplicateDefault = "More than one default declaration"
+
+> repeatedDefault :: String
+> repeatedDefault = "Repeated default declaration"
+
+> nonLinear :: String -> Ident -> String
+> nonLinear what tv =
+>   "Type variable " ++ name tv ++ " occurs more than once in " ++ what
 
 > unboundVariable :: Ident -> String
 > unboundVariable tv = "Undefined type variable " ++ name tv
 
+> ambiguousType :: Ident -> String
+> ambiguousType tv =
+>   "Method type does not mention type variable " ++ name tv
+
+> constrainedClassType :: Ident -> String
+> constrainedClassType tv =
+>   "Method type context must not constrain type variable " ++ name tv
+
+> invalidSimpleConstraint :: String -> Doc -> ClassAssert -> String
+> invalidSimpleConstraint what doc ca = show $
+>   vcat [text "Illegal class constraint" <+> ppClassAssert ca,
+>         text "in" <+> text what <+> text "declaration" <+> doc,
+>         text "Constraints in class and instance declarations must be of the",
+>         text "form C u, where u is a type variable."]
+
+> invalidConstraint :: ClassAssert -> String
+> invalidConstraint ca = show $
+>   vcat [text "Illegal class constraint" <+> ppClassAssert ca,
+>         text "Constraints must be of the form C u or C (u t1 ... tn),",
+>         text "where u is a type variable and t1, ..., tn are types."]
+
+> notSimpleType :: TypeExpr -> String
+> notSimpleType ty = show $
+>   vcat [text "Illegal instance type" <+> ppTypeExpr 0 ty,
+>         text "The instance type must be of the form (T u1 ... un),",
+>         text "where T is not a type synonym and u1, ..., un are",
+>         text "mutually distinct type variables."]
+
 \end{verbatim}
diff -u curry-0.9.11/TypeTrans.lhs curry-0.9.11-classful/TypeTrans.lhs
--- curry-0.9.11/TypeTrans.lhs	2007-06-15 14:16:34.000000000 +0200
+++ curry-0.9.11-classful/TypeTrans.lhs	2008-06-16 09:45:46.000000000 +0200
@@ -1,7 +1,7 @@
 % -*- LaTeX -*-
-% $Id: TypeTrans.lhs 2058 2007-01-02 16:11:46Z wlux $
+% $Id: TypeTrans.lhs 2723 2008-06-14 15:56:40Z wlux $
 %
-% Copyright (c) 1999-2005, Wolfgang Lux
+% Copyright (c) 1999-2008, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{TypeTrans.lhs}
@@ -10,150 +10,300 @@
 external type representations.
 \begin{verbatim}
 
-> module TypeTrans(toType, toTypes, fromType,
->                  expandMonoType, expandMonoTypes, expandPolyType,
->                  ppType, ppTypeScheme) where
+> module TypeTrans(toType, toTypes, toQualType, toConstrType, toMethodType,
+>                  fromType, fromQualType,
+>                  expandMonoType, expandConstrType, expandMethodType,
+>                  expandPolyType, minContext, maxContext,
+>                  ppType, ppQualType, ppTypeScheme, ppInstance) where
 > import Base
+> import Curry
 > import CurryPP
 > import List
 > import Map
+> import PredefIdent
+> import PredefTypes
 > import Pretty
 > import TopEnv
+> import Types
+> import TypeInfo
 > import TypeSubst
+> import ValueInfo
 
 \end{verbatim}
 The functions \texttt{toType} and \texttt{toTypes} convert Curry type
-expressions into types. The compiler uses only correctly qualified
-names internally and therefore adds the name of the current module to
-all type constructors that lack a module qualifier. Type variables are
-assigned ascending indices in the order of their occurrence in the
-types. It is possible to pass a list of additional type variables to
-both functions, which are assigned indices before those variables
-occurring in the type. This allows preserving the order of type
-variables in the left hand side of a type declaration.
+expressions into types. The function \texttt{toQualType} similarly
+converts a qualified type expression into a qualified type.
 
-Note the subtle difference between \texttt{toTypes m tvs tys} and
-\texttt{map (toType m tvs) tys}. The former ensures that consistent
+The function \texttt{toConstrType} returns the type and additional
+information for a data or newtype constructor. A special feature of
+this function is that it restricts the context to those type variables
+which are free in the argument types as specified in Sect.~4.2.1 of
+the revised Haskell'98 report~\cite{PeytonJones03:Haskell}.
+
+The function \texttt{toMethodType} returns the type of a type class
+method. It adds the implicit type class constraint to the method's
+type signature and ensures that the class' type variable is always
+assigned index 0.
+
+Type variables are assigned ascending indices in the order of their
+occurrence in the types. It is possible to pass a list of additional
+type variables to these functions, which are assigned indices before
+those variables occurring in the type.  This allows preserving the
+order of type variables in the left hand side of a type declaration
+and in the head of a type class declaration, respectively.
+
+Note the subtle difference between \texttt{toTypes tvs tys} and
+\texttt{map (toType tvs) tys}. The former ensures that consistent
 indices are assigned to all type variables occurring in the type
 expressions \texttt{tys}, whereas the latter assigns type variable
-indices independently for each type expression.
+indices independently in each type expression.
 \begin{verbatim}
 
-> toType :: ModuleIdent -> [Ident] -> TypeExpr -> Type
-> toType m tvs ty = qualifyType m (toType' (enumTypeVars tvs ty) ty)
+> toType :: [Ident] -> TypeExpr -> Type
+> toType tvs ty = toType' (enumTypeVars tvs ty) ty
+
+> toTypes :: [Ident] -> [TypeExpr] -> [Type]
+> toTypes tvs tys = map (toType' (enumTypeVars tvs tys)) tys
+
+> toQualType :: QualTypeExpr -> QualType
+> toQualType ty = toQualType' (enumTypeVars [] ty) ty
 
-> toTypes :: ModuleIdent -> [Ident] -> [TypeExpr] -> [Type]
-> toTypes m tvs tys = map (qualifyType m . toType' (enumTypeVars tvs tys)) tys
+> toConstrType :: [ClassAssert] -> QualIdent -> [Ident] -> [ClassAssert]
+>              -> [TypeExpr] -> (ConstrInfo,QualType)
+> toConstrType cxL tc tvs cxR tys =
+>   (ConstrInfo (length (filter (`notElem` tvs) tvs'')) (toContext' tvs' cxR'),
+>    canonType (toQualType' tvs' (QualTypeExpr (cxL' ++ cxR') ty')))
+>   where tvs' = enumTypeVars tvs tys
+>         tvs'' = nub (fv tys)
+>         cxL' = restrictContext tvs'' cxL
+>         cxR' = restrictContext tvs'' cxR
+>         ty' = foldr ArrowType ty0 tys
+>         ty0 = foldl ApplyType (ConstructorType tc) (map VariableType tvs)
+
+> toMethodType :: QualIdent -> Ident -> QualTypeExpr -> QualType
+> toMethodType cls tv (QualTypeExpr cx ty) =
+>   toQualType' tvs (QualTypeExpr (ClassAssert cls (VariableType tv) : cx) ty)
+>   where tvs = enumTypeVars [tv] (QualTypeExpr cx ty)
 
 > enumTypeVars :: Expr a => [Ident] -> a -> FM Ident Int
 > enumTypeVars tvs ty = fromListFM (zip (tvs ++ tvs') [0..])
 >   where tvs' = [tv | tv <- nub (fv ty), tv `notElem` tvs]
 
+> restrictContext :: [Ident] -> [ClassAssert] -> [ClassAssert]
+> restrictContext tvs cx =
+>   [ClassAssert cls ty | ClassAssert cls ty <- cx, cvar ty `elem` tvs]
+>   where cvar (VariableType tv) = tv
+>         cvar (ApplyType ty _) = cvar ty
+
+> toQualType' :: FM Ident Int -> QualTypeExpr -> QualType
+> toQualType' tvs (QualTypeExpr cx ty) =
+>   QualType (toContext' tvs cx) (toType' tvs ty)
+
+> toContext' :: FM Ident Int -> [ClassAssert] -> Context
+> toContext' tvs cx = nub (map (toTypePred' tvs) cx)
+
+> toTypePred' :: FM Ident Int -> ClassAssert -> TypePred
+> toTypePred' tvs (ClassAssert cls ty) = TypePred cls (toType' tvs ty)
+
 > toType' :: FM Ident Int -> TypeExpr -> Type
-> toType' tvs (ConstructorType tc tys) =
->   TypeConstructor tc (map (toType' tvs) tys)
-> toType' tvs (VariableType tv) =
->   maybe (internalError ("toType " ++ show tv)) TypeVariable (lookupFM tv tvs)
-> toType' tvs (TupleType tys) = tupleType (map (toType' tvs) tys)
-> toType' tvs (ListType ty) = listType (toType' tvs ty)
-> toType' tvs (ArrowType ty1 ty2) =
->   TypeArrow (toType' tvs ty1) (toType' tvs ty2)
-
-> qualifyType :: ModuleIdent -> Type -> Type
-> qualifyType m (TypeConstructor tc tys) =
->   TypeConstructor (if isPrimTypeId tc then tc else qualQualify m tc)
->                   (map (qualifyType m) tys)
-> qualifyType _ (TypeVariable tv) = TypeVariable tv
-> qualifyType m (TypeConstrained tys tv) =
->   TypeConstrained (map (qualifyType m) tys) tv
-> qualifyType m (TypeArrow ty1 ty2) =
->   TypeArrow (qualifyType m ty1) (qualifyType m ty2)
-> qualifyType _ (TypeSkolem k) = TypeSkolem k
-
-\end{verbatim}
-The function \texttt{fromType} converts a type into a Curry type
-expression. During the conversion, the compiler removes unnecessary
-module qualifiers from type constructors that are in scope with
-unqualified names.
-\begin{verbatim}
-
-> fromType :: TCEnv -> Type -> TypeExpr
-> fromType tcEnv ty = fromType' (unqualifyType tcEnv ty)
-
-> fromType' :: Type -> TypeExpr
-> fromType' (TypeConstructor tc tys)
->   | isQTupleId tc = TupleType tys'
->   | tc == qListId && length tys == 1 = ListType (head tys')
->   | otherwise = ConstructorType tc tys'
->   where tys' = map fromType' tys
-> fromType' (TypeVariable tv) =
->   VariableType (if tv >= 0 then nameSupply !! tv
->                            else mkIdent ('_' : show (-tv)))
-> fromType' (TypeConstrained tys _) = fromType' (head tys)
-> fromType' (TypeArrow ty1 ty2) = ArrowType (fromType' ty1) (fromType' ty2)
-> fromType' (TypeSkolem k) = VariableType (mkIdent ("_?" ++ show k))
+> toType' tvs ty = toTypeApp tvs ty []
 
-> unqualifyType :: TCEnv -> Type -> Type
-> unqualifyType tcEnv (TypeConstructor tc tys) =
->   TypeConstructor (unqualifyTC tcEnv tc) (map (unqualifyType tcEnv) tys)
-> unqualifyType _ (TypeVariable tv) = TypeVariable tv
-> unqualifyType tcEnv (TypeConstrained tys tv) =
->   TypeConstrained (map (unqualifyType tcEnv) tys) tv
-> unqualifyType tcEnv (TypeArrow ty1 ty2) =
->   TypeArrow (unqualifyType tcEnv ty1) (unqualifyType tcEnv ty2)
-> unqualifyType _ (TypeSkolem k) = TypeSkolem k
+> toTypeApp :: FM Ident Int -> TypeExpr -> [Type] -> Type
+> toTypeApp tvs (ConstructorType tc) tys
+>   | unqualify tc == arrowId && length tys == 2 =
+>       TypeArrow (tys !! 0) (tys !! 1)
+>   | otherwise = foldl TypeApply (TypeConstructor tc) tys
+> toTypeApp tvs (VariableType tv) tys =
+>   maybe (internalError ("toType " ++ show tv))
+>         (\tv -> foldl TypeApply (TypeVariable tv) tys)
+>         (lookupFM tv tvs)
+> toTypeApp tvs (TupleType tys) tys'
+>   | null tys' = tupleType (map (toType' tvs) tys)
+>   | otherwise = internalError "toType (TupleType)"
+> toTypeApp tvs (ListType ty) tys
+>   | null tys = listType (toType' tvs ty)
+>   | otherwise = internalError "toType (ListType)"
+> toTypeApp tvs (ArrowType ty1 ty2) tys
+>   | null tys = TypeArrow (toType' tvs ty1) (toType' tvs ty2)
+>   | otherwise = internalError "toType (ArrowType)"
+> toTypeApp tvs (ApplyType ty1 ty2) tys =
+>   toTypeApp tvs ty1 (toType' tvs ty2 : tys)
 
-> unqualifyTC :: TCEnv -> QualIdent -> QualIdent
-> unqualifyTC tcEnv tc =
->   case lookupTopEnv tc' tcEnv of
->     [t] | origName t == tc -> qualify tc'
->     _ -> tc
+\end{verbatim}
+The functions \texttt{fromType} and \texttt{fromQualType} convert a
+(qualified) type into a (qualified) Curry type expression.
+\begin{verbatim}
+
+> fromType :: [Ident] -> Type -> TypeExpr
+> fromType tvs ty = fromTypeApp tvs ty []
+
+> fromQualType :: [Ident] -> QualType -> QualTypeExpr
+> fromQualType tvs (QualType cx ty) =
+>   QualTypeExpr (map (fromTypePred tvs) cx) (fromType tvs ty)
+
+> fromTypePred :: [Ident] -> TypePred -> ClassAssert
+> fromTypePred tvs (TypePred cls ty) = ClassAssert cls (fromType tvs ty)
+
+> fromTypeApp :: [Ident] -> Type -> [TypeExpr] -> TypeExpr
+> fromTypeApp _ (TypeConstructor tc) tys
+>   | tc' == listId && length tys == 1 = ListType (head tys)
+>   | isTupleId tc' && length tys == tupleArity tc' = TupleType tys
+>   | otherwise = foldl ApplyType (ConstructorType tc) tys
 >   where tc' = unqualify tc
+> fromTypeApp tvs (TypeVariable tv) tys =
+>   foldl ApplyType
+>         (VariableType (if tv >= 0 then tvs !! tv
+>                                   else mkIdent ('_' : show (-tv))))
+>         tys
+> fromTypeApp tvs (TypeConstrained tys _) tys' = fromTypeApp tvs (head tys) tys'
+> fromTypeApp _ (TypeSkolem k) tys =
+>   foldl ApplyType (VariableType (mkIdent ("_?" ++ show k))) tys
+> fromTypeApp tvs (TypeApply ty1 ty2) tys =
+>   fromTypeApp tvs ty1 (fromType tvs ty2 : tys)
+> fromTypeApp tvs (TypeArrow ty1 ty2) tys =
+>   foldl ApplyType (ArrowType (fromType tvs ty1) (fromType tvs ty2)) tys
 
 \end{verbatim}
-The functions \texttt{expandMonoType}, \texttt{expandMonoTypes}, and
-\texttt{expandPolyType} convert type expressions into types and also
+The functions \texttt{expandMonoType} and \texttt{expandPolyType}
+convert (qualified) type expressions into (qualified) types and also
 expand all type synonyms and qualify all type constructors during the
-conversion. Qualification and expansion have to be performed at the
-same time, since type constructors are recorded in the type
-constructor environment using the names visible in the source code,
-but the expanded types refer to the original names.
+conversion.
+
+The function \texttt{expandConstrType} computes the type and
+additional information for a data or newtype constructor. Similar to
+\texttt{toConstrType}, the type's context is restricted to those type
+variables which are free in the argument types. However, type synonyms
+are expanded and type constructors and type classes are qualified with
+the name of the module containing their definition.
+
+The function \texttt{expandMethodType} converts the type of a type
+class method. Similar to function \texttt{toMethodType}, the implicit
+type class constraint is added to the method's type and the class'
+type variable is assigned index 0. However, type synonyms are expanded
+and type constructors and type classes are qualified with the name of
+the module containing their definition.
 \begin{verbatim}
 
 > expandMonoType :: TCEnv -> [Ident] -> TypeExpr -> Type
-> expandMonoType tcEnv tvs ty =
->   expandType tcEnv (toType' (enumTypeVars tvs ty) ty)
-
-> expandMonoTypes :: TCEnv -> [Ident] -> [TypeExpr] -> [Type]
-> expandMonoTypes tcEnv tvs tys =
->   map (expandType tcEnv . toType' (enumTypeVars tvs tys)) tys
+> expandMonoType tcEnv tvs = expandType tcEnv . toType tvs
 
-> expandPolyType :: TCEnv -> TypeExpr -> TypeScheme
-> expandPolyType tcEnv ty = polyType $ normalize 0 $ expandMonoType tcEnv [] ty
+> expandConstrType :: TCEnv -> [ClassAssert] -> QualIdent -> [Ident]
+>                  -> [ClassAssert] -> [TypeExpr] -> (ConstrInfo,QualType)
+> expandConstrType tcEnv cxL tc tvs cxR tys =
+>   (ConstrInfo n' cxR'',normalize n (expandQualType tcEnv ty'))
+>   where n = length tvs
+>         (ConstrInfo n' cxR',ty') = toConstrType cxL tc tvs cxR tys
+>         QualType cxR'' _ =
+>           normalize n (expandQualType tcEnv (contextMap (const cxR') ty'))
+
+> expandMethodType :: TCEnv -> QualIdent -> Ident -> QualTypeExpr -> QualType
+> expandMethodType tcEnv cls tv =
+>   normalize 1 . expandQualType tcEnv . toMethodType cls tv
+
+> expandPolyType :: TCEnv -> QualTypeExpr -> QualType
+> expandPolyType tcEnv = normalize 0 . expandQualType tcEnv . toQualType
+
+> expandQualType :: TCEnv -> QualType -> QualType
+> expandQualType tcEnv (QualType cx ty) =
+>   QualType (expandContext tcEnv cx) (expandType tcEnv ty)
+
+> expandContext :: TCEnv -> [TypePred] -> [TypePred]
+> expandContext tcEnv cx = minContext tcEnv (map (expandTypePred tcEnv) cx)
+
+> expandTypePred :: TCEnv -> TypePred -> TypePred
+> expandTypePred tcEnv (TypePred cls ty) =
+>   case qualLookupTopEnv cls tcEnv of
+>     [TypeClass cls' _ _ _] -> TypePred cls' (expandType tcEnv ty)
+>     _ -> internalError ("expandTypePred " ++ show cls)
 
 > expandType :: TCEnv -> Type -> Type
-> expandType tcEnv (TypeConstructor tc tys) =
+> expandType tcEnv ty = expandTypeApp tcEnv ty []
+
+> expandTypeApp :: TCEnv -> Type -> [Type] -> Type
+> expandTypeApp tcEnv (TypeConstructor tc) tys =
 >   case qualLookupTopEnv tc tcEnv of
->     [DataType tc' _ _] -> TypeConstructor tc' tys'
->     [RenamingType tc' _ _] -> TypeConstructor tc' tys'
->     [AliasType _ _ ty] -> expandAliasType tys' ty
+>     [DataType tc' _ _] -> foldl TypeApply (TypeConstructor tc') tys
+>     [RenamingType tc' _ _] -> foldl TypeApply (TypeConstructor tc') tys
+>     [AliasType _ n _ ty] -> applyType (expandAliasType tys' ty) tys''
+>       where (tys',tys'') = splitAt n tys
 >     _ -> internalError ("expandType " ++ show tc)
->   where tys' = map (expandType tcEnv) tys
-> expandType _ (TypeVariable tv) = TypeVariable tv
-> expandType _ (TypeConstrained tys tv) = TypeConstrained tys tv
-> expandType tcEnv (TypeArrow ty1 ty2) =
->   TypeArrow (expandType tcEnv ty1) (expandType tcEnv ty2)
-> expandType _ (TypeSkolem k) = TypeSkolem k
+> expandTypeApp _ (TypeVariable tv) tys = foldl TypeApply (TypeVariable tv) tys
+> expandTypeApp _ (TypeConstrained tys tv) tys' =
+>   foldl TypeApply (TypeConstrained tys tv) tys'
+> expandTypeApp _ (TypeSkolem k) tys = foldl TypeApply (TypeSkolem k) tys
+> expandTypeApp tcEnv (TypeApply ty1 ty2) tys =
+>   expandTypeApp tcEnv ty1 (expandType tcEnv ty2 : tys)
+> expandTypeApp tcEnv (TypeArrow ty1 ty2) tys =
+>   foldl TypeApply
+>         (TypeArrow (expandType tcEnv ty1) (expandType tcEnv ty2))
+>         tys
+
+\end{verbatim}
+The function \texttt{minContext} transforms a context by removing all
+type predicates from the context which are implied by other predicates
+according to the super class hierarchy. Inversely, the function
+\texttt{maxContext} adds all predicates to a context which are implied
+by the predicates in the given context.
+\begin{verbatim}
+
+> minContext :: TCEnv -> Context -> Context
+> minContext tcEnv cx = cx' \\ concatMap implied cx'
+>   where cx' = nub cx
+>         implied (TypePred cls ty) =
+>           [TypePred cls' ty | cls' <- tail (allSuperClasses cls tcEnv)]
+
+> maxContext :: TCEnv -> Context -> Context
+> maxContext tcEnv cx = nub (concatMap implied cx)
+>   where implied (TypePred cls ty) =
+>           [TypePred cls' ty | cls' <- sort (allSuperClasses cls tcEnv)]
 
 \end{verbatim}
 The following functions implement pretty-printing for types by
-converting them into type expressions.
+converting them into type expressions. In order to improve
+readability, module qualifiers are removed as far as possible.
 \begin{verbatim}
 
 > ppType :: TCEnv -> Type -> Doc
-> ppType tcEnv = ppTypeExpr 0 . fromType tcEnv
+> ppType tcEnv = ppTypeExpr 0 . fromType nameSupply . unqualifyType tcEnv
+
+> ppQualType :: TCEnv -> QualType -> Doc
+> ppQualType tcEnv =
+>   ppQualTypeExpr . fromQualType nameSupply . unqualifyQualType tcEnv
 
 > ppTypeScheme :: TCEnv -> TypeScheme -> Doc
-> ppTypeScheme tcEnv (ForAll _ ty) = ppType tcEnv ty
+> ppTypeScheme tcEnv (ForAll _ ty) = ppQualType tcEnv ty
+
+> ppInstance :: TCEnv -> TypePred -> Doc
+> ppInstance tcEnv =
+>   ppClassAssert . fromTypePred nameSupply . unqualifyTypePred tcEnv
+
+> unqualifyType :: TCEnv -> Type -> Type
+> unqualifyType tcEnv (TypeConstructor tc) =
+>   TypeConstructor (unqualifyTC tcEnv tc)
+> unqualifyType _ (TypeVariable tv) = TypeVariable tv
+> unqualifyType tcEnv (TypeConstrained tys tv) =
+>   TypeConstrained (map (unqualifyType tcEnv) tys) tv
+> unqualifyType _ (TypeSkolem k) = TypeSkolem k
+> unqualifyType tcEnv (TypeApply ty1 ty2) =
+>   TypeApply (unqualifyType tcEnv ty1) (unqualifyType tcEnv ty2)
+> unqualifyType tcEnv (TypeArrow ty1 ty2) =
+>   TypeArrow (unqualifyType tcEnv ty1) (unqualifyType tcEnv ty2)
+
+> unqualifyQualType :: TCEnv -> QualType -> QualType
+> unqualifyQualType tcEnv (QualType cx ty) =
+>   QualType (map (unqualifyTypePred tcEnv) cx) (unqualifyType tcEnv ty)
+
+> unqualifyTypePred :: TCEnv -> TypePred -> TypePred
+> unqualifyTypePred tcEnv (TypePred cls ty) =
+>   TypePred (unqualifyTC tcEnv cls) (unqualifyType tcEnv ty)
+
+> unqualifyTC :: TCEnv -> QualIdent -> QualIdent
+> unqualifyTC tcEnv tc
+>   | isPrimTypeId tc' = qualify tc'
+>   | otherwise =
+>       case lookupTopEnv tc' tcEnv of
+>         [t] | origName t == tc -> qualify tc'
+>         _ -> tc
+>   where tc' = unqualify tc
 
 \end{verbatim}
diff -u curry-0.9.11/Typing.lhs curry-0.9.11-classful/Typing.lhs
--- curry-0.9.11/Typing.lhs	2007-06-15 14:16:34.000000000 +0200
+++ curry-0.9.11-classful/Typing.lhs	2010-07-01 12:08:41.000000000 +0200
@@ -1,298 +1,268 @@
 % -*- LaTeX -*-
-% $Id: Typing.lhs 2146 2007-04-02 08:01:20Z wlux $
+% $Id: Typing.lhs 2970 2010-07-01 09:11:20Z wlux $
 %
-% Copyright (c) 2003-2007, Wolfgang Lux
+% Copyright (c) 2003-2010, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{Typing.lhs}
 \section{Computing the Type of Curry Expressions}
 \begin{verbatim}
 
-> module Typing(Typeable(..)) where
+> module Typing(Typeable(..), etaType, withType, matchType, argumentTypes,
+>               bindDecls, bindLhs, bindTerms, bindTerm,
+>               declVars, termVars) where
 > import Base
-> import TypeSubst
-> import Combined
-> import Monad
+> import Curry
+> import CurryUtils
+> import Env
+> import Maybe
+> import PredefIdent
+> import PredefTypes
 > import TopEnv
+> import Types
+> import TypeInfo
+> import TypeSubst
+> import ValueInfo
 > import Utils
 
 \end{verbatim}
-During the transformation of Curry source code into the intermediate
-language, the compiler has to recompute the types of expressions. This
-is simpler than type checking because the types of all variables are
-known. Yet, the compiler still must handle functions and constructors
-with polymorphic types and instantiate their type schemes using fresh
-type variables. Since all types computed by \texttt{typeOf} are
-monomorphic, we can use type variables with non-negative offsets for
-the instantiation of type schemes here without risk of name conflicts.
-Using non-negative offsets also makes it easy to distinguish these
-fresh variables from free type variables introduce during type
-inference, which must be regarded as constants here.
-
-However, using non-negative offsets for fresh type variables gives
-rise to two problems when those types are entered back into the type
-environment, e.g., while introducing auxiliary variables during
-desugaring. The first is that those type variables now appear to be
-universally quantified variables, but with indices greater than the
-number of quantified type variables.\footnote{To be precise, this can
-  happen only for auxiliary variables, which have monomorphic types,
-  whereas auxiliary functions will be assigned polymorphic types and
-  these type variables will be properly quantified. However, in this
-  case the assigned types may be too general.} This results in an
-internal error (``Prelude.!!: index too large'') whenever such a type
-is instantiated. The second problem is that there may be inadvertent
-name captures because \texttt{computeType} always uses indices
-starting at 0 for the fresh type variables. In order to avoid these
-problems, \texttt{computeType} renames all type variables with
-non-negative offsets after the final type has been computed, using
-negative indices below the one with the smallest value occurring in
-the type environment. Computing the minimum index of all type
-variables in the type environment seems prohibitively inefficient.
-However, recall that, thanks to laziness, the minimum is computed only
-when the final type contains any type variables with non-negative
-indices. This happens, for instance, 36 times while compiling the
-prelude (for 159 evaluated applications of \texttt{typeOf}) and only
-twice while compiling the standard \texttt{IO} module (for 21
-applications of \texttt{typeOf}).\footnote{These numbers were obtained
-  for version 0.9.9.}
-
-A careful reader will note that inadvertent name captures are still
-possible if one computes the types of two or more auxiliary variables
-before actually entering their types into the environment. Therefore,
-make sure that you enter the types of these auxiliary variables
-immediately into the type environment, unless you are sure that those
-types cannot contain fresh type variables. One such case are the free
-variables of a goal.
-
-\ToDo{In the long run, this module should be made obsolete by adding
-attributes to the abstract syntax tree -- e.g., along the lines of
-Chap.~6 in~\cite{PeytonJonesLester92:Book} -- and returning an
-abstract syntax tree attributed with type information together with
-the type environment from type inference. This also would allow
-getting rid of the identifiers in the representation of integer
-literals, which are used in order to implement overloading of
-integer constants.}
-
-\ToDo{When computing the type of an expression with a type signature
-make use of the annotation instead of recomputing its type. In order
-to do this, we must either ensure that the types are properly
-qualified and expanded or we need access to the type constructor
-environment.}
+After the compiler has attributed patterns and expressions with type
+information during type inference, it is straightforward to recompute
+the type of every pattern and expression. Since all annotated types
+are monomorphic, there is no need to instantiate any variables or
+perform any (non-trivial) unifications.
 \begin{verbatim}
 
-> type TyState a = StateT TypeSubst (StateT Int Id) a
+> class Typeable a where
+>   typeOf :: a -> Type
 
-> run :: TyState a -> ValueEnv -> a
-> run m tyEnv = runSt (callSt m idSubst) 0
+> instance Typeable Type where
+>   typeOf = id
 
-> class Typeable a where
->   typeOf :: ValueEnv -> a -> Type
+> instance Typeable QualType where
+>   typeOf = unqualType
 
-> instance Typeable Ident where
->   typeOf = computeType identType
+> instance Typeable a => Typeable (ConstrTerm a) where
+>   typeOf (LiteralPattern a _) = typeOf a
+>   typeOf (NegativePattern a _) = typeOf a
+>   typeOf (VariablePattern a _) = typeOf a
+>   typeOf (ConstructorPattern a _ _) = typeOf a
+>   typeOf (FunctionPattern a _ _) = typeOf a
+>   typeOf (InfixPattern a _ _ _) = typeOf a
+>   typeOf (ParenPattern t) = typeOf t
+>   typeOf (RecordPattern a _ _) = typeOf a
+>   typeOf (TuplePattern ts) = tupleType (map typeOf ts)
+>   typeOf (ListPattern a _) = typeOf a
+>   typeOf (AsPattern _ t) = typeOf t
+>   typeOf (LazyPattern t) = typeOf t
+
+> instance Typeable a => Typeable (Expression a) where
+>   typeOf (Literal a _) = typeOf a
+>   typeOf (Variable a _) = typeOf a
+>   typeOf (Constructor a _) = typeOf a
+>   typeOf (Paren e) = typeOf e
+>   typeOf (Typed e _) = typeOf e
+>   typeOf (Record a _ _) = typeOf a
+>   typeOf (RecordUpdate e _) = typeOf e
+>   typeOf (Tuple es) = tupleType (map typeOf es)
+>   typeOf (List a _) = typeOf a
+>   typeOf (ListCompr e _) = listType (typeOf e)
+>   typeOf (EnumFrom e) = listType (typeOf e)
+>   typeOf (EnumFromThen e _) = listType (typeOf e)
+>   typeOf (EnumFromTo e _) = listType (typeOf e)
+>   typeOf (EnumFromThenTo e _ _) = listType (typeOf e)
+>   typeOf (UnaryMinus e) = typeOf e
+>   typeOf (Apply e _) =
+>     case typeOf e of
+>       TypeArrow _ ty -> ty
+>       _ -> internalError "typeOf (Apply)"
+>   typeOf (InfixApply _ op _) =
+>     case typeOf (infixOp op) of
+>       TypeArrow _ (TypeArrow _ ty) -> ty
+>       _ -> internalError "typeOf (InfixApply)"
+>   typeOf (LeftSection _ op) =
+>     case typeOf (infixOp op) of
+>       TypeArrow _ ty -> ty
+>       _ -> internalError "typeOf (LeftSection)"
+>   typeOf (RightSection op _) =
+>     case typeOf (infixOp op) of
+>       TypeArrow ty1 (TypeArrow _ ty2) -> TypeArrow ty1 ty2
+>       _ -> internalError "typeOf (RightSection)"
+>   typeOf (Lambda _ ts e) = foldr (TypeArrow . typeOf) (typeOf e) ts
+>   typeOf (Let _ e) = typeOf e
+>   typeOf (Do _ e) = typeOf e
+>   typeOf (IfThenElse _ e _) = typeOf e
+>   typeOf (Case _ as) = head [typeOf rhs | Alt _ _ rhs <- as]
+>   typeOf (Fcase _ as) = head [typeOf rhs | Alt _ _ rhs <- as]
+
+> instance Typeable a => Typeable (Rhs a) where
+>   typeOf (SimpleRhs _ e _) = typeOf e
+>   typeOf (GuardedRhs es _) = head [typeOf e | CondExpr _ _ e <- es]
 
-> instance Typeable ConstrTerm where
->   typeOf = computeType argType
+\end{verbatim}
+After desugaring, the compiler removes newtype constructors and
+changes renaming types into type synonyms. However, in contrast to
+type synonyms, renaming types can be recursive. Therefore, we expand
+type synonyms only lazily during program transformations. This may be
+necessary, e.g., when a function is $\eta$-expanded and its result
+type is a renaming type whose representation type is a function type:
+\begin{verbatim}
+  newtype ST s a = ST (\s -> (a,s))
+  returnST x = ST (\s -> (x,s))
+\end{verbatim}
+Here \texttt{returnST} can be $\eta$-expanded after removing the
+newtype constructor \texttt{ST} and its type must be changed from
+\texttt{a -> ST s a} into \texttt{a -> s -> (a,s)}.
+\begin{verbatim}
 
-> instance Typeable Expression where
->   typeOf = computeType exprType
-
-> instance Typeable Rhs where
->   typeOf = computeType rhsType
-
-> computeType :: (ValueEnv -> a -> TyState Type) -> ValueEnv -> a -> Type
-> computeType f tyEnv x = normalize 0 (run doComputeType tyEnv)
->   where doComputeType =
->           do
->             ty <- f tyEnv x
->             theta <- fetchSt
->             return (fixTypeVars tyEnv (subst theta ty))
-
-> fixTypeVars :: ValueEnv -> Type -> Type
-> fixTypeVars tyEnv ty = subst (foldr2 bindSubst idSubst tvs tvs') ty
->   where tvs = filter (>= 0) (typeVars ty)
->         tvs' = map TypeVariable [n - 1,n - 2 ..]
->         n = minimum (0 : concatMap typeVars tys)
->         tys = [ty | (_,Value _ _ (ForAll _ ty)) <- localBindings tyEnv]
-
-> identType :: ValueEnv -> Ident -> TyState Type
-> identType tyEnv x = instUniv (varType x tyEnv)
-
-> litType :: ValueEnv -> Literal -> TyState Type
-> litType _ (Char _) = return charType
-> litType tyEnv (Int v _) = identType tyEnv v
-> litType _ (Float _) = return floatType
-> litType _ (String _) = return stringType
-
-> argType :: ValueEnv -> ConstrTerm -> TyState Type
-> argType tyEnv (LiteralPattern l) = litType tyEnv l
-> argType tyEnv (NegativePattern _ l) = litType tyEnv l
-> argType tyEnv (VariablePattern v) = identType tyEnv v
-> argType tyEnv (ConstructorPattern c ts) =
->   do
->     (tys,ty) <- liftM arrowUnapply (instUniv (conType c tyEnv))
->     tys' <- mapM (argType tyEnv) ts
->     unifyList tys tys'
->     return ty
-> argType tyEnv (InfixPattern t1 op t2) =
->   argType tyEnv (ConstructorPattern op [t1,t2])
-> argType tyEnv (ParenPattern t) = argType tyEnv t
-> argType tyEnv (TuplePattern ts) = liftM tupleType (mapM (argType tyEnv) ts)
-> argType tyEnv (ListPattern ts) =
->   do
->     ty <- freshTypeVar
->     mapM_ (elemType ty) ts
->     return (listType ty)
->   where elemType ty t = argType tyEnv t >>= unify ty
-> argType tyEnv (AsPattern v _) = argType tyEnv (VariablePattern v)
-> argType tyEnv (LazyPattern t) = argType tyEnv t
-
-> exprType :: ValueEnv -> Expression -> TyState Type
-> exprType tyEnv (Literal l) = litType tyEnv l
-> exprType tyEnv (Variable v) = instUniv (funType v tyEnv)
-> exprType tyEnv (Constructor c) = instUniv (conType c tyEnv)
-> exprType tyEnv (Typed e _) = exprType tyEnv e
-> exprType tyEnv (Paren e) = exprType tyEnv e
-> exprType tyEnv (Tuple es) = liftM tupleType (mapM (exprType tyEnv) es)
-> exprType tyEnv (List es) =
->   do
->     ty <- freshTypeVar
->     mapM_ (elemType ty) es
->     return (listType ty)
->   where elemType ty e = exprType tyEnv e >>= unify ty
-> exprType tyEnv (ListCompr e _) = liftM listType (exprType tyEnv e)
-> exprType tyEnv (EnumFrom _) = return (listType intType)
-> exprType tyEnv (EnumFromThen _ _) = return (listType intType)
-> exprType tyEnv (EnumFromTo _ _) = return (listType intType)
-> exprType tyEnv (EnumFromThenTo _ _ _) = return (listType intType)
-> exprType tyEnv (UnaryMinus _ e) = exprType tyEnv e
-> exprType tyEnv (Apply e1 e2) =
->   do
->     (ty1,ty2) <- exprType tyEnv e1 >>= unifyArrow
->     exprType tyEnv e2 >>= unify ty1
->     return ty2
-> exprType tyEnv (InfixApply e1 op e2) =
->   do
->     (ty1,ty2,ty3) <- exprType tyEnv (infixOp op) >>= unifyArrow2
->     exprType tyEnv e1 >>= unify ty1
->     exprType tyEnv e2 >>= unify ty2
->     return ty3
-> exprType tyEnv (LeftSection e op) =
->   do
->     (ty1,ty2,ty3) <- exprType tyEnv (infixOp op) >>= unifyArrow2
->     exprType tyEnv e >>= unify ty1
->     return (TypeArrow ty2 ty3)
-> exprType tyEnv (RightSection op e) =
->   do
->     (ty1,ty2,ty3) <- exprType tyEnv (infixOp op) >>= unifyArrow2
->     exprType tyEnv e >>= unify ty2
->     return (TypeArrow ty1 ty3)
-> exprType tyEnv (Lambda args e) =
->   do
->     tys <- mapM (argType tyEnv) args
->     ty <- exprType tyEnv e
->     return (foldr TypeArrow ty tys)
-> exprType tyEnv (Let _ e) = exprType tyEnv e
-> exprType tyEnv (Do _ e) = exprType tyEnv e
-> exprType tyEnv (IfThenElse e1 e2 e3) =
->   do
->     exprType tyEnv e1 >>= unify boolType
->     ty2 <- exprType tyEnv e2
->     ty3 <- exprType tyEnv e3
->     unify ty2 ty3
->     return ty3
-> exprType tyEnv (Case _ alts) =
->   do
->     ty <- freshTypeVar
->     mapM_ (altType ty) alts
->     return ty
->   where altType ty (Alt _ _ rhs) = rhsType tyEnv rhs >>= unify ty
-
-> rhsType :: ValueEnv -> Rhs -> TyState Type
-> rhsType tyEnv (SimpleRhs _ e _) = exprType tyEnv e
-> rhsType tyEnv (GuardedRhs es _) =
->   do
->     ty <- freshTypeVar
->     mapM_ (condExprType ty) es
->     return ty
->   where condExprType ty (CondExpr _ _ e) = exprType tyEnv e >>= unify ty
+> etaType :: TCEnv -> Int -> Type -> Type
+> etaType _ 0 ty = ty
+> etaType tcEnv n (TypeArrow ty1 ty2) =
+>   TypeArrow ty1 (etaType tcEnv (n - 1) ty2)
+> etaType tcEnv n ty =
+>   case unapplyType True ty of
+>     (TypeConstructor tc,tys) ->
+>       case qualLookupTopEnv tc tcEnv of
+>         [AliasType _ n' _ ty'] ->
+>           -- NB n' <= length tys here because ty has kind *
+>           etaType tcEnv n (applyType (expandAliasType tys' ty') tys'')
+>           where (tys',tys'') = splitAt n' tys
+>         [_] -> ty
+>         _ -> internalError "etaType"
+>     _ -> ty
 
 \end{verbatim}
-In order to avoid name conflicts with non-generalized type variables
-in a type we instantiate quantified type variables using non-negative
-offsets here.
+When inlining variable and function definitions, the compiler must
+eventually update the type annotations of the inlined expression. To
+that end, the variable or function's annotated type and the type of
+the inlined expression must be unified. Since the program is type
+correct, this unification is just a simple one way matching where we
+only need to match the type variables in the inlined expression's type
+with the corresponding types in the variable or function's annotated
+type. However, we may need to expand type synonyms stemming from
+removed newtypes.
+
+\ToDo{We would like to use the more general type signature
+  \texttt{(Functor f,Typeable (f Type)) => TCEnv -> Type -> f Type ->
+    f Type} for \texttt{withType}. Unfortunately, nhc98 at present
+  supports only simple class constraints, i.e., constraints where the
+  constrained type is a type variable.}
 \begin{verbatim}
 
-> freshTypeVar :: TyState Type
-> freshTypeVar = liftM TypeVariable $ liftSt $ updateSt (1 +)
+> withType :: (SubstType t,Typeable t) => TCEnv -> Type
+>          -> Expression t -> Expression t
+> withType tcEnv ty x = fmap (subst (matchType tcEnv (typeOf x) ty idSubst)) x
+
+> matchType :: TCEnv -> Type -> Type -> TypeSubst -> TypeSubst
+> matchType tcEnv ty1 ty2 =
+>   foldr (flip fromMaybe) (noMatch ty1 ty2)
+>         [matchTypeApp tcEnv ty1 ty2 | ty1 <- tys1, ty2 <- tys2]
+>   where tys1 = expand tcEnv ty1
+>         tys2 = expand tcEnv ty2
+>         noMatch ty1 ty2 = internalError $
+>           "matchType " ++ showsPrec 11 ty1 " " ++ showsPrec 11 ty2 ""
+
+> matchTypeApp :: TCEnv -> Type -> Type -> Maybe (TypeSubst -> TypeSubst)
+> matchTypeApp _ (TypeVariable tv) ty
+>   | ty == TypeVariable tv = Just id
+>   | otherwise = Just (bindSubst tv ty)
+> matchTypeApp _ (TypeConstructor tc1) (TypeConstructor tc2)
+>   | tc1 == tc2 = Just id
+> matchTypeApp _ (TypeConstrained _ tv1) (TypeConstrained _ tv2)
+>   | tv1 == tv2 = Just id
+> matchTypeApp _ (TypeSkolem k1) (TypeSkolem k2)
+>   | k1 == k2 = Just id
+> matchTypeApp tcEnv (TypeApply ty11 ty12) (TypeApply ty21 ty22) =
+>   fmap (. matchType tcEnv ty12 ty22) (matchTypeApp tcEnv ty11 ty21)
+> matchTypeApp tcEnv (TypeArrow ty11 ty12) (TypeArrow ty21 ty22) =
+>   Just (matchType tcEnv ty11 ty21 . matchType tcEnv ty12 ty22)
+> matchTypeApp tcEnv (TypeApply ty11 ty12) (TypeArrow ty21 ty22) =
+>   fmap (. matchType tcEnv ty12 ty22)
+>        (matchTypeApp tcEnv ty11 (TypeApply (TypeConstructor qArrowId) ty21))
+> matchTypeApp tcEnv (TypeArrow ty11 ty12) (TypeApply ty21 ty22) =
+>   fmap (. matchType tcEnv ty12 ty22)
+>        (matchTypeApp tcEnv (TypeApply (TypeConstructor qArrowId) ty11) ty21)
+> matchTypeApp _ _ _ = Nothing
+
+> expand :: TCEnv -> Type -> [Type]
+> expand tcEnv ty = ty : uncurry (expandType tcEnv) (unapplyType False ty)
+>   where expandType tcEnv (TypeConstructor tc) tys =
+>           case qualLookupTopEnv tc tcEnv of
+>             [AliasType _ n _ ty]
+>               | n < length tys -> []
+>               | otherwise ->
+>                   expand tcEnv (applyType (expandAliasType tys' ty) tys'')
+>               where (tys',tys'') = splitAt n tys
+>             [_] -> []
+>             _ -> internalError "expand"
+>         expandType _ _ _ = []
 
-> instType :: Int -> Type -> TyState Type
-> instType n ty =
->   do
->     tys <- sequence (replicate n freshTypeVar)
->     return (expandAliasType tys ty)
+\end{verbatim}
+The function \texttt{argumentTypes} returns the labels and the
+argument types of a data constructor instantiated at a particular
+type. This function is useful for desugaring record patterns and
+expressions, where the compiler must compute the types of the omitted
+arguments. Since the type annotation of record patterns and
+expressions applies to the pattern or expression as a whole, the
+instance type is unified with the constructor's result type and the
+resulting substitution is applied to all argument types. Note that
+this is sound because record fields cannot have existentially
+quantified types and therefore all type variables appearing in their
+types occur in the constructor's result type as well.
+\begin{verbatim}
 
-> instUniv :: TypeScheme -> TyState Type
-> instUniv (ForAll n ty) = instType n ty
+> argumentTypes :: TCEnv -> Type -> QualIdent -> ValueEnv -> ([Ident],[Type])
+> argumentTypes tcEnv ty c tyEnv =
+>   (ls,map (subst (matchType tcEnv ty0 ty idSubst)) tys)
+>   where (ls,_,ty') = conType c tyEnv
+>         (tys,ty0) = arrowUnapply (rawType ty')
 
 \end{verbatim}
-When unifying two types, the non-generalized variables, i.e.,
-variables with negative offsets, must not be substituted. Otherwise,
-the unification algorithm is identical to the one used by the type
-checker.
+The functions \texttt{bindDecls}, \texttt{bindDecl}, \texttt{bindLhs},
+\texttt{bindTerm} augment the type environment with the types of the
+entities defined in local declaration groups and terms, respectively,
+using the types from their type attributes.
 \begin{verbatim}
 
-> unify :: Type -> Type -> TyState ()
-> unify ty1 ty2 =
->   updateSt_ (\theta -> unifyTypes (subst theta ty1) (subst theta ty2) theta)
-
-> unifyList :: [Type] -> [Type] -> TyState ()
-> unifyList tys1 tys2 = sequence_ (zipWith unify tys1 tys2)
-
-> unifyArrow :: Type -> TyState (Type,Type)
-> unifyArrow ty =
->   do
->     theta <- fetchSt
->     case subst theta ty of
->       TypeVariable tv
->         | tv >= 0 ->
->             do
->               ty1 <- freshTypeVar
->               ty2 <- freshTypeVar
->               updateSt_ (bindVar tv (TypeArrow ty1 ty2))
->               return (ty1,ty2)
->       TypeArrow ty1 ty2 -> return (ty1,ty2)
->       ty' -> internalError ("unifyArrow (" ++ show ty' ++ ")")
-
-> unifyArrow2 :: Type -> TyState (Type,Type,Type)
-> unifyArrow2 ty =
->   do
->     (ty1,ty2) <- unifyArrow ty
->     (ty21,ty22) <- unifyArrow ty2
->     return (ty1,ty21,ty22)
-
-> unifyTypes :: Type -> Type -> TypeSubst -> TypeSubst
-> unifyTypes (TypeVariable tv1) (TypeVariable tv2) theta
->   | tv1 == tv2 = theta
-> unifyTypes (TypeVariable tv) ty theta
->   | tv >= 0 = bindVar tv ty theta
-> unifyTypes ty (TypeVariable tv) theta
->   | tv >= 0 = bindVar tv ty theta
-> unifyTypes (TypeConstructor tc1 tys1) (TypeConstructor tc2 tys2) theta
->   | tc1 == tc2 = unifyTypeLists tys1 tys2 theta
-> unifyTypes (TypeConstrained tys1 tv1) (TypeConstrained tys2 tv2) theta
->   | tv1 == tv2 = theta
-> unifyTypes (TypeArrow ty11 ty12) (TypeArrow ty21 ty22) theta =
->   unifyTypeLists [ty11,ty12] [ty21,ty22] theta
-> unifyTypes (TypeSkolem k1) (TypeSkolem k2) theta
->   | k1 == k2 = theta
-> unifyTypes ty1 ty2 _ =
->   internalError ("unify: (" ++ show ty1 ++ ") (" ++ show ty2 ++ ")")
-
-> unifyTypeLists :: [Type] -> [Type] -> TypeSubst -> TypeSubst
-> unifyTypeLists [] [] theta = theta
-> unifyTypeLists (ty1:tys1) (ty2:tys2) theta =
->   unifyTypes (subst theta' ty1) (subst theta' ty2) theta'
->   where theta' = unifyTypeLists tys1 tys2 theta
+> bindDecls :: (ValueType t,Typeable t) => [Decl t] -> ValueEnv -> ValueEnv
+> bindDecls ds tyEnv = foldr bindDecl tyEnv ds
+
+> bindDecl :: (ValueType t,Typeable t) => Decl t -> ValueEnv -> ValueEnv
+> bindDecl d tyEnv = bindLocalVars (filter (unbound tyEnv) (declVars d)) tyEnv
+>   where unbound tyEnv v = null (lookupTopEnv (fst3 v) tyEnv)
+
+> bindLhs :: (ValueType t,Typeable t) => Lhs t -> ValueEnv -> ValueEnv
+> bindLhs = bindTerms . snd . flatLhs
+
+> bindTerms :: (ValueType t,Typeable t) => [ConstrTerm t] -> ValueEnv
+>           -> ValueEnv
+> bindTerms ts tyEnv = foldr bindTerm tyEnv ts
+
+> bindTerm :: (ValueType t,Typeable t) => ConstrTerm t -> ValueEnv -> ValueEnv
+> bindTerm t tyEnv = bindLocalVars (filter (unbound tyEnv) (termVars t)) tyEnv
+>   where unbound tyEnv v = null (lookupTopEnv (fst3 v) tyEnv)
+
+> declVars :: (ValueType t,Typeable t) => Decl t -> [(Ident,Int,t)]
+> declVars (InfixDecl _ _ _ _) = []
+> declVars (TypeSig _ _ _) = []
+> declVars (FunctionDecl _ ty f eqs) = [(f,eqnArity (head eqs),ty)]
+> declVars (ForeignDecl _ _ ty f _) = [(f,foreignArity (typeOf ty),ty)]
+> declVars (PatternDecl _ t _) = termVars t
+> declVars (FreeDecl _ vs) = [(v,0,ty) | FreeVar ty v <- vs]
+> declVars (TrustAnnot _ _ _) = []
+
+> termVars :: (ValueType t,Typeable t) => ConstrTerm t -> [(Ident,Int,t)]
+> termVars (LiteralPattern _ _) = []
+> termVars (NegativePattern _ _) = []
+> termVars (VariablePattern ty v) = [(v,0,ty)]
+> termVars (ConstructorPattern _ _ ts) = concatMap termVars ts
+> termVars (FunctionPattern _ _ ts) = concatMap termVars ts
+> termVars (InfixPattern _ t1 _ t2) = termVars t1 ++ termVars t2
+> termVars (ParenPattern t) = termVars t
+> termVars (RecordPattern _ _ fs) = concat [termVars t | Field _ t <- fs]
+> termVars (TuplePattern ts) = concatMap termVars ts
+> termVars (ListPattern _ ts) = concatMap termVars ts
+> termVars (AsPattern v t) = (v,0,toValueType (typeOf t)) : termVars t
+> termVars (LazyPattern t) = termVars t
 
 \end{verbatim}
Sottodirectory in comune: curry-0.9.11/unix e curry-0.9.11-classful/unix
Solo in curry-0.9.11-classful/: unix.htm
diff -u curry-0.9.11/Unlit.lhs curry-0.9.11-classful/Unlit.lhs
--- curry-0.9.11/Unlit.lhs	2007-06-15 14:16:35.000000000 +0200
+++ curry-0.9.11-classful/Unlit.lhs	2008-04-22 23:41:57.000000000 +0200
@@ -1,103 +1,149 @@
 % -*- LaTeX -*-
-% $Id: Unlit.lhs 1783 2005-10-06 20:35:55Z wlux $
+% $Id: Unlit.lhs 2676 2008-04-22 13:10:38Z wlux $
 %
-% Copyright (c) 2000-2005, Wolfgang Lux
+% Copyright (c) 2000-2008, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{Unlit.lhs}
 \section{Literate Comments}
 Since version 0.7 of the language report, Curry accepts literate
 source programs. In a literate source all program lines must begin
-with a greater sign in the first column. All other lines are assumed
-to be documentation. In order to avoid some common errors with
+with a \verb|>| character in the first column. All other lines are
+assumed to be documentation. In order to avoid some common errors with
 literate programs, Curry requires at least one program line to be
 present in the file. In addition, every block of program code must be
-preceded by a blank line and followed by a blank line.
+preceded and followed by a blank line.
+
+Besides this ``traditional'' literate style, which was adopted from
+Haskell, we also support Haskell's alternative style where the program
+text is enclosed with lines starting with \verb|\begin{code}| and
+\verb|\end{code}|, respectively. It is possible but not recommended to
+mix both styles in the same file.
 
 The module \texttt{Unlit} acts as a preprocessor which converts
 literate source programs into the ``un-literate'' format accepted by
 the lexer. The implementation, together with the comments below, was
-derived from appendix D in the Haskell 1.2 report.
+derived from appendix C in the Haskell 1.2 report.
 \begin{verbatim}
 
 > module Unlit(unlit) where
 > import Char
+> import List
 > import Position
 
 \end{verbatim}
-Each of the lines in a literate script is a program line, a blank
-line, or a comment line. In the first case the text is kept with the
-line.
-\begin{verbatim}
-
-> data Classified = Program String | Blank | Comment
-
-\end{verbatim}
-In a literate program, program lines begin with a \verb|>| character,
-blank lines contain only whitespace, and all other lines are comment
-lines.
-\begin{verbatim}
-
-> classify :: String -> Classified
-> classify ""            = Blank
-> classify (c:cs)
->   | c == '>'           = Program cs
->   | all isSpace (c:cs) = Blank
->   | otherwise          = Comment
+Each line of a literate script is either a program line, one of the
+delimiters \verb|\begin{code}| and \verb|\end{code}|, a blank line, or
+a comment line. In the first case the text is kept with the line.
+\begin{verbatim}
+
+> data Classified = Program String | BeginCode | EndCode | Blank | Comment
+
+\end{verbatim}
+In a literate program, all lines between the \verb|\begin{code}| and
+\verb|\end{code}| delimiters and all other lines starting with a
+\verb|>| character are program lines. The remaining lines are either
+blank lines, containing only white space, or comment lines. The
+function \texttt{classify} below classifies a single program line. Its
+first argument is a flag that denotes whether that line belongs to a
+code block between \verb|\begin{code}| and \verb|\end{code}|
+delimiters. The boolean flag returned together with the classified
+line denotes whether the next line belongs to a code block. The
+leading \verb|>| character of program lines outside code blocks is
+replaced by a single space in order to preserve tab alignments.
+\begin{verbatim}
+
+> classify :: Bool -> String -> (Bool,Classified)
+> classify True  cs =
+>   if "\\end{code}" `isPrefixOf` cs then (False,EndCode)
+>   else (True,Program cs)
+> classify False ""      = (False,Blank)
+> classify False (c:cs)
+>   | c == '>'           = (False,Program (' ':cs))
+>   | c == '\\'          =
+>       if "begin{code}" `isPrefixOf` cs then (True,BeginCode)
+>       else (False,Comment)
+>   | all isSpace (c:cs) = (False,Blank)
+>   | otherwise          = (False,Comment)
 
 \end{verbatim}
-In the corresponding program, program lines have the leading \verb|>|
-replaced by a leading space, to preserve tab alignments.
+In the transformed source only the contents of program lines is
+retained.
 \begin{verbatim}
 
 > unclassify :: Classified -> String
-> unclassify (Program cs) = ' ' : cs
+> unclassify (Program cs) = cs
+> unclassify BeginCode    = ""
+> unclassify EndCode      = ""
 > unclassify Blank        = ""
 > unclassify Comment      = ""
 
 \end{verbatim}
-Process a literate program into error messages (if any) and the
-corresponding non-literate program.
+The main function of this module processes a literate program into
+error messages (if any) and the corresponding non-literate program.
 \begin{verbatim}
 
 > unlit :: FilePath -> String -> (String,String)
 > unlit fn lcy = (es,cy)
->   where cs = map classify (lines lcy)
+>   where (_,cs) = mapAccumL classify False (lines lcy)
 >         es = unlines (errors fn cs)
 >         cy = unlines (map unclassify cs)
 
 \end{verbatim}
-Check that each program line is not adjacent to a comment line and
-there is at least one program line.
+Check that each program line is not adjacent to a comment line, the
+last code block is terminated with \verb|\end{code}|, and there is at
+least one program line or one (possibly empty) code block.
 \begin{verbatim}
 
 > errors :: FilePath -> [Classified] -> [String]
 > errors fn cs =
->   concat (zipWith3 adjacent (iterate nl (first fn)) cs (tail cs)) ++
->   empty fn (filter isProgram cs)
+>   concat (zipWith adjacent cs' (tail cs')) ++
+>   if null ds then empty p0 (filter isProgram cs)
+>   else [last ds | odd (length ds)]
+>   where p0 = first fn
+>         cs' = zipWith P (iterate nl p0) cs
+>         ds = delims cs'
 
 \end{verbatim}
 Given a line number and a pair of adjacent lines, generate a list of
-error messages, which will contain either one entry or none.
+error messages, which will contain either one entry or none. Note that
+blank lines are not required after the \verb|\begin{code}| and before
+the \verb|\end{code}| delimiters.
 \begin{verbatim}
 
-> adjacent :: Position -> Classified -> Classified -> [String]
-> adjacent p (Program _) Comment     = [message (nl p) "after"]
-> adjacent p Comment     (Program _) = [message p "before"]
-> adjacent p _           _           = []
+> adjacent :: P Classified -> P Classified -> [String]
+> adjacent (P _ (Program _)) (P p Comment    ) = [message p "after"]
+> adjacent (P _ (Program _)) (P p BeginCode  ) = [message p "after"]
+> adjacent (P p EndCode    ) (P _ (Program _)) = [message p "before"]
+> adjacent (P p Comment    ) (P _ (Program _)) = [message p "before"]
+> adjacent _                 _                 = []
 
 > message p w = atP p ("comment line " ++ w ++ " program line.")
 
 \end{verbatim}
-Given the list of program lines generate an error if this list is
-empty.
+Given the list of program lines report an error if this list is empty.
 \begin{verbatim}
 
-> empty :: FilePath -> [Classified] -> [String]
-> empty fn cs = [atP (first fn) ("no code in literate script") | null cs]
+> empty :: Position -> [Classified] -> [String]
+> empty p cs = [atP p "no code in literate script" | null cs]
 
 > isProgram :: Classified -> Bool
 > isProgram (Program _) = True
-> isProgram _ = False
+> isProgram _           = False
+
+\end{verbatim}
+If a literate program uses \verb|\begin{code}| and \verb|\end{code}|
+delimiters, we make sure that the last code block is closed. The
+following function associates an error message with every delimiter,
+but an error is reported only if the number of delimiters is odd.
+\begin{verbatim}
+
+> delims :: [P Classified] -> [String]
+> delims cs = [atP p "missing \\end{code}" | P p c <- cs, isDelim c]
+
+> isDelim :: Classified -> Bool
+> isDelim BeginCode = True
+> isDelim EndCode   = True
+> isDelim _         = False
 
 \end{verbatim}
diff -u curry-0.9.11/UnusedCheck.lhs curry-0.9.11-classful/UnusedCheck.lhs
--- curry-0.9.11/UnusedCheck.lhs	2007-06-15 14:16:34.000000000 +0200
+++ curry-0.9.11-classful/UnusedCheck.lhs	2011-10-08 12:42:57.000000000 +0200
@@ -1,37 +1,43 @@
 % -*- LaTeX -*-
-% $Id: UnusedCheck.lhs 2219 2007-06-01 06:24:12Z wlux $
+% $Id: UnusedCheck.lhs 3056 2011-10-07 16:27:03Z wlux $
 %
-% Copyright (c) 2005-2007, Wolfgang Lux
+% Copyright (c) 2005-2011, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{UnusedCheck.lhs}
 \section{Checking for Unused Variables}
-After syntax checking and renaming, the compiler can optionally report
-unused data constructors, functions, and variables in the source code.
-Note that we do not check for unused type constructors and type
-variables at present.
+After syntax checking and before renaming, the compiler can optionally
+report unused data constructors, functions, and variables in the
+source code. Note that we do not check for unused type constructors
+and type variables at present.
 \begin{verbatim}
 
 > module UnusedCheck(unusedCheck,unusedCheckGoal) where
-> import Base hiding(TypeKind(..), ValueKind(..))
-> import Set
+> import Base
+> import Curry
+> import CurryUtils
 > import Options
+> import Position
+> import Set
+> import Utils
 
 \end{verbatim}
-In order to report unused variables in a module, we first compute the
-set of all used variables in the module. Using the resulting set we
-then check for unused variables in the code and report warnings for
-them according to the compiler options.
+Since local variables have not yet been renamed, we compute the set of
+used variables together with the list of unused variables. In
+particular, whenever a scope is left we collect the unused variables
+of that scope and remove their identifiers from the set of used
+variables. At the end, we report warnings for the unused variables
+according to the compiler options.
 \begin{verbatim}
 
-> unusedCheck :: [Warn] -> Module -> [String]
+> unusedCheck :: [Warn] -> Module a -> [String]
 > unusedCheck us (Module m (Just (Exporting _ es)) _ ds) =
->   reportUnused us $ unused (used m es (used m ds zeroSet)) noPosition ds []
->   where noPosition = error "noPosition"
+>   reportUnused us $
+>   snd (checkUnused noPosition ds . used m es . used m ds $ (zeroSet,[]))
 
-> unusedCheckGoal :: [Warn] -> ModuleIdent -> Goal -> [String]
+> unusedCheckGoal :: [Warn] -> ModuleIdent -> Goal a -> [String]
 > unusedCheckGoal us m (Goal p e ds) =
->   reportUnused us $ unused (used m g' zeroSet) p g' []
+>   reportUnused us $ snd (used m g' $ (zeroSet,[]))
 >   where g' = SimpleRhs p e ds
 
 > reportUnused :: [Warn] -> [Undef] -> [String]
@@ -39,7 +45,9 @@
 
 > data Undef =
 >     Data Position Ident
+>   | Label Position Ident
 >   | Decl Position Ident
+>   | Meth Position Ident
 >   | Var Position Ident
 >   | Pattern Position
 >   deriving (Eq,Show)
@@ -49,13 +57,17 @@
 >   | null (filter (`elem` [minUnused..maxUnused]) us) = []
 >   | otherwise = filter warn vs
 >   where warn (Data _ _) = WarnUnusedData `elem` us
+>         warn (Label _ _) = WarnUnusedData `elem` us
 >         warn (Decl _ _) = WarnUnusedDecl `elem` us
+>         warn (Meth _ _) = WarnUnusedDecl `elem` us
 >         warn (Var _ _) = WarnUnusedVar `elem` us
 >         warn (Pattern _) = WarnUnusedDecl `elem` us
 
 > format :: Undef -> String
 > format (Data p c) = atP p ("Warning: unused data constructor " ++ name c)
+> format (Label p l) = atP p ("Warning: unused field label " ++ name l)
 > format (Decl p x) = atP p ("Warning: unused variable " ++ name x)
+> format (Meth p f) = atP p ("Warning: unused method " ++ name f)
 > format (Var p x) = atP p ("Warning: unused variable " ++ name x)
 > format (Pattern p) = atP p "Warning: unused pattern declaration"
 
@@ -64,172 +76,198 @@
 > unusedVars unused used p xs = ([unused p x | x <- xs, x `notElemSet` used] ++)
 
 \end{verbatim}
-Collecting used identifiers and filtering unused ones are each
-implemented by a traversal of the syntax tree.
+Collecting used identifiers and filtering unused ones are implemented
+by a traversal of the syntax tree.
 \begin{verbatim}
 
+> type U = (Set Ident,[Undef])
+
 > class SyntaxTree a where
->   used :: ModuleIdent -> a -> Set Ident -> Set Ident
->   unused :: Set Ident -> Position -> a -> [Undef] -> [Undef]
+>   used :: ModuleIdent -> a -> U -> U
 
 > instance SyntaxTree a => SyntaxTree [a] where
 >   used _ [] = id
 >   used m (x:xs) = used m x . used m xs
->   unused used p xs ys = foldr (unused used p) ys xs
 
 > instance SyntaxTree Export where
 >   used m (Export x) = used m x
->   used m (ExportTypeWith tc cs) = used m (map (qualifyLike tc) cs)
->   unused _ _ _ = id
+>   used m (ExportTypeWith tc xs) = used m (map (qualifyLike tc) xs)
 
-> instance SyntaxTree TopDecl where
->   used m (DataDecl _ _ _ _) = id
->   used m (NewtypeDecl _ _ _ _) = id
->   used m (TypeDecl _ _ _ _) = id
+> instance SyntaxTree (TopDecl a) where
+>   used _ (DataDecl _ _ _ _ _ _) = id
+>   used _ (NewtypeDecl _ _ _ _ _ _) = id
+>   used _ (TypeDecl _ _ _ _) = id
+>   used m (ClassDecl _ _ _ _ ds) = used m ds
+>   used m (InstanceDecl _ _ _ _ ds) = used m ds
+>   used m (DefaultDecl _ _) = id
 >   used m (BlockDecl d) = used m d
 
->   unused used p (DataDecl _ _ _ cs) = unused used p cs
->   unused used p (NewtypeDecl _ _ _ nc) = unused used p nc
->   unused _ _ (TypeDecl _ _ _ _) = id
->   unused used p (BlockDecl d) = unused used p d
+> instance SyntaxTree (Decl a) where
+>   used _ (InfixDecl _ _ _ _) = id
+>   used _ (TypeSig _ _ _) = id
+>   used m (FunctionDecl _ _ f eqs) =
+>     nest (apFst (deleteFromSet f) . used m eqs)
+>   used _ (ForeignDecl _ _ _ _ _) = id
+>   used m (PatternDecl _ t rhs) =
+>     case t of
+>       VariablePattern _ v -> nest (apFst (deleteFromSet v) . used m rhs)
+>       _ -> used m t . used m rhs
+>   used _ (FreeDecl _ _) = id
+>   used _ (TrustAnnot _ _ _) = id
+
+> instance SyntaxTree (Equation a) where
+>   used m (Equation p lhs rhs) =
+>     nest (checkUnused p lhs . used m lhs . used m rhs)
 
-> instance SyntaxTree ConstrDecl where
->   used _ _ = id
->   unused used _ (ConstrDecl p _ c _) = unusedVars Data used p [c]
->   unused used _ (ConOpDecl p _ _ op _) = unusedVars Data used p [op]
-
-> instance SyntaxTree NewConstrDecl where
->   used _ _ = id
->   unused used _ (NewConstrDecl p c _) = unusedVars Data used p [c]
-
-> instance SyntaxTree Decl where
->   used m (FunctionDecl _ f eqs) =
->     unionSet (deleteFromSet f (used m eqs zeroSet))
->   used m (PatternDecl _ (VariablePattern v) rhs) =
->     unionSet (deleteFromSet v (used m rhs zeroSet))
->   used m (PatternDecl _ t rhs) = used m t . used m rhs
->   used _ _ = id
->
->   unused used _ (FunctionDecl p f eqs) =
->     unusedVars Decl used p [f] . unused used p eqs
->   unused used _ (ForeignDecl p _ _ _ f _) = unusedVars Decl used p [f]
->   unused used _ (PatternDecl p (VariablePattern v) rhs)
->     | isAnonId v = ([Pattern p] ++)
->     | otherwise = unusedVars Decl used p [v]
->   unused used _ (PatternDecl p t rhs) =
->      ([Pattern p | not (any (`elemSet` used) bvs)] ++) .
->      unusedVars Var used p bvs . unused used p rhs
->     where bvs = filter (not . isAnonId) (bv t)
->   unused used _ (FreeDecl p xs) = unusedVars Decl used p xs
->   unused _ _ _ = id
-
-> instance SyntaxTree Equation where
->   used m (Equation _ lhs rhs) = used m lhs . used m rhs
->   unused used _ (Equation p lhs rhs) = unused used p lhs . unused used p rhs
-
-> instance SyntaxTree Lhs where
+> instance SyntaxTree (Lhs a) where
 >   used m (FunLhs _ ts) = used m ts
 >   used m (OpLhs t1 _ t2) = used m t1 . used m t2
 >   used m (ApLhs lhs ts) = used m lhs . used m ts
->   unused used p lhs = unusedVars Var used p (filter (not . isAnonId) (bv lhs))
 
-> instance SyntaxTree ConstrTerm where
->   used _ (LiteralPattern _) = id
+> instance SyntaxTree (ConstrTerm a) where
+>   used _ (LiteralPattern _ _) = id
 >   used _ (NegativePattern _ _) = id
->   used m (VariablePattern _) = id
->   used m (ConstructorPattern c ts) = used m c . used m ts
->   used m (InfixPattern t1 op t2) = used m t1 . used m op . used m t2
+>   used _ (VariablePattern _ _) = id
+>   used m (ConstructorPattern _ c ts) = used m c . used m ts
+>   used m (FunctionPattern _ f ts) = used m f . used m ts
+>   used m (InfixPattern _ t1 op t2) =
+>     used m t1 . used m (opName op) . used m t2
 >   used m (ParenPattern t) = used m t
+>   used m (RecordPattern _ c fs) = used m c . used m fs
 >   used m (TuplePattern ts) = used m ts
->   used m (ListPattern ts) = used m ts
+>   used m (ListPattern _ ts) = used m ts
 >   used m (AsPattern _ t) = used m t
 >   used m (LazyPattern t) = used m t
->
->   unused used p t = unusedVars Var used p (filter (not . isAnonId) (bv t))
 
-> instance SyntaxTree Rhs where
->   used m (SimpleRhs _ e ds) = used m ds . used m e
->   used m (GuardedRhs es ds) = used m ds . used m es
->   unused used _ (SimpleRhs p e ds) = unused used p ds . unused used p e
->   unused used p (GuardedRhs es ds) = unused used p ds . unused used p es
+> instance SyntaxTree (Rhs a) where
+>   used m (SimpleRhs p e ds) = nest (checkUnused p ds . used m ds . used m e)
+>   used m (GuardedRhs es ds) =
+>     nest (checkUnused noPosition ds . used m ds . used m es)
 
-> instance SyntaxTree CondExpr where
+> instance SyntaxTree (CondExpr a) where
 >   used m (CondExpr _ g e) = used m g . used m e
->   unused used _ (CondExpr p g e) = unused used p g . unused used p e
 
-> instance SyntaxTree Expression where
->   used _ (Literal _) = id
->   used m (Variable x) = used m x
->   used m (Constructor c) = used m c
+> instance SyntaxTree (Expression a) where
+>   used _ (Literal _ _) = id
+>   used m (Variable _ x) = used m x
+>   used m (Constructor _ c) = used m c
 >   used m (Paren e) = used m e
 >   used m (Typed e _) = used m e
+>   used m (Record _ c fs) = used m c . used m fs
+>   used m (RecordUpdate e fs) = used m e . used m fs
 >   used m (Tuple es) = used m es
->   used m (List es) = used m es
->   used m (ListCompr e qs) = used m qs . used m e
+>   used m (List _ es) = used m es
+>   used m (ListCompr e qs) = nest (used m qs . used m e)
 >   used m (EnumFrom e) = used m e
 >   used m (EnumFromThen e1 e2) = used m e1 . used m e2
 >   used m (EnumFromTo e1 e2) = used m e1 . used m e2
 >   used m (EnumFromThenTo e1 e2 e3) = used m e1 . used m e2 . used m e3
->   used m (UnaryMinus _ e) = used m e
+>   used m (UnaryMinus e) = used m e
 >   used m (Apply e1 e2) = used m e1 . used m e2
 >   used m (InfixApply e1 op e2) = used m e1 . used m (opName op) . used m e2
 >   used m (LeftSection e op) = used m e . used m (opName op)
 >   used m (RightSection op e) = used m (opName op) . used m e
->   used m (Lambda ts e) = used m ts . used m e
->   used m (Let ds e) = used m ds . used m e
->   used m (Do sts e) = used m sts . used m e
+>   used m (Lambda p ts e) = nest (checkUnused p ts . used m ts . used m e)
+>   used m (Let ds e) = nest (checkUnused noPosition ds . used m ds . used m e)
+>   used m (Do sts e) = nest (used m sts . used m e)
 >   used m (IfThenElse e1 e2 e3) = used m e1 . used m e2 . used m e3
 >   used m (Case e as) = used m e . used m as
->
->   unused _ _ (Literal _) = id
->   unused _ _ (Variable _) = id
->   unused _ _ (Constructor _) = id
->   unused used p (Paren e) = unused used p e
->   unused used p (Typed e _) = unused used p e
->   unused used p (Tuple es) = unused used p es
->   unused used p (List es) = unused used p es
->   unused used p (ListCompr e qs) = unused used p qs . unused used p e
->   unused used p (EnumFrom e) = unused used p e
->   unused used p (EnumFromThen e1 e2) = unused used p e1 . unused used p e2
->   unused used p (EnumFromTo e1 e2) = unused used p e1 . unused used p e2
->   unused used p (EnumFromThenTo e1 e2 e3) =
->     unused used p e1 . unused used p e2 . unused used p e3
->   unused used p (UnaryMinus _ e) = unused used p e
->   unused used p (Apply e1 e2) = unused used p e1 . unused used p e2
->   unused used p (InfixApply e1 _ e2) = unused used p e1 . unused used p e2
->   unused used p (LeftSection e _) = unused used p e
->   unused used p (RightSection _ e) = unused used p e
->   unused used p (Lambda ts e) = unused used p ts . unused used p e
->   unused used p (Let ds e) = unused used p ds . unused used p e
->   unused used p (Do sts e) = unused used p sts . unused used p e
->   unused used p (IfThenElse e1 e2 e3) =
->     unused used p e1 . unused used p e2 . unused used p e3
->   unused used p (Case e as) = unused used p e . unused used p as
+>   used m (Fcase e as) = used m e . used m as
 
-> instance SyntaxTree Statement where
+> instance SyntaxTree (Statement a) where
 >   used m (StmtExpr e) = used m e
->   used m (StmtBind t e) = used m t . used m e
->   used m (StmtDecl ds) = used m ds
->   unused used p (StmtExpr e) = unused used p e
->   unused used p (StmtBind t e) = unused used p t . unused used p e
->   unused used p (StmtDecl ds) = unused used p ds
-
-> instance SyntaxTree Alt where
->   used m (Alt _ t rhs) = used m t . used m rhs
->   unused used _ (Alt p t rhs) = unused used p t . unused used p rhs
+>   used m (StmtBind p t e) = used m e . checkUnused p t . used m t
+>   used m (StmtDecl ds) = checkUnused noPosition ds . used m ds
+
+> instance SyntaxTree (Alt a) where
+>   used m (Alt p t rhs) = nest (checkUnused p t . used m t . used m rhs)
+
+> instance SyntaxTree a => SyntaxTree (Field a) where
+>   used m (Field l x) = used m l . used m x
 
 > instance SyntaxTree QualIdent where
 >   used m x =
 >     case splitQualIdent (qualUnqualify m x) of
 >       (Just _,_) -> id
->       (Nothing,x') -> addToSet x'
->   unused _ _ _ = id
+>       (Nothing,x') -> apFst (addToSet x')
+
+\end{verbatim}
+Within each scope, we check for unused variables and then remove the
+set of bound variables from the list of used variables. The functions
+\texttt{nest}, which isolates an expression from its right neighbor,
+and \texttt{checkUnused}, which actually checks for unused variables,
+are kept separate in order to handle qualifiers in list comprehensions
+and statement sequences in do expressions correctly. Recall that for a
+statement sequence $t \leftarrow e; \emph{sts}$, the variables used in
+\emph{sts} (but not those in $e$) are relevant for determining the
+unused variables of pattern $t$.
+\begin{verbatim}
+
+> nest :: (U -> U) -> U -> U
+> nest used (vs,us) = (vs' `unionSet` vs,us')
+>   where (vs',us') = used (zeroSet,us)
+
+> checkUnused :: (QuantExpr a,Binder a) => Position -> a -> U -> U
+> checkUnused p x (vs,us) = (foldr deleteFromSet vs (bv x),unused vs p x us)
+
+> class Binder a where
+>   unused :: Set Ident -> Position -> a -> [Undef] -> [Undef]
+
+> instance Binder a => Binder [a] where
+>   unused used p xs ys = foldr (unused used p) ys xs
+
+> instance Binder (TopDecl a) where
+>   unused used p (DataDecl _ _ _ _ cs _) = unused used p cs
+>   unused used p (NewtypeDecl _ _ _ _ nc _) = unused used p nc
+>   unused _ _ (TypeDecl _ _ _ _) = id
+>   unused used _ (ClassDecl p _ _ _ ds) =
+>     flip (foldr ($)) [unusedVars Meth used p fs | TypeSig p fs _ <- ds]
+>   unused _ _ (InstanceDecl _ _ _ _ _) = id
+>   unused _ _ (DefaultDecl _ _) = id
+>   unused used p (BlockDecl d) = unused used p d
+
+> instance Binder ConstrDecl where
+>   unused used _ (ConstrDecl p _ _ c _) = unusedVars Data used p [c]
+>   unused used _ (ConOpDecl p _ _ _ op _) = unusedVars Data used p [op]
+>   unused used _ (RecordDecl p _ _ c fs) =
+>     unusedVars Data used p [c] . unused used p fs
+
+> instance Binder FieldDecl where
+>   unused used _ (FieldDecl p ls _) = unusedVars Label used p ls
+
+> instance Binder NewConstrDecl where
+>   unused used _ (NewConstrDecl p c _) = unusedVars Data used p [c]
+>   unused used _ (NewRecordDecl p c l _) =
+>     unusedVars Data used p [c] . unusedVars Label used p [l]
+
+> instance Binder (Decl a) where
+>   unused _ _ (InfixDecl _ _ _ _) = id
+>   unused _ _ (TypeSig _ _ _) = id
+>   unused used _ (FunctionDecl p _ f _) = unusedVars Decl used p [f]
+>   unused used _ (ForeignDecl p _ _ f _) = unusedVars Decl used p [f]
+>   unused used _ (PatternDecl p t rhs) =
+>     case t of
+>       VariablePattern _ v
+>         | v == anonId -> ([Pattern p] ++)
+>         | otherwise -> unusedVars Decl used p [v]
+>       _ ->
+>         ([Pattern p | not (any (`elemSet` used) bvs)] ++) .
+>         unusedVars Var used p bvs
+>     where bvs = bv t
+>   unused used _ (FreeDecl p vs) = unusedVars Decl used p (bv vs)
+>   unused _ _ (TrustAnnot _ _ _) = id
+
+> instance Binder (Lhs a) where
+>   unused used p lhs = unusedVars Var used p (bv lhs)
+
+> instance Binder (ConstrTerm a) where
+>   unused used p t = unusedVars Var used p (bv t)
 
 \end{verbatim}
-Anonymous identifiers in patterns are always ignored.
+Auxiliary functions.
 \begin{verbatim}
 
-> isAnonId :: Ident -> Bool
-> isAnonId x = unRenameIdent x == anonId
+> noPosition :: Position
+> noPosition = error "noPosition"
 
 \end{verbatim}
diff -u curry-0.9.11/Utils.lhs curry-0.9.11-classful/Utils.lhs
--- curry-0.9.11/Utils.lhs	2007-06-15 14:16:36.000000000 +0200
+++ curry-0.9.11-classful/Utils.lhs	2013-05-13 09:54:58.000000000 +0200
@@ -1,7 +1,7 @@
 % -*- LaTeX -*-
-% $Id: Utils.lhs 1744 2005-08-23 16:17:12Z wlux $
+% $Id: Utils.lhs 3136 2013-05-12 15:53:27Z wlux $
 %
-% Copyright (c) 2001-2003, Wolfgang Lux
+% Copyright (c) 2001-2013, Wolfgang Lux
 % See LICENSE for the full license.
 %
 \nwfilename{Utils.lhs}
@@ -12,6 +12,7 @@
 \begin{verbatim}
 
 > module Utils where
+> import IO
 > infixr 5 ++!
 
 \end{verbatim}
@@ -42,6 +43,15 @@
 > uncurry3 f (x,y,z) = f x y z
 
 \end{verbatim}
+\paragraph{Strings}
+The function \texttt{showLn} is a variant of \texttt{show} that adds a
+newline character to the converted string.
+\begin{verbatim}
+
+> showLn :: Show a => a -> String
+> showLn x = shows x "\n"
+
+\end{verbatim}
 \paragraph{Lists}
 The function \texttt{(++!)} is variant of the list concatenation
 operator \texttt{(++)} that ignores the second argument if the first
@@ -99,3 +109,18 @@
 >     return (s'',y:ys)
 
 \end{verbatim}
+\paragraph{IO functions}
+\begin{verbatim}
+The IO actions \texttt{putErr} and \texttt{putErrLn} are variants of
+\texttt{putStr} and \texttt{putStrLn} that write their argument string
+to the standard error output. Unfortunately, hbc's \texttt{IO} module
+lacks a definition of \texttt{hPutStrLn}.
+\begin{verbatim}
+
+> putErr :: String -> IO ()
+> putErr = hPutStr stderr
+
+> putErrLn :: String -> IO ()
+> putErrLn s = putErr (unlines [s])
+
+\end{verbatim}
Solo in curry-0.9.11-classful/: ValueInfo.lhs
Sottodirectory in comune: curry-0.9.11/windows e curry-0.9.11-classful/windows
Solo in curry-0.9.11-classful/: windows.htm
